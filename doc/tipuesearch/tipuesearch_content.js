var tipuesearch = {"pages":[{"title":" the SCATTERING code ","text":"the SCATTERING code BIGOS – B inary I nelastic scattering and G eneralized O ptical cross S ection package is a set of FORTRAN 90 codes that\nallow the user to obtain various physical quantities related to the scattering problem involving diatomic molecules and\natoms. The package is being developed at the Nicolaus Copernicus University in Toruń. Here, we present the SCATTERINC code, the central part of the BIGOS package.\nThe purpose of the SCATTERING code is to solve the coupled equations for a given scattering system, provide the\nscattering S-matrix elements and calculate the state-to-state cross-sections. Please read the Program Description . Note This version of the code is adjusted for diatom - atom collision systems, in particular the H 2 - He system. Please, refer to this version of the code by citing the following paper H. Jozwiak, F. Thibault, A. Viel, P. Wcislo, F. Lique, Rovibrational (de-)excitation of H 2 by He revisited https://doi.org/10.48550/arXiv.2311.09890 Developer Info Hubert Jóźwiak","tags":"home","loc":"index.html"},{"title":"get_radial_coupling_term_value – the SCATTERING code","text":"public  subroutine get_radial_coupling_term_value(intermolecular_distance, lambda_, v_, j_, v_prime_, j_prime_, radial_term_value_) Returns the interpolated value of a specific radial coupling term\nat a given distance. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: intermolecular_distance Intermolecular distance, R integer(kind=int32), intent(in) :: lambda_ Legendre expansion index integer(kind=int32), intent(in) :: v_ pre-collisional vibrational quantum number integer(kind=int32), intent(in) :: j_ pre-collisional rotational quantum number integer(kind=int32), intent(in) :: v_prime_ post-collisional vibrational quantum number integer(kind=int32), intent(in) :: j_prime_ post-collisional rotational quantum number real(kind=dp), intent(out) :: radial_term_value_ Value of the radial coupling coefficient Calls proc~~get_radial_coupling_term_value~~CallsGraph proc~get_radial_coupling_term_value get_radial_coupling_term_value proc~ispline ispline proc~get_radial_coupling_term_value->proc~ispline proc~float_to_character float_to_character proc~ispline->proc~float_to_character proc~write_warning write_warning proc~ispline->proc~write_warning proc~write_message write_message proc~write_warning->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~get_radial_coupling_term_value~~CalledByGraph proc~get_radial_coupling_term_value get_radial_coupling_term_value proc~pes_contribution pes_contribution proc~pes_contribution->proc~get_radial_coupling_term_value proc~numerov numerov proc~numerov->proc~pes_contribution program~scattering SCATTERING program~scattering->proc~numerov Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code get_radial_coupling_term_value Source Code subroutine get_radial_coupling_term_value ( intermolecular_distance , & lambda_ , v_ , j_ , v_prime_ , j_prime_ , radial_term_value_ ) !! Returns the interpolated value of a specific radial coupling term !! at a given distance. !---------------------------------------------------------------------! real ( dp ), intent ( in ) :: intermolecular_distance !! Intermolecular distance, \\R\\ integer ( int32 ), intent ( in ) :: lambda_ !! Legendre expansion index integer ( int32 ), intent ( in ) :: v_ !! pre-collisional vibrational quantum number integer ( int32 ), intent ( in ) :: j_ !! pre-collisional rotational quantum number integer ( int32 ), intent ( in ) :: v_prime_ !! post-collisional vibrational quantum number integer ( int32 ), intent ( in ) :: j_prime_ !! post-collisional rotational quantum number real ( dp ), intent ( out ) :: radial_term_value_ !! Value of the radial coupling coefficient !---------------------------------------------------------------------! integer ( int32 ) :: lambda_index , coupling_index !---------------------------------------------------------------------! lambda_index = find_lambda_index ( lambda_ ) !---------------------------------------------------------------------! if ( lambda_index == 0 ) then call handle_lambda_index_error ( lambda_ ) return endif !---------------------------------------------------------------------! coupling_index = find_coupling_index ( v_ , j_ , v_prime_ , j_prime_ ) !---------------------------------------------------------------------! if ( coupling_index == 0 ) then call handle_coupling_index_error ( v_ , j_ , v_prime_ , j_prime_ ) return endif !---------------------------------------------------------------------! radial_term_value_ = ISPLINE ( intermolecular_distance , nr , rmat , & vmat3D (:, lambda_index , coupling_index ), & bmat3D (:, lambda_index , coupling_index ), & cmat3D (:, lambda_index , coupling_index ), & dmat3D (:, lambda_index , coupling_index )) !---------------------------------------------------------------------! end subroutine get_radial_coupling_term_value","tags":"","loc":"proc/get_radial_coupling_term_value.html"},{"title":"interpolate_radial_coupling_terms – the SCATTERING code","text":"public  subroutine interpolate_radial_coupling_terms() Interpolates the radial coupling terms using cubic spline functions.\nThe resulting spline coefficients for each coupling term\nare stored in bmat3D, cmat3D, and dmat3D matrices. Arguments None Calls proc~~interpolate_radial_coupling_terms~~CallsGraph proc~interpolate_radial_coupling_terms interpolate_radial_coupling_terms proc~spline spline proc~interpolate_radial_coupling_terms->proc~spline proc~integer_to_character integer_to_character proc~spline->proc~integer_to_character proc~write_error write_error proc~spline->proc~write_error proc~write_message write_message proc~write_error->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~interpolate_radial_coupling_terms~~CalledByGraph proc~interpolate_radial_coupling_terms interpolate_radial_coupling_terms program~scattering SCATTERING program~scattering->proc~interpolate_radial_coupling_terms Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code interpolate_radial_coupling_terms Source Code subroutine interpolate_radial_coupling_terms !! Interpolates the radial coupling terms using cubic spline functions. !! The resulting spline coefficients for each coupling term !! are stored in bmat3D, cmat3D, and dmat3D matrices. !---------------------------------------------------------------------! integer ( int32 ) :: lambda_index_ , coupling_index_ !---------------------------------------------------------------------! do lambda_index_ = 1 , nterms do coupling_index_ = 1 , ncoupl !---------------------------------------------------------------! ! Compute spline coefficients for each coupling term !---------------------------------------------------------------! call SPLINE ( nr , rmat , vmat3D (:, lambda_index_ , coupling_index_ ), & spline_coeff_b , spline_coeff_c , spline_coeff_d ) !---------------------------------------------------------------! ! Store coefficients in the respective matrices !---------------------------------------------------------------! bmat3D (:, lambda_index_ , coupling_index_ ) = spline_coeff_b cmat3D (:, lambda_index_ , coupling_index_ ) = spline_coeff_c dmat3D (:, lambda_index_ , coupling_index_ ) = spline_coeff_d enddo enddo !---------------------------------------------------------------------! end subroutine interpolate_radial_coupling_terms","tags":"","loc":"proc/interpolate_radial_coupling_terms.html"},{"title":"read_radial_coupling_terms – the SCATTERING code","text":"public  subroutine read_radial_coupling_terms() reads the radial coupling terms from the external file.\nThe file is assumed to be formatted as described in\n\"Supplying radial terms\" section.\nThe read radial coupling terms are kept in vmat/read_vmat3D Arguments None Calls proc~~read_radial_coupling_terms~~CallsGraph proc~read_radial_coupling_terms read_radial_coupling_terms proc~file_io_status file_io_status proc~read_radial_coupling_terms->proc~file_io_status proc~integer_to_character integer_to_character proc~file_io_status->proc~integer_to_character proc~write_error write_error proc~file_io_status->proc~write_error proc~write_message write_message proc~write_error->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~read_radial_coupling_terms~~CalledByGraph proc~read_radial_coupling_terms read_radial_coupling_terms program~scattering SCATTERING program~scattering->proc~read_radial_coupling_terms Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code read_radial_coupling_terms Source Code subroutine read_radial_coupling_terms !! reads the radial coupling terms from the external file. !! The file is assumed to be formatted as described in !! \"Supplying radial terms\" section. !! The read radial coupling terms are kept in vmat/read_vmat3D !---------------------------------------------------------------------! character ( len = 200 ) :: err_message integer ( int32 ) :: nrtmp , l1 , iskip_ , lambda_index_ , ir , icol , io_status !---------------------------------------------------------------------! open ( pes_file_unit , file = trim ( potentialfile ), form = 'formatted' , & status = 'old' , iostat = io_status , iomsg = err_message ) call file_io_status ( io_status , err_message , pes_file_unit , 'o' ) !---------------------------------------------------------------------! ! Skip the informative lines at the beginning !---------------------------------------------------------------------! call skip_header_lines !---------------------------------------------------------------------! do lambda_index_ = 1 , nterms call read_and_validate_lambda ( lambda_index_ ) call read_potential_data ( lambda_index_ ) enddo !---------------------------------------------------------------------! close ( pes_file_unit , iostat = io_status , iomsg = err_message ) call file_io_status ( io_status , err_message , pes_file_unit , 'c' ) !---------------------------------------------------------------------! ! Check if supplied radial terms cover a sufficient range of R !---------------------------------------------------------------------! call validate_r_range !---------------------------------------------------------------------! end subroutine read_radial_coupling_terms","tags":"","loc":"proc/read_radial_coupling_terms.html"},{"title":"reduce_radial_coupling_terms – the SCATTERING code","text":"public  subroutine reduce_radial_coupling_terms() Reduces the read_vmat3D matrix to retain only the necessary coupling terms. Arguments None Calls proc~~reduce_radial_coupling_terms~~CallsGraph proc~reduce_radial_coupling_terms reduce_radial_coupling_terms proc~write_message write_message proc~reduce_radial_coupling_terms->proc~write_message proc~integer_to_character integer_to_character proc~reduce_radial_coupling_terms->proc~integer_to_character Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~reduce_radial_coupling_terms~~CalledByGraph proc~reduce_radial_coupling_terms reduce_radial_coupling_terms program~scattering SCATTERING program~scattering->proc~reduce_radial_coupling_terms Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code reduce_radial_coupling_terms Source Code subroutine reduce_radial_coupling_terms !! Reduces the read_vmat3D matrix to retain only the necessary coupling terms. !---------------------------------------------------------------------! integer ( int32 ) :: lambda_index_ , radial_index_ , coupling_index_ !---------------------------------------------------------------------! if ( totalcol /= ncoupl ) then call write_message ( \"Reducing the number of the radial coupling terms...\" ) call print_pes_quantum_numbers ( \"Original\" , totalcol ) call reduce_coupling_terms () call print_pes_quantum_numbers ( \"Reduced\" , ncoupl ) call write_message ( \"Reduced \" // & trim ( adjustl ( integer_to_character ( totalcol ))) // & \" radial terms to \" // trim ( adjustl ( integer_to_character ( ncoupl )))) else !------------------------------------------------------------------! ! if there is nothing to be reduced, copy read_vmat3d to vmat3d !------------------------------------------------------------------! vmat3D = read_vmat3D endif !---------------------------------------------------------------------! deallocate ( read_vmat3D ) !---------------------------------------------------------------------! end subroutine reduce_radial_coupling_terms","tags":"","loc":"proc/reduce_radial_coupling_terms.html"},{"title":"envj – the SCATTERING code","text":"public  function envj(n, x) utility function used by MSTA1 and MSTA2. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: x Return Value real(kind=8) Called by proc~~envj~~CalledByGraph proc~envj envj proc~msta1 msta1 proc~msta1->proc~envj proc~msta2 msta2 proc~msta2->proc~envj proc~ikv ikv proc~ikv->proc~msta1 proc~ikv->proc~msta2 proc~rctj rctj proc~rctj->proc~msta1 proc~rctj->proc~msta2 proc~modified_bessel_k_ratio modified_bessel_k_ratio proc~modified_bessel_k_ratio->proc~ikv proc~riccati_bessel_j riccati_bessel_j proc~riccati_bessel_j->proc~rctj proc~calculate_k_matrix calculate_k_matrix proc~calculate_k_matrix->proc~modified_bessel_k_ratio proc~calculate_k_matrix->proc~riccati_bessel_j program~scattering SCATTERING program~scattering->proc~calculate_k_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables logten n_r8 r8_gamma_log Variables Type Visibility Attributes Name Initial real(kind=8), public :: logten real(kind=8), public :: n_r8 real(kind=8), public :: r8_gamma_log","tags":"","loc":"proc/envj.html"},{"title":"msta1 – the SCATTERING code","text":"public  function msta1(x, mp) determines a backward recurrence starting point for Jn(x). Arguments Type Intent Optional Attributes Name real(kind=8) :: x integer(kind=4) :: mp Return Value integer(kind=4) Calls proc~~msta1~~CallsGraph proc~msta1 msta1 proc~envj envj proc~msta1->proc~envj Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~msta1~~CalledByGraph proc~msta1 msta1 proc~ikv ikv proc~ikv->proc~msta1 proc~rctj rctj proc~rctj->proc~msta1 proc~modified_bessel_k_ratio modified_bessel_k_ratio proc~modified_bessel_k_ratio->proc~ikv proc~riccati_bessel_j riccati_bessel_j proc~riccati_bessel_j->proc~rctj proc~calculate_k_matrix calculate_k_matrix proc~calculate_k_matrix->proc~modified_bessel_k_ratio proc~calculate_k_matrix->proc~riccati_bessel_j program~scattering SCATTERING program~scattering->proc~calculate_k_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables a0 f f0 f1 it n0 n1 nn Variables Type Visibility Attributes Name Initial real(kind=8), public :: a0 real(kind=8), public :: f real(kind=8), public :: f0 real(kind=8), public :: f1 integer(kind=4), public :: it integer(kind=4), public :: n0 integer(kind=4), public :: n1 integer(kind=4), public :: nn","tags":"","loc":"proc/msta1.html"},{"title":"msta2 – the SCATTERING code","text":"public  function msta2(x, n, mp) determines a backward recurrence starting point for Jn(x). Arguments Type Intent Optional Attributes Name real(kind=8) :: x integer(kind=4) :: n integer(kind=4) :: mp Return Value integer(kind=4) Calls proc~~msta2~~CallsGraph proc~msta2 msta2 proc~envj envj proc~msta2->proc~envj Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~msta2~~CalledByGraph proc~msta2 msta2 proc~ikv ikv proc~ikv->proc~msta2 proc~rctj rctj proc~rctj->proc~msta2 proc~modified_bessel_k_ratio modified_bessel_k_ratio proc~modified_bessel_k_ratio->proc~ikv proc~riccati_bessel_j riccati_bessel_j proc~riccati_bessel_j->proc~rctj proc~calculate_k_matrix calculate_k_matrix proc~calculate_k_matrix->proc~modified_bessel_k_ratio proc~calculate_k_matrix->proc~riccati_bessel_j program~scattering SCATTERING program~scattering->proc~calculate_k_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables a0 ejn f f0 f1 hmp it n0 n1 nn obj Variables Type Visibility Attributes Name Initial real(kind=8), public :: a0 real(kind=8), public :: ejn real(kind=8), public :: f real(kind=8), public :: f0 real(kind=8), public :: f1 real(kind=8), public :: hmp integer(kind=4), public :: it integer(kind=4), public :: n0 integer(kind=4), public :: n1 integer(kind=4), public :: nn real(kind=8), public :: obj","tags":"","loc":"proc/msta2.html"},{"title":"gamma – the SCATTERING code","text":"public  subroutine gamma(x, ga) evaluates the Gamma function. Arguments Type Intent Optional Attributes Name real(kind=8) :: x real(kind=8) :: ga Contents Variables g gr k m m1 pi r z Variables Type Visibility Attributes Name Initial real(kind=8), public, dimension ( 26 ) :: g = (/1.0D+00, 0.5772156649015329D+00, -0.6558780715202538D+00, -0.420026350340952D-01, 0.1665386113822915D+00, -0.421977345555443D-01, -0.96219715278770D-02, 0.72189432466630D-02, -0.11651675918591D-02, -0.2152416741149D-03, 0.1280502823882D-03, -0.201348547807D-04, -0.12504934821D-05, 0.11330272320D-05, -0.2056338417D-06, 0.61160950D-08, 0.50020075D-08, -0.11812746D-08, 0.1043427D-09, 0.77823D-11, -0.36968D-11, 0.51D-12, -0.206D-13, -0.54D-14, 0.14D-14, 0.1D-15/) real(kind=8), public :: gr integer(kind=4), public :: k integer(kind=4), public :: m integer(kind=4), public :: m1 real(kind=8), public, parameter :: pi = 3.141592653589793D+00 real(kind=8), public :: r real(kind=8), public :: z","tags":"","loc":"proc/gamma.html"},{"title":"ikv – the SCATTERING code","text":"public  subroutine ikv(v, x, vm, bi, di, bk, dk) computes modified Bessel function Iv(x) and Kv(x) and their derivatives. Arguments Type Intent Optional Attributes Name real(kind=8) :: v real(kind=8) :: x real(kind=8) :: vm real(kind=8) :: bi (0:*) real(kind=8) :: di (0:*) real(kind=8) :: bk (0:*) real(kind=8) :: dk (0:*) Calls proc~~ikv~~CallsGraph proc~ikv ikv proc~msta1 msta1 proc~ikv->proc~msta1 proc~msta2 msta2 proc~ikv->proc~msta2 proc~envj envj proc~msta1->proc~envj proc~msta2->proc~envj Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~ikv~~CalledByGraph proc~ikv ikv proc~modified_bessel_k_ratio modified_bessel_k_ratio proc~modified_bessel_k_ratio->proc~ikv proc~calculate_k_matrix calculate_k_matrix proc~calculate_k_matrix->proc~modified_bessel_k_ratio program~scattering SCATTERING program~scattering->proc~calculate_k_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables a1 a2 bi0 bk0 bk1 bk2 ca cb cs ct f f1 f2 gan gap k k0 m n pi piv r r1 r2 sum v0 v0n v0p vt w0 wa ww x2 Variables Type Visibility Attributes Name Initial real(kind=8), public :: a1 real(kind=8), public :: a2 real(kind=8), public :: bi0 real(kind=8), public :: bk0 real(kind=8), public :: bk1 real(kind=8), public :: bk2 real(kind=8), public :: ca real(kind=8), public :: cb real(kind=8), public :: cs real(kind=8), public :: ct real(kind=8), public :: f real(kind=8), public :: f1 real(kind=8), public :: f2 real(kind=8), public :: gan real(kind=8), public :: gap integer(kind=4), public :: k integer(kind=4), public :: k0 integer(kind=4), public :: m integer(kind=4), public :: n real(kind=8), public :: pi real(kind=8), public :: piv real(kind=8), public :: r real(kind=8), public :: r1 real(kind=8), public :: r2 real(kind=8), public :: sum real(kind=8), public :: v0 real(kind=8), public :: v0n real(kind=8), public :: v0p real(kind=8), public :: vt real(kind=8), public :: w0 real(kind=8), public :: wa real(kind=8), public :: ww real(kind=8), public :: x2","tags":"","loc":"proc/ikv.html"},{"title":"rctj – the SCATTERING code","text":"public  subroutine rctj(n, x, nm, rj, dj) computes Riccati-Bessel function of the first kind, and derivatives. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: x integer(kind=4) :: nm real(kind=8) :: rj (0:n) real(kind=8) :: dj (0:n) Calls proc~~rctj~~CallsGraph proc~rctj rctj proc~msta1 msta1 proc~rctj->proc~msta1 proc~msta2 msta2 proc~rctj->proc~msta2 proc~envj envj proc~msta1->proc~envj proc~msta2->proc~envj Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~rctj~~CalledByGraph proc~rctj rctj proc~riccati_bessel_j riccati_bessel_j proc~riccati_bessel_j->proc~rctj proc~calculate_k_matrix calculate_k_matrix proc~calculate_k_matrix->proc~riccati_bessel_j program~scattering SCATTERING program~scattering->proc~calculate_k_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables cs f f0 f1 k m rj0 rj1 Variables Type Visibility Attributes Name Initial real(kind=8), public :: cs real(kind=8), public :: f real(kind=8), public :: f0 real(kind=8), public :: f1 integer(kind=4), public :: k integer(kind=4), public :: m real(kind=8), public :: rj0 real(kind=8), public :: rj1","tags":"","loc":"proc/rctj.html"},{"title":"rcty – the SCATTERING code","text":"public  subroutine rcty(n, x, nm, ry, dy) computes Riccati-Bessel function of the second kind, and derivatives. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: x integer(kind=4) :: nm real(kind=8) :: ry (0:n) real(kind=8) :: dy (0:n) Called by proc~~rcty~~CalledByGraph proc~rcty rcty proc~riccati_bessel_y riccati_bessel_y proc~riccati_bessel_y->proc~rcty proc~calculate_k_matrix calculate_k_matrix proc~calculate_k_matrix->proc~riccati_bessel_y program~scattering SCATTERING program~scattering->proc~calculate_k_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables k rf0 rf1 rf2 Variables Type Visibility Attributes Name Initial integer(kind=4), public :: k real(kind=8), public :: rf0 real(kind=8), public :: rf1 real(kind=8), public :: rf2","tags":"","loc":"proc/rcty.html"},{"title":"ETOTAL – the SCATTERING code","text":"public  function ETOTAL() result(etot_) returns the total energy Arguments None Return Value real(kind=dp) Called by proc~~etotal~~CalledByGraph proc~etotal ETOTAL proc~is_open is_open proc~is_open->proc~etotal program~scattering SCATTERING program~scattering->proc~etotal proc~numerov numerov program~scattering->proc~numerov proc~count_open_channels_in_block count_open_channels_in_block program~scattering->proc~count_open_channels_in_block proc~save_open_basis_levels save_open_basis_levels program~scattering->proc~save_open_basis_levels proc~calculate_k_matrix calculate_k_matrix program~scattering->proc~calculate_k_matrix proc~count_open_basis_levels count_open_basis_levels program~scattering->proc~count_open_basis_levels proc~calculate_largest_wavenumber calculate_largest_wavenumber program~scattering->proc~calculate_largest_wavenumber proc~print_channels print_channels program~scattering->proc~print_channels proc~read_input_file read_input_file program~scattering->proc~read_input_file proc~wavenumber_from_energy wavenumber_from_energy proc~wavenumber_from_energy->proc~etotal proc~input_summary input_summary proc~input_summary->proc~etotal proc~numerov->proc~etotal proc~count_open_channels_in_block->proc~is_open proc~save_open_basis_levels->proc~is_open proc~save_open_basis_levels->proc~wavenumber_from_energy proc~calculate_k_matrix->proc~is_open proc~calculate_k_matrix->proc~wavenumber_from_energy proc~count_open_basis_levels->proc~is_open proc~calculate_largest_wavenumber->proc~is_open proc~calculate_largest_wavenumber->proc~wavenumber_from_energy proc~print_channels->proc~is_open proc~print_channels->proc~wavenumber_from_energy proc~read_input_file->proc~input_summary Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/etotal.html"},{"title":"count_open_basis_levels – the SCATTERING code","text":"public  function count_open_basis_levels() result(open_) counts the energetically accessible levels in the basis Arguments None Return Value integer(kind=int32) Calls proc~~count_open_basis_levels~~CallsGraph proc~count_open_basis_levels count_open_basis_levels proc~is_open is_open proc~count_open_basis_levels->proc~is_open proc~etotal ETOTAL proc~is_open->proc~etotal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~count_open_basis_levels~~CalledByGraph proc~count_open_basis_levels count_open_basis_levels program~scattering SCATTERING program~scattering->proc~count_open_basis_levels Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables ilevel Source Code count_open_basis_levels Variables Type Visibility Attributes Name Initial integer(kind=int32), public :: ilevel Source Code function count_open_basis_levels () result ( open_ ) !! counts the energetically accessible levels in the basis !------------------------------------------------------------------------! integer ( int32 ) :: open_ , ilevel !------------------------------------------------------------------------! open_ = 0 do ilevel = 1 , nlevel if ( is_open ( elevel ( ilevel ))) open_ = open_ + 1 enddo !------------------------------------------------------------------------! end function count_open_basis_levels","tags":"","loc":"proc/count_open_basis_levels.html"},{"title":"is_open – the SCATTERING code","text":"public  function is_open(energy_) result(is_open_) checks if a channel/level is energetically accessible (open)\nby comparing energy with etotal() Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: energy_ level/channel energy Return Value logical Calls proc~~is_open~~CallsGraph proc~is_open is_open proc~etotal ETOTAL proc~is_open->proc~etotal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~is_open~~CalledByGraph proc~is_open is_open proc~count_open_channels_in_block count_open_channels_in_block proc~count_open_channels_in_block->proc~is_open proc~save_open_basis_levels save_open_basis_levels proc~save_open_basis_levels->proc~is_open proc~calculate_k_matrix calculate_k_matrix proc~calculate_k_matrix->proc~is_open proc~count_open_basis_levels count_open_basis_levels proc~count_open_basis_levels->proc~is_open proc~calculate_largest_wavenumber calculate_largest_wavenumber proc~calculate_largest_wavenumber->proc~is_open proc~print_channels print_channels proc~print_channels->proc~is_open program~scattering SCATTERING program~scattering->proc~count_open_channels_in_block program~scattering->proc~save_open_basis_levels program~scattering->proc~calculate_k_matrix program~scattering->proc~count_open_basis_levels program~scattering->proc~calculate_largest_wavenumber program~scattering->proc~print_channels Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code is_open Source Code function is_open ( energy_ ) result ( is_open_ ) !! checks if a channel/level is energetically accessible (open) !! by comparing energy with etotal() !------------------------------------------------------------------------! real ( dp ), intent ( in ) :: energy_ !! level/channel energy logical :: is_open_ !------------------------------------------------------------------------! is_open_ = ( energy_ <= ETOTAL () ) !------------------------------------------------------------------------! end function is_open","tags":"","loc":"proc/is_open.html"},{"title":"wavenumber_from_energy – the SCATTERING code","text":"public  function wavenumber_from_energy(energy_) result(k_) returns the wavenumber, k_{a}, given the energy of a given state,\nE_{a}; calls etot() function; atomic units in the whole function\n k_{a} = \\sqrt(2 \\mu (E_{tot} - E_{a}) \nsince it uses reducedmass and etotal(), the function checks\nif units are already converted Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: energy_ energy of a given state,  E_{a} , in a.u. Return Value real(kind=dp) wavenumber, k_{a}, in a.u. Calls proc~~wavenumber_from_energy~~CallsGraph proc~wavenumber_from_energy wavenumber_from_energy proc~etotal ETOTAL proc~wavenumber_from_energy->proc~etotal proc~write_error write_error proc~wavenumber_from_energy->proc~write_error proc~write_message write_message proc~write_error->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~wavenumber_from_energy~~CalledByGraph proc~wavenumber_from_energy wavenumber_from_energy proc~save_open_basis_levels save_open_basis_levels proc~save_open_basis_levels->proc~wavenumber_from_energy proc~calculate_k_matrix calculate_k_matrix proc~calculate_k_matrix->proc~wavenumber_from_energy proc~print_channels print_channels proc~print_channels->proc~wavenumber_from_energy proc~calculate_largest_wavenumber calculate_largest_wavenumber proc~calculate_largest_wavenumber->proc~wavenumber_from_energy program~scattering SCATTERING program~scattering->proc~save_open_basis_levels program~scattering->proc~calculate_k_matrix program~scattering->proc~print_channels program~scattering->proc~calculate_largest_wavenumber Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents","tags":"","loc":"proc/wavenumber_from_energy.html"},{"title":"input_check – the SCATTERING code","text":"public  subroutine input_check(nmlistind) checks if the supplied input parameters are correct Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: nmlistind nmlistind = 1: namelist INPUT\nnmlistind = 2: namelist BASIS\nnmlistind = 3: namelist POTENTIAL Calls proc~~input_check~~CallsGraph proc~input_check input_check interface~incorrect_value incorrect_value proc~input_check->interface~incorrect_value proc~integer_to_character integer_to_character proc~input_check->proc~integer_to_character proc~write_error write_error proc~input_check->proc~write_error proc~write_message write_message proc~input_check->proc~write_message proc~write_error->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~input_check~~CalledByGraph proc~input_check input_check proc~read_input_file read_input_file proc~read_input_file->proc~input_check program~scattering SCATTERING program~scattering->proc~read_input_file Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables icol il ilevel Source Code input_check Variables Type Visibility Attributes Name Initial integer(kind=int32), public :: icol integer(kind=int32), public :: il integer(kind=int32), public :: ilevel Source Code subroutine input_check ( nmlistind ) !! checks if the supplied input parameters are correct !------------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: nmlistind !! nmlistind = 1: namelist INPUT !! nmlistind = 2: namelist BASIS !! nmlistind = 3: namelist POTENTIAL !------------------------------------------------------------------------! integer ( int32 ) :: ilevel , il , icol !------------------------------------------------------------------------! if ( nmlistind . eq . 1 ) then !------------------------------------------------------------------------! ! Namelist input: !------------------------------------------------------------------------! if ( reducedmass . lt . 0 ) then call incorrect_value ( \"reducedmass\" , reducedmass , 5 ) endif if (( ietoterel . ne . 0 ). and .( ietoterel . ne . 1 )) then call incorrect_value ( \"ietoterel\" , ietoterel , 5 ) endif if ( energy . lt . 0 ) then call incorrect_value ( \"energy\" , energy , 5 ) endif if ( rmin . le . 0 ) then call incorrect_value ( \"rmin\" , rmin , 5 ) endif if ( rmax . le . 0 ) then call incorrect_value ( \"rmax\" , rmax , 5 ) endif if ( rmax . lt . rmin ) then call incorrect_value ( \"rmax/rmin\" , rmax / rmin , 5 ) endif if ( steps . le . 0.d0 ) then call incorrect_value ( \"steps\" , steps , 5 ) endif if ( vdepth . lt . 0.d0 ) then call incorrect_value ( \"vdepth\" , vdepth , 5 ) endif if ( jtotmin . lt . 0 ) then call incorrect_value ( \"jtotmin\" , jtotmin , 5 ) endif if ( jtotmax . lt . 0 ) then if ( ncac . lt . 0 ) then call write_message ( \"JTOTMAX < 0:\" ) call incorrect_value ( \"ncac\" , ncac , 5 ) endif if ( dtol . lt . 0 ) then call write_message ( \"JTOTMAX < 0:\" ) call incorrect_value ( \"dtol\" , dtol , 5 ) endif if ( otol . lt . 0 ) then call write_message ( \"JTOTMAX < 0:\" ) call incorrect_value ( \"otol\" , otol , 5 ) endif else if ( jtotmax . lt . jtotmin ) then call write_message ( \"jtotmax is smaller than jtotmin\" ) call incorrect_value ( \"jtotmax/jtotmin\" , & real ( jtotmax / jtotmin , dp ), 5 ) endif endif if ( nlevel . le . 0 ) then call incorrect_value ( \"nlevel\" , nlevel , 5 ) endif if ( ietoterel . eq . 1 ) then if ( initial . le . 0 ) then call write_message ( \"ietoterel = 1:\" ) call incorrect_value ( \"initial\" , initial , 5 ) endif if ( initial . gt . nlevel ) then call write_message ( \"ietoterel = 1:\" ) call write_message ( \"nlevel = \" // integer_to_character ( nlevel )) call incorrect_value ( \"initial > nlevel\" , initial , 5 ) endif endif if ( nr . le . 0 ) then call incorrect_value ( \"nr\" , nr , 5 ) endif if ( nterms . le . 0 ) then call incorrect_value ( \"nterms\" , nterms , 5 ) endif if ( totalcol . le . 0 ) then call incorrect_value ( \"totalcol\" , totalcol , 5 ) endif if ( n_skip_lines . lt . 0 ) then call incorrect_value ( \"n_skip_lines\" , n_skip_lines , 5 ) endif if (( iunits . ne . 0 ). and .( iunits . ne . 1 )) then call incorrect_value ( \"iunits\" , iunits , 5 ) endif inquire ( file = potentialfile , exist = pes_file_exists ) if ( pes_file_exists . eqv .. false .) then call write_error ( trim ( adjustl ( potentialfile )) // \" does not exist\" ) endif if (( ipart . ne . 0 ). and .( ipart . ne . 1 )) then call incorrect_value ( \"ipart\" , ipart , 5 ) endif if ( prntlvl . lt . 0 ) then call incorrect_value ( \"prntlvl\" , prntlvl , 5 ) endif !------------------------------------------------------------------------! else if ( nmlistind . eq . 2 ) then !------------------------------------------------------------------------! ! Namelist basis: !------------------------------------------------------------------------! do ilevel = 1 , nlevel if ( v1array ( ilevel ). lt . 0 ) then call incorrect_value ( \"v1array(\" // integer_to_character ( ilevel ) // \")\" , v1array ( ilevel ), 5 ) endif if ( j1array ( ilevel ). lt . 0 ) then call incorrect_value ( \"j1array(\" // integer_to_character ( ilevel ) // \")\" , j1array ( ilevel ), 5 ) endif if ( elevel ( ilevel ). lt . 0.0_dp ) then call incorrect_value ( \"elevel(\" // integer_to_character ( ilevel ) // \")\" , elevel ( ilevel ), 5 ) endif enddo !------------------------------------------------------------------------! else if ( nmlistind . eq . 3 ) then !------------------------------------------------------------------------! ! Namelist potential: !------------------------------------------------------------------------! do il = 1 , nterms if ( l1tab ( il ). lt . 0 ) then call incorrect_value ( \"l1tab(\" // integer_to_character ( il ) // \")\" , l1tab ( il ), 5 ) endif enddo do icol = 1 , totalcol if ( v1pes ( icol ). lt . 0 ) then call incorrect_value ( \"v1pes(\" // integer_to_character ( icol ) // \")\" , v1pes ( icol ), 5 ) endif if ( j1pes ( icol ). lt . 0 ) then call incorrect_value ( \"j1pes(\" // integer_to_character ( icol ) // \")\" , j1pes ( icol ), 5 ) endif if ( v1ppes ( icol ). lt . 0 ) then call incorrect_value ( \"vp1pes(\" // integer_to_character ( icol ) // \")\" , v1ppes ( icol ), 5 ) endif if ( j1ppes ( icol ). lt . 0 ) then call incorrect_value ( \"j1ppes(\" // integer_to_character ( icol ) // \")\" , j1ppes ( icol ), 5 ) endif enddo endif !------------------------------------------------------------------------! end subroutine input_check","tags":"","loc":"proc/input_check.html"},{"title":"input_summary – the SCATTERING code","text":"public  subroutine input_summary() summarize the input parameters for the current run Arguments None Calls proc~~input_summary~~CallsGraph proc~input_summary input_summary proc~write_message write_message proc~input_summary->proc~write_message proc~integer_to_character integer_to_character proc~input_summary->proc~integer_to_character proc~float_to_character float_to_character proc~input_summary->proc~float_to_character proc~etotal ETOTAL proc~input_summary->proc~etotal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~input_summary~~CalledByGraph proc~input_summary input_summary proc~read_input_file read_input_file proc~read_input_file->proc~input_summary program~scattering SCATTERING program~scattering->proc~read_input_file Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables ilevel Source Code input_summary Variables Type Visibility Attributes Name Initial integer(kind=int32), public :: ilevel Source Code subroutine input_summary !! summarize the input parameters for the current run !------------------------------------------------------------------------! integer ( int32 ) :: ilevel !------------------------------------------------------------------------! call write_message ( \"User-supplied label: \" // label ) call write_message ( \"Reduced mass: \" // & trim ( adjustl ( float_to_character ( reducedmass , \"(F10.4)\" ))) // \" a.m.u.\" ) call write_message ( \"*** Energy levels in the basis set: ***\" ) call write_message ( \"   v       j            Energy (cm&#94;{-1})\" ) do ilevel = 1 , nlevel write ( * , \"(I4,4X,I4,16X,F12.4)\" ) v1array ( ilevel ), j1array ( ilevel ), elevel ( ilevel ) enddo write ( * , \"(44X,A3)\" ) \"***\" if ( jtotmax . ne . 999999 ) then call write_message ( \"The equations will be solved \" // & \"for total angular momentum J from \" // & trim ( adjustl ( integer_to_character ( jtotmin ))) // \" to \" & // trim ( adjustl ( integer_to_character ( jtotmax ))) // \" with step \" // & trim ( adjustl ( integer_to_character ( jtotstep )))) else call write_message ( \"The loop over JTOT will be performed from \" // & trim ( adjustl ( integer_to_character ( jtotmin ))) // \" with step \" // & trim ( adjustl ( integer_to_character ( jtotstep ))) // \" until \" // & trim ( adjustl ( integer_to_character ( ncac ))) // & \" consecutive JTOT-blocks contribute less than \" // & trim ( adjustl ( float_to_character ( dtol , \"(E10.4)\" ))) // & \" A&#94;2 to the elastic XS and less than \" // & trim ( adjustl ( float_to_character ( otol , \"(E10.4)\" ))) // & \" A&#94;2 to the inelastic XS\" ) endif if ( ietoterel . eq . 0 ) then call write_message ( \"The calculations will be performed for the total energy equal to \" & // trim ( adjustl ( float_to_character ( ETOTAL (), \"(F10.4)\" ))) // \" cm-1\" ) else if ( ietoterel . eq . 1 ) then call write_message ( \"Relative kinetic energy of the colliding system: \" // & trim ( adjustl ( float_to_character ( energy , \"(F10.4)\" ))) // \" cm-1\" ) call write_message ( \"The kinetic energy is calculated with respect to the\" // & \" v = \" // trim ( adjustl ( integer_to_character ( v1array ( initial )))) // & \" j = \" // trim ( adjustl ( integer_to_character ( j1array ( initial )))) // & \" level in the basis set with the rotational energy \" // & trim ( adjustl ( float_to_character ( elevel ( initial ), \"(F10.4)\" ))) & // \" cm-1.\" ) call write_message ( \"This gives the total energy equal to \" // & trim ( adjustl ( float_to_character ( ETOTAL (), \"(F10.4)\" ))) // \" cm-1\" ) endif if ( ipart . eq . 1 ) then call write_message ( \"Partial cross sections will be saved into \" // partialfile ) endif call write_message ( \"S-matrix elements will be saved into \" // smatrixfile ) !------------------------------------------------------------------------! end subroutine input_summary","tags":"","loc":"proc/input_summary.html"},{"title":"read_input_file – the SCATTERING code","text":"public  subroutine read_input_file() reads the input file prepared by the user using NAMELIST feature\nthe code uses 3 namelists: input, basis and potential Arguments None Calls proc~~read_input_file~~CallsGraph proc~read_input_file read_input_file interface~allocate_1d allocate_1d proc~read_input_file->interface~allocate_1d interface~allocate_3d allocate_3d proc~read_input_file->interface~allocate_3d proc~input_summary input_summary proc~read_input_file->proc~input_summary proc~file_io_status file_io_status proc~read_input_file->proc~file_io_status proc~input_check input_check proc~read_input_file->proc~input_check proc~integer_to_character integer_to_character proc~input_summary->proc~integer_to_character proc~etotal ETOTAL proc~input_summary->proc~etotal proc~write_message write_message proc~input_summary->proc~write_message proc~float_to_character float_to_character proc~input_summary->proc~float_to_character proc~file_io_status->proc~integer_to_character proc~write_error write_error proc~file_io_status->proc~write_error proc~input_check->proc~integer_to_character interface~incorrect_value incorrect_value proc~input_check->interface~incorrect_value proc~input_check->proc~write_message proc~input_check->proc~write_error proc~write_error->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~read_input_file~~CalledByGraph proc~read_input_file read_input_file program~scattering SCATTERING program~scattering->proc~read_input_file Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables err_message icol icoupl iilevel il ilevel io_status Source Code read_input_file Variables Type Visibility Attributes Name Initial character(len=200), public :: err_message integer(kind=int32), public :: icol integer(kind=int32), public :: icoupl integer(kind=int32), public :: iilevel integer(kind=int32), public :: il integer(kind=int32), public :: ilevel integer(kind=int32), public :: io_status Source Code subroutine read_input_file !! reads the input file prepared by the user using NAMELIST feature !! the code uses 3 namelists: input, basis and potential !------------------------------------------------------------------------! character ( len = 200 ) :: err_message integer ( int32 ) :: ilevel , iilevel , icoupl , icol , il , io_status !------------------------------------------------------------------------! namelist / INPUT / label , reducedmass , ietoterel , energy , & jtotmin , jtotmax , jtotstep , rmin , rmax , dr , steps , vdepth , & ncac , dtol , otol , nlevel , initial , nr , nterms , totalcol , & n_skip_lines , iunits , potentialfile , smatrixfile , ipart , partialfile , & prntlvl namelist / BASIS / v1array , j1array , elevel namelist / POTENTIAL / l1tab , l2tab , lltab , v1pes , j1pes , v1ppes , j1ppes !------------------------------------------------------------------------------! ! Pre-declaration of variables                                                 ! !------------------------------------------------------------------------------! ! The most important variables (if they are not specified, the code stops):    ! !------------------------------------------------------------------------------! reducedmass = - 1.0_dp energy = - 1.0_dp rmin = - 1.0_dp rmax = - 1.0_dp nlevel = - 1 initial = - 1 nr = - 1 nterms = - 1 !------------------------------------------------------------------------------! ! Additional variables (the code runs with the pre-declared values):           ! !------------------------------------------------------------------------------! ietoterel = 0 jtotmin = 0 jtotmax = - 1 jtotstep = 1 dr = - 1.0_dp steps = 10 vdepth = 0.0_dp ncac = 1 dtol = 0.1_dp otol = 0.1_dp totalcol = 1 n_skip_lines = 0 iunits = 0 potentialfile = 'RadialTerms.dat' smatrixfile = 'SmatrixFile.dat' ipart = 0 partialfile = 'PartialFile.dat' prntlvl = 2 !------------------------------------------------------------------------------! open ( unit = 5 , action = 'read' , form = 'formatted' , access = 'sequential' , & status = 'old' , iostat = io_status , iomsg = err_message ) call file_io_status ( io_status , err_message , 5 , 'o' ) !------------------------------------------------------------------------------! ! Read the input namelist:                                                     ! !------------------------------------------------------------------------------! read ( unit = 5 , nml = INPUT , iostat = io_status , iomsg = err_message ) call file_io_status ( io_status , err_message , 5 , 'r' ) !------------------------------------------------------------------------------! ! Check if the variables from input namelist are supplied correctly:           ! !------------------------------------------------------------------------------! call input_check ( 1 ) if ( jtotmax . eq . - 1 ) jtotmax = 999999 call allocate_1d ( v1array , nlevel ) call allocate_1d ( j1array , nlevel ) call allocate_1d ( elevel , nlevel ) call allocate_1d ( l1tab , nterms ) call allocate_1d ( v1pes , totalcol ) call allocate_1d ( v1ppes , totalcol ) call allocate_1d ( j1pes , totalcol ) call allocate_1d ( j1ppes , totalcol ) select case ( iunits ) case ( 0 ) radial_term_distance_converter = 1.0_dp case ( 1 ) radial_term_distance_converter = bohrtoangstrom end select radial_term_energy_converter = 1.0_dp / hartreetocm !------------------------------------------------------------------------------! ! Read the basis namelist & check if the values were supplied correctly:       ! !------------------------------------------------------------------------------! read ( unit = 5 , nml = BASIS , iostat = io_status , iomsg = err_message ) call file_io_status ( io_status , err_message , 5 , 'r' ) call input_check ( 2 ) !------------------------------------------------------------------------------! ! If itype = 2/4 the code reads all the totalcol coupling terms, but some of   ! ! them will not be used in the calculations. Here, the code prepares           ! ! the arrays of ncoupl size, that will hold only the necessary terms           ! !------------------------------------------------------------------------------! ncoupl = nlevel * ( nlevel + 1 ) / 2 call allocate_1d ( reduced_j1pes , ncoupl ) call allocate_1d ( reduced_j1ppes , ncoupl ) call allocate_1d ( reduced_v1pes , ncoupl ) call allocate_1d ( reduced_v1ppes , ncoupl ) icoupl = 0 do ilevel = 1 , nlevel do iilevel = ilevel , nlevel icoupl = icoupl + 1 reduced_v1pes ( icoupl ) = v1array ( ilevel ) reduced_j1pes ( icoupl ) = j1array ( ilevel ) reduced_v1ppes ( icoupl ) = v1array ( iilevel ) reduced_j1ppes ( icoupl ) = j1array ( iilevel ) enddo enddo !------------------------------------------------------------------------------! ! Read the potential namelist & check if the values were supplied correctly:   ! !------------------------------------------------------------------------------! read ( unit = 5 , nml = POTENTIAL , iostat = io_status , iomsg = err_message ) call file_io_status ( io_status , err_message , 5 , 'r' ) call input_check ( 3 ) close ( 5 ) !------------------------------------------------------------------------------! ! Prepare the arrays that are needed for interpolation of the coupling terms:  ! !------------------------------------------------------------------------------! call allocate_1d ( rmat , nr ) call allocate_1d ( spline_coeff_b , nr ) call allocate_1d ( spline_coeff_c , nr ) call allocate_1d ( spline_coeff_d , nr ) call allocate_3d ( read_vmat3D , nr , nterms , totalcol ) call allocate_3d ( vmat3D , nr , nterms , ncoupl ) call allocate_3d ( bmat3D , nr , nterms , ncoupl ) call allocate_3d ( cmat3D , nr , nterms , ncoupl ) call allocate_3d ( dmat3D , nr , nterms , ncoupl ) !------------------------------------------------------------------------------! ! Summarize the input parameters:                                              ! !------------------------------------------------------------------------------! call input_summary end subroutine read_input_file","tags":"","loc":"proc/read_input_file.html"},{"title":"save_open_basis_levels – the SCATTERING code","text":"public  subroutine save_open_basis_levels(number_of_open_basis_levels, open_basis_levels, open_basis_wavevectors) saves indices to open levels in the basis and corresponding\nwavenumbers (in A&#94;2) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: number_of_open_basis_levels number of energetically accessible levels in the basis integer(kind=int32), intent(inout) :: open_basis_levels (number_of_open_basis_levels) array holding indices to energetically accessible levels in the basis real(kind=dp), intent(inout) :: open_basis_wavevectors (number_of_open_basis_levels) array holding wavevectors calculated w.r.t energetically accessible levels in the basis Calls proc~~save_open_basis_levels~~CallsGraph proc~save_open_basis_levels save_open_basis_levels proc~is_open is_open proc~save_open_basis_levels->proc~is_open proc~wavenumber_from_energy wavenumber_from_energy proc~save_open_basis_levels->proc~wavenumber_from_energy proc~etotal ETOTAL proc~is_open->proc~etotal proc~wavenumber_from_energy->proc~etotal proc~write_error write_error proc~wavenumber_from_energy->proc~write_error proc~write_message write_message proc~write_error->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~save_open_basis_levels~~CalledByGraph proc~save_open_basis_levels save_open_basis_levels program~scattering SCATTERING program~scattering->proc~save_open_basis_levels Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables count_ ilevel Source Code save_open_basis_levels Variables Type Visibility Attributes Name Initial integer(kind=int32), public :: count_ integer(kind=int32), public :: ilevel Source Code subroutine save_open_basis_levels ( number_of_open_basis_levels , & open_basis_levels , open_basis_wavevectors ) !! saves indices to open levels in the basis and corresponding !! wavenumbers (in A&#94;2) !------------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: number_of_open_basis_levels !! number of energetically accessible levels in the basis integer ( int32 ), intent ( inout ) :: open_basis_levels ( number_of_open_basis_levels ) !! array holding indices to energetically accessible levels in the basis real ( dp ), intent ( inout ) :: open_basis_wavevectors ( number_of_open_basis_levels ) !! array holding wavevectors calculated w.r.t energetically accessible levels in the basis !------------------------------------------------------------------------! integer ( int32 ) :: count_ , ilevel !------------------------------------------------------------------------! count_ = 0 do ilevel = 1 , nlevel if ( is_open ( elevel ( ilevel ))) then count_ = count_ + 1 open_basis_levels ( count_ ) = ilevel open_basis_wavevectors ( count_ ) = & wavenumber_from_energy ( elevel ( ilevel )) / bohrtoangstrom endif enddo !------------------------------------------------------------------------! end subroutine save_open_basis_levels","tags":"","loc":"proc/save_open_basis_levels.html"},{"title":"units_conversion – the SCATTERING code","text":"public  subroutine units_conversion() converts all physical quantities to atomic units Arguments None Called by proc~~units_conversion~~CalledByGraph proc~units_conversion units_conversion program~scattering SCATTERING program~scattering->proc~units_conversion Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables ilevel Source Code units_conversion Variables Type Visibility Attributes Name Initial integer(kind=int32), public :: ilevel Source Code subroutine units_conversion !! converts all physical quantities to atomic units !------------------------------------------------------------------------! integer ( int32 ) :: ilevel !------------------------------------------------------------------------! reducedmass = reducedmass * amutoau energy = energy / hartreetocm vdepth = vdepth / hartreetocm !------------------------------------------------------------------------! do ilevel = 1 , nlevel elevel ( ilevel ) = elevel ( ilevel ) / hartreetocm enddo !------------------------------------------------------------------------! units_converted = . true . !------------------------------------------------------------------------! end subroutine units_conversion","tags":"","loc":"proc/units_conversion.html"},{"title":"is_sum_even – the SCATTERING code","text":"public  function is_sum_even(x, y, z) result(sum_even) checks if the sum of 3 integers is an even integer Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x variables to check if the sum is even integer(kind=int32), intent(in) :: y variables to check if the sum is even integer(kind=int32), intent(in) :: z variables to check if the sum is even Return Value logical (out) result: true/false Called by proc~~is_sum_even~~CalledByGraph proc~is_sum_even is_sum_even proc~zero_projections_3j_condition zero_projections_3j_condition proc~zero_projections_3j_condition->proc~is_sum_even proc~check_nonzero_coupling_matrix_elements check_nonzero_coupling_matrix_elements proc~check_nonzero_coupling_matrix_elements->proc~zero_projections_3j_condition proc~process_single_matrix_element process_single_matrix_element proc~process_single_matrix_element->proc~zero_projections_3j_condition program~scattering SCATTERING program~scattering->proc~check_nonzero_coupling_matrix_elements proc~prepare_coupling_matrix_elements prepare_coupling_matrix_elements program~scattering->proc~prepare_coupling_matrix_elements proc~prepare_coupling_matrix_elements->proc~process_single_matrix_element Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code is_sum_even Source Code function is_sum_even ( x , y , z ) result ( sum_even ) !! checks if the sum of 3 integers is an even integer !------------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: x , y , z !! variables to check if the sum is even logical :: sum_even !! (out) result: true/false !------------------------------------------------------------------------! sum_even = ( modulo ( x + y + z , 2 ) == 0 ) !------------------------------------------------------------------------! end function is_sum_even","tags":"","loc":"proc/is_sum_even.html"},{"title":"ispline – the SCATTERING code","text":"public  function ispline(u_, N_, x_, y_, b_, c_, d_) result(spl_result) returns interpolated value at guven u_ point\nnumber of points and ascending order of x is not checked since\nispline is called after \"spline\" where these checks are done Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: u_ point at which the tabulated value is interpolated integer(kind=int32), intent(in) :: N_ number of grid points real(kind=dp), intent(in) :: x_ (N_) grid points real(kind=dp), intent(in) :: y_ (N_) tabulated values real(kind=dp), intent(in) :: b_ (N_) arrays with coefficients of the spline function real(kind=dp), intent(in) :: c_ (N_) arrays with coefficients of the spline function real(kind=dp), intent(in) :: d_ (N_) arrays with coefficients of the spline function Return Value real(kind=dp) interpolated value at u_ Calls proc~~ispline~~CallsGraph proc~ispline ispline proc~float_to_character float_to_character proc~ispline->proc~float_to_character proc~write_warning write_warning proc~ispline->proc~write_warning proc~write_message write_message proc~write_warning->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~ispline~~CalledByGraph proc~ispline ispline proc~get_radial_coupling_term_value get_radial_coupling_term_value proc~get_radial_coupling_term_value->proc~ispline proc~pes_contribution pes_contribution proc~pes_contribution->proc~get_radial_coupling_term_value proc~numerov numerov proc~numerov->proc~pes_contribution program~scattering SCATTERING program~scattering->proc~numerov Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables dx_ k_ l_ mid_ Source Code ispline Variables Type Visibility Attributes Name Initial real(kind=dp), public :: dx_ integer(kind=int32), public :: k_ integer(kind=int32), public :: l_ integer(kind=int32), public :: mid_ Source Code function ispline ( u_ , N_ , x_ , y_ , b_ , c_ , d_ ) result ( spl_result ) !! returns interpolated value at guven u_ point !! number of points and ascending order of x is not checked since !! ispline is called after \"spline\" where these checks are done !------------------------------------------------------------------------! real ( dp ), intent ( in ) :: u_ !! point at which the tabulated value is interpolated integer ( int32 ), intent ( in ) :: N_ !! number of grid points real ( dp ), intent ( in ) :: x_ ( N_ ) !! grid points real ( dp ), intent ( in ) :: y_ ( N_ ) !! tabulated values real ( dp ), intent ( in ) :: b_ ( N_ ), c_ ( N_ ), d_ ( N_ ) !! arrays with coefficients of the spline function real ( dp ) :: spl_result !! interpolated value at u_ !------------------------------------------------------------------------! integer ( int32 ) :: k_ , l_ , mid_ real ( dp ) :: dx_ !------------------------------------------------------------------------! if ( u_ > x_ ( N_ )) then call write_warning ( \"ispline: point u_ = \" // & trim ( adjustl ( float_to_character ( u_ ))) // \" exceeds the original \" & // \"grid: x(N) = \" // trim ( adjustl ( float_to_character ( x_ ( N_ ))))) spl_result = y_ ( N_ ) else if ( u_ < x_ ( 1 ) ) then call write_warning ( \"ispline: point u_ = \" // & trim ( adjustl ( float_to_character ( u_ ))) // \" exceeds the original \" & // \"grid: x(1) = \" // trim ( adjustl ( float_to_character ( x_ ( 1 ))))) spl_result = y_ ( 1 ) else !---------------------------------------------------------------------! l_ = 1 k_ = N_ + 1 do while ( k_ > l_ + 1 ) mid_ = nint ( ( l_ + k_ ) / 2.0_dp ) if ( x_ ( mid_ ) > u_ ) then k_ = mid_ else l_ = mid_ endif end do dx_ = u_ - x_ ( l_ ) spl_result = y_ ( l_ ) + dx_ * ( b_ ( l_ ) + dx_ * ( c_ ( l_ ) + d_ ( l_ ) * dx_ )) !---------------------------------------------------------------------! endif !------------------------------------------------------------------------! end function ispline","tags":"","loc":"proc/ispline.html"},{"title":"percival_seaton_coefficient – the SCATTERING code","text":"public  function percival_seaton_coefficient(j_, j_prime_, lambda_, omega_) result(percival_seaton_coefficient_) Uses fwigxjpf proc~~percival_seaton_coefficient~~UsesGraph proc~percival_seaton_coefficient percival_seaton_coefficient fwigxjpf fwigxjpf proc~percival_seaton_coefficient->fwigxjpf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. calculates Percival-Seaton coefficients (body-fixed variant) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: j_ pre-collisional rotational angular momentum integer(kind=int32), intent(in) :: j_prime_ post-collisional rotational angular momentum integer(kind=int32), intent(in) :: lambda_ Legendre expansion coefficient  \\lambda integer(kind=int32), intent(in) :: omega_ \\bar{\\Omega} Return Value real(kind=dp) (out) result: percival seaton coefficient in the body-fixed frame Calls proc~~percival_seaton_coefficient~~CallsGraph proc~percival_seaton_coefficient percival_seaton_coefficient fwig3jj fwig3jj proc~percival_seaton_coefficient->fwig3jj Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~percival_seaton_coefficient~~CalledByGraph proc~percival_seaton_coefficient percival_seaton_coefficient proc~process_single_matrix_element process_single_matrix_element proc~process_single_matrix_element->proc~percival_seaton_coefficient proc~prepare_coupling_matrix_elements prepare_coupling_matrix_elements proc~prepare_coupling_matrix_elements->proc~process_single_matrix_element program~scattering SCATTERING program~scattering->proc~prepare_coupling_matrix_elements Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code percival_seaton_coefficient Source Code function percival_seaton_coefficient ( j_ , j_prime_ , lambda_ , omega_ ) & result ( percival_seaton_coefficient_ ) !! calculates Percival-Seaton coefficients (body-fixed variant) !! \\begin{equation} !! \\label{eq:algebraic_coeffs} !! g_{{\\lambda},\\gamma,\\gamma'}&#94;{Jp} = \\delta_{\\bar{\\Omega},\\bar{\\Omega}'} (-1)&#94;{\\bar{\\Omega}} \\sqrt{(2j+1)(2j'+1)} !! \\begin{pmatrix} !!   j & j' & \\lambda \\\\ 0 & 0 & 0 !! \\end{pmatrix} !! \\begin{pmatrix} !! j & j' & \\lambda \\\\ \\bar{\\Omega} & -\\bar{\\Omega} & 0 \\end{pmatrix}. !! \\end{equation} !------------------------------------------------------------------------! use fwigxjpf , only : fwig3jj !------------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: j_ !! pre-collisional rotational angular momentum integer ( int32 ), intent ( in ) :: j_prime_ !! post-collisional rotational angular momentum integer ( int32 ), intent ( in ) :: omega_ !! \\\\bar{\\Omega}\\ integer ( int32 ), intent ( in ) :: lambda_ !! Legendre expansion coefficient \\ \\lambda\\ real ( dp ) :: percival_seaton_coefficient_ !! (out) result: percival seaton coefficient in the body-fixed frame !------------------------------------------------------------------------! percival_seaton_coefficient_ = ( - 1.0_dp ) ** ( omega_ ) * sqrt ( & real (( 2 * j_ + 1 ) * ( 2 * j_prime_ + 1 ), dp )) & * fwig3jj ( 2 * j_ , 2 * j_prime_ , 2 * lambda_ , 0 , 0 , 0 ) & * fwig3jj ( 2 * j_ , 2 * j_prime_ , 2 * lambda_ , & 2 * omega_ , - 2 * omega_ , 0 ) !------------------------------------------------------------------------! end function percival_seaton_coefficient","tags":"","loc":"proc/percival_seaton_coefficient.html"},{"title":"triangle_inequality_holds – the SCATTERING code","text":"public  function triangle_inequality_holds(x, y, z) result(holds) check if the triangle inequality for 3 variables hols Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x variables to check the triangle inequality integer(kind=int32), intent(in) :: y variables to check the triangle inequality integer(kind=int32), intent(in) :: z variables to check the triangle inequality Return Value logical (out) result: true/false Called by proc~~triangle_inequality_holds~~CalledByGraph proc~triangle_inequality_holds triangle_inequality_holds proc~zero_projections_3j_condition zero_projections_3j_condition proc~zero_projections_3j_condition->proc~triangle_inequality_holds proc~check_nonzero_coupling_matrix_elements check_nonzero_coupling_matrix_elements proc~check_nonzero_coupling_matrix_elements->proc~zero_projections_3j_condition proc~process_single_matrix_element process_single_matrix_element proc~process_single_matrix_element->proc~zero_projections_3j_condition program~scattering SCATTERING program~scattering->proc~check_nonzero_coupling_matrix_elements proc~prepare_coupling_matrix_elements prepare_coupling_matrix_elements program~scattering->proc~prepare_coupling_matrix_elements proc~prepare_coupling_matrix_elements->proc~process_single_matrix_element Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code triangle_inequality_holds Source Code function triangle_inequality_holds ( x , y , z ) result ( holds ) !! check if the triangle inequality for 3 variables hols !------------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: x , y , z !! variables to check the triangle inequality logical :: holds !! (out) result: true/false !------------------------------------------------------------------------! holds = ( ( x + y >= z ) . and . ( x + z >= y ) . and . ( y + z >= x ) ) !------------------------------------------------------------------------! end function triangle_inequality_holds","tags":"","loc":"proc/triangle_inequality_holds.html"},{"title":"zero_projections_3j_condition – the SCATTERING code","text":"public  function zero_projections_3j_condition(x, y, z) result(is_valid) checks the condition for nonvanishing 3-j symbol with zero projections:\ntriangle inequality on x,y,z and if the sum x+y+z is an even integer Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x variables to check for 3-j symbol conditions integer(kind=int32), intent(in) :: y variables to check for 3-j symbol conditions integer(kind=int32), intent(in) :: z variables to check for 3-j symbol conditions Return Value logical (out) result: true/false if conditions are met Calls proc~~zero_projections_3j_condition~~CallsGraph proc~zero_projections_3j_condition zero_projections_3j_condition proc~triangle_inequality_holds triangle_inequality_holds proc~zero_projections_3j_condition->proc~triangle_inequality_holds proc~is_sum_even is_sum_even proc~zero_projections_3j_condition->proc~is_sum_even Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~zero_projections_3j_condition~~CalledByGraph proc~zero_projections_3j_condition zero_projections_3j_condition proc~check_nonzero_coupling_matrix_elements check_nonzero_coupling_matrix_elements proc~check_nonzero_coupling_matrix_elements->proc~zero_projections_3j_condition proc~process_single_matrix_element process_single_matrix_element proc~process_single_matrix_element->proc~zero_projections_3j_condition program~scattering SCATTERING program~scattering->proc~check_nonzero_coupling_matrix_elements proc~prepare_coupling_matrix_elements prepare_coupling_matrix_elements program~scattering->proc~prepare_coupling_matrix_elements proc~prepare_coupling_matrix_elements->proc~process_single_matrix_element Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code zero_projections_3j_condition Source Code function zero_projections_3j_condition ( x , y , z ) result ( is_valid ) !! checks the condition for nonvanishing 3-j symbol with zero projections: !! triangle inequality on x,y,z and if the sum x+y+z is an even integer !------------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: x , y , z !! variables to check for 3-j symbol conditions logical :: is_valid !! (out) result: true/false if conditions are met !------------------------------------------------------------------------! is_valid = ( triangle_inequality_holds ( x , y , z ) . and . is_sum_even ( x , y , z )) !------------------------------------------------------------------------! end function zero_projections_3j_condition","tags":"","loc":"proc/zero_projections_3j_condition.html"},{"title":"modified_bessel_k_ratio – the SCATTERING code","text":"public  subroutine modified_bessel_k_ratio(l_, x_, ratio_) calculates the ratio of the modified Bessel function of the second\nkind K_{l_ + 1/2}(x) and its first derivative (Eq. ...)\nUses ikv function from special_functions.f90 Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: l_ l - order of the function (without the 1/2 factor!) real(kind=dp), intent(in) :: x_ x - argument of the function real(kind=dp), intent(inout) :: ratio_ ratio of the modified Bessel function of the second kind to its derivative Calls proc~~modified_bessel_k_ratio~~CallsGraph proc~modified_bessel_k_ratio modified_bessel_k_ratio proc~ikv ikv proc~modified_bessel_k_ratio->proc~ikv proc~integer_to_character integer_to_character proc~modified_bessel_k_ratio->proc~integer_to_character proc~write_warning write_warning proc~modified_bessel_k_ratio->proc~write_warning proc~msta1 msta1 proc~ikv->proc~msta1 proc~msta2 msta2 proc~ikv->proc~msta2 proc~write_message write_message proc~write_warning->proc~write_message proc~envj envj proc~msta1->proc~envj proc~msta2->proc~envj Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~modified_bessel_k_ratio~~CalledByGraph proc~modified_bessel_k_ratio modified_bessel_k_ratio proc~calculate_k_matrix calculate_k_matrix proc~calculate_k_matrix->proc~modified_bessel_k_ratio program~scattering SCATTERING program~scattering->proc~calculate_k_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables bi_arr_ bk_arr_ di_arr_ dk_arr_ highest_order_ highest_order_real_ order_ Source Code modified_bessel_k_ratio Variables Type Visibility Attributes Name Initial real(kind=dp), public, dimension(l_+1) :: bi_arr_ real(kind=dp), public, dimension(l_+1) :: bk_arr_ real(kind=dp), public, dimension(l_+1) :: di_arr_ real(kind=dp), public, dimension(l_+1) :: dk_arr_ integer(kind=int32), public :: highest_order_ real(kind=dp), public :: highest_order_real_ real(kind=dp), public :: order_ Source Code subroutine modified_bessel_k_ratio ( l_ , x_ , ratio_ ) !! calculates the ratio of the modified Bessel function of the second !! kind K_{l_ + 1/2}(x) and its first derivative (Eq. ...) !! Uses ikv function from special_functions.f90 !------------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: l_ !! l - order of the function (without the 1/2 factor!) real ( dp ), intent ( in ) :: x_ !! x - argument of the function real ( dp ), intent ( inout ) :: ratio_ !! ratio of the modified Bessel function of the second kind to its derivative !------------------------------------------------------------------------! integer ( int32 ) :: highest_order_ real ( dp ) :: order_ , highest_order_real_ real ( dp ), dimension ( l_ + 1 ) :: bi_arr_ , di_arr_ , bk_arr_ , dk_arr_ !------------------------------------------------------------------------! order_ = real ( l_ , dp ) + 0.5_dp call ikv ( order_ , x_ , highest_order_real_ , bi_arr_ , di_arr_ , bk_arr_ , dk_arr_ ) highest_order_ = nint ( highest_order_real_ - 0.5_dp ) !------------------------------------------------------------------------! if ( highest_order_ < l_ ) then !---------------------------------------------------------------------! call write_warning ( \"modified_bessel_k_ratio: maximum order of modified Bessel function:\" & // trim ( adjustl ( integer_to_character ( highest_order_ ))) // \"is smaller than \" // & \"requested order l = \" // trim ( adjustl ( integer_to_character ( l_ ))) ) !---------------------------------------------------------------------! ratio_ = dk_arr_ ( highest_order_ ) / bk_arr_ ( highest_order_ ) else ratio_ = dk_arr_ ( l_ + 1 ) / bk_arr_ ( l_ + 1 ) endif !------------------------------------------------------------------------! end subroutine modified_bessel_k_ratio","tags":"","loc":"proc/modified_bessel_k_ratio.html"},{"title":"riccati_bessel_j – the SCATTERING code","text":"public  subroutine riccati_bessel_j(l_, x_, j_, jp_) calculates the Riccati-Bessel function of the first kind and its\nfirst derivative. Calls the rctj function from special_functions.f90 Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: l_ l - order of the Riccati-Bessel function of the first kind real(kind=dp), intent(in) :: x_ x - argument of the Riccati-Bessel function of the first kind real(kind=dp), intent(inout) :: j_ j_{l} (x) - Riccati-Bessel funciton of the first kind real(kind=dp), intent(inout) :: jp_ j_{l}' (x) - derivative of the Riccati-Bessel funciton of the first kind Calls proc~~riccati_bessel_j~~CallsGraph proc~riccati_bessel_j riccati_bessel_j proc~rctj rctj proc~riccati_bessel_j->proc~rctj proc~integer_to_character integer_to_character proc~riccati_bessel_j->proc~integer_to_character proc~write_warning write_warning proc~riccati_bessel_j->proc~write_warning proc~msta1 msta1 proc~rctj->proc~msta1 proc~msta2 msta2 proc~rctj->proc~msta2 proc~write_message write_message proc~write_warning->proc~write_message proc~envj envj proc~msta1->proc~envj proc~msta2->proc~envj Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~riccati_bessel_j~~CalledByGraph proc~riccati_bessel_j riccati_bessel_j proc~calculate_k_matrix calculate_k_matrix proc~calculate_k_matrix->proc~riccati_bessel_j program~scattering SCATTERING program~scattering->proc~calculate_k_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables dj_ highest_order_ rj_ Source Code riccati_bessel_j Variables Type Visibility Attributes Name Initial real(kind=dp), public, dimension(l_+1) :: dj_ integer(kind=int32), public :: highest_order_ real(kind=dp), public, dimension(l_+1) :: rj_ Source Code subroutine riccati_bessel_j ( l_ , x_ , j_ , jp_ ) !! calculates the Riccati-Bessel function of the first kind and its !! first derivative. Calls the rctj function from special_functions.f90 !------------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: l_ !! l - order of the Riccati-Bessel function of the first kind real ( dp ), intent ( in ) :: x_ !! x - argument of the Riccati-Bessel function of the first kind real ( dp ), intent ( inout ) :: j_ !! j_{l} (x) - Riccati-Bessel funciton of the first kind real ( dp ), intent ( inout ) :: jp_ !! j_{l}' (x) - derivative of the Riccati-Bessel funciton of the first kind !------------------------------------------------------------------------! integer ( int32 ) :: highest_order_ real ( dp ), dimension ( l_ + 1 ) :: rj_ , dj_ !------------------------------------------------------------------------! if ( l_ == 0 ) then call rctj ( l_ + 1 , x_ , highest_order_ , rj_ , dj_ ) else call rctj ( l_ , x_ , highest_order_ , rj_ , dj_ ) endif if ( highest_order_ < l_ ) then !---------------------------------------------------------------------! call write_warning ( \"riccati_bessel_j: maximum order of Riccati-Bessel function:\" & // trim ( adjustl ( integer_to_character ( highest_order_ ))) // \"is smaller than \" // & \"requested order l = \" // trim ( adjustl ( integer_to_character ( l_ ))) ) !---------------------------------------------------------------------! j_ = rj_ ( highest_order_ ) jp_ = dj_ ( highest_order_ ) else j_ = rj_ ( l_ + 1 ) jp_ = dj_ ( l_ + 1 ) endif !------------------------------------------------------------------------! end subroutine riccati_bessel_j","tags":"","loc":"proc/riccati_bessel_j.html"},{"title":"riccati_bessel_y – the SCATTERING code","text":"public  subroutine riccati_bessel_y(l_, x_, y_, yp_) calculates the Riccati-Bessel function of the second kind and its\nfirst derivative. Calls the rcty function from special_functions.f90 Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: l_ l - order of the Riccati-Bessel function of the second kind real(kind=dp), intent(in) :: x_ x - argument of the Riccati-Bessel function of the second kind real(kind=dp), intent(inout) :: y_ y_{l} (x) - Riccati-Bessel funciton of the second kind real(kind=dp), intent(inout) :: yp_ y_{l}' (x) - derivative of the Riccati-Bessel funciton of the second kind Calls proc~~riccati_bessel_y~~CallsGraph proc~riccati_bessel_y riccati_bessel_y proc~rcty rcty proc~riccati_bessel_y->proc~rcty proc~integer_to_character integer_to_character proc~riccati_bessel_y->proc~integer_to_character proc~write_warning write_warning proc~riccati_bessel_y->proc~write_warning proc~write_message write_message proc~write_warning->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~riccati_bessel_y~~CalledByGraph proc~riccati_bessel_y riccati_bessel_y proc~calculate_k_matrix calculate_k_matrix proc~calculate_k_matrix->proc~riccati_bessel_y program~scattering SCATTERING program~scattering->proc~calculate_k_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables dy_ highest_order_ ry_ Source Code riccati_bessel_y Variables Type Visibility Attributes Name Initial real(kind=dp), public, dimension(l_+1) :: dy_ integer(kind=int32), public :: highest_order_ real(kind=dp), public, dimension(l_+1) :: ry_ Source Code subroutine riccati_bessel_y ( l_ , x_ , y_ , yp_ ) !! calculates the Riccati-Bessel function of the second kind and its !! first derivative. Calls the rcty function from special_functions.f90 !------------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: l_ !! l - order of the Riccati-Bessel function of the second kind real ( dp ), intent ( in ) :: x_ !! x - argument of the Riccati-Bessel function of the second kind real ( dp ), intent ( inout ) :: y_ !! y_{l} (x) - Riccati-Bessel funciton of the second kind real ( dp ), intent ( inout ) :: yp_ !! y_{l}' (x) - derivative of the Riccati-Bessel funciton of the second kind !------------------------------------------------------------------------! integer ( int32 ) :: highest_order_ real ( dp ), dimension ( l_ + 1 ) :: ry_ , dy_ !------------------------------------------------------------------------! if ( l_ == 0 ) then call rcty ( l_ + 1 , x_ , highest_order_ , ry_ , dy_ ) else call rcty ( l_ , x_ , highest_order_ , ry_ , dy_ ) endif y_ = ry_ ( l_ + 1 ) yp_ = dy_ ( l_ + 1 ) !------------------------------------------------------------------------! if ( highest_order_ < l_ ) then !---------------------------------------------------------------------! call write_warning ( \"riccati_bessel_j: maximum order of Riccati-Bessel function:\" & // trim ( adjustl ( integer_to_character ( highest_order_ ))) // \"is smaller than \" // & \"requested order l = \" // trim ( adjustl ( integer_to_character ( l_ ))) ) !---------------------------------------------------------------------! y_ = ry_ ( highest_order_ ) yp_ = dy_ ( highest_order_ ) else y_ = ry_ ( l_ + 1 ) yp_ = dy_ ( l_ + 1 ) endif !------------------------------------------------------------------------! end subroutine riccati_bessel_y","tags":"","loc":"proc/riccati_bessel_y.html"},{"title":"spline – the SCATTERING code","text":"public  subroutine spline(N_, x_, y_, b_, c_, d_) determines b, c and d coefficients of the cubic spline function\ny(x) = y_i + b_i * dx + c_i * dx&#94;2 + d_i * dx&#94;3,\nwhere dx = x - x_i, and x_i <= x < x_i+1.\nThe algorithm is based on\nGerald, C., and Wheatley, P., \"Applied Numerical Analysis\", Addison-Wesley, 1994. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: N_ number of grid points real(kind=dp), intent(in) :: x_ (N_) grid points (ascending order) real(kind=dp), intent(in) :: y_ (N_) tabulated values real(kind=dp), intent(out) :: b_ (N_) arrays with coefficients of the spline function real(kind=dp), intent(out) :: c_ (N_) arrays with coefficients of the spline function real(kind=dp), intent(out) :: d_ (N_) arrays with coefficients of the spline function Calls proc~~spline~~CallsGraph proc~spline spline proc~integer_to_character integer_to_character proc~spline->proc~integer_to_character proc~write_error write_error proc~spline->proc~write_error proc~write_message write_message proc~write_error->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~spline~~CalledByGraph proc~spline spline proc~interpolate_radial_coupling_terms interpolate_radial_coupling_terms proc~interpolate_radial_coupling_terms->proc~spline program~scattering SCATTERING program~scattering->proc~interpolate_radial_coupling_terms Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables diff_x_ i_ j_ w_ Source Code spline Variables Type Visibility Attributes Name Initial real(kind=dp), public :: diff_x_ (N_-1) integer(kind=int32), public :: i_ integer(kind=int32), public :: j_ real(kind=dp), public :: w_ Source Code subroutine spline ( N_ , x_ , y_ , b_ , c_ , d_ ) !! determines b, c and d coefficients of the cubic spline function !! y(x) = y_i + b_i * dx + c_i * dx&#94;2 + d_i * dx&#94;3, !! where dx = x - x_i, and x_i <= x < x_i+1. !! The algorithm is based on !! Gerald, C., and Wheatley, P., \"Applied Numerical Analysis\", Addison-Wesley, 1994. !------------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: N_ !! number of grid points real ( dp ), intent ( in ) :: x_ ( N_ ) !! grid points (ascending order) real ( dp ), intent ( in ) :: y_ ( N_ ) !! tabulated values real ( dp ), intent ( out ) :: b_ ( N_ ), c_ ( N_ ), d_ ( N_ ) !! arrays with coefficients of the spline function !------------------------------------------------------------------------! integer ( int32 ) :: i_ , j_ real ( dp ) :: w_ real ( dp ) :: diff_x_ ( N_ - 1 ) !------------------------------------------------------------------------! ! check if the number of points is larger than 4 !------------------------------------------------------------------------! if ( N_ < 4 ) then call write_error ( \"spline function called with \" // & trim ( adjustl ( integer_to_character ( N_ ))) // \" points\" ) endif !------------------------------------------------------------------------! ! check if x is sorted in ascending order !------------------------------------------------------------------------! do i_ = 2 , N_ if ( x_ ( i_ ) <= x_ ( i_ - 1 )) then call write_error ( \"spline: x values are not in ascending order \" // & \" at index \" // trim ( adjustl ( integer_to_character ( i_ )))) endif end do !------------------------------------------------------------------------! diff_x_ = x_ ( 2 : N_ ) - x_ ( 1 : N_ - 1 ) !------------------------------------------------------------------------! b_ ( 2 : N_ - 1 ) = 2.0_dp * ( diff_x_ ( 1 : N_ - 2 ) + diff_x_ ( 2 : N_ - 1 )) b_ ( 1 ) = - diff_x_ ( 1 ) b_ ( N_ ) = - diff_x_ ( N_ - 1 ) c_ ( 2 : N_ - 1 ) = ( y_ ( 3 : N_ ) - y_ ( 2 : N_ - 1 ) ) / diff_x_ ( 2 : N_ - 1 ) & - ( y_ ( 2 : N_ - 1 ) - y_ ( 1 : N_ - 2 ) ) / diff_x_ ( 1 : N_ - 2 ) c_ ( 1 ) = c_ ( 3 ) / ( x_ ( 4 ) - x_ ( 2 )) - c_ ( 2 ) / ( x_ ( 3 ) - x_ ( 1 )) c_ ( N_ ) = c_ ( N_ - 1 ) / ( x_ ( N_ ) - x_ ( N_ - 2 )) - c_ ( N_ - 2 ) / ( x_ ( N_ - 1 ) - x_ ( N_ - 3 )) c_ ( 1 ) = c_ ( 1 ) / ( x_ ( 4 ) - x_ ( 1 )) * diff_x_ ( 1 ) ** 2 c_ ( N_ ) = - c_ ( N_ ) / ( x_ ( N_ ) - x_ ( N_ - 3 )) * diff_x_ ( N_ - 1 ) ** 2 do i_ = 2 , N_ w_ = diff_x_ ( i_ - 1 ) / b_ ( i_ - 1 ) b_ ( i_ ) = b_ ( i_ ) - w_ * diff_x_ ( i_ - 1 ) c_ ( i_ ) = c_ ( i_ ) - w_ * c_ ( i_ - 1 ) end do c_ ( N_ ) = c_ ( N_ ) / b_ ( N_ ) do j_ = 1 , N_ - 1 i_ = N_ - j_ c_ ( i_ ) = ( c_ ( i_ ) - diff_x_ ( i_ ) * c_ ( i_ + 1 )) / b_ ( i_ ) end do b_ ( 1 : N_ - 1 ) = ( y_ ( 2 : N_ ) - y_ ( 1 : N_ - 1 ) ) / diff_x_ ( 1 : N_ - 1 ) & - ( 2.0_dp * c_ ( 1 : N_ - 1 ) + c_ ( 2 : N_ ) ) * diff_x_ ( 1 : N_ - 1 ) d_ ( 1 : N_ - 1 ) = ( c_ ( 2 : N_ ) - c_ ( 1 : N_ - 1 ) ) / diff_x_ ( 1 : N_ - 1 ) c_ = c_ * 3.0_dp end subroutine spline","tags":"","loc":"proc/spline.html"},{"title":"check_unitarity_for_each_channel – the SCATTERING code","text":"public  function check_unitarity_for_each_channel(sum_of_squares) result(is_unitary_) checks if the calculated sum of squares equals 1 for each channel Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: sum_of_squares (:)  \\sum_{\\gamma'} \\Bigl|{S}&#94;{Jp}_{\\gamma, \\gamma'}\\Bigr|&#94;{2}  Return Value logical (output) if .true. unitarity is fulfilled, .false. otherwise Called by proc~~check_unitarity_for_each_channel~~CalledByGraph proc~check_unitarity_for_each_channel check_unitarity_for_each_channel proc~unitarity_check unitarity_check proc~unitarity_check->proc~check_unitarity_for_each_channel program~scattering SCATTERING program~scattering->proc~unitarity_check Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables channel_index Source Code check_unitarity_for_each_channel Variables Type Visibility Attributes Name Initial integer, public :: channel_index Source Code function check_unitarity_for_each_channel ( sum_of_squares ) & result ( is_unitary_ ) !! checks if the calculated sum of squares equals 1 for each channel !---------------------------------------------------------------------! real ( dp ), intent ( in ) :: sum_of_squares (:) !! \\ \\sum\\_{\\gamma'} \\Bigl|{S}&#94;{Jp}\\_{\\gamma, \\gamma'}\\Bigr|&#94;{2} \\ logical :: is_unitary_ !! (output) if .true. unitarity is fulfilled, .false. otherwise !---------------------------------------------------------------------! integer :: channel_index !---------------------------------------------------------------------! is_unitary_ = . true . do channel_index = 1 , size ( sum_of_squares ) if ( abs ( sum_of_squares ( channel_index ) - 1.0_dp ) > unitary_tolerance ) then is_unitary_ = . false . exit endif end do !---------------------------------------------------------------------! end function check_unitarity_for_each_channel","tags":"","loc":"proc/check_unitarity_for_each_channel.html"},{"title":"calculate_sum_of_squares_for_each_channel – the SCATTERING code","text":"public  subroutine calculate_sum_of_squares_for_each_channel(s_matrix_real, s_matrix_imag, sum_of_squares_) calculates the sum\n \\sum_{\\gamma'} \\Bigl|{S}&#94;{Jp}_{\\gamma, \\gamma'}\\Bigr|&#94;{2} \nfor all \\gamma channels Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: s_matrix_real (:,:) real part of the S-matrix real(kind=dp), intent(in) :: s_matrix_imag (:,:) imaginary part of the S-matrix real(kind=dp), intent(out) :: sum_of_squares_ (:) (output)  \\sum_{\\gamma'} \\Bigl|{S}&#94;{Jp}_{\\gamma, \\gamma'}\\Bigr|&#94;{2}  Called by proc~~calculate_sum_of_squares_for_each_channel~~CalledByGraph proc~calculate_sum_of_squares_for_each_channel calculate_sum_of_squares_for_each_channel proc~unitarity_check unitarity_check proc~unitarity_check->proc~calculate_sum_of_squares_for_each_channel program~scattering SCATTERING program~scattering->proc~unitarity_check Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables channel_index_ Source Code calculate_sum_of_squares_for_each_channel Variables Type Visibility Attributes Name Initial integer(kind=int32), public :: channel_index_ Source Code subroutine calculate_sum_of_squares_for_each_channel ( s_matrix_real , & s_matrix_imag , sum_of_squares_ ) !! calculates the sum !! \\ \\sum\\_{\\gamma'} \\Bigl|{S}&#94;{Jp}\\_{\\gamma, \\gamma'}\\Bigr|&#94;{2} \\ !! for all \\\\gamma\\ channels !---------------------------------------------------------------------! real ( dp ), intent ( in ) :: s_matrix_real (:,:) !! real part of the S-matrix real ( dp ), intent ( in ) :: s_matrix_imag (:,:) !! imaginary part of the S-matrix real ( dp ), intent ( out ) :: sum_of_squares_ (:) !! (output) \\ \\sum\\_{\\gamma'} \\Bigl|{S}&#94;{Jp}\\_{\\gamma, \\gamma'}\\Bigr|&#94;{2} \\ !---------------------------------------------------------------------! integer ( int32 ) :: channel_index_ !---------------------------------------------------------------------! do channel_index_ = 1 , size ( s_matrix_real , 1 ) sum_of_squares_ ( channel_index_ ) = & sum ( s_matrix_real ( channel_index_ , :) ** 2 & + s_matrix_imag ( channel_index_ , :) ** 2 ) enddo !---------------------------------------------------------------------! end subroutine calculate_sum_of_squares_for_each_channel","tags":"","loc":"proc/calculate_sum_of_squares_for_each_channel.html"},{"title":"handle_unitarity_output_message – the SCATTERING code","text":"public  subroutine handle_unitarity_output_message(is_unitary) handle printing messages depending on the outcome of unitarity check Arguments Type Intent Optional Attributes Name logical, intent(in) :: is_unitary if .true. unitarity is fulfilled, .false. otherwise Calls proc~~handle_unitarity_output_message~~CallsGraph proc~handle_unitarity_output_message handle_unitarity_output_message proc~write_message write_message proc~handle_unitarity_output_message->proc~write_message proc~write_warning write_warning proc~handle_unitarity_output_message->proc~write_warning proc~write_warning->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~handle_unitarity_output_message~~CalledByGraph proc~handle_unitarity_output_message handle_unitarity_output_message proc~unitarity_check unitarity_check proc~unitarity_check->proc~handle_unitarity_output_message program~scattering SCATTERING program~scattering->proc~unitarity_check Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code handle_unitarity_output_message Source Code subroutine handle_unitarity_output_message ( is_unitary ) !! handle printing messages depending on the outcome of unitarity check !---------------------------------------------------------------------! logical , intent ( in ) :: is_unitary !! if .true. unitarity is fulfilled, .false. otherwise !---------------------------------------------------------------------! if ( is_unitary ) then call write_message ( \"S-matrix unitary condition fulfilled\" ) else call write_warning ( \"Unitary condition is not fulfilled for one or more channels\" ) call write_message ( \"Consider increasing the STEPS parameter\" ) endif !---------------------------------------------------------------------! end subroutine handle_unitarity_output_message","tags":"","loc":"proc/handle_unitarity_output_message.html"},{"title":"unitarity_check – the SCATTERING code","text":"public  subroutine unitarity_check(number_of_open_channels, s_matrix_real, s_matrix_imag, is_unitary) checks the unitarity of the S-matrix\n(Eq. (13) in \"Solution of coupled equations\") Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: number_of_open_channels number of open channels real(kind=dp), intent(in) :: s_matrix_real (number_of_open_channels,number_of_open_channels) real part of the S-matrix real(kind=dp), intent(in) :: s_matrix_imag (number_of_open_channels,number_of_open_channels) imaginary part of the S-matrix logical, intent(inout) :: is_unitary (output) if .true. unitarity is fulfilled, .false. otherwise Calls proc~~unitarity_check~~CallsGraph proc~unitarity_check unitarity_check proc~write_header write_header proc~unitarity_check->proc~write_header proc~check_unitarity_for_each_channel check_unitarity_for_each_channel proc~unitarity_check->proc~check_unitarity_for_each_channel proc~handle_unitarity_output_message handle_unitarity_output_message proc~unitarity_check->proc~handle_unitarity_output_message proc~calculate_sum_of_squares_for_each_channel calculate_sum_of_squares_for_each_channel proc~unitarity_check->proc~calculate_sum_of_squares_for_each_channel proc~write_message write_message proc~write_header->proc~write_message proc~write_error write_error proc~write_header->proc~write_error interface~incorrect_value incorrect_value proc~write_header->interface~incorrect_value proc~handle_unitarity_output_message->proc~write_message proc~write_warning write_warning proc~handle_unitarity_output_message->proc~write_warning proc~write_error->proc~write_message proc~write_warning->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~unitarity_check~~CalledByGraph proc~unitarity_check unitarity_check program~scattering SCATTERING program~scattering->proc~unitarity_check Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables channel_index sum_of_squares Source Code unitarity_check Variables Type Visibility Attributes Name Initial integer(kind=int32), public :: channel_index real(kind=dp), public :: sum_of_squares (number_of_open_channels) Source Code subroutine unitarity_check ( number_of_open_channels , s_matrix_real , & s_matrix_imag , is_unitary ) !! checks the unitarity of the S-matrix !! (Eq. (13) in \"Solution of coupled equations\") !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: number_of_open_channels !! number of open channels real ( dp ), intent ( in ) :: s_matrix_real ( number_of_open_channels , number_of_open_channels ) !! real part of the S-matrix real ( dp ), intent ( in ) :: s_matrix_imag ( number_of_open_channels , number_of_open_channels ) !! imaginary part of the S-matrix logical , intent ( inout ) :: is_unitary !! (output) if .true. unitarity is fulfilled, .false. otherwise !---------------------------------------------------------------------! integer ( int32 ) :: channel_index real ( dp ) :: sum_of_squares ( number_of_open_channels ) !---------------------------------------------------------------------! is_unitary = . true . !---------------------------------------------------------------------! call write_header ( \"unitarity\" ) !---------------------------------------------------------------------! ! Calculating sum of squares for each channel !---------------------------------------------------------------------! call calculate_sum_of_squares_for_each_channel ( s_matrix_real , & s_matrix_imag , sum_of_squares ) !---------------------------------------------------------------------! ! Checking unitarity for each channel !---------------------------------------------------------------------! is_unitary = check_unitarity_for_each_channel ( sum_of_squares ) !---------------------------------------------------------------------! ! Handling the output message based on unitarity check !---------------------------------------------------------------------! call handle_unitarity_output_message ( is_unitary ) !---------------------------------------------------------------------! end subroutine unitarity_check","tags":"","loc":"proc/unitarity_check.html"},{"title":"allocate_1d – the SCATTERING code","text":"public interface allocate_1d Called by interface~~allocate_1d~~CalledByGraph interface~allocate_1d allocate_1d proc~read_input_file read_input_file proc~read_input_file->interface~allocate_1d program~scattering SCATTERING program~scattering->interface~allocate_1d program~scattering->proc~read_input_file proc~crosssection CROSSSECTION program~scattering->proc~crosssection proc~crosssection->interface~allocate_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines allocate_1d_dp allocate_1d_int32 allocate_1d_sp Subroutines public pure module subroutine allocate_1d_dp(array_, size_) allocate a 1d array and fill it with 0s (double precision version) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), allocatable :: array_ (:) integer(kind=int32), intent(in) :: size_ public pure module subroutine allocate_1d_int32(array_, size_) allocate a 1d array and fill it with 0s (integer version) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), allocatable :: array_ (:) integer(kind=int32), intent(in) :: size_ public pure module subroutine allocate_1d_sp(array_, size_) allocate a 1d array and fill it with 0s (single precision version) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout), allocatable :: array_ (:) integer(kind=int32), intent(in) :: size_","tags":"","loc":"interface/allocate_1d.html"},{"title":"allocate_2d – the SCATTERING code","text":"public interface allocate_2d Called by interface~~allocate_2d~~CalledByGraph interface~allocate_2d allocate_2d proc~numerov numerov proc~numerov->interface~allocate_2d program~scattering SCATTERING program~scattering->interface~allocate_2d program~scattering->proc~numerov Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines allocate_2d_dp allocate_2d_int32 allocate_2d_sp Subroutines public pure module subroutine allocate_2d_dp(array_, size1_, size2_) allocate a 2d array and fill it with 0s (double precision version) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), allocatable :: array_ (:,:) integer(kind=int32), intent(in) :: size1_ integer(kind=int32), intent(in) :: size2_ public pure module subroutine allocate_2d_int32(array_, size1_, size2_) allocate a 2d array and fill it with 0s (integer version) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), allocatable :: array_ (:,:) integer(kind=int32), intent(in) :: size1_ integer(kind=int32), intent(in) :: size2_ public pure module subroutine allocate_2d_sp(array_, size1_, size2_) allocate a 2d array and fill it with 0s (single precision version) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout), allocatable :: array_ (:,:) integer(kind=int32), intent(in) :: size1_ integer(kind=int32), intent(in) :: size2_","tags":"","loc":"interface/allocate_2d.html"},{"title":"allocate_3d – the SCATTERING code","text":"public interface allocate_3d Called by interface~~allocate_3d~~CalledByGraph interface~allocate_3d allocate_3d proc~read_input_file read_input_file proc~read_input_file->interface~allocate_3d program~scattering SCATTERING program~scattering->proc~read_input_file Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines allocate_3d_dp allocate_3d_int32 allocate_3d_sp Subroutines public pure module subroutine allocate_3d_dp(array_, size1_, size2_, size3_) allocate a 3d array and fill it with 0s (double precision version) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), allocatable :: array_ (:,:,:) integer(kind=int32), intent(in) :: size1_ integer(kind=int32), intent(in) :: size2_ integer(kind=int32), intent(in) :: size3_ public pure module subroutine allocate_3d_int32(array_, size1_, size2_, size3_) allocate a 3d array and fill it with 0s (integer version) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), allocatable :: array_ (:,:,:) integer(kind=int32), intent(in) :: size1_ integer(kind=int32), intent(in) :: size2_ integer(kind=int32), intent(in) :: size3_ public pure module subroutine allocate_3d_sp(array_, size1_, size2_, size3_) allocate a 3d array and fill it with 0s (single precision version) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout), allocatable :: array_ (:,:,:) integer(kind=int32), intent(in) :: size1_ integer(kind=int32), intent(in) :: size2_ integer(kind=int32), intent(in) :: size3_","tags":"","loc":"interface/allocate_3d.html"},{"title":"append – the SCATTERING code","text":"public interface append Called by interface~~append~~CalledByGraph interface~append append program~scattering SCATTERING program~scattering->interface~append Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines append_dp append_int32 append_sp Subroutines public pure module subroutine append_dp(array_, element_) append element to an array (double precision version) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), allocatable :: array_ (:) real(kind=dp), intent(in) :: element_ public pure module subroutine append_int32(array_, element_) append element to an array (integer version) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), allocatable :: array_ (:) integer(kind=int32), intent(in) :: element_ public pure module subroutine append_sp(array_, element_) append element to an array (single precision version) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout), allocatable :: array_ (:) real(kind=sp), intent(in) :: element_","tags":"","loc":"interface/append.html"},{"title":"fill_symmetric_matrix – the SCATTERING code","text":"public interface fill_symmetric_matrix Called by interface~~fill_symmetric_matrix~~CalledByGraph interface~fill_symmetric_matrix fill_symmetric_matrix proc~calculate_log_der_matrix calculate_log_der_matrix proc~calculate_log_der_matrix->interface~fill_symmetric_matrix proc~pes_contribution pes_contribution proc~pes_contribution->interface~fill_symmetric_matrix proc~calculate_s_matrix calculate_s_matrix proc~calculate_s_matrix->interface~fill_symmetric_matrix proc~numerov numerov proc~numerov->interface~fill_symmetric_matrix proc~numerov->proc~calculate_log_der_matrix proc~numerov->proc~pes_contribution proc~cenitrfugal_matrix cenitrfugal_matrix proc~numerov->proc~cenitrfugal_matrix proc~cenitrfugal_matrix->interface~fill_symmetric_matrix program~scattering SCATTERING program~scattering->proc~calculate_s_matrix program~scattering->proc~numerov Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines fill_symmetric_matrix_dp fill_symmetric_matrix_int32 fill_symmetric_matrix_sp Subroutines public module subroutine fill_symmetric_matrix_dp(matrix_, upper_lower_) fill the upper/lower triangle of a symmetric matrix (double precision version) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: matrix_ (:,:) character(len=1), intent(in) :: upper_lower_ public module subroutine fill_symmetric_matrix_int32(matrix_, upper_lower_) fill the upper/lower triangle of a symmetric matrix (integer version) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: matrix_ (:,:) character(len=1), intent(in) :: upper_lower_ public module subroutine fill_symmetric_matrix_sp(matrix_, upper_lower_) fill the upper/lower triangle of a symmetric matrix (single precision version) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: matrix_ (:,:) character(len=1), intent(in) :: upper_lower_","tags":"","loc":"interface/fill_symmetric_matrix.html"},{"title":"invert_symmetric_matrix – the SCATTERING code","text":"public interface invert_symmetric_matrix Called by interface~~invert_symmetric_matrix~~CalledByGraph interface~invert_symmetric_matrix invert_symmetric_matrix proc~calculate_s_matrix calculate_s_matrix proc~calculate_s_matrix->interface~invert_symmetric_matrix proc~calculate_log_der_matrix calculate_log_der_matrix proc~calculate_log_der_matrix->interface~invert_symmetric_matrix proc~numerov numerov proc~numerov->interface~invert_symmetric_matrix proc~numerov->proc~calculate_log_der_matrix program~scattering SCATTERING program~scattering->proc~calculate_s_matrix program~scattering->proc~numerov Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines invert_symmetric_matrix_dp invert_symmetric_matrix_int32 invert_symmetric_matrix_sp Subroutines public module subroutine invert_symmetric_matrix_dp(matrix_) invert a symmetric matrix using DSYTRI method (double precision version) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: matrix_ (:,:) public module subroutine invert_symmetric_matrix_int32(matrix_) invert a symmetric matrix using DSYTRI method (integer version) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: matrix_ (:,:) public module subroutine invert_symmetric_matrix_sp(matrix_) invert a symmetric matrix using DSYTRI method (single precision version) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: matrix_ (:,:)","tags":"","loc":"interface/invert_symmetric_matrix.html"},{"title":"check_nonzero_coupling_matrix_elements – the SCATTERING code","text":"public  subroutine check_nonzero_coupling_matrix_elements(channels_level_indices, channels_omega_values, number_of_nonzero_coupling_matrix_elements, number_of_nonzero_coupling_coefficients) checks the number of non-zero coupling matrix elements due to\nthe \\bar{\\Omega} = \\bar{\\Omega}' condition,\n\"number_of_nonzero_coupling_matrix_elements\",\nand the total number of non-zero algebraic coefficients,\n g_{{\\lambda},\\gamma,\\gamma'}&#94;{Jp} , in the whole matrix,\n\"number_of_nonzero_coupling_coefficients\". Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: channels_level_indices (:) holds the indices pointing to the basis arrays integer(kind=int32), intent(in) :: channels_omega_values (:) holds all values of \\bar{\\Omega} integer(kind=int32), intent(out) :: number_of_nonzero_coupling_matrix_elements number of non-zero terms in the sum () for each non-zero element of the coupling matrix integer(kind=int32), intent(out) :: number_of_nonzero_coupling_coefficients number of all non-zero algberaix coefficients in the whole coupling matrix Calls proc~~check_nonzero_coupling_matrix_elements~~CallsGraph proc~check_nonzero_coupling_matrix_elements check_nonzero_coupling_matrix_elements proc~zero_projections_3j_condition zero_projections_3j_condition proc~check_nonzero_coupling_matrix_elements->proc~zero_projections_3j_condition proc~triangle_inequality_holds triangle_inequality_holds proc~zero_projections_3j_condition->proc~triangle_inequality_holds proc~is_sum_even is_sum_even proc~zero_projections_3j_condition->proc~is_sum_even Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~check_nonzero_coupling_matrix_elements~~CalledByGraph proc~check_nonzero_coupling_matrix_elements check_nonzero_coupling_matrix_elements program~scattering SCATTERING program~scattering->proc~check_nonzero_coupling_matrix_elements Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables channel_index_1_ channel_index_2_ count_nonzero_coupling_coefficients count_nonzero_coupling_matrix_elements j_ j_prime_ lambda_ legendre_term_index_ omega_ omega_prime_ Source Code check_nonzero_coupling_matrix_elements Variables Type Visibility Attributes Name Initial integer(kind=int32), public :: channel_index_1_ integer(kind=int32), public :: channel_index_2_ integer(kind=int32), public :: count_nonzero_coupling_coefficients integer(kind=int32), public :: count_nonzero_coupling_matrix_elements integer(kind=int32), public :: j_ integer(kind=int32), public :: j_prime_ integer(kind=int32), public :: lambda_ integer(kind=int32), public :: legendre_term_index_ integer(kind=int32), public :: omega_ integer(kind=int32), public :: omega_prime_ Source Code subroutine check_nonzero_coupling_matrix_elements ( channels_level_indices ,& channels_omega_values , number_of_nonzero_coupling_matrix_elements , & number_of_nonzero_coupling_coefficients ) !! checks the number of non-zero coupling matrix elements due to !! the \\bar{\\Omega} = \\bar{\\Omega}' condition, !! \"number_of_nonzero_coupling_matrix_elements\", !! and the total number of non-zero algebraic coefficients, !! \\ g\\_{{\\lambda},\\gamma,\\gamma'}&#94;{Jp} \\, in the whole matrix, !! \"number_of_nonzero_coupling_coefficients\". !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: channels_level_indices (:) !! holds the indices pointing to the basis arrays integer ( int32 ), intent ( in ) :: channels_omega_values (:) !! holds all values of \\bar{\\Omega} integer ( int32 ), intent ( out ) :: number_of_nonzero_coupling_matrix_elements !! number of non-zero terms in the sum () for each non-zero element of the coupling matrix integer ( int32 ), intent ( out ) :: number_of_nonzero_coupling_coefficients !! number of all non-zero algberaix coefficients in the whole coupling matrix !---------------------------------------------------------------------! integer ( int32 ) :: count_nonzero_coupling_matrix_elements , & count_nonzero_coupling_coefficients , j_ , j_prime_ , omega_ , & omega_prime_ , lambda_ , channel_index_1_ , channel_index_2_ , legendre_term_index_ !---------------------------------------------------------------------! count_nonzero_coupling_coefficients = 0 count_nonzero_coupling_matrix_elements = 0 do channel_index_1_ = 1 , size ( channels_level_indices ) j_ = j1array ( channels_level_indices ( channel_index_1_ )) omega_ = channels_omega_values ( channel_index_1_ ) do channel_index_2_ = 1 , channel_index_1_ j_prime_ = j1array ( channels_level_indices ( channel_index_2_ )) omega_prime_ = channels_omega_values ( channel_index_2_ ) !---------------------------------------------------------------! if ( omega_ /= omega_prime_ ) cycle !---------------------------------------------------------------! count_nonzero_coupling_matrix_elements = & count_nonzero_coupling_matrix_elements + 1 do legendre_term_index_ = 1 , nterms lambda_ = l1tab ( legendre_term_index_ ) if (. not . zero_projections_3j_condition ( j_ , j_prime_ , lambda_ )) cycle count_nonzero_coupling_coefficients = & count_nonzero_coupling_coefficients + 1 enddo enddo enddo !---------------------------------------------------------------------! number_of_nonzero_coupling_coefficients = count_nonzero_coupling_coefficients number_of_nonzero_coupling_matrix_elements = count_nonzero_coupling_matrix_elements !---------------------------------------------------------------------! end subroutine check_nonzero_coupling_matrix_elements","tags":"","loc":"proc/check_nonzero_coupling_matrix_elements.html"},{"title":"prepare_coupling_matrix_elements – the SCATTERING code","text":"public  subroutine prepare_coupling_matrix_elements(channels_level_indices, channels_omega_values, nonzero_terms_per_element, nonzero_legendre_indices, nonzero_coupling_coefficients) -- nonzero_terms_per_element - number of non-vanishing terms in\n   the sum over \\lambda in Eq. 1 in the \"Coupling Matrix\" section\n-- nonzero_legendre_indices - corresponding \\lambda value for\n   each non-vanishing coefficient is saved as an index to \"l1tab\"\n-- nonzero_coupling_coefficients --  holds all non-vanishing\n    g_{{\\lambda},\\gamma,\\gamma'}&#94;{Jp}  coefficients Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: channels_level_indices (:) holds the indices pointing to the basis arrays integer(kind=int32), intent(in) :: channels_omega_values (:) holds all values of \\bar{\\Omega} integer(kind=int32), intent(inout) :: nonzero_terms_per_element (:) keeps the number of non-vanishing elements of the sum over \\lambda\nfor each non-zero element of the coupling matrix integer(kind=int32), intent(inout) :: nonzero_legendre_indices (:) holds indices pointing to l1tab, which correspond to\nthe non-vanishing elements of the sum over \\lambda\nfor each non-zero element of the coupling matrix; real(kind=dp), intent(inout) :: nonzero_coupling_coefficients (:) holds the values of the non-zero algebraic coefficients Calls proc~~prepare_coupling_matrix_elements~~CallsGraph proc~prepare_coupling_matrix_elements prepare_coupling_matrix_elements proc~process_single_matrix_element process_single_matrix_element proc~prepare_coupling_matrix_elements->proc~process_single_matrix_element proc~zero_projections_3j_condition zero_projections_3j_condition proc~process_single_matrix_element->proc~zero_projections_3j_condition proc~percival_seaton_coefficient percival_seaton_coefficient proc~process_single_matrix_element->proc~percival_seaton_coefficient proc~triangle_inequality_holds triangle_inequality_holds proc~zero_projections_3j_condition->proc~triangle_inequality_holds proc~is_sum_even is_sum_even proc~zero_projections_3j_condition->proc~is_sum_even fwig3jj fwig3jj proc~percival_seaton_coefficient->fwig3jj Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~prepare_coupling_matrix_elements~~CalledByGraph proc~prepare_coupling_matrix_elements prepare_coupling_matrix_elements program~scattering SCATTERING program~scattering->proc~prepare_coupling_matrix_elements Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables channel_index_1_ channel_index_2_ count_nonzero_coupling_coefficients count_nonzero_coupling_matrix_elements count_nonzero_legendre_terms j_ j_prime_ lambda_ legendre_term_index_ omega_ omega_prime_ pscoeff Source Code prepare_coupling_matrix_elements Variables Type Visibility Attributes Name Initial integer(kind=int32), public :: channel_index_1_ integer(kind=int32), public :: channel_index_2_ integer(kind=int32), public :: count_nonzero_coupling_coefficients integer(kind=int32), public :: count_nonzero_coupling_matrix_elements integer(kind=int32), public :: count_nonzero_legendre_terms integer(kind=int32), public :: j_ integer(kind=int32), public :: j_prime_ integer(kind=int32), public :: lambda_ integer(kind=int32), public :: legendre_term_index_ integer(kind=int32), public :: omega_ integer(kind=int32), public :: omega_prime_ real(kind=dp), public :: pscoeff Source Code subroutine prepare_coupling_matrix_elements ( channels_level_indices , & channels_omega_values , nonzero_terms_per_element , & nonzero_legendre_indices , nonzero_coupling_coefficients ) !! prepares: !! -- nonzero_terms_per_element - number of non-vanishing terms in !!    the sum over \\\\lambda\\ in Eq. 1 in the \"Coupling Matrix\" section !! -- nonzero_legendre_indices - corresponding \\\\lambda\\ value for !!    each non-vanishing coefficient is saved as an index to \"l1tab\" !! -- nonzero_coupling_coefficients --  holds _all_ non-vanishing !!    \\ g\\_{{\\lambda},\\gamma,\\gamma'}&#94;{Jp} \\ coefficients !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: channels_level_indices (:) !! holds the indices pointing to the basis arrays integer ( int32 ), intent ( in ) :: channels_omega_values (:) !! holds all values of \\bar{\\Omega} integer ( int32 ), intent ( inout ) :: nonzero_terms_per_element (:) !! keeps the number of non-vanishing elements of the sum over \\\\lambda\\ !! for each non-zero element of the coupling matrix integer ( int32 ), intent ( inout ) :: nonzero_legendre_indices (:) !! holds indices pointing to l1tab, which correspond to !! the non-vanishing elements of the sum over \\\\lambda\\ !! for each non-zero element of the coupling matrix; real ( dp ), intent ( inout ) :: nonzero_coupling_coefficients (:) !! holds the values of the non-zero algebraic coefficients !---------------------------------------------------------------------! integer ( int32 ) :: count_nonzero_coupling_matrix_elements , & count_nonzero_coupling_coefficients , count_nonzero_legendre_terms , & j_ , j_prime_ , omega_ , omega_prime_ , lambda_ , channel_index_1_ , & channel_index_2_ , legendre_term_index_ real ( dp ) :: pscoeff !---------------------------------------------------------------------! nonzero_terms_per_element = 0 nonzero_legendre_indices = 0 nonzero_coupling_coefficients = 0 count_nonzero_coupling_coefficients = 0 count_nonzero_coupling_matrix_elements = 0 !---------------------------------------------------------------------! do channel_index_1_ = 1 , size ( channels_level_indices ) j_ = j1array ( channels_level_indices ( channel_index_1_ )) omega_ = channels_omega_values ( channel_index_1_ ) do channel_index_2_ = 1 , channel_index_1_ j_prime_ = j1array ( channels_level_indices ( channel_index_2_ )) omega_prime_ = channels_omega_values ( channel_index_2_ ) if ( omega_ /= omega_prime_ ) cycle !---------------------------------------------------------------! ! passed \\bar{\\Omega} = \\bar{\\Omega}' condition !---------------------------------------------------------------! count_nonzero_coupling_matrix_elements = & count_nonzero_coupling_matrix_elements + 1 !---------------------------------------------------------------! ! process a single matrix element: ! determine non-zero terms in the sum over legendre polynomials ! for this element; these are saved to ... !---------------------------------------------------------------! call process_single_matrix_element ( j_ , j_prime_ , omega_ , & count_nonzero_coupling_coefficients , & count_nonzero_legendre_terms , nonzero_legendre_indices , & nonzero_coupling_coefficients ) nonzero_terms_per_element ( count_nonzero_coupling_matrix_elements )& = count_nonzero_legendre_terms enddo enddo !---------------------------------------------------------------------! end subroutine prepare_coupling_matrix_elements","tags":"","loc":"proc/prepare_coupling_matrix_elements.html"},{"title":"print_coupling_matrix_elements_summary – the SCATTERING code","text":"public  subroutine print_coupling_matrix_elements_summary(number_of_channels, number_of_nonzero_coupling_matrix_elements, number_of_nonzero_coupling_coefficients) print a shor summary on the number of non-zero matrix elements\nof the coupling matrix Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: number_of_channels size of the basis integer(kind=int32), intent(in) :: number_of_nonzero_coupling_matrix_elements number of non-zero terms in the sum () for each non-zero element\nof the coupling matrix integer(kind=int32), intent(in) :: number_of_nonzero_coupling_coefficients number of all non-zero algberaix coefficients in the whole\ncoupling matrix Calls proc~~print_coupling_matrix_elements_summary~~CallsGraph proc~print_coupling_matrix_elements_summary print_coupling_matrix_elements_summary proc~write_message write_message proc~print_coupling_matrix_elements_summary->proc~write_message proc~integer_to_character integer_to_character proc~print_coupling_matrix_elements_summary->proc~integer_to_character Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~print_coupling_matrix_elements_summary~~CalledByGraph proc~print_coupling_matrix_elements_summary print_coupling_matrix_elements_summary program~scattering SCATTERING program~scattering->proc~print_coupling_matrix_elements_summary Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code print_coupling_matrix_elements_summary Source Code subroutine print_coupling_matrix_elements_summary ( number_of_channels , & number_of_nonzero_coupling_matrix_elements , & number_of_nonzero_coupling_coefficients ) !! print a shor summary on the number of non-zero matrix elements !! of the coupling matrix !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: number_of_channels !! size of the basis integer ( int32 ), intent ( in ) :: number_of_nonzero_coupling_matrix_elements !! number of non-zero terms in the sum () for each non-zero element !! of the coupling matrix integer ( int32 ), intent ( in ) :: number_of_nonzero_coupling_coefficients !! number of all non-zero algberaix coefficients in the whole !! coupling matrix !---------------------------------------------------------------------! call write_message ( repeat ( \"*\" , 90 )) call write_message ( repeat ( \" \" , 5 ) // \"Size of the coupling matrix: \" // & integer_to_character ( number_of_channels )) call write_message ( repeat ( \" \" , 5 ) // \"Number of non-zero elements \" // & \"of the potential matrix: \" // integer_to_character ( & number_of_nonzero_coupling_matrix_elements )) call write_message ( repeat ( \" \" , 5 ) // \"Number of non-zero elements \" // & \" of the coupling matrix: \" // integer_to_character ( & number_of_nonzero_coupling_coefficients )) call write_message ( repeat ( '*' , 90 )) !---------------------------------------------------------------------! end subroutine print_coupling_matrix_elements_summary","tags":"","loc":"proc/print_coupling_matrix_elements_summary.html"},{"title":"process_single_matrix_element – the SCATTERING code","text":"public  subroutine process_single_matrix_element(j_, j_prime_, omega_, count_nonzero_coupling_coefficients, count_nonzero_legendre_terms, nonzero_legendre_indices, nonzero_coupling_coefficients) calculates the non-zero algebraic coefficients\n g_{{\\lambda},\\gamma,\\gamma'}&#94;{Jp}  for a single matrix\nelement - see Eq. (1) in the \"Coupling matrix\" section;\nalgebraic coefficients are saved to nonzero_coupling_coefficients\narray; corresponding indices to l1tab are saved to\nnonzero_legendre_indices array Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: j_ pre-collisional rotational angular momentum integer(kind=int32), intent(in) :: j_prime_ post-collisional rotational angular momentum integer(kind=int32), intent(in) :: omega_ \\bar{\\Omega} integer(kind=int32), intent(inout) :: count_nonzero_coupling_coefficients running index counting non-zero coupling coefficients,\n g_{{\\lambda},\\gamma,\\gamma'}&#94;{Jp}  in the whole matrix;\nincremented in this subroutine integer(kind=int32), intent(inout) :: count_nonzero_legendre_terms number of non-zero terms in Legendre expansion for a single\nmatrix element of the interaction potential integer(kind=int32), intent(inout) :: nonzero_legendre_indices (:) holds indices pointing to l1tab, which correspond to\nthe non-vanishing elements of the sum over \\lambda\nfor each non-zero element of the coupling matrix; real(kind=dp), intent(inout) :: nonzero_coupling_coefficients (:) holds values of the non-zero algebraic coefficients Calls proc~~process_single_matrix_element~~CallsGraph proc~process_single_matrix_element process_single_matrix_element proc~zero_projections_3j_condition zero_projections_3j_condition proc~process_single_matrix_element->proc~zero_projections_3j_condition proc~percival_seaton_coefficient percival_seaton_coefficient proc~process_single_matrix_element->proc~percival_seaton_coefficient proc~triangle_inequality_holds triangle_inequality_holds proc~zero_projections_3j_condition->proc~triangle_inequality_holds proc~is_sum_even is_sum_even proc~zero_projections_3j_condition->proc~is_sum_even fwig3jj fwig3jj proc~percival_seaton_coefficient->fwig3jj Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~process_single_matrix_element~~CalledByGraph proc~process_single_matrix_element process_single_matrix_element proc~prepare_coupling_matrix_elements prepare_coupling_matrix_elements proc~prepare_coupling_matrix_elements->proc~process_single_matrix_element program~scattering SCATTERING program~scattering->proc~prepare_coupling_matrix_elements Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables lambda_ legendre_term_index_ pscoeff Source Code process_single_matrix_element Variables Type Visibility Attributes Name Initial integer(kind=int32), public :: lambda_ integer(kind=int32), public :: legendre_term_index_ real(kind=dp), public :: pscoeff Source Code subroutine process_single_matrix_element ( j_ , j_prime_ , omega_ , & count_nonzero_coupling_coefficients , count_nonzero_legendre_terms , & nonzero_legendre_indices , nonzero_coupling_coefficients ) !! calculates the non-zero algebraic coefficients !! \\ g\\_{{\\lambda},\\gamma,\\gamma'}&#94;{Jp} \\ for a single matrix !! element - see Eq. (1) in the \"Coupling matrix\" section; !! algebraic coefficients are saved to nonzero_coupling_coefficients !! array; corresponding indices to l1tab are saved to !! nonzero_legendre_indices array !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: j_ !! pre-collisional rotational angular momentum integer ( int32 ), intent ( in ) :: j_prime_ !! post-collisional rotational angular momentum integer ( int32 ), intent ( in ) :: omega_ !! \\\\bar{\\Omega}\\ integer ( int32 ), intent ( inout ) :: count_nonzero_coupling_coefficients !! running index counting non-zero coupling coefficients, !! \\ g\\_{{\\lambda},\\gamma,\\gamma'}&#94;{Jp} \\ in the whole matrix; !! incremented in this subroutine integer ( int32 ), intent ( inout ) :: count_nonzero_legendre_terms !! number of non-zero terms in Legendre expansion for a single !! matrix element of the interaction potential integer ( int32 ), intent ( inout ) :: nonzero_legendre_indices (:) !! holds indices pointing to l1tab, which correspond to !! the non-vanishing elements of the sum over \\\\lambda\\ !! for each non-zero element of the coupling matrix; real ( dp ), intent ( inout ) :: nonzero_coupling_coefficients (:) !! holds values of the non-zero algebraic coefficients !---------------------------------------------------------------------! integer ( int32 ) :: legendre_term_index_ , lambda_ real ( dp ) :: pscoeff !---------------------------------------------------------------------! count_nonzero_legendre_terms = 0 do legendre_term_index_ = 1 , nterms lambda_ = l1tab ( legendre_term_index_ ) !------------------------------------------------------------! ! check the condition on 3-j symbol with zero projections !------------------------------------------------------------! if (. not . zero_projections_3j_condition ( j_ , j_prime_ , lambda_ )) cycle !------------------------------------------------------------! count_nonzero_coupling_coefficients = & count_nonzero_coupling_coefficients + 1 !------------------------------------------------------------! ! calculate the Percival-Seaton coefficient !------------------------------------------------------------! pscoeff = percival_seaton_coefficient ( j_ , j_prime_ , lambda_ , omega_ ) !------------------------------------------------------------! ! save the Percival-Seaton coefficient !------------------------------------------------------------! nonzero_coupling_coefficients ( & count_nonzero_coupling_coefficients ) = pscoeff !------------------------------------------------------------! ! save indices to l1tab corresponding to \\\\lambda\\ !------------------------------------------------------------! nonzero_legendre_indices ( count_nonzero_coupling_coefficients )& = legendre_term_index_ !------------------------------------------------------------! count_nonzero_legendre_terms = count_nonzero_legendre_terms + 1 enddo !---------------------------------------------------------------------! end subroutine process_single_matrix_element","tags":"","loc":"proc/process_single_matrix_element.html"},{"title":"CROSSSECTION – the SCATTERING code","text":"public  subroutine CROSSSECTION(jj, nopen, number_of_channels, number_of_open_basis_levels, open_basis_levels, open_basis_wavevectors, srmatrix, simatrix, channels_level_indices, channels_l_values, xs_array) calculate the state-to-state cross-section Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: jj total angular momentum integer(kind=int32), intent(in) :: nopen number of open channels integer(kind=int32), intent(in) :: number_of_channels size of the basis integer(kind=int32), intent(in) :: number_of_open_basis_levels number of all possible state-to-state XS integer(kind=int32), intent(in) :: open_basis_levels (number_of_open_basis_levels) holds indices to the basis arrays which correspond to open channels real(kind=dp), intent(in) :: open_basis_wavevectors (number_of_open_basis_levels) holds wavenumbers k_{i} real(kind=dp), intent(in) :: srmatrix (nopen,nopen) real and imaginary parts of the S-matrix real(kind=dp), intent(in) :: simatrix (nopen,nopen) real and imaginary parts of the S-matrix integer(kind=int32), intent(in) :: channels_level_indices (number_of_channels) holds the indices pointing to the basis arrays integer(kind=int32), intent(in) :: channels_l_values (number_of_channels) holds all values of l real(kind=dp), intent(inout) :: xs_array (number_of_open_basis_levels*number_of_open_basis_levels) array holding all XSs Calls proc~~crosssection~~CallsGraph proc~crosssection CROSSSECTION interface~allocate_1d allocate_1d proc~crosssection->interface~allocate_1d proc~time_count_summary time_count_summary proc~crosssection->proc~time_count_summary proc~write_message write_message proc~time_count_summary->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~crosssection~~CalledByGraph proc~crosssection CROSSSECTION program~scattering SCATTERING program~scattering->proc~crosssection Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables ifin ii iinit il ilp ioccur1 ioccur2 j1lev j1plev jblockarr jfin jinit jpblockarr lptmp ltmp njoccur njpoccur teli telr telsq time_finish time_start v1lev v1plev waveinit xs_time xssum Variables Type Visibility Attributes Name Initial integer(kind=int32), public :: ifin integer(kind=int32), public :: ii integer(kind=int32), public :: iinit integer(kind=int32), public :: il integer(kind=int32), public :: ilp integer(kind=int32), public :: ioccur1 integer(kind=int32), public :: ioccur2 integer(kind=int32), public :: j1lev integer(kind=int32), public :: j1plev integer(kind=int32), public, allocatable :: jblockarr (:) integer(kind=int32), public :: jfin integer(kind=int32), public :: jinit integer(kind=int32), public, allocatable :: jpblockarr (:) integer(kind=int32), public :: lptmp integer(kind=int32), public :: ltmp integer(kind=int32), public :: njoccur integer(kind=int32), public :: njpoccur real(kind=dp), public :: teli real(kind=dp), public :: telr real(kind=dp), public :: telsq real(kind=dp), public :: time_finish real(kind=dp), public :: time_start integer(kind=int32), public :: v1lev integer(kind=int32), public :: v1plev real(kind=dp), public :: waveinit real(kind=dp), public :: xs_time real(kind=dp), public :: xssum","tags":"","loc":"proc/crosssection.html"},{"title":"check_dtol_otol – the SCATTERING code","text":"public  subroutine check_dtol_otol(maxXSdiag, maxXSoff, ncacdiag, ncacoff, terminate) check if the dtol/otol condition on partial XS is already fulfilled Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: maxXSdiag largest elastic and inelastic XS real(kind=dp), intent(in) :: maxXSoff largest elastic and inelastic XS integer(kind=int32), intent(inout) :: ncacdiag number of consecutive blocks for which dtol/otol condition is already\nfulfilled. Gets incremented within the subroutine integer(kind=int32), intent(inout) :: ncacoff number of consecutive blocks for which dtol/otol condition is already\nfulfilled. Gets incremented within the subroutine logical, intent(inout) :: terminate if .true. the dtol/otol condition is fulfilled;\nJ-tot loop is terminated Called by proc~~check_dtol_otol~~CalledByGraph proc~check_dtol_otol check_dtol_otol program~scattering SCATTERING program~scattering->proc~check_dtol_otol Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables diagcontr icount icount2 offcontr Source Code check_dtol_otol Variables Type Visibility Attributes Name Initial logical, public :: diagcontr integer(kind=int32), public :: icount integer(kind=int32), public :: icount2 logical, public :: offcontr Source Code subroutine check_dtol_otol ( maxXSdiag , maxXSoff , ncacdiag , ncacoff , terminate ) !! check if the dtol/otol condition on partial XS is already fulfilled !---------------------------------------------------------------------------! real ( dp ), intent ( in ) :: maxXSdiag , maxXSoff !! largest elastic and inelastic XS integer ( int32 ), intent ( inout ) :: ncacdiag , ncacoff !! number of consecutive blocks for which dtol/otol condition is already !! fulfilled. Gets incremented within the subroutine logical , intent ( inout ) :: terminate !! if .true. the dtol/otol condition is fulfilled; !! J-tot loop is terminated !---------------------------------------------------------------------------! integer ( int32 ) :: icount , icount2 logical :: diagcontr , offcontr !---------------------------------------------------------------------------! terminate = . false . !---------------------------------------------------------------------------! ! diagcontr and offcontr check if dtol and otol are fulfilled, respectively !---------------------------------------------------------------------------! diagcontr = . false . offcontr = . false . !---------------------------------------------------------------------------! if ( maxXSdiag . le . dtol ) diagcontr = . true . if ( maxXSoff . le . otol ) offcontr = . true . !---------------------------------------------------------------------------! if ( diagcontr ) then ncacdiag = ncacdiag + 1 else ncacdiag = 0 endif !------------------------------------------------------------------------------! if ( offcontr ) then ncacoff = ncacoff + 1 else ncacoff = 0 endif !------------------------------------------------------------------------------! ! Finish the calculations if both contributions are smaller than the limits:   ! !------------------------------------------------------------------------------! if (( ncacdiag . ge . ncac ). and .( ncacoff . ge . ncac )) terminate = . true . !------------------------------------------------------------------------------! end subroutine check_dtol_otol","tags":"","loc":"proc/check_dtol_otol.html"},{"title":"print_largest_partial_xs – the SCATTERING code","text":"public  subroutine print_largest_partial_xs(jj, maxXSdiag, maxXSoff, jinddiag, jindoff1, jindoff2, number_of_open_basis_levels, open_basis_levels) print the largest partial elastic and inelastic state-to-state XS\nin given J-block Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: jj total angular momentum real(kind=dp), intent(in) :: maxXSdiag the largest partial elastic state-to-state XS in this J-block real(kind=dp), intent(in) :: maxXSoff the largest partial inelastic state-to-state XS in this J-block integer(kind=int32), intent(in) :: jinddiag index pointing indirectly to quantum numbers associated with\nthe largest partial elastic state-to-state XS in this J-block integer(kind=int32), intent(in) :: jindoff1 indices pointing indirectly to quantum numbers associated with\nthe largest partial inelastic state-to-state XS in this J-block integer(kind=int32), intent(in) :: jindoff2 indices pointing indirectly to quantum numbers associated with\nthe largest partial inelastic state-to-state XS in this J-block integer(kind=int32), intent(in) :: number_of_open_basis_levels number of all possible state-to-state XS (size of open_basis_levels array) integer(kind=int32), intent(in) :: open_basis_levels (number_of_open_basis_levels) holds indices to the basis arrays which correspond to open channels Calls proc~~print_largest_partial_xs~~CallsGraph proc~print_largest_partial_xs print_largest_partial_xs proc~integer_to_character integer_to_character proc~print_largest_partial_xs->proc~integer_to_character proc~float_to_character float_to_character proc~print_largest_partial_xs->proc~float_to_character proc~write_message write_message proc~print_largest_partial_xs->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~print_largest_partial_xs~~CalledByGraph proc~print_largest_partial_xs print_largest_partial_xs program~scattering SCATTERING program~scattering->proc~print_largest_partial_xs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables header_line line Source Code print_largest_partial_xs Variables Type Visibility Attributes Name Initial character(len=200), public :: header_line character(len=200), public :: line Source Code subroutine print_largest_partial_xs ( jj , maxXSdiag , maxXSoff , jinddiag , jindoff1 , & jindoff2 , number_of_open_basis_levels , open_basis_levels ) !! print the largest partial elastic and inelastic state-to-state XS !! in given J-block !---------------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: jj !! total angular momentum real ( dp ), intent ( in ) :: maxXSdiag !! the largest partial elastic state-to-state XS in this J-block real ( dp ), intent ( in ) :: maxXSoff !! the largest partial inelastic state-to-state XS in this J-block integer ( int32 ), intent ( in ) :: jinddiag !! index pointing indirectly to quantum numbers associated with !! the largest partial elastic state-to-state XS in this J-block integer ( int32 ), intent ( in ) :: jindoff1 , jindoff2 !! indices pointing indirectly to quantum numbers associated with !! the largest partial inelastic state-to-state XS in this J-block integer ( int32 ), intent ( in ) :: number_of_open_basis_levels !! number of all possible state-to-state XS (size of open_basis_levels array) integer ( int32 ), intent ( in ) :: open_basis_levels ( number_of_open_basis_levels ) !! holds indices to the basis arrays which correspond to open channels !---------------------------------------------------------------------------! character ( len = 200 ) :: header_line , line !---------------------------------------------------------------------------! if (( prntlvl . eq . 1 ). or .( prntlvl . eq . 2 )) then call write_message ( \"Largest partial elastic state-to-state for JTOT = \" // & trim ( adjustl ( integer_to_character ( jj ))) // \": \" // & trim ( adjustl ( float_to_character ( maxXSdiag )))) call write_message ( \"Largest partial inelastic state-to-state for JTOT = \" // & trim ( adjustl ( integer_to_character ( jj ))) // \": \" // & trim ( adjustl ( float_to_character ( maxXSoff )))) call write_message ( repeat ( \" \" , 43 ) // \"***\" ) else if ( prntlvl . ge . 3 ) then !------------------------------------------------------------------------! call write_message ( \"Largest partial elastic state-to-state for JTOT = \" // & integer_to_character ( jj ) ) write ( header_line , \"(2x,a4,2x,a4,2x,a2,2x,a4,2x,a4,16x,a2)\" ) \"v1_f\" , & \"j1_f\" , \"<-\" , \"v1_i\" , \"j1_i\" , \"XS\" call write_message ( header_line ) write ( line , \"(2X,I4,2X,I4,6X,I4,2X,I4,2X,E16.8)\" ) & v1array ( open_basis_levels ( jinddiag )), j1array ( open_basis_levels ( jinddiag )), & v1array ( open_basis_levels ( jinddiag )), j1array ( open_basis_levels ( jinddiag )), maxXSdiag call write_message ( line ) !------------------------------------------------------------------------! call write_message ( \"Largest partial inelastic state-to-state for JTOT = \" // & integer_to_character ( jj ) ) call write_message ( header_line ) write ( line , \"(2X,I4,2X,I4,6X,I4,2X,I4,2X,E16.8)\" ) & v1array ( open_basis_levels ( jindoff2 )), j1array ( open_basis_levels ( jindoff2 )), & v1array ( open_basis_levels ( jindoff1 )), j1array ( open_basis_levels ( jindoff1 )), maxXSoff call write_message ( line ) call write_message ( repeat ( \" \" , 43 ) // \"***\" ) !------------------------------------------------------------------------! endif end subroutine print_largest_partial_xs","tags":"","loc":"proc/print_largest_partial_xs.html"},{"title":"calculate_k_matrix – the SCATTERING code","text":"public  subroutine calculate_k_matrix(number_of_channels, log_der_matrix, number_of_open_channels, channels_level_indices, channels_l_values, r_, k_matrix) calculates the K-matrix from log-derivative matrix using Eq. (4) in\n\"Solution of coupled equations\" Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: number_of_channels y-matrix is of number_of_channels x number_of_channels size real(kind=dp), intent(in) :: log_der_matrix (number_of_channels,number_of_channels) asymptotic log-derivative matrix integer(kind=int32), intent(in) :: number_of_open_channels number of open channels integer(kind=int32), intent(in) :: channels_level_indices (number_of_channels) holds the indices pointing to the basis arrays integer(kind=int32), intent(in) :: channels_l_values (number_of_channels) holds all values of l real(kind=dp), intent(in) :: r_ Rmax real(kind=dp), intent(inout) :: k_matrix (number_of_open_channels,number_of_open_channels) K-matrix Calls proc~~calculate_k_matrix~~CallsGraph proc~calculate_k_matrix calculate_k_matrix proc~is_open is_open proc~calculate_k_matrix->proc~is_open dgesv dgesv proc~calculate_k_matrix->dgesv proc~wavenumber_from_energy wavenumber_from_energy proc~calculate_k_matrix->proc~wavenumber_from_energy proc~riccati_bessel_y riccati_bessel_y proc~calculate_k_matrix->proc~riccati_bessel_y proc~modified_bessel_k_ratio modified_bessel_k_ratio proc~calculate_k_matrix->proc~modified_bessel_k_ratio proc~riccati_bessel_j riccati_bessel_j proc~calculate_k_matrix->proc~riccati_bessel_j dgemm dgemm proc~calculate_k_matrix->dgemm proc~etotal ETOTAL proc~is_open->proc~etotal proc~wavenumber_from_energy->proc~etotal proc~write_error write_error proc~wavenumber_from_energy->proc~write_error proc~integer_to_character integer_to_character proc~riccati_bessel_y->proc~integer_to_character proc~write_warning write_warning proc~riccati_bessel_y->proc~write_warning proc~rcty rcty proc~riccati_bessel_y->proc~rcty proc~modified_bessel_k_ratio->proc~integer_to_character proc~modified_bessel_k_ratio->proc~write_warning proc~ikv ikv proc~modified_bessel_k_ratio->proc~ikv proc~riccati_bessel_j->proc~integer_to_character proc~riccati_bessel_j->proc~write_warning proc~rctj rctj proc~riccati_bessel_j->proc~rctj proc~write_message write_message proc~write_warning->proc~write_message proc~msta2 msta2 proc~ikv->proc~msta2 proc~msta1 msta1 proc~ikv->proc~msta1 proc~write_error->proc~write_message proc~rctj->proc~msta2 proc~rctj->proc~msta1 proc~envj envj proc~msta2->proc~envj proc~msta1->proc~envj Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~calculate_k_matrix~~CalledByGraph proc~calculate_k_matrix calculate_k_matrix program~scattering SCATTERING program~scattering->proc~calculate_k_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code calculate_k_matrix Source Code subroutine calculate_k_matrix ( number_of_channels , log_der_matrix , & number_of_open_channels , channels_level_indices , channels_l_values , & r_ , k_matrix ) !! calculates the K-matrix from log-derivative matrix using Eq. (4) in !! \"Solution of coupled equations\" !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: number_of_channels !! y-matrix is of number_of_channels x number_of_channels size real ( dp ), intent ( in ) :: log_der_matrix ( number_of_channels , number_of_channels ) !! asymptotic log-derivative matrix integer ( int32 ), intent ( in ) :: number_of_open_channels !! number of open channels integer ( int32 ), intent ( in ) :: channels_level_indices ( number_of_channels ) !! holds the indices pointing to the basis arrays integer ( int32 ), intent ( in ) :: channels_l_values ( number_of_channels ) !! holds all values of l real ( dp ), intent ( in ) :: r_ !! Rmax real ( dp ), intent ( inout ) :: k_matrix ( number_of_open_channels , number_of_open_channels ) !! K-matrix !---------------------------------------------------------------------! integer ( int32 ) :: open_channel_index_ , closed_channel_index_ , & channel_index_ , status_ , l_ real ( dp ) :: wavenumber , x , j_element_ , jp_element_ , n_element_ , & np_element_ , ratio integer ( int32 ) :: open_channels_indices ( number_of_open_channels ) integer ( int32 ) :: closed_channels_indices ( number_of_channels - number_of_open_channels ) real ( dp ) :: diag_n_matrix ( number_of_channels , number_of_channels ), & diag_np_matrix ( number_of_channels , number_of_channels ), & diag_j_matrix ( number_of_channels , number_of_open_channels ), & diag_jp_matrix ( number_of_channels , number_of_open_channels ) !---------------------------------------------------------------------! ! diag_j_matrix   -  diagonal J matrix (Eqs. 5, 7) ! diag_jp_matrix  -  diagonal J`matrix (derivative of J) ! diag_n_matrix   -  diagonal N matrix (Eqs. 6, 8) ! diag_np_matrix  -  diagonal N`matrix (derivative of N) !---------------------------------------------------------------------! diag_j_matrix = 0 diag_jp_matrix = 0 diag_n_matrix = 0 diag_np_matrix = 0 !---------------------------------------------------------------------! open_channel_index_ = 0 closed_channel_index_ = 0 !---------------------------------------------------------------------! ! save indices to open and closed channels ! this is because channels might not be sorted eneregetically !---------------------------------------------------------------------! do channel_index_ = 1 , number_of_channels if ( is_open ( elevel ( channels_level_indices ( channel_index_ )))) then open_channel_index_ = open_channel_index_ + 1 open_channels_indices ( open_channel_index_ ) = channel_index_ else closed_channel_index_ = closed_channel_index_ + 1 closed_channels_indices ( closed_channel_index_ ) = channel_index_ endif enddo !---------------------------------------------------------------------! ! Prepare J, J', N and N' matrices (Eqs. 5-6) ! open channels: !---------------------------------------------------------------------! do open_channel_index_ = 1 , number_of_open_channels wavenumber = wavenumber_from_energy ( & elevel ( channels_level_indices ( open_channels_indices ( open_channel_index_ )))) x = wavenumber * r_ l_ = channels_l_values ( open_channels_indices ( open_channel_index_ )) call riccati_bessel_j ( & l_ , x , j_element_ , jp_element_ ) diag_j_matrix ( open_channel_index_ , open_channel_index_ ) & = ( wavenumber ) ** ( - 0.5d0 ) * j_element_ diag_jp_matrix ( open_channel_index_ , open_channel_index_ ) & = ( wavenumber ) ** ( 0.5d0 ) * jp_element_ call riccati_bessel_y ( l_ , x , n_element_ , np_element_ ) diag_n_matrix ( open_channel_index_ , open_channel_index_ ) & = ( wavenumber ) ** ( - 0.5d0 ) * n_element_ diag_np_matrix ( open_channel_index_ , open_channel_index_ ) & = ( wavenumber ) ** ( 0.5d0 ) * np_element_ enddo !---------------------------------------------------------------------! ! Prepare J, J', N and N' matrices (Eqs. 7-8) ! closed channels: !---------------------------------------------------------------------! do closed_channel_index_ = 1 , number_of_channels - number_of_open_channels wavenumber = wavenumber_from_energy ( & elevel ( channels_level_indices ( closed_channels_indices ( closed_channel_index_ )))) x = wavenumber * r_ l_ = channels_l_values ( closed_channels_indices ( closed_channel_index_ )) call modified_bessel_k_ratio ( l_ , x , ratio ) !------------------------------------------------------------------! ! substitution for closed channels, (Eqs. 10 - 11) !------------------------------------------------------------------! diag_n_matrix ( number_of_open_channels + closed_channel_index_ , & number_of_open_channels + closed_channel_index_ ) = 1.d0 diag_np_matrix ( number_of_open_channels + closed_channel_index_ , & number_of_open_channels + closed_channel_index_ ) = wavenumber * ratio enddo !---------------------------------------------------------------------! -----------------------> consider a separate function call DGEMM ( 'N' , 'N' , number_of_channels , number_of_channels , & number_of_channels , 1.0d0 , log_der_matrix , number_of_channels , diag_n_matrix , & number_of_channels , - 1.d0 , diag_np_matrix , number_of_channels ) call DGEMM ( 'N' , 'N' , number_of_channels , number_of_open_channels , & number_of_channels , - 1.0d0 , log_der_matrix , number_of_channels , diag_j_matrix , & number_of_channels , 1.d0 , diag_jp_matrix , number_of_channels ) !---------------------------------------------------------------------! call DGESV ( number_of_channels , number_of_open_channels , diag_np_matrix , & number_of_channels , diag_j_matrix , diag_jp_matrix , number_of_channels , status_ ) !---------------------------------------------------------------------! k_matrix = diag_jp_matrix ( 1 : number_of_open_channels , 1 : number_of_open_channels ) !---------------------------------------------------------------------! end subroutine calculate_k_matrix","tags":"","loc":"proc/calculate_k_matrix.html"},{"title":"calculate_s_matrix – the SCATTERING code","text":"public  subroutine calculate_s_matrix(number_of_open_channels, k_matrix, s_matrix_real, s_matrix_imag) calculates S-matrix from open-open portion of the K-matrix using\nEq. (12) in \"Solution of coupled equations\" Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: number_of_open_channels number of open channels real(kind=dp), intent(in) :: k_matrix (number_of_open_channels,number_of_open_channels) K-matrix real(kind=dp), intent(inout) :: s_matrix_real (number_of_open_channels,number_of_open_channels) (output) real part of the S-matrix real(kind=dp), intent(inout) :: s_matrix_imag (number_of_open_channels,number_of_open_channels) (output) imaginary part of the S-matrix Calls proc~~calculate_s_matrix~~CallsGraph proc~calculate_s_matrix calculate_s_matrix dgemm dgemm proc~calculate_s_matrix->dgemm interface~invert_symmetric_matrix invert_symmetric_matrix proc~calculate_s_matrix->interface~invert_symmetric_matrix interface~fill_symmetric_matrix fill_symmetric_matrix proc~calculate_s_matrix->interface~fill_symmetric_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~calculate_s_matrix~~CalledByGraph proc~calculate_s_matrix calculate_s_matrix program~scattering SCATTERING program~scattering->proc~calculate_s_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code calculate_s_matrix Source Code subroutine calculate_s_matrix ( number_of_open_channels , k_matrix , & s_matrix_real , s_matrix_imag ) !! calculates S-matrix from open-open portion of the K-matrix using !! Eq. (12) in \"Solution of coupled equations\" !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: number_of_open_channels !! number of open channels real ( dp ), intent ( in ) :: k_matrix ( number_of_open_channels , number_of_open_channels ) !! K-matrix real ( dp ), intent ( inout ) :: s_matrix_real ( number_of_open_channels , number_of_open_channels ) !! (output) real part of the S-matrix real ( dp ), intent ( inout ) :: s_matrix_imag ( number_of_open_channels , number_of_open_channels ) !! (output) imaginary part of the S-matrix !---------------------------------------------------------------------! integer ( int32 ) :: open_channel_index_1_ , open_channel_index_2_ real ( dp ) :: s_tmp_matrix ( number_of_open_channels , number_of_open_channels ) !---------------------------------------------------------------------! s_matrix_real = 0 s_matrix_imag = 0 !---------------------------------------------------------------------! call DGEMM ( 'N' , 'N' , number_of_open_channels , number_of_open_channels , & number_of_open_channels , 0.5d0 , k_matrix , number_of_open_channels , & k_matrix , number_of_open_channels , 0.d0 , s_tmp_matrix , number_of_open_channels ) !---------------------------------------------------------------------! do open_channel_index_1_ = 1 , number_of_open_channels s_tmp_matrix ( open_channel_index_1_ , open_channel_index_1_ ) = & s_tmp_matrix ( open_channel_index_1_ , open_channel_index_1_ ) + 0.5d0 enddo !---------------------------------------------------------------------! call invert_symmetric_matrix ( s_tmp_matrix ) call fill_symmetric_matrix ( s_tmp_matrix , 'u' ) !---------------------------------------------------------------------! call DGEMM ( 'N' , 'N' , number_of_open_channels , number_of_open_channels , & number_of_open_channels , - 1.0d0 , s_tmp_matrix , number_of_open_channels ,& k_matrix , number_of_open_channels , 0.d0 , s_matrix_imag , number_of_open_channels ) !---------------------------------------------------------------------! do open_channel_index_1_ = 1 , number_of_open_channels do open_channel_index_2_ = 1 , number_of_open_channels s_matrix_real ( open_channel_index_1_ , open_channel_index_2_ ) = & s_tmp_matrix ( open_channel_index_1_ , open_channel_index_2_ ) enddo s_matrix_real ( open_channel_index_1_ , open_channel_index_1_ ) = & s_matrix_real ( open_channel_index_1_ , open_channel_index_1_ ) - 1.d0 enddo !---------------------------------------------------------------------! end subroutine calculate_s_matrix","tags":"","loc":"proc/calculate_s_matrix.html"},{"title":"calculate_sf_matrix_from_bf_matrix – the SCATTERING code","text":"public  subroutine calculate_sf_matrix_from_bf_matrix(number_of_channels, total_angular_momentum_, channels_level_indices, channels_omega_values, channels_l_values, bf_matrix, sf_matrix) takes as an input matrix in the body-fixed frame and transforms it \nto the spec-fixed frame; iterates over all matrix elements\nand calls calculate_single_SF_element Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: number_of_channels size of the basis integer(kind=int32), intent(in) :: total_angular_momentum_ total angular momentum integer(kind=int32), intent(in) :: channels_level_indices (number_of_channels) holds the indices pointing to the basis arrays integer(kind=int32), intent(in) :: channels_omega_values (number_of_channels) holds all values of \\bar{\\Omega} integer(kind=int32), intent(in) :: channels_l_values (number_of_channels) holds all values of l real(kind=dp), intent(in) :: bf_matrix (number_of_channels,number_of_channels) matrix in the BF frame real(kind=dp), intent(inout) :: sf_matrix (number_of_channels,number_of_channels) (output) matrix in the SF frame Called by proc~~calculate_sf_matrix_from_bf_matrix~~CalledByGraph proc~calculate_sf_matrix_from_bf_matrix calculate_sf_matrix_from_bf_matrix program~scattering SCATTERING program~scattering->proc~calculate_sf_matrix_from_bf_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code calculate_sf_matrix_from_bf_matrix Source Code subroutine calculate_sf_matrix_from_bf_matrix ( number_of_channels , & total_angular_momentum_ , channels_level_indices , & channels_omega_values , channels_l_values , bf_matrix , sf_matrix ) !! takes as an input matrix in the body-fixed frame and transforms it !! to the spec-fixed frame; iterates over all matrix elements !! and calls calculate_single_SF_element !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: number_of_channels !! size of the basis integer ( int32 ), intent ( in ) :: total_angular_momentum_ !! total angular momentum integer ( int32 ), intent ( in ) :: channels_level_indices ( number_of_channels ) !! holds the indices pointing to the basis arrays integer ( int32 ), intent ( in ) :: channels_omega_values ( number_of_channels ) !! holds all values of \\bar{\\Omega} integer ( int32 ), intent ( in ) :: channels_l_values ( number_of_channels ) !! holds all values of l real ( dp ), intent ( in ) :: bf_matrix ( number_of_channels , number_of_channels ) !! matrix in the BF frame real ( dp ), intent ( inout ) :: sf_matrix ( number_of_channels , number_of_channels ) !! (output) matrix in the SF frame !---------------------------------------------------------------------! integer ( int32 ) :: l_ , lp_ , omega_ , omegap_ , v1_ , j1_ , v1p_ , j1p_ , channel_index_1_ , channel_index_2_ real ( dp ) :: single_sf_element !---------------------------------------------------------------------! do channel_index_1_ = 1 , number_of_channels v1_ = v1array ( channels_level_indices ( channel_index_1_ )) j1_ = j1array ( channels_level_indices ( channel_index_1_ )) l_ = channels_l_values ( channel_index_1_ ) do channel_index_2_ = 1 , number_of_channels v1p_ = v1array ( channels_level_indices ( channel_index_2_ )) j1p_ = j1array ( channels_level_indices ( channel_index_2_ )) lp_ = channels_l_values ( channel_index_2_ ) call calculate_single_SF_element ( number_of_channels , & total_angular_momentum_ , v1_ , j1_ , v1p_ , j1p_ , l_ , lp_ , & channels_level_indices , channels_omega_values , bf_matrix , & single_sf_element ) sf_matrix ( channel_index_1_ , channel_index_2_ ) = single_sf_element enddo enddo !---------------------------------------------------------------------! end subroutine calculate_sf_matrix_from_bf_matrix","tags":"","loc":"proc/calculate_sf_matrix_from_bf_matrix.html"},{"title":"calculate_log_der_matrix – the SCATTERING code","text":"public  subroutine calculate_log_der_matrix(h, y_dim, tt_min, tt_n, tt_plus, r_n, r_plus, log_der_matrix) calculates the log-derivative matrix from Eq. (6.29)\ncalled by numerov and log_derivative at the end of the propagation Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: h step of the propagation integer(kind=int32), intent(in) :: y_dim dimension of the log-derivative matrix real(kind=dp), intent(in) :: tt_min (y_dim,y_dim) T-matrix at R_{max - 1} real(kind=dp), intent(in) :: tt_n (y_dim,y_dim) T-matrix at R_{max} real(kind=dp), intent(in) :: tt_plus (y_dim,y_dim) T-matrix at R_{max + 1} real(kind=dp), intent(in) :: r_n (y_dim,y_dim) R-matrix at R_{max} real(kind=dp), intent(in) :: r_plus (y_dim,y_dim) R-matrix at R_{max + 1} real(kind=dp), intent(inout) :: log_der_matrix (y_dim,y_dim) log-derivative matrix Calls proc~~calculate_log_der_matrix~~CallsGraph proc~calculate_log_der_matrix calculate_log_der_matrix interface~invert_symmetric_matrix invert_symmetric_matrix proc~calculate_log_der_matrix->interface~invert_symmetric_matrix dgemm dgemm proc~calculate_log_der_matrix->dgemm interface~fill_symmetric_matrix fill_symmetric_matrix proc~calculate_log_der_matrix->interface~fill_symmetric_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~calculate_log_der_matrix~~CalledByGraph proc~calculate_log_der_matrix calculate_log_der_matrix proc~numerov numerov proc~numerov->proc~calculate_log_der_matrix program~scattering SCATTERING program~scattering->proc~numerov Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables a ab abc b bra c d de def e f g i j Source Code calculate_log_der_matrix Variables Type Visibility Attributes Name Initial real(kind=dp), public :: a (y_dim,y_dim) real(kind=dp), public :: ab (y_dim,y_dim) real(kind=dp), public :: abc (y_dim,y_dim) real(kind=dp), public :: b (y_dim,y_dim) real(kind=dp), public :: bra (y_dim,y_dim) real(kind=dp), public :: c (y_dim,y_dim) real(kind=dp), public :: d (y_dim,y_dim) real(kind=dp), public :: de (y_dim,y_dim) real(kind=dp), public :: def (y_dim,y_dim) real(kind=dp), public :: e (y_dim,y_dim) real(kind=dp), public :: f (y_dim,y_dim) real(kind=dp), public :: g (y_dim,y_dim) integer(kind=int32), public :: i integer(kind=int32), public :: j Source Code subroutine calculate_log_der_matrix ( h , y_dim , tt_min , tt_n , tt_plus , r_n , r_plus , log_der_matrix ) !! calculates the log-derivative matrix from Eq. (6.29) !! called by numerov and log_derivative at the end of the propagation !---------------------------------------------------------------------! real ( dp ), intent ( in ) :: h !! step of the propagation integer ( int32 ), intent ( in ) :: y_dim !! dimension of the log-derivative matrix real ( dp ), intent ( in ) :: tt_min ( y_dim , y_dim ) !! T-matrix at R_{max - 1} real ( dp ), intent ( in ) :: tt_n ( y_dim , y_dim ) !! T-matrix at R_{max} real ( dp ), intent ( in ) :: tt_plus ( y_dim , y_dim ) !! T-matrix at R_{max + 1} real ( dp ), intent ( in ) :: r_n ( y_dim , y_dim ) !! R-matrix at R_{max} real ( dp ), intent ( in ) :: r_plus ( y_dim , y_dim ) !! R-matrix at R_{max + 1} real ( dp ), intent ( inout ) :: log_der_matrix ( y_dim , y_dim ) !! log-derivative matrix !---------------------------------------------------------------------! integer ( int32 ) :: i , j real ( dp ) :: a ( y_dim , y_dim ), b ( y_dim , y_dim ), c ( y_dim , y_dim ), & d ( y_dim , y_dim ), e ( y_dim , y_dim ), f ( y_dim , y_dim ), g ( y_dim , y_dim ), & ab ( y_dim , y_dim ), abc ( y_dim , y_dim ), de ( y_dim , y_dim ), & def ( y_dim , y_dim ), bra ( y_dim , y_dim ) !---------------------------------------------------------------------! log_der_matrix = 0 !---------------------------------------------------------------------! do i = 1 , y_dim do j = 1 , y_dim a ( i , j ) = - tt_plus ( i , j ) b ( i , j ) = - tt_plus ( i , j ) c ( i , j ) = r_plus ( i , j ) d ( i , j ) = - tt_min ( i , j ) e ( i , j ) = - tt_min ( i , j ) f ( i , j ) = r_n ( i , j ) g ( i , j ) = - tt_n ( i , j ) end do a ( i , i ) = 0.5 + a ( i , i ) b ( i , i ) = 1. + b ( i , i ) d ( i , i ) = 0.5 + d ( i , i ) e ( i , i ) = 1. + e ( i , i ) g ( i , i ) = 1. + g ( i , i ) end do !---------------------------------------------------------------------! call invert_symmetric_matrix ( b ) call fill_symmetric_matrix ( b , \"u\" ) call invert_symmetric_matrix ( e ) call fill_symmetric_matrix ( e , \"u\" ) call invert_symmetric_matrix ( f ) call fill_symmetric_matrix ( f , \"u\" ) !---------------------------------------------------------------------! CALL DGEMM ( 'N' , 'N' , y_dim , y_dim , y_dim , 1.0d0 ,& a , y_dim , b , y_dim , 0.d0 , ab , y_dim ) CALL DGEMM ( 'N' , 'N' , y_dim , y_dim , y_dim , 1.0d0 ,& ab , y_dim , c , y_dim , 0.d0 , abc , y_dim ) CALL DGEMM ( 'N' , 'N' , y_dim , y_dim , y_dim , 1.0d0 ,& d , y_dim , e , y_dim , 0.d0 , de , y_dim ) CALL DGEMM ( 'N' , 'N' , y_dim , y_dim , y_dim , 1.0d0 ,& de , y_dim , f , y_dim , 0.d0 , DEF , y_dim ) !----------------------------------------------------------------------! bra = abc - def !---------------------------------------------------------------------! CALL DGEMM ( 'N' , 'N' , y_dim , y_dim , y_dim , dble ( 1.d0 / h ), bra ,& y_dim , g , y_dim , 0.d0 , log_der_matrix , y_dim ) !---------------------------------------------------------------------! end subroutine calculate_log_der_matrix","tags":"","loc":"proc/calculate_log_der_matrix.html"},{"title":"cenitrfugal_matrix – the SCATTERING code","text":"public  subroutine cenitrfugal_matrix(number_of_channels, jj, channels_level_indices, channels_omega_values, centmatrix) calculates the (R* 2) centrifugal matrix from Eq. (6.19)\nonly called once at the beginning of the calculations Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: number_of_channels size of the basis integer(kind=int32), intent(in) :: jj total angular momentum integer(kind=int32), intent(in) :: channels_level_indices (number_of_channels) holds the indices pointing to the basis arrays integer(kind=int32), intent(in) :: channels_omega_values (number_of_channels) holds all values of \\bar{\\Omega} real(kind=dp), intent(out) :: centmatrix (number_of_channels,number_of_channels) (output) - (R* 2) centrifugal matrix Calls proc~~cenitrfugal_matrix~~CallsGraph proc~cenitrfugal_matrix cenitrfugal_matrix dfloat dfloat proc~cenitrfugal_matrix->dfloat interface~fill_symmetric_matrix fill_symmetric_matrix proc~cenitrfugal_matrix->interface~fill_symmetric_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~cenitrfugal_matrix~~CalledByGraph proc~cenitrfugal_matrix cenitrfugal_matrix proc~numerov numerov proc~numerov->proc~cenitrfugal_matrix program~scattering SCATTERING program~scattering->proc~numerov Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables centtmp delta1 delta2 ii ij j1ptmp j1tmp omegaptmp omegatmp v1ptmp v1tmp Variables Type Visibility Attributes Name Initial real(kind=dp), public :: centtmp real(kind=dp), public :: delta1 real(kind=dp), public :: delta2 integer(kind=int32), public :: ii integer(kind=int32), public :: ij integer(kind=int32), public :: j1ptmp integer(kind=int32), public :: j1tmp integer(kind=int32), public :: omegaptmp integer(kind=int32), public :: omegatmp integer(kind=int32), public :: v1ptmp integer(kind=int32), public :: v1tmp","tags":"","loc":"proc/cenitrfugal_matrix.html"},{"title":"numerov – the SCATTERING code","text":"public  subroutine numerov(channels_level_indices, channels_omega_values, number_of_nonzero_coupling_matrix_elements, number_of_nonzero_coupling_coefficients, nonzero_terms_per_element, nonzero_legendre_indices, nonzero_coupling_coefficients, nsteps, number_of_channels, jj, log_der_matrix) renormalized Numerov propagator Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: channels_level_indices (number_of_channels) holds the indices pointing to the basis arrays integer(kind=int32), intent(in) :: channels_omega_values (number_of_channels) holds all values of \\bar{\\Omega} integer(kind=int32), intent(in) :: number_of_nonzero_coupling_matrix_elements number of non-zero terms in the sum () for each non-zero element of the coupling matrix integer(kind=int32), intent(in) :: number_of_nonzero_coupling_coefficients number of all non-zero algberaix coefficients in the whole coupling matrix integer(kind=int32), intent(in) :: nonzero_terms_per_element (number_of_nonzero_coupling_matrix_elements) keeps the number of non-zero terms in the sum (Eq. (6.21)) for\neach non-zero element of W/V integer(kind=int32), intent(in) :: nonzero_legendre_indices (number_of_nonzero_coupling_coefficients) holds the proper indices pointing to l1/l2/lltabs, which\ncorrespond to the non-vanishing elements of the sum  (Eq. (6.21))\nfor each non-zero element of W/V real(kind=dp), intent(in) :: nonzero_coupling_coefficients (number_of_nonzero_coupling_coefficients) holds the values of the non-zero algebraic coefficients integer(kind=int32), intent(in) :: nsteps number of steps from rmin to rmax integer(kind=int32), intent(in) :: number_of_channels size of the basis integer(kind=int32), intent(in) :: jj total angular momentum real(kind=dp), intent(inout) :: log_der_matrix (:,:) resulting log-derivative matrix at RMAX Calls proc~~numerov~~CallsGraph proc~numerov numerov proc~etotal ETOTAL proc~numerov->proc~etotal proc~calculate_log_der_matrix calculate_log_der_matrix proc~numerov->proc~calculate_log_der_matrix proc~pes_contribution pes_contribution proc~numerov->proc~pes_contribution interface~fill_symmetric_matrix fill_symmetric_matrix proc~numerov->interface~fill_symmetric_matrix proc~cenitrfugal_matrix cenitrfugal_matrix proc~numerov->proc~cenitrfugal_matrix interface~invert_symmetric_matrix invert_symmetric_matrix proc~numerov->interface~invert_symmetric_matrix interface~allocate_2d allocate_2d proc~numerov->interface~allocate_2d proc~float_to_character float_to_character proc~numerov->proc~float_to_character proc~write_message write_message proc~numerov->proc~write_message proc~calculate_log_der_matrix->interface~fill_symmetric_matrix proc~calculate_log_der_matrix->interface~invert_symmetric_matrix dgemm dgemm proc~calculate_log_der_matrix->dgemm proc~pes_contribution->interface~fill_symmetric_matrix proc~get_radial_coupling_term_value get_radial_coupling_term_value proc~pes_contribution->proc~get_radial_coupling_term_value proc~cenitrfugal_matrix->interface~fill_symmetric_matrix dfloat dfloat proc~cenitrfugal_matrix->dfloat proc~ispline ispline proc~get_radial_coupling_term_value->proc~ispline proc~ispline->proc~float_to_character proc~write_warning write_warning proc~ispline->proc~write_warning proc~write_warning->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~numerov~~CalledByGraph proc~numerov numerov program~scattering SCATTERING program~scattering->proc~numerov Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables cent_mat finish i ii ij r r_center r_plus r_temp rmatrix start step_numerov t_center t_mat t_minus t_plus u_left u_right umatrix v_mat v_tmp w_mat w_tmp Source Code numerov Variables Type Visibility Attributes Name Initial real(kind=dp), public, dimension(number_of_channels,number_of_channels) :: cent_mat real(kind=dp), public :: finish integer(kind=int32), public :: i integer(kind=int32), public :: ii integer(kind=int32), public :: ij real(kind=dp), public :: r real(kind=dp), public, allocatable, dimension(:,:) :: r_center real(kind=dp), public, allocatable, dimension(:,:) :: r_plus real(kind=dp), public, allocatable, dimension(:,:) :: r_temp real(kind=dp), public, allocatable, dimension(:,:) :: rmatrix real(kind=dp), public :: start real(kind=dp), public :: step_numerov real(kind=dp), public, allocatable, dimension(:,:) :: t_center real(kind=dp), public, dimension(number_of_channels,number_of_channels) :: t_mat real(kind=dp), public, allocatable, dimension(:,:) :: t_minus real(kind=dp), public, allocatable, dimension(:,:) :: t_plus real(kind=dp), public, dimension(number_of_channels,number_of_channels) :: u_left real(kind=dp), public, dimension(number_of_channels,number_of_channels) :: u_right real(kind=dp), public, allocatable, dimension(:,:) :: umatrix real(kind=dp), public, dimension(number_of_channels,number_of_channels) :: v_mat real(kind=dp), public, allocatable, dimension(:,:) :: v_tmp real(kind=dp), public, dimension(number_of_channels,number_of_channels) :: w_mat real(kind=dp), public, allocatable, dimension(:,:) :: w_tmp Source Code subroutine numerov ( channels_level_indices , channels_omega_values , & number_of_nonzero_coupling_matrix_elements , & number_of_nonzero_coupling_coefficients , nonzero_terms_per_element , & nonzero_legendre_indices , nonzero_coupling_coefficients , nsteps , & number_of_channels , jj , log_der_matrix ) !! renormalized Numerov propagator !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: number_of_channels !! size of the basis integer ( int32 ), intent ( in ) :: channels_level_indices ( number_of_channels ) !! holds the indices pointing to the basis arrays integer ( int32 ), intent ( in ) :: channels_omega_values ( number_of_channels ) !! holds all values of \\bar{\\Omega} integer ( int32 ), intent ( in ) :: number_of_nonzero_coupling_matrix_elements !! number of non-zero terms in the sum () for each non-zero element of the coupling matrix integer ( int32 ), intent ( in ) :: number_of_nonzero_coupling_coefficients !! number of all non-zero algberaix coefficients in the whole coupling matrix integer ( int32 ), intent ( in ) :: nonzero_terms_per_element ( number_of_nonzero_coupling_matrix_elements ) !! keeps the number of non-zero terms in the sum (Eq. (6.21)) for !! each non-zero element of W/V integer ( int32 ), intent ( in ) :: nonzero_legendre_indices ( number_of_nonzero_coupling_coefficients ) !! holds the proper indices pointing to l1/l2/lltabs, which !! correspond to the non-vanishing elements of the sum  (Eq. (6.21)) !! for each non-zero element of W/V real ( dp ), intent ( in ) :: nonzero_coupling_coefficients ( number_of_nonzero_coupling_coefficients ) !! holds the values of the non-zero algebraic coefficients integer ( int32 ), intent ( in ) :: nsteps !! number of steps from rmin to rmax integer ( int32 ), intent ( in ) :: jj !! total angular momentum real ( dp ), intent ( inout ) :: log_der_matrix (:,:) !! resulting log-derivative matrix at RMAX !---------------------------------------------------------------------! integer ( int32 ) :: i , ii , ij real ( dp ) :: start , finish , r , step_numerov real ( dp ), allocatable , dimension (:,:) :: umatrix , r_temp , rmatrix , & t_minus , t_center , t_plus , r_center , r_plus , w_tmp , v_tmp real ( dp ), dimension ( number_of_channels , number_of_channels ) :: & cent_mat , v_mat , w_mat , t_mat , u_left , u_right !---------------------------------------------------------------------! CALL CPU_TIME ( start ) !---------------------------------------------------------------------! ! Calculate the centrifugal term !---------------------------------------------------------------------! call cenitrfugal_matrix ( number_of_channels , jj , channels_level_indices , & channels_omega_values , cent_mat ) step_numerov = ( rmax - rmin ) / dble ( nsteps - 1 ) call allocate_2d ( R_temp , number_of_channels , number_of_channels ) !---------------------------------------------------------------------! ! Calculate the PES contribution at rmin !---------------------------------------------------------------------! call pes_contribution ( number_of_channels , jj , rmin , & channels_level_indices , channels_omega_values , & number_of_nonzero_coupling_matrix_elements , & number_of_nonzero_coupling_coefficients , & nonzero_terms_per_element , nonzero_legendre_indices , & nonzero_coupling_coefficients , v_mat ) !---------------------------------------------------------------------! ! Coupling matrix W at rmin !---------------------------------------------------------------------! w_mat = v_mat - ( 1. / rmin ** 2. ) * cent_mat !---------------------------------------------------------------------! ! T-matrix (Eq. 6.23) !---------------------------------------------------------------------! do ii = 1 , number_of_channels do ij = 1 , number_of_channels t_mat ( ii , ij ) = - (( step_numerov ** 2. ) / 1 2. ) * ( w_mat ( ii , ij )) enddo t_mat ( ii , ii ) = - (( step_numerov ** 2. ) / 1 2. ) * & ( 2 * reducedmass * ETOTAL ()) + t_mat ( ii , ii ) enddo !---------------------------------------------------------------------! ! U-matrix (Eq. 6.25) !---------------------------------------------------------------------! do ii = 1 , number_of_channels do ij = 1 , number_of_channels u_left ( ii , ij ) = - t_mat ( ii , ij ) end do u_left ( ii , ii ) = 1.d0 + u_left ( ii , ii ) end do call invert_symmetric_matrix ( u_left ) call fill_symmetric_matrix ( u_left , 'u' ) !---------------------------------------------------------------------! ! R-matrix at rmin + 1 = U-matrix at rmin !---------------------------------------------------------------------! do ii = 1 , number_of_channels do ij = 1 , number_of_channels r_temp ( ii , ij ) = 1 2.d0 * u_left ( ii , ij ) enddo r_temp ( ii , ii ) = r_temp ( ii , ii ) - 1 0.d0 enddo !---------------------------------------------------------------------! ! Continue the propagation to rmax !---------------------------------------------------------------------! do i = 2 , nsteps !------------------------------------------------------------------! ! Coupling matrix W at R !------------------------------------------------------------------! R = rmin + ( i - 1 ) * step_numerov call allocate_2d ( rmatrix , number_of_channels , number_of_channels ) call allocate_2d ( umatrix , number_of_channels , number_of_channels ) call pes_contribution ( number_of_channels , jj , R , & channels_level_indices , channels_omega_values , & number_of_nonzero_coupling_matrix_elements , & number_of_nonzero_coupling_coefficients , & nonzero_terms_per_element , nonzero_legendre_indices , & nonzero_coupling_coefficients , v_mat ) w_mat = v_mat - ( 1. / R ** 2. ) * cent_mat !------------------------------------------------------------------! ! T-matrix at R (6.18) !------------------------------------------------------------------! do ii = 1 , number_of_channels do ij = 1 , number_of_channels t_mat ( ii , ij ) = - (( step_numerov ** 2. ) / 1 2. ) * ( w_mat ( ii , ij )) enddo t_mat ( ii , ii ) = - (( step_numerov ** 2. ) / 1 2. ) * & ( 2 * reducedmass * ETOTAL ()) + t_mat ( ii , ii ) enddo !------------------------------------------------------------------! ! U-matrix at R (6.20) !------------------------------------------------------------------! do ii = 1 , number_of_channels do ij = 1 , number_of_channels u_left ( ii , ij ) = - t_mat ( ii , ij ) end do u_left ( ii , ii ) = 1.d0 + u_left ( ii , ii ) end do call invert_symmetric_matrix ( u_left ) call fill_symmetric_matrix ( u_left , 'u' ) do ii = 1 , number_of_channels do ij = 1 , number_of_channels umatrix ( ii , ij ) = 1 2.d0 * u_left ( ii , ij ) enddo umatrix ( ii , ii ) = umatrix ( ii , ii ) - 1 0.d0 enddo call invert_symmetric_matrix ( r_temp ) call fill_symmetric_matrix ( r_temp , 'u' ) !------------------------------------------------------------------! ! Prepare T at Rmax - 1 and R at Rmax !------------------------------------------------------------------! if ( i == nsteps - 1 ) then call allocate_2d ( v_tmp , number_of_channels , number_of_channels ) call allocate_2d ( w_tmp , number_of_channels , number_of_channels ) call allocate_2d ( t_minus , number_of_channels , number_of_channels ) call pes_contribution ( number_of_channels , jj , r , & channels_level_indices , channels_omega_values , & number_of_nonzero_coupling_matrix_elements , & number_of_nonzero_coupling_coefficients , & nonzero_terms_per_element , nonzero_legendre_indices , & nonzero_coupling_coefficients , v_tmp ) w_tmp = v_tmp - ( 1. / R ** 2. ) * cent_mat do ii = 1 , number_of_channels do ij = 1 , number_of_channels t_minus ( ii , ij ) = - (( step_numerov ** 2. ) / 1 2. ) * & ( w_tmp ( ii , ij )) enddo t_minus ( ii , ii ) = - (( step_numerov ** 2. ) / 1 2. ) * & ( 2 * reducedmass * ETOTAL ()) + t_minus ( ii , ii ) enddo call allocate_2d ( r_center , number_of_channels , number_of_channels ) r_center = umatrix - r_temp !---------------------------------------------------------------! ! Prepare T at Rmax and R max + 1, and R at Rmax + 1 !---------------------------------------------------------------! else if ( i == nsteps ) then call allocate_2d ( v_tmp , number_of_channels , number_of_channels ) call allocate_2d ( w_tmp , number_of_channels , number_of_channels ) call allocate_2d ( t_center , number_of_channels , number_of_channels ) call pes_contribution ( number_of_channels , jj , r , & channels_level_indices , channels_omega_values , & number_of_nonzero_coupling_matrix_elements , & number_of_nonzero_coupling_coefficients , & nonzero_terms_per_element , nonzero_legendre_indices , & nonzero_coupling_coefficients , v_tmp ) w_tmp = v_tmp - ( 1. / R ** 2. ) * cent_mat do ii = 1 , number_of_channels do ij = 1 , number_of_channels t_center ( ii , ij ) = - (( step_numerov ** 2. ) / 1 2. ) * & ( w_tmp ( ii , ij )) enddo t_center ( ii , ii ) = - (( step_numerov ** 2. ) / 1 2. ) * & ( 2 * reducedmass * ETOTAL ()) + t_center ( ii , ii ) enddo call allocate_2d ( r_plus , number_of_channels , number_of_channels ) r_plus = umatrix - r_temp r = rmax + step_numerov call allocate_2d ( v_tmp , number_of_channels , number_of_channels ) call allocate_2d ( t_plus , number_of_channels , number_of_channels ) call allocate_2d ( w_tmp , number_of_channels , number_of_channels ) call pes_contribution ( number_of_channels , jj , r , & channels_level_indices , channels_omega_values , & number_of_nonzero_coupling_matrix_elements , & number_of_nonzero_coupling_coefficients , & nonzero_terms_per_element , nonzero_legendre_indices , & nonzero_coupling_coefficients , v_tmp ) w_tmp = v_tmp - ( 1. / R ** 2. ) * cent_mat do ii = 1 , number_of_channels do ij = 1 , number_of_channels t_plus ( ii , ij ) = - (( step_numerov ** 2. ) / 1 2. ) * & ( w_tmp ( ii , ij )) enddo t_plus ( ii , ii ) = - (( step_numerov ** 2. ) / 1 2. ) * & ( 2 * reducedmass * ETOTAL ()) + t_plus ( ii , ii ) enddo end if !------------------------------------------------------------------! ! R-matrix at R_{n+1} (Eq. 6.28) !------------------------------------------------------------------! rmatrix = umatrix - r_temp call allocate_2d ( r_temp , number_of_channels , number_of_channels ) !------------------------------------------------------------------! ! Move R_{n+1} to R_{n} !------------------------------------------------------------------! r_temp = rmatrix end do CALL CPU_TIME ( finish ) !---------------------------------------------------------------------! ! Eq. (6.29) !---------------------------------------------------------------------! call calculate_log_der_matrix ( step_numerov , number_of_channels , & t_minus , t_center , t_plus , r_center , r_plus , log_der_matrix ) !---------------------------------------------------------------------! if ( prntlvl . ge . 2 ) then call write_message ( \"Numerov propagator took \" // & trim ( adjustl ( float_to_character ( finish - start , \"(E14.8)\" ))) // & \" seconds\" ) endif !---------------------------------------------------------------------! end subroutine numerov","tags":"","loc":"proc/numerov.html"},{"title":"pes_contribution – the SCATTERING code","text":"public  subroutine pes_contribution(number_of_channels, jj, r, channels_level_indices, channels_omega_values, number_of_nonzero_coupling_matrix_elements, number_of_nonzero_coupling_coefficients, nonzero_terms_per_element, nonzero_legendre_indices, nonzero_coupling_coefficients, vmatrix) calculates the contribution from the PES in (X) at given R Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: number_of_channels size of the basis integer(kind=int32), intent(in) :: jj total angular momentum real(kind=dp), intent(in) :: r intermolecular distance integer(kind=int32), intent(in) :: channels_level_indices (number_of_channels) holds the indices pointing to the basis arrays integer(kind=int32), intent(in) :: channels_omega_values (number_of_channels) holds all values of \\bar{\\Omega} integer(kind=int32), intent(in) :: number_of_nonzero_coupling_matrix_elements number of non-zero terms in the sum () for each non-zero element of the coupling matrix integer(kind=int32), intent(in) :: number_of_nonzero_coupling_coefficients number of all non-zero algberaix coefficients in the whole coupling matrix integer(kind=int32), intent(in) :: nonzero_terms_per_element (number_of_nonzero_coupling_matrix_elements) keeps the number of non-zero terms in the sum (Eq. (6.21)) for\neach non-zero element of W/V integer(kind=int32), intent(in) :: nonzero_legendre_indices (number_of_nonzero_coupling_coefficients) holds the proper indices pointing to l1/l2/lltabs, which\ncorrespond to the non-vanishing elements of the sum  (Eq. (6.21))\nfor each non-zero element of W/V real(kind=dp), intent(in) :: nonzero_coupling_coefficients (number_of_nonzero_coupling_coefficients) holds the values of the non-zero algebraic coefficients real(kind=dp), intent(out) :: vmatrix (number_of_channels,number_of_channels) (output) - the PES contribution to the coupling matrix Calls proc~~pes_contribution~~CallsGraph proc~pes_contribution pes_contribution proc~get_radial_coupling_term_value get_radial_coupling_term_value proc~pes_contribution->proc~get_radial_coupling_term_value interface~fill_symmetric_matrix fill_symmetric_matrix proc~pes_contribution->interface~fill_symmetric_matrix proc~ispline ispline proc~get_radial_coupling_term_value->proc~ispline proc~float_to_character float_to_character proc~ispline->proc~float_to_character proc~write_warning write_warning proc~ispline->proc~write_warning proc~write_message write_message proc~write_warning->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~pes_contribution~~CalledByGraph proc~pes_contribution pes_contribution proc~numerov numerov proc~numerov->proc~pes_contribution program~scattering SCATTERING program~scattering->proc~numerov Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables erot ii ij il indvl inonzero_coupling_matrix_elements j1ptmp j1tmp l1 nonzerolam omegaptmp omegatmp pscoeff sumtemp v v1ptmp v1tmp Source Code pes_contribution Variables Type Visibility Attributes Name Initial real(kind=dp), public :: erot integer(kind=int32), public :: ii integer(kind=int32), public :: ij integer(kind=int32), public :: il integer(kind=int32), public :: indvl integer(kind=int32), public :: inonzero_coupling_matrix_elements integer(kind=int32), public :: j1ptmp integer(kind=int32), public :: j1tmp integer(kind=int32), public :: l1 integer(kind=int32), public :: nonzerolam integer(kind=int32), public :: omegaptmp integer(kind=int32), public :: omegatmp real(kind=dp), public :: pscoeff real(kind=dp), public :: sumtemp real(kind=dp), public :: v integer(kind=int32), public :: v1ptmp integer(kind=int32), public :: v1tmp Source Code subroutine pes_contribution ( number_of_channels , jj , r , & channels_level_indices , channels_omega_values , & number_of_nonzero_coupling_matrix_elements , & number_of_nonzero_coupling_coefficients , & nonzero_terms_per_element , nonzero_legendre_indices , & nonzero_coupling_coefficients , vmatrix ) !! calculates the contribution from the PES in (X) at given R !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: number_of_channels !! size of the basis integer ( int32 ), intent ( in ) :: jj !! total angular momentum real ( dp ), intent ( in ) :: r !! intermolecular distance integer ( int32 ), intent ( in ) :: channels_level_indices ( number_of_channels ) !! holds the indices pointing to the basis arrays integer ( int32 ), intent ( in ) :: channels_omega_values ( number_of_channels ) !! holds all values of \\bar{\\Omega} integer ( int32 ), intent ( in ) :: number_of_nonzero_coupling_matrix_elements !! number of non-zero terms in the sum () for each non-zero element of the coupling matrix integer ( int32 ), intent ( in ) :: number_of_nonzero_coupling_coefficients !! number of all non-zero algberaix coefficients in the whole coupling matrix integer ( int32 ), intent ( in ) :: nonzero_terms_per_element ( number_of_nonzero_coupling_matrix_elements ) !! keeps the number of non-zero terms in the sum (Eq. (6.21)) for !! each non-zero element of W/V integer ( int32 ), intent ( in ) :: nonzero_legendre_indices ( number_of_nonzero_coupling_coefficients ) !! holds the proper indices pointing to l1/l2/lltabs, which !! correspond to the non-vanishing elements of the sum  (Eq. (6.21)) !! for each non-zero element of W/V real ( dp ), intent ( in ) :: nonzero_coupling_coefficients ( number_of_nonzero_coupling_coefficients ) !! holds the values of the non-zero algebraic coefficients real ( dp ), intent ( out ) :: vmatrix ( number_of_channels , number_of_channels ) !! (output) - the PES contribution to the coupling matrix !---------------------------------------------------------------------! integer ( int32 ) :: indvl , inonzero_coupling_matrix_elements , omegatmp , omegaptmp , l1 , & nonzerolam , v1tmp , j1tmp , v1ptmp , j1ptmp , ii , ij , il real ( dp ) :: erot , sumtemp , pscoeff , v !---------------------------------------------------------------------! vmatrix = 0 indvl = 0 inonzero_coupling_matrix_elements = 0 !---------------------------------------------------------------------! do ii = 1 , number_of_channels v1tmp = v1array ( channels_level_indices ( ii )) j1tmp = j1array ( channels_level_indices ( ii )) omegatmp = channels_omega_values ( ii ) erot = elevel ( channels_level_indices ( ii )) do ij = 1 , ii v1ptmp = v1array ( channels_level_indices ( ij )) j1ptmp = j1array ( channels_level_indices ( ij )) omegaptmp = channels_omega_values ( ij ) if ( omegatmp . ne . omegaptmp ) cycle inonzero_coupling_matrix_elements = inonzero_coupling_matrix_elements + 1 nonzerolam = nonzero_terms_per_element ( inonzero_coupling_matrix_elements ) sumtemp = 0.d0 do il = 1 , nonzerolam indvl = indvl + 1 l1 = l1tab ( nonzero_legendre_indices ( indvl )) pscoeff = nonzero_coupling_coefficients ( indvl ) call get_radial_coupling_term_value ( r , l1 , v1tmp , j1tmp , v1ptmp , j1ptmp , v ) sumtemp = sumtemp + pscoeff * v enddo vmatrix ( ii , ij ) = - 2 * reducedmass * sumtemp enddo vmatrix ( ii , ii ) = vmatrix ( ii , ii ) - ( 2 * reducedmass * erot ) enddo !---------------------------------------------------------------------! call fill_symmetric_matrix ( vmatrix , 'u' ) !---------------------------------------------------------------------! end subroutine pes_contribution","tags":"","loc":"proc/pes_contribution.html"},{"title":"float_to_character – the SCATTERING code","text":"public  function float_to_character(f, format_string) result(res) Converts a floating-point number to a character string. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: f input floating-point number character(len=*), intent(in), optional :: format_string Optional format string. Return Value character(len=64) Output character string. Called by proc~~float_to_character~~CalledByGraph proc~float_to_character float_to_character program~scattering SCATTERING program~scattering->proc~float_to_character proc~numerov numerov program~scattering->proc~numerov proc~print_largest_partial_xs print_largest_partial_xs program~scattering->proc~print_largest_partial_xs proc~read_input_file read_input_file program~scattering->proc~read_input_file proc~ispline ispline proc~ispline->proc~float_to_character proc~input_summary input_summary proc~input_summary->proc~float_to_character proc~numerov->proc~float_to_character proc~pes_contribution pes_contribution proc~numerov->proc~pes_contribution proc~print_largest_partial_xs->proc~float_to_character proc~get_radial_coupling_term_value get_radial_coupling_term_value proc~get_radial_coupling_term_value->proc~ispline proc~read_input_file->proc~input_summary proc~pes_contribution->proc~get_radial_coupling_term_value Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code float_to_character Source Code function float_to_character ( f , format_string ) result ( res ) !! Converts a floating-point number to a character string. !---------------------------------------------------------------------! real ( dp ), intent ( in ) :: f !! input floating-point number character ( len =* ), intent ( in ), optional :: format_string !! Optional format string. character ( len = 64 ) :: res !! Output character string. !---------------------------------------------------------------------! character ( len = 32 ) :: default_format , user_format !---------------------------------------------------------------------! ! Default format: 6 decimal places !---------------------------------------------------------------------! default_format = '(F0.6)' !---------------------------------------------------------------------! if ( present ( format_string )) then user_format = trim ( format_string ) else user_format = default_format endif !---------------------------------------------------------------------! write ( res , user_format ) f res = adjustl ( res ) !---------------------------------------------------------------------! end function float_to_character","tags":"","loc":"proc/float_to_character.html"},{"title":"integer_to_character – the SCATTERING code","text":"public  function integer_to_character(i) result(res) transfers integer to a character Arguments Type Intent Optional Attributes Name integer, intent(in) :: i input integer Return Value character(len=32) output character Called by proc~~integer_to_character~~CalledByGraph proc~integer_to_character integer_to_character proc~spline spline proc~spline->proc~integer_to_character proc~print_coupling_matrix_elements_summary print_coupling_matrix_elements_summary proc~print_coupling_matrix_elements_summary->proc~integer_to_character program~scattering SCATTERING program~scattering->proc~integer_to_character program~scattering->proc~print_coupling_matrix_elements_summary proc~reduce_radial_coupling_terms reduce_radial_coupling_terms program~scattering->proc~reduce_radial_coupling_terms proc~file_io_status file_io_status program~scattering->proc~file_io_status proc~print_largest_partial_xs print_largest_partial_xs program~scattering->proc~print_largest_partial_xs proc~interpolate_radial_coupling_terms interpolate_radial_coupling_terms program~scattering->proc~interpolate_radial_coupling_terms proc~calculate_k_matrix calculate_k_matrix program~scattering->proc~calculate_k_matrix proc~read_input_file read_input_file program~scattering->proc~read_input_file proc~read_radial_coupling_terms read_radial_coupling_terms program~scattering->proc~read_radial_coupling_terms proc~reduce_radial_coupling_terms->proc~integer_to_character proc~input_summary input_summary proc~input_summary->proc~integer_to_character proc~file_io_status->proc~integer_to_character proc~input_check input_check proc~input_check->proc~integer_to_character proc~modified_bessel_k_ratio modified_bessel_k_ratio proc~modified_bessel_k_ratio->proc~integer_to_character proc~riccati_bessel_j riccati_bessel_j proc~riccati_bessel_j->proc~integer_to_character proc~riccati_bessel_y riccati_bessel_y proc~riccati_bessel_y->proc~integer_to_character proc~print_largest_partial_xs->proc~integer_to_character proc~interpolate_radial_coupling_terms->proc~spline proc~calculate_k_matrix->proc~modified_bessel_k_ratio proc~calculate_k_matrix->proc~riccati_bessel_j proc~calculate_k_matrix->proc~riccati_bessel_y proc~read_input_file->proc~input_summary proc~read_input_file->proc~file_io_status proc~read_input_file->proc~input_check proc~read_radial_coupling_terms->proc~file_io_status Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code integer_to_character Source Code function integer_to_character ( i ) result ( res ) !! transfers integer to a character !---------------------------------------------------------------------! integer , intent ( in ) :: i !! input integer character ( len = 32 ) :: res !! output character !---------------------------------------------------------------------! write ( res , '(i0)' ) i res = adjustl ( res ) !---------------------------------------------------------------------! end function integer_to_character","tags":"","loc":"proc/integer_to_character.html"},{"title":"to_lowercase – the SCATTERING code","text":"public  function to_lowercase(str) result(low_str) forces lowercase on given string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str input string Return Value character(len=len) output (lowercase) string Contents Source Code to_lowercase Source Code function to_lowercase ( str ) result ( low_str ) !! forces lowercase on given string !---------------------------------------------------------------------! character ( len =* ), intent ( in ) :: str !! input string character ( len = len ( str )) :: low_str !! output (lowercase) string !---------------------------------------------------------------------! integer ( int32 ) :: i !---------------------------------------------------------------------! do i = 1 , len ( str ) low_str ( i : i ) = char_to_lowercase ( str ( i : i )) enddo !---------------------------------------------------------------------! end function to_lowercase","tags":"","loc":"proc/to_lowercase.html"},{"title":"alloc_status – the SCATTERING code","text":"public  subroutine alloc_status(istat_, message_, op_, unit_) check the status after allocation Arguments Type Intent Optional Attributes Name integer(kind=int32) :: istat_ result of stat=istat in (de)allocate character(len=*), intent(in) :: message_ a message to be written character(len=1), intent(in) :: op_ 'a' for allocation, 'd' for deallocation integer(kind=int32), intent(in), optional :: unit_ optional, unit where the message will be written Calls proc~~alloc_status~~CallsGraph proc~alloc_status alloc_status proc~write_error write_error proc~alloc_status->proc~write_error proc~write_message write_message proc~write_error->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code alloc_status Source Code subroutine alloc_status ( istat_ , message_ , op_ , unit_ ) !! check the status after allocation !---------------------------------------------------------------------! integer ( int32 ) :: istat_ !! result of stat=istat in (de)allocate character ( len = * ), intent ( in ) :: message_ !! a message to be written character ( len = 1 ), intent ( in ) :: op_ !! 'a' for allocation, 'd' for deallocation integer ( int32 ), optional , intent ( in ) :: unit_ !! optional, unit where the message will be written !---------------------------------------------------------------------! character ( len = :), allocatable :: add_prefix_ !---------------------------------------------------------------------! add_prefix_ = '' if ( istat_ /= 0 ) then select case ( op_ ) case ( 'a' ) add_prefix_ = 'memory allocation: ' // trim ( message_ ) case ( 'd' ) add_prefix_ = 'memory deallocation: ' // trim ( message_ ) case default call write_error & ( 'Incorrect op_ argument in alloc_status subroutine (' & // trim ( op_ ) // ')' ) end select call write_error ( add_prefix_ , unit_ ) endif !---------------------------------------------------------------------! end subroutine alloc_status","tags":"","loc":"proc/alloc_status.html"},{"title":"file_io_status – the SCATTERING code","text":"public  subroutine file_io_status(istat_, iomsg_, channel_, op_, unit_) check the status during various io operations on files Arguments Type Intent Optional Attributes Name integer(kind=int32) :: istat_ result of iostat in open/read/write/close character(len=*), intent(in) :: iomsg_ result of iomsg in open/read/write/close integer(kind=int32), intent(in) :: channel_ name of the file character(len=1), intent(in) :: op_ 'o' for opening of the file, 'r' for reading, 'w' for writing,\n'c' for closing integer(kind=int32), intent(in), optional :: unit_ optional, unit where the message will be written Calls proc~~file_io_status~~CallsGraph proc~file_io_status file_io_status proc~integer_to_character integer_to_character proc~file_io_status->proc~integer_to_character proc~write_error write_error proc~file_io_status->proc~write_error proc~write_message write_message proc~write_error->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~file_io_status~~CalledByGraph proc~file_io_status file_io_status proc~read_radial_coupling_terms read_radial_coupling_terms proc~read_radial_coupling_terms->proc~file_io_status program~scattering SCATTERING program~scattering->proc~file_io_status program~scattering->proc~read_radial_coupling_terms proc~read_input_file read_input_file program~scattering->proc~read_input_file proc~read_input_file->proc~file_io_status Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code file_io_status Source Code subroutine file_io_status ( istat_ , iomsg_ , channel_ , op_ , unit_ ) !! check the status during various io operations on files !---------------------------------------------------------------------! integer ( int32 ) :: istat_ !! result of iostat in open/read/write/close character ( len = * ), intent ( in ) :: iomsg_ !! result of iomsg in open/read/write/close integer ( int32 ), intent ( in ) :: channel_ !! name of the file character ( len = 1 ), intent ( in ) :: op_ !! 'o' for opening of the file, 'r' for reading, 'w' for writing, !! 'c' for closing integer ( int32 ), optional , intent ( in ) :: unit_ !! optional, unit where the message will be written !---------------------------------------------------------------------! character ( len = :), allocatable :: add_prefix_ !---------------------------------------------------------------------! add_prefix_ = '' if ( istat_ /= 0 ) then select case ( op_ ) case ( 'o' ) add_prefix_ = 'opening file on channel: ' // & integer_to_character ( channel_ ) case ( 'r' ) add_prefix_ = 'reading file on channel: ' // & integer_to_character ( channel_ ) case ( 'w' ) add_prefix_ = 'writing to file on channel: ' // & integer_to_character ( channel_ ) case ( 'c' ) add_prefix_ = 'closing file on channel: ' // & integer_to_character ( channel_ ) case default call write_error & ( 'Incorrect op_ argument in file_io_status subroutine (' & // trim ( op_ ) // ')' ) end select call write_error ( trim ( add_prefix_ ) // \" with message: \" // iomsg_ , unit_ ) endif !---------------------------------------------------------------------! end subroutine file_io_status","tags":"","loc":"proc/file_io_status.html"},{"title":"time_count_summary – the SCATTERING code","text":"public  subroutine time_count_summary(start_, stop_, time_, message_) print the message about the time it took to complete a single task Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: start_ initial time real(kind=dp), intent(in) :: stop_ final time real(kind=dp), intent(out) :: time_ stop_ - start_ character(len=*), intent(in), optional :: message_ (optional) a message to print instead of a default\n\"Completed in ... s\" Calls proc~~time_count_summary~~CallsGraph proc~time_count_summary time_count_summary proc~write_message write_message proc~time_count_summary->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~time_count_summary~~CalledByGraph proc~time_count_summary time_count_summary proc~crosssection CROSSSECTION proc~crosssection->proc~time_count_summary program~scattering SCATTERING program~scattering->proc~time_count_summary program~scattering->proc~crosssection Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code time_count_summary Source Code subroutine time_count_summary ( start_ , stop_ , time_ , message_ ) !! print the message about the time it took to complete a single task !---------------------------------------------------------------------! real ( dp ), intent ( in ) :: start_ !! initial time real ( dp ), intent ( in ) :: stop_ !! final time real ( dp ), intent ( out ) :: time_ !! stop_ - start_ character ( len = * ), optional , intent ( in ) :: message_ !! (optional) a message to print instead of a default !! \"Completed in ... s\" !---------------------------------------------------------------------! character ( len = 12 ) :: default_message = 'Completed in' character ( len = 100 ) :: time_msg !---------------------------------------------------------------------! time_ = stop_ - start_ if ( present ( message_ )) then write ( time_msg , fmt = '(a,x,a,es11.4,x,a)' ) & '--' , trim ( message_ ), time_ , 's' else write ( time_msg , fmt = '(a,x,a,es11.4,x,a)' ) & '--' , default_message , time_ , 's' endif call write_message ( time_msg ) !---------------------------------------------------------------------! end subroutine time_count_summary","tags":"","loc":"proc/time_count_summary.html"},{"title":"write_error – the SCATTERING code","text":"public  subroutine write_error(message_, unit_) writes an error message on a chosen unit Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message_ a message to be written integer(kind=int32), intent(in), optional :: unit_ optional, unit where the message will be written Calls proc~~write_error~~CallsGraph proc~write_error write_error proc~write_message write_message proc~write_error->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~write_error~~CalledByGraph proc~write_error write_error proc~spline spline proc~spline->proc~write_error proc~set_space_fixed_channels set_space_fixed_channels proc~set_space_fixed_channels->proc~write_error proc~wavenumber_from_energy wavenumber_from_energy proc~wavenumber_from_energy->proc~write_error proc~write_header write_header proc~write_header->proc~write_error proc~file_io_status file_io_status proc~file_io_status->proc~write_error proc~input_check input_check proc~input_check->proc~write_error proc~alloc_status alloc_status proc~alloc_status->proc~write_error program~scattering SCATTERING program~scattering->proc~set_space_fixed_channels program~scattering->proc~write_header program~scattering->proc~file_io_status proc~read_radial_coupling_terms read_radial_coupling_terms program~scattering->proc~read_radial_coupling_terms proc~interpolate_radial_coupling_terms interpolate_radial_coupling_terms program~scattering->proc~interpolate_radial_coupling_terms proc~print_channels print_channels program~scattering->proc~print_channels proc~save_open_basis_levels save_open_basis_levels program~scattering->proc~save_open_basis_levels proc~calculate_k_matrix calculate_k_matrix program~scattering->proc~calculate_k_matrix proc~calculate_largest_wavenumber calculate_largest_wavenumber program~scattering->proc~calculate_largest_wavenumber proc~unitarity_check unitarity_check program~scattering->proc~unitarity_check proc~read_input_file read_input_file program~scattering->proc~read_input_file proc~read_radial_coupling_terms->proc~file_io_status proc~interpolate_radial_coupling_terms->proc~spline proc~print_channels->proc~wavenumber_from_energy proc~save_open_basis_levels->proc~wavenumber_from_energy proc~calculate_k_matrix->proc~wavenumber_from_energy proc~calculate_largest_wavenumber->proc~wavenumber_from_energy proc~unitarity_check->proc~write_header proc~read_input_file->proc~file_io_status proc~read_input_file->proc~input_check Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_error Source Code subroutine write_error ( message_ , unit_ ) !! writes an error message on a chosen unit !---------------------------------------------------------------------! character ( len = * ), intent ( in ) :: message_ !! a message to be written integer ( int32 ), optional , intent ( in ) :: unit_ !! optional, unit where the message will be written !---------------------------------------------------------------------! call write_message ( 'Error: ' // trim ( message_ ), unit_ ) stop !---------------------------------------------------------------------! end subroutine write_error","tags":"","loc":"proc/write_error.html"},{"title":"write_header – the SCATTERING code","text":"public  subroutine write_header(header_type, opt_integer_) writes headers on screen Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: header_type specifies the type of the header: 'main', 'input_read',\n'input_check', 'input_summary', 'initialization', 'check_norm',\n'save_basis', 'save_pes', 'radial_terms', 'save_radial_terms',\n'reconstruction' integer(kind=int32), intent(in), optional :: opt_integer_ optional integer used in case \"block\" to pass jtot value Calls proc~~write_header~~CallsGraph proc~write_header write_header proc~write_message write_message proc~write_header->proc~write_message proc~write_error write_error proc~write_header->proc~write_error interface~incorrect_value incorrect_value proc~write_header->interface~incorrect_value proc~write_error->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~write_header~~CalledByGraph proc~write_header write_header proc~unitarity_check unitarity_check proc~unitarity_check->proc~write_header program~scattering SCATTERING program~scattering->proc~write_header program~scattering->proc~unitarity_check Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_header Source Code subroutine write_header ( header_type , opt_integer_ ) !! writes headers on screen character ( len = * ), intent ( in ) :: header_type !! specifies the type of the header: 'main', 'input_read', !! 'input_check', 'input_summary', 'initialization', 'check_norm', !! 'save_basis', 'save_pes', 'radial_terms', 'save_radial_terms', !! 'reconstruction' integer ( int32 ), optional , intent ( in ) :: opt_integer_ !! optional integer used in case \"block\" to pass jtot value !---------------------------------------------------------------------! character ( len = 100 ) :: header_star , header_str character ( len = 10 ) :: tmp_str_ integer ( int32 ) :: len_str_ !---------------------------------------------------------------------! select case ( trim ( header_type )) case ( 'main' ) write ( header_star , fmt = \"(a90)\" ) repeat ( \"*\" , 90 ) call write_message ( header_star ) call write_message ( header_star ) write ( header_str , fmt = '(a,25x,a43,20x,a)' ) & '*' , 'BIGOS quantum scattering package, vs. 0.00.' , '*' call write_message ( header_str ) write ( header_str , fmt = '(a,36x,a19,33x,a)' ) & '*' , 'the SCATTERING code' , '*' call write_message ( header_str ) write ( header_str , fmt = '(a,29x,a31,28x,a)' ) & '*' , 'adjusted for H2-He calculations' , '*' call write_message ( header_str ) write ( header_str , fmt = '(a,37x,a17,34x,a)' ) & '*' , 'by Hubert Jozwiak' , '*' call write_message ( header_str ) write ( header_str , fmt = '(a,40x,a11,37x,a)' ) & '*' , '20/12/2023 ' , '*' call write_message ( header_str ) call write_message ( header_star ) case ( 'block' ) call write_message ( repeat ( '*' , 90 )) if ( present ( opt_integer_ )) then write ( tmp_str_ , \"(i10)\" ) opt_integer_ len_str_ = len_trim ( tmp_str_ ) write ( * , '(\"*\", A, \"JTOT = \", A, A, \"*\")' ) & repeat ( ' ' , 40 - len_str_ ), tmp_str_ , repeat ( ' ' , 41 ) call write_message ( repeat ( '*' , 90 )) else call write_error ( \"**** JTOT value not provided in \" // & \"write_header_block ****\" ) endif case ( 'unitarity' ) call write_message ( repeat ( \" \" , 43 ) // \"***\" ) call write_message ( \"Check of the unitarity of the S-matrix:\" ) call write_message ( repeat ( \" \" , 34 ) // \"*** S-matrix elements: ***\" ) call write_message ( \"   ROW   COL\" // repeat ( \" \" , 15 ) // \"S**2\" // & repeat ( \" \" , 17 ) // \"RE (S)\" // repeat ( \" \" , 17 ) // \"IM (S)\" ) case default call incorrect_value ( 'header_type (write_header)' , header_type ) end select !---------------------------------------------------------------------! end subroutine write_header","tags":"","loc":"proc/write_header.html"},{"title":"write_message – the SCATTERING code","text":"public  subroutine write_message(message_, unit_) writes a message on a chosen unit Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message_ a message to be written integer(kind=int32), intent(in), optional :: unit_ optional, unit where the message will be written Called by proc~~write_message~~CalledByGraph proc~write_message write_message proc~write_warning write_warning proc~write_warning->proc~write_message proc~print_coupling_matrix_elements_summary print_coupling_matrix_elements_summary proc~print_coupling_matrix_elements_summary->proc~write_message program~scattering SCATTERING program~scattering->proc~write_message program~scattering->proc~print_coupling_matrix_elements_summary proc~reduce_radial_coupling_terms reduce_radial_coupling_terms program~scattering->proc~reduce_radial_coupling_terms proc~write_header write_header program~scattering->proc~write_header proc~time_count_summary time_count_summary program~scattering->proc~time_count_summary proc~print_largest_partial_xs print_largest_partial_xs program~scattering->proc~print_largest_partial_xs proc~numerov numerov program~scattering->proc~numerov proc~print_channels print_channels program~scattering->proc~print_channels proc~set_space_fixed_channels set_space_fixed_channels program~scattering->proc~set_space_fixed_channels proc~file_io_status file_io_status program~scattering->proc~file_io_status proc~read_input_file read_input_file program~scattering->proc~read_input_file proc~unitarity_check unitarity_check program~scattering->proc~unitarity_check proc~crosssection CROSSSECTION program~scattering->proc~crosssection proc~read_radial_coupling_terms read_radial_coupling_terms program~scattering->proc~read_radial_coupling_terms proc~interpolate_radial_coupling_terms interpolate_radial_coupling_terms program~scattering->proc~interpolate_radial_coupling_terms proc~save_open_basis_levels save_open_basis_levels program~scattering->proc~save_open_basis_levels proc~calculate_k_matrix calculate_k_matrix program~scattering->proc~calculate_k_matrix proc~calculate_largest_wavenumber calculate_largest_wavenumber program~scattering->proc~calculate_largest_wavenumber proc~reduce_radial_coupling_terms->proc~write_message proc~write_error write_error proc~write_error->proc~write_message proc~input_summary input_summary proc~input_summary->proc~write_message proc~input_check input_check proc~input_check->proc~write_message proc~input_check->proc~write_error proc~handle_unitarity_output_message handle_unitarity_output_message proc~handle_unitarity_output_message->proc~write_message proc~handle_unitarity_output_message->proc~write_warning proc~write_header->proc~write_message proc~write_header->proc~write_error proc~time_count_summary->proc~write_message proc~print_largest_partial_xs->proc~write_message proc~numerov->proc~write_message proc~pes_contribution pes_contribution proc~numerov->proc~pes_contribution proc~print_channels->proc~write_message proc~wavenumber_from_energy wavenumber_from_energy proc~print_channels->proc~wavenumber_from_energy proc~spline spline proc~spline->proc~write_error proc~wavenumber_from_energy->proc~write_error proc~set_space_fixed_channels->proc~write_error proc~ispline ispline proc~ispline->proc~write_warning proc~modified_bessel_k_ratio modified_bessel_k_ratio proc~modified_bessel_k_ratio->proc~write_warning proc~riccati_bessel_y riccati_bessel_y proc~riccati_bessel_y->proc~write_warning proc~riccati_bessel_j riccati_bessel_j proc~riccati_bessel_j->proc~write_warning proc~file_io_status->proc~write_error proc~alloc_status alloc_status proc~alloc_status->proc~write_error proc~read_input_file->proc~input_summary proc~read_input_file->proc~input_check proc~read_input_file->proc~file_io_status proc~unitarity_check->proc~handle_unitarity_output_message proc~unitarity_check->proc~write_header proc~crosssection->proc~time_count_summary proc~read_radial_coupling_terms->proc~file_io_status proc~interpolate_radial_coupling_terms->proc~spline proc~save_open_basis_levels->proc~wavenumber_from_energy proc~get_radial_coupling_term_value get_radial_coupling_term_value proc~get_radial_coupling_term_value->proc~ispline proc~calculate_k_matrix->proc~wavenumber_from_energy proc~calculate_k_matrix->proc~modified_bessel_k_ratio proc~calculate_k_matrix->proc~riccati_bessel_y proc~calculate_k_matrix->proc~riccati_bessel_j proc~calculate_largest_wavenumber->proc~wavenumber_from_energy proc~pes_contribution->proc~get_radial_coupling_term_value Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_message Source Code subroutine write_message ( message_ , unit_ ) !! writes a message on a chosen unit !---------------------------------------------------------------------! character ( len = * ), intent ( in ) :: message_ !! a message to be written integer ( int32 ), optional , intent ( in ) :: unit_ !! optional, unit where the message will be written !---------------------------------------------------------------------! if ( present ( unit_ )) then write ( unit_ , '(a)' ) trim ( message_ ) else write ( output_unit , '(a)' ) trim ( message_ ) endif !---------------------------------------------------------------------! end subroutine write_message","tags":"","loc":"proc/write_message.html"},{"title":"write_warning – the SCATTERING code","text":"public  subroutine write_warning(message_, unit_) writes a warning message on a chosen unit Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message_ a message to be written integer(kind=int32), intent(in), optional :: unit_ optional, unit where the message will be written Calls proc~~write_warning~~CallsGraph proc~write_warning write_warning proc~write_message write_message proc~write_warning->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~write_warning~~CalledByGraph proc~write_warning write_warning proc~ispline ispline proc~ispline->proc~write_warning proc~riccati_bessel_j riccati_bessel_j proc~riccati_bessel_j->proc~write_warning proc~handle_unitarity_output_message handle_unitarity_output_message proc~handle_unitarity_output_message->proc~write_warning proc~riccati_bessel_y riccati_bessel_y proc~riccati_bessel_y->proc~write_warning proc~modified_bessel_k_ratio modified_bessel_k_ratio proc~modified_bessel_k_ratio->proc~write_warning proc~get_radial_coupling_term_value get_radial_coupling_term_value proc~get_radial_coupling_term_value->proc~ispline proc~calculate_k_matrix calculate_k_matrix proc~calculate_k_matrix->proc~riccati_bessel_j proc~calculate_k_matrix->proc~riccati_bessel_y proc~calculate_k_matrix->proc~modified_bessel_k_ratio proc~unitarity_check unitarity_check proc~unitarity_check->proc~handle_unitarity_output_message proc~pes_contribution pes_contribution proc~pes_contribution->proc~get_radial_coupling_term_value program~scattering SCATTERING program~scattering->proc~calculate_k_matrix program~scattering->proc~unitarity_check proc~numerov numerov program~scattering->proc~numerov proc~numerov->proc~pes_contribution Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_warning Source Code subroutine write_warning ( message_ , unit_ ) !! writes a warning message on a chosen unit !---------------------------------------------------------------------! character ( len = * ), intent ( in ) :: message_ !! a message to be written integer ( int32 ), optional , intent ( in ) :: unit_ !! optional, unit where the message will be written !---------------------------------------------------------------------! call write_message ( 'Warning: ' // trim ( message_ ), unit_ ) !---------------------------------------------------------------------! end subroutine write_warning","tags":"","loc":"proc/write_warning.html"},{"title":"incorrect_value – the SCATTERING code","text":"public interface incorrect_value interface for the following message: incorrect value encountered:\n  variable_name = variable_value Called by interface~~incorrect_value~~CalledByGraph interface~incorrect_value incorrect_value proc~input_check input_check proc~input_check->interface~incorrect_value proc~write_header write_header proc~write_header->interface~incorrect_value proc~read_input_file read_input_file proc~read_input_file->proc~input_check program~scattering SCATTERING program~scattering->proc~write_header program~scattering->proc~read_input_file proc~unitarity_check unitarity_check program~scattering->proc~unitarity_check proc~unitarity_check->proc~write_header Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures incorrect_value_ch incorrect_value_int32 incorrect_value_sp incorrect_value_dp Module Procedures private  subroutine incorrect_value_ch(name_, value_, unit_) incorrect value encountered:\n  variable_name = variable_value Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name_ name of the variable character(len=*), intent(in) :: value_ value of the variable integer(kind=int32), intent(in), optional :: unit_ optional, unit where the message will be written private  subroutine incorrect_value_int32(name_, value_, unit_) incorrect value encountered:\n  variable_name = variable_value Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name_ name of the variable integer(kind=int32), intent(in) :: value_ value of the variable integer(kind=int32), intent(in), optional :: unit_ optional, unit where the message will be written private  subroutine incorrect_value_sp(name_, value_, unit_) incorrect value encountered:\n  variable_name = variable_value Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name_ name of the variable real(kind=sp), intent(in) :: value_ value of the variable integer(kind=int32), intent(in), optional :: unit_ optional, unit where the message will be written private  subroutine incorrect_value_dp(name_, value_, unit_) incorrect value encountered:\n  variable_name = variable_value Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name_ name of the variable real(kind=dp), intent(in) :: value_ value of the variable integer(kind=int32), intent(in), optional :: unit_ optional, unit where the message will be written","tags":"","loc":"interface/incorrect_value.html"},{"title":"calculate_largest_wavenumber – the SCATTERING code","text":"public  function calculate_largest_wavenumber(channels_level_indices) result(largest_wavenumber_) Calculates the largest wave number in the block;\ncalled only if there are any open channels Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: channels_level_indices (:) holds the indices pointing to the basis arrays Return Value real(kind=dp) (output) the largest wave number (wavmax) in the block Calls proc~~calculate_largest_wavenumber~~CallsGraph proc~calculate_largest_wavenumber calculate_largest_wavenumber proc~is_open is_open proc~calculate_largest_wavenumber->proc~is_open proc~wavenumber_from_energy wavenumber_from_energy proc~calculate_largest_wavenumber->proc~wavenumber_from_energy proc~etotal ETOTAL proc~is_open->proc~etotal proc~wavenumber_from_energy->proc~etotal proc~write_error write_error proc~wavenumber_from_energy->proc~write_error proc~write_message write_message proc~write_error->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~calculate_largest_wavenumber~~CalledByGraph proc~calculate_largest_wavenumber calculate_largest_wavenumber program~scattering SCATTERING program~scattering->proc~calculate_largest_wavenumber Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code calculate_largest_wavenumber Source Code function calculate_largest_wavenumber ( channels_level_indices ) result ( largest_wavenumber_ ) !! Calculates the largest wave number in the block; !! called only if there are any open channels !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: channels_level_indices (:) !! holds the indices pointing to the basis arrays real ( dp ) :: largest_wavenumber_ !! (output) the largest wave number (wavmax) in the block !---------------------------------------------------------------------! integer ( int32 ) :: channel_index_ real ( dp ) :: wavenumber_ !---------------------------------------------------------------------! wavenumber_ = 0.0_dp !---------------------------------------------------------------------! do channel_index_ = 1 , size ( channels_level_indices ) if ( is_open ( elevel ( channels_level_indices ( channel_index_ )))) then wavenumber_ = wavenumber_from_energy ( elevel ( channels_level_indices ( channel_index_ ))) largest_wavenumber_ = max ( largest_wavenumber_ , wavenumber_ ) endif enddo !---------------------------------------------------------------------! end function calculate_largest_wavenumber","tags":"","loc":"proc/calculate_largest_wavenumber.html"},{"title":"count_open_channels_in_block – the SCATTERING code","text":"public  function count_open_channels_in_block(channels_level_indices) result(number_of_open_channels_) counts the energetically accessible channels in the given block Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: channels_level_indices (:) holds the indices pointing to the basis arrays Return Value integer(kind=int32) (output) number of open channels Calls proc~~count_open_channels_in_block~~CallsGraph proc~count_open_channels_in_block count_open_channels_in_block proc~is_open is_open proc~count_open_channels_in_block->proc~is_open proc~etotal ETOTAL proc~is_open->proc~etotal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~count_open_channels_in_block~~CalledByGraph proc~count_open_channels_in_block count_open_channels_in_block program~scattering SCATTERING program~scattering->proc~count_open_channels_in_block Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code count_open_channels_in_block Source Code function count_open_channels_in_block ( channels_level_indices ) & result ( number_of_open_channels_ ) !! counts the energetically accessible channels in the given block !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: channels_level_indices (:) !! holds the indices pointing to the basis arrays integer ( int32 ) :: number_of_open_channels_ !! (output) number of open channels !---------------------------------------------------------------------! integer ( int32 ) :: channel_index_ !---------------------------------------------------------------------! number_of_open_channels_ = 0 do channel_index_ = 1 , size ( channels_level_indices ) if ( is_open ( elevel ( channels_level_indices ( channel_index_ )))) then number_of_open_channels_ = number_of_open_channels_ + 1 endif enddo !---------------------------------------------------------------------! end function count_open_channels_in_block","tags":"","loc":"proc/count_open_channels_in_block.html"},{"title":"print_channels – the SCATTERING code","text":"public  subroutine print_channels(parity_exponent_, channels_level_indices, channels_omega_values) prints information about body-fixed channels on screen Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: parity_exponent_ parity exponent of the block (0 if p = +1, 1 if p = -1) integer(kind=int32), intent(inout) :: channels_level_indices (:) holds the indices pointing to the basis arrays integer(kind=int32), intent(inout) :: channels_omega_values (:) holds all values of \\bar{\\Omega} Calls proc~~print_channels~~CallsGraph proc~print_channels print_channels proc~write_message write_message proc~print_channels->proc~write_message proc~wavenumber_from_energy wavenumber_from_energy proc~print_channels->proc~wavenumber_from_energy proc~is_open is_open proc~print_channels->proc~is_open proc~etotal ETOTAL proc~wavenumber_from_energy->proc~etotal proc~write_error write_error proc~wavenumber_from_energy->proc~write_error proc~is_open->proc~etotal proc~write_error->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~print_channels~~CalledByGraph proc~print_channels print_channels program~scattering SCATTERING program~scattering->proc~print_channels Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code print_channels Source Code subroutine print_channels ( parity_exponent_ , channels_level_indices , & channels_omega_values ) !! prints information about body-fixed channels on screen !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: parity_exponent_ !! parity exponent of the block (0 if p = +1, 1 if p = -1) integer ( int32 ), intent ( inout ) :: channels_level_indices (:) !! holds the indices pointing to the basis arrays integer ( int32 ), intent ( inout ) :: channels_omega_values (:) !! holds all values of \\bar{\\Omega} !---------------------------------------------------------------------! integer ( int32 ) :: channel_index_ , v_ , j_ , omega_ , parity_ real ( dp ) :: internal_energy_ , wavenumber_ !---------------------------------------------------------------------! call write_message ( \"  v1      j1     omega      p\" // repeat ( \" \" , 10 ) & // \"E_vj\" // repeat ( \" \" , 16 ) // \"wv\" ) !---------------------------------------------------------------------! do channel_index_ = 1 , size ( channels_level_indices ) v_ = v1array ( channels_level_indices ( channel_index_ )) j_ = j1array ( channels_level_indices ( channel_index_ )) omega_ = channels_omega_values ( channel_index_ ) parity_ = ( - 1 ) ** parity_exponent_ internal_energy_ = elevel ( channels_level_indices ( channel_index_ )) !------------------------------------------------------------------! ! format for open channels: !------------------------------------------------------------------! if ( is_open ( internal_energy_ )) then wavenumber_ = wavenumber_from_energy ( internal_energy_ ) call write_channel_line ( v_ , j_ , omega_ , parity_ , & internal_energy_ , wavenumber_ ) !------------------------------------------------------------------! ! format for closed channels: !------------------------------------------------------------------! else call write_channel_line ( v_ , j_ , omega_ , parity_ , internal_energy_ ) endif !------------------------------------------------------------------! enddo !---------------------------------------------------------------------! end subroutine print_channels","tags":"","loc":"proc/print_channels.html"},{"title":"set_body_fixed_channels – the SCATTERING code","text":"public  subroutine set_body_fixed_channels(total_angular_momentum_, parity_exponent_, channels_level_indices, channels_omega_values) Prepares the channels_level_indices array which holds indices that refer to the\nbasis arrays: v1level/j1level/elevel, and channels_omega_values which holds values\nof \\bar{\\Omega} Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: total_angular_momentum_ total angular momentum integer(kind=int32), intent(in) :: parity_exponent_ parity exponent of the block (0 if p = +1, 1 if p = -1) integer(kind=int32), intent(inout) :: channels_level_indices (:) holds the indices pointing to the basis arrays integer(kind=int32), intent(inout) :: channels_omega_values (:) holds all values of \\bar{\\Omega} Called by proc~~set_body_fixed_channels~~CalledByGraph proc~set_body_fixed_channels set_body_fixed_channels program~scattering SCATTERING program~scattering->proc~set_body_fixed_channels Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code set_body_fixed_channels Source Code subroutine set_body_fixed_channels ( total_angular_momentum_ , & parity_exponent_ , channels_level_indices , channels_omega_values ) !! Prepares the channels_level_indices array which holds indices that refer to the !! basis arrays: v1level/j1level/elevel, and channels_omega_values which holds values !! of \\bar{\\Omega} !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: total_angular_momentum_ !! total angular momentum integer ( int32 ), intent ( in ) :: parity_exponent_ !! parity exponent of the block (0 if p = +1, 1 if p = -1) integer ( int32 ), intent ( inout ) :: channels_level_indices (:) !! holds the indices pointing to the basis arrays integer ( int32 ), intent ( inout ) :: channels_omega_values (:) !! holds all values of \\bar{\\Omega} !---------------------------------------------------------------------! integer ( int32 ) :: level_index_ , channel_index_ , omega_max_ , parity_term_exponent_ !---------------------------------------------------------------------! ! due to construction of body-fixed basis states: ! |v j \\bar{\\Omega} J p > = N (|v j \\bar{\\Omega} J > !                         + p (-1)&#94;{J} |v j -\\bar{\\Omega} J > ) ! we are interested in the exponent of the \"p (-1)&#94;{J}\" term !---------------------------------------------------------------------! parity_term_exponent_ = mod ( parity_exponent_ + total_angular_momentum_ , 2 ) !---------------------------------------------------------------------! channel_index_ = 0 !---------------------------------------------------------------------! do level_index_ = 1 , nlevel omega_max_ = min ( j1array ( level_index_ ), total_angular_momentum_ ) call update_body_fixed_channels_info ( omega_max_ , parity_term_exponent_ , & level_index_ , channel_index_ , channels_level_indices , channels_omega_values ) enddo !---------------------------------------------------------------------! end subroutine set_body_fixed_channels","tags":"","loc":"proc/set_body_fixed_channels.html"},{"title":"set_number_of_channels – the SCATTERING code","text":"public  subroutine set_number_of_channels(total_angular_momentum_, number_of_channels_even_parity_block, number_of_channels_odd_parity_block) determine the number of scattering channels in each parity block \nfor given total angular momentum in both body-fixed and\nspace-fixed frames Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: total_angular_momentum_ total angular momentum integer(kind=int32), intent(out) :: number_of_channels_even_parity_block number of channels in the p = 1 (even parity) block integer(kind=int32), intent(out) :: number_of_channels_odd_parity_block number of channels in the p = -1 (odd parity) block Called by proc~~set_number_of_channels~~CalledByGraph proc~set_number_of_channels set_number_of_channels program~scattering SCATTERING program~scattering->proc~set_number_of_channels Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code set_number_of_channels Source Code subroutine set_number_of_channels ( total_angular_momentum_ , & number_of_channels_even_parity_block , number_of_channels_odd_parity_block ) !! determine the number of scattering channels in each parity block !! for given total angular momentum in both body-fixed and !! space-fixed frames !---------------------------------------------------------------------! !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: total_angular_momentum_ !! total angular momentum integer ( int32 ), intent ( out ) :: number_of_channels_even_parity_block !! number of channels in the p = 1 (even parity) block integer ( int32 ), intent ( out ) :: number_of_channels_odd_parity_block !! number of channels in the p = -1 (odd parity) block !---------------------------------------------------------------------! integer ( int32 ) :: number_of_channels_even_parity_block_sf , & number_of_channels_odd_parity_block_sf !---------------------------------------------------------------------! ! body-fixed frame !---------------------------------------------------------------------! call calculate_number_of_channels_body_fixed ( total_angular_momentum_ , & number_of_channels_even_parity_block , number_of_channels_odd_parity_block ) !---------------------------------------------------------------------! ! space-fixed frame !---------------------------------------------------------------------! call calculate_number_of_channels_space_fixed ( total_angular_momentum_ , & number_of_channels_even_parity_block_sf , number_of_channels_odd_parity_block_sf ) !---------------------------------------------------------------------! ! Check if the number of channels is the same !---------------------------------------------------------------------! call check_number_of_channels ( number_of_channels_even_parity_block , & number_of_channels_even_parity_block_sf , \"even\" ) call check_number_of_channels ( number_of_channels_odd_parity_block , & number_of_channels_odd_parity_block_sf , \"odd\" ) !---------------------------------------------------------------------! end subroutine set_number_of_channels","tags":"","loc":"proc/set_number_of_channels.html"},{"title":"set_space_fixed_channels – the SCATTERING code","text":"public  subroutine set_space_fixed_channels(total_angular_momentum_, parity_exponent_, channels_l_values) Prepares the channels_l_values array which holds values of\norbital angular momentum, l, a space-fixed-frame quantum number. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: total_angular_momentum_ total angular momentum integer(kind=int32), intent(in) :: parity_exponent_ parity exponent of the block (0 if p = +1, 1 if p = -1) integer(kind=int32), intent(inout) :: channels_l_values (:) holds all values of l Calls proc~~set_space_fixed_channels~~CallsGraph proc~set_space_fixed_channels set_space_fixed_channels proc~write_error write_error proc~set_space_fixed_channels->proc~write_error proc~write_message write_message proc~write_error->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~set_space_fixed_channels~~CalledByGraph proc~set_space_fixed_channels set_space_fixed_channels program~scattering SCATTERING program~scattering->proc~set_space_fixed_channels Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code set_space_fixed_channels Source Code subroutine set_space_fixed_channels ( total_angular_momentum_ , & parity_exponent_ , channels_l_values ) !! Prepares the channels_l_values array which holds values of !! orbital angular momentum, \\l\\, a space-fixed-frame quantum number. !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: total_angular_momentum_ !! total angular momentum integer ( int32 ), intent ( in ) :: parity_exponent_ !! parity exponent of the block (0 if p = +1, 1 if p = -1) integer ( int32 ), intent ( inout ) :: channels_l_values (:) !! holds all values of l !---------------------------------------------------------------------! integer :: level_index_ , l_min_ , l_max_ , l_ , channel_index_ !---------------------------------------------------------------------! channel_index_ = 0 do level_index_ = 1 , nlevel l_min_ = abs ( total_angular_momentum_ - j1array ( level_index_ )) l_max_ = total_angular_momentum_ + j1array ( level_index_ ) do l_ = l_min_ , l_max_ if ( mod ( l_ + j1array ( level_index_ ), 2 ) == parity_exponent_ ) then channel_index_ = channel_index_ + 1 if ( channel_index_ > size ( channels_l_values )) then call write_error ( \"channel_index_ out of bounds of \" // & \"channels_l_values in set_space_fixed_channels.\" ) end if channels_l_values ( channel_index_ ) = l_ endif enddo enddo !---------------------------------------------------------------------! end subroutine set_space_fixed_channels","tags":"","loc":"proc/set_space_fixed_channels.html"},{"title":"radial_coupling_terms_mod – the SCATTERING code","text":"This module provides all functions that handle radial coupling terms\n of the PES. It covers:\n 1. reading radial coupling terms from external file (\"read_radial_coupling_terms\",\n    \"skip_header_lines\", \"read_and_validate_lambda\", \"read_potential_data\",\n    \"validate_r_range\")\n 2. reducing the number of read coupling terms to retain only necessary\n    couplings (\"reduce_radial_coupling_terms\", \"print_pes_quantum_numbers\",\n    \"reduce_coupling_terms\", \"find_reduced_term\")\n 3. interpolation of radial coupling terms (\"interpolate_radial_coupling_terms\")\n 4. providing value of the interpolated radial coupling term (\"get_radial_coupling_term_value\")\n--------------------------------------------------------------------------! Uses iso_fortran_env io_mod utility_functions_mod math_functions_mod module~~radial_coupling_terms_mod~~UsesGraph module~radial_coupling_terms_mod radial_coupling_terms_mod iso_fortran_env iso_fortran_env module~radial_coupling_terms_mod->iso_fortran_env module~math_functions_mod math_functions_mod module~radial_coupling_terms_mod->module~math_functions_mod module~utility_functions_mod utility_functions_mod module~radial_coupling_terms_mod->module~utility_functions_mod module~io_mod io_mod module~radial_coupling_terms_mod->module~io_mod module~math_functions_mod->iso_fortran_env module~math_functions_mod->module~utility_functions_mod module~special_functions_mod special_functions_mod module~math_functions_mod->module~special_functions_mod module~utility_functions_mod->iso_fortran_env module~io_mod->iso_fortran_env module~io_mod->module~utility_functions_mod module~array_operations_mod array_operations_mod module~io_mod->module~array_operations_mod module~array_operations_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~radial_coupling_terms_mod~~UsedByGraph module~radial_coupling_terms_mod radial_coupling_terms_mod module~propagators PROPAGATORS module~propagators->module~radial_coupling_terms_mod program~scattering SCATTERING program~scattering->module~radial_coupling_terms_mod program~scattering->module~propagators Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines get_radial_coupling_term_value interpolate_radial_coupling_terms read_radial_coupling_terms reduce_radial_coupling_terms Subroutines public  subroutine get_radial_coupling_term_value (intermolecular_distance, lambda_, v_, j_, v_prime_, j_prime_, radial_term_value_) Returns the interpolated value of a specific radial coupling term\nat a given distance. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: intermolecular_distance Intermolecular distance, R integer(kind=int32), intent(in) :: lambda_ Legendre expansion index integer(kind=int32), intent(in) :: v_ pre-collisional vibrational quantum number integer(kind=int32), intent(in) :: j_ pre-collisional rotational quantum number integer(kind=int32), intent(in) :: v_prime_ post-collisional vibrational quantum number integer(kind=int32), intent(in) :: j_prime_ post-collisional rotational quantum number real(kind=dp), intent(out) :: radial_term_value_ Value of the radial coupling coefficient public  subroutine interpolate_radial_coupling_terms () Interpolates the radial coupling terms using cubic spline functions.\nThe resulting spline coefficients for each coupling term\nare stored in bmat3D, cmat3D, and dmat3D matrices. Arguments None public  subroutine read_radial_coupling_terms () reads the radial coupling terms from the external file.\nThe file is assumed to be formatted as described in\n\"Supplying radial terms\" section.\nThe read radial coupling terms are kept in vmat/read_vmat3D Arguments None public  subroutine reduce_radial_coupling_terms () Reduces the read_vmat3D matrix to retain only the necessary coupling terms. Arguments None","tags":"","loc":"module/radial_coupling_terms_mod.html"},{"title":"special_functions_mod – the SCATTERING code","text":"This module holds rctj, rcty, envj, msta1, msta2, ikv, gamma from\n special_functions library, donwloaded from:\n https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html\n  Author: Original FORTRAN77 version by Shanjie Zhang, Jianming Jin.\nFORTRAN90 version by John Burkardt. Reference: Shanjie Zhang, Jianming Jin,\nComputation of Special Functions,\nWiley, 1996,\nISBN: 0-471-11963-6,\nLC: QA351.C45. --------------------------------------------------------------------------! Used by module~~special_functions_mod~~UsedByGraph module~special_functions_mod special_functions_mod module~math_functions_mod math_functions_mod module~math_functions_mod->module~special_functions_mod module~radial_coupling_terms_mod radial_coupling_terms_mod module~radial_coupling_terms_mod->module~math_functions_mod module~coupling_matrix_mod coupling_matrix_mod module~coupling_matrix_mod->module~math_functions_mod module~boundary_conditions_mod boundary_conditions_mod module~boundary_conditions_mod->module~math_functions_mod module~propagators PROPAGATORS module~propagators->module~radial_coupling_terms_mod program~scattering SCATTERING program~scattering->module~radial_coupling_terms_mod program~scattering->module~coupling_matrix_mod program~scattering->module~boundary_conditions_mod program~scattering->module~propagators Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Functions envj msta1 msta2 Subroutines gamma ikv rctj rcty Functions public  function envj (n, x) utility function used by MSTA1 and MSTA2. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: x Return Value real(kind=8) public  function msta1 (x, mp) determines a backward recurrence starting point for Jn(x). Arguments Type Intent Optional Attributes Name real(kind=8) :: x integer(kind=4) :: mp Return Value integer(kind=4) public  function msta2 (x, n, mp) determines a backward recurrence starting point for Jn(x). Arguments Type Intent Optional Attributes Name real(kind=8) :: x integer(kind=4) :: n integer(kind=4) :: mp Return Value integer(kind=4) Subroutines public  subroutine gamma (x, ga) evaluates the Gamma function. Arguments Type Intent Optional Attributes Name real(kind=8) :: x real(kind=8) :: ga public  subroutine ikv (v, x, vm, bi, di, bk, dk) computes modified Bessel function Iv(x) and Kv(x) and their derivatives. Arguments Type Intent Optional Attributes Name real(kind=8) :: v real(kind=8) :: x real(kind=8) :: vm real(kind=8) :: bi (0:*) real(kind=8) :: di (0:*) real(kind=8) :: bk (0:*) real(kind=8) :: dk (0:*) public  subroutine rctj (n, x, nm, rj, dj) computes Riccati-Bessel function of the first kind, and derivatives. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: x integer(kind=4) :: nm real(kind=8) :: rj (0:n) real(kind=8) :: dj (0:n) public  subroutine rcty (n, x, nm, ry, dy) computes Riccati-Bessel function of the second kind, and derivatives. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: x integer(kind=4) :: nm real(kind=8) :: ry (0:n) real(kind=8) :: dy (0:n)","tags":"","loc":"module/special_functions_mod.html"},{"title":"io_mod – the SCATTERING code","text":"this module provides following functions and subroutines:\n1. input_file - reads the input file prepared by the user\n2. input_check - checks the variables supplied in the input file\n3. input_summary - summary of the input variables\n5. etotal (function) - returns the total energy of the system\n6. wavenumber_from_energy (function) - returns the wavenumber\n7. units_conversion - converts all physical quantities to atomic units\n8. count_available_xs (function) - counts energetically accessible\n   levels in the basis\n9. jaccess (function) - returns jopen and waveopen - arrays needed for\n   calculations of the state-to-state XS Uses iso_fortran_env array_operations_mod utility_functions_mod module~~io_mod~~UsesGraph module~io_mod io_mod iso_fortran_env iso_fortran_env module~io_mod->iso_fortran_env module~utility_functions_mod utility_functions_mod module~io_mod->module~utility_functions_mod module~array_operations_mod array_operations_mod module~io_mod->module~array_operations_mod module~utility_functions_mod->iso_fortran_env module~array_operations_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~io_mod~~UsedByGraph module~io_mod io_mod module~coupling_matrix_mod coupling_matrix_mod module~coupling_matrix_mod->module~io_mod module~unitarity_check_mod unitarity_check_mod module~unitarity_check_mod->module~io_mod module~propagators PROPAGATORS module~propagators->module~io_mod module~radial_coupling_terms_mod radial_coupling_terms_mod module~propagators->module~radial_coupling_terms_mod module~statetostatexs statetostateXS module~statetostatexs->module~io_mod module~boundary_conditions_mod boundary_conditions_mod module~boundary_conditions_mod->module~io_mod module~channels_mod channels_mod module~channels_mod->module~io_mod program~scattering SCATTERING program~scattering->module~io_mod program~scattering->module~coupling_matrix_mod program~scattering->module~unitarity_check_mod program~scattering->module~propagators program~scattering->module~statetostatexs program~scattering->module~boundary_conditions_mod program~scattering->module~channels_mod program~scattering->module~radial_coupling_terms_mod module~radial_coupling_terms_mod->module~io_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables amutoau bmat bmat3D bohrtoangstrom cmat cmat3D dmat dmat3D dr dtol elevel energy hartreetocm ietoterel initial input_unit ipart iunits j1array j1pes j1ppes jtotmax jtotmin jtotstep l1tab l2tab label lltab n_skip_lines ncac ncoupl nlevel nmodlevels nr nterms otol partial_file_unit partialfile pes_file_exists pes_file_unit pi potentialfile prntlvl radial_term_distance_converter radial_term_energy_converter read_vmat3D reduced_j1pes reduced_j1ppes reduced_v1pes reduced_v1ppes reducedmass rmat rmax rmin s_matrix_unit saveeigenvectors smatrixfile spline_coeff_b spline_coeff_c spline_coeff_d steps totalcol unitary_tolerance units_converted v1array v1pes v1ppes vdepth vmat vmat3D Functions ETOTAL count_open_basis_levels is_open wavenumber_from_energy Subroutines input_check input_summary read_input_file save_open_basis_levels units_conversion Variables Type Visibility Attributes Name Initial real(kind=dp), public, parameter :: amutoau = 1822.8884862d0 real(kind=dp), public, allocatable :: bmat (:,:) real(kind=dp), public, allocatable :: bmat3D (:,:,:) real(kind=dp), public, parameter :: bohrtoangstrom = 0.5291772109d0 real(kind=dp), public, allocatable :: cmat (:,:) real(kind=dp), public, allocatable :: cmat3D (:,:,:) real(kind=dp), public, allocatable :: dmat (:,:) real(kind=dp), public, allocatable :: dmat3D (:,:,:) real(kind=dp), public :: dr real(kind=dp), public :: dtol real(kind=dp), public, allocatable :: elevel (:) real(kind=dp), public :: energy real(kind=dp), public, parameter :: hartreetocm = 219474.631363d0 integer(kind=int32), public :: ietoterel integer(kind=int32), public :: initial integer(kind=int32), public, parameter :: input_unit = 5 integer(kind=int32), public :: ipart integer(kind=int32), public :: iunits integer(kind=int32), public, allocatable :: j1array (:) integer(kind=int32), public, allocatable :: j1pes (:) integer(kind=int32), public, allocatable :: j1ppes (:) integer(kind=int32), public :: jtotmax integer(kind=int32), public :: jtotmin integer(kind=int32), public :: jtotstep integer(kind=int32), public, allocatable :: l1tab (:) integer(kind=int32), public, allocatable :: l2tab (:) character(len=80), public :: label integer(kind=int32), public, allocatable :: lltab (:) integer(kind=int32), public :: n_skip_lines integer(kind=int32), public :: ncac integer(kind=int32), public :: ncoupl integer(kind=int32), public :: nlevel integer(kind=int32), public :: nmodlevels integer(kind=int32), public :: nr integer(kind=int32), public :: nterms real(kind=dp), public :: otol integer(kind=int32), public, parameter :: partial_file_unit = 12 character(len=80), public :: partialfile logical, public :: pes_file_exists integer(kind=int32), public, parameter :: pes_file_unit = 8 real(kind=dp), public, parameter :: pi = dacos(-1.d0) character(len=80), public :: potentialfile integer(kind=int32), public :: prntlvl real(kind=dp), public :: radial_term_distance_converter real(kind=dp), public :: radial_term_energy_converter real(kind=dp), public, allocatable :: read_vmat3D (:,:,:) integer(kind=int32), public, allocatable :: reduced_j1pes (:) integer(kind=int32), public, allocatable :: reduced_j1ppes (:) integer(kind=int32), public, allocatable :: reduced_v1pes (:) integer(kind=int32), public, allocatable :: reduced_v1ppes (:) real(kind=dp), public :: reducedmass real(kind=dp), public, allocatable :: rmat (:) real(kind=dp), public :: rmax real(kind=dp), public :: rmin integer(kind=int32), public, parameter :: s_matrix_unit = 11 integer(kind=int32), public :: saveeigenvectors character(len=80), public :: smatrixfile real(kind=dp), public, allocatable :: spline_coeff_b (:) real(kind=dp), public, allocatable :: spline_coeff_c (:) real(kind=dp), public, allocatable :: spline_coeff_d (:) integer(kind=int32), public :: steps integer(kind=int32), public :: totalcol real(kind=dp), public, parameter :: unitary_tolerance = 1e-6_dp logical, public :: units_converted = .false. integer(kind=int32), public, allocatable :: v1array (:) integer(kind=int32), public, allocatable :: v1pes (:) integer(kind=int32), public, allocatable :: v1ppes (:) real(kind=dp), public :: vdepth real(kind=dp), public, allocatable :: vmat (:,:) real(kind=dp), public, allocatable :: vmat3D (:,:,:) Functions public  function ETOTAL () result(etot_) returns the total energy Arguments None Return Value real(kind=dp) public  function count_open_basis_levels () result(open_) counts the energetically accessible levels in the basis Arguments None Return Value integer(kind=int32) public  function is_open (energy_) result(is_open_) checks if a channel/level is energetically accessible (open)\nby comparing energy with etotal() Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: energy_ level/channel energy Return Value logical public  function wavenumber_from_energy (energy_) result(k_) returns the wavenumber, k_{a}, given the energy of a given state,\nE_{a}; calls etot() function; atomic units in the whole function\n k_{a} = \\sqrt(2 \\mu (E_{tot} - E_{a}) \nsince it uses reducedmass and etotal(), the function checks\nif units are already converted Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: energy_ energy of a given state,  E_{a} , in a.u. Return Value real(kind=dp) wavenumber, k_{a}, in a.u. Subroutines public  subroutine input_check (nmlistind) checks if the supplied input parameters are correct Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: nmlistind nmlistind = 1: namelist INPUT\nnmlistind = 2: namelist BASIS\nnmlistind = 3: namelist POTENTIAL public  subroutine input_summary () summarize the input parameters for the current run Arguments None public  subroutine read_input_file () reads the input file prepared by the user using NAMELIST feature\nthe code uses 3 namelists: input, basis and potential Arguments None public  subroutine save_open_basis_levels (number_of_open_basis_levels, open_basis_levels, open_basis_wavevectors) saves indices to open levels in the basis and corresponding\nwavenumbers (in A&#94;2) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: number_of_open_basis_levels number of energetically accessible levels in the basis integer(kind=int32), intent(inout) :: open_basis_levels (number_of_open_basis_levels) array holding indices to energetically accessible levels in the basis real(kind=dp), intent(inout) :: open_basis_wavevectors (number_of_open_basis_levels) array holding wavevectors calculated w.r.t energetically accessible levels in the basis public  subroutine units_conversion () converts all physical quantities to atomic units Arguments None","tags":"","loc":"module/io_mod.html"},{"title":"math_functions_mod – the SCATTERING code","text":"this module holds 4 types of functions:\n-- algebraic functions: percival_seaton_coefficient\n-- geometric functions: triangle_inequality_holds, is_sum_even, zero_projections_3j_condition\n-- bessel functions: groups functions: riccati_bessel_j, bessely and modified_bessel_k_ratio\n   that call special functions from special_functions.f90 library\n-- interpolation procedures: spline and ispline functions for interpolating data\n-- additional functions: rctj, rcty, envj, msta1, msta2, ikv, gamma from\n   special_functions library Uses special_functions_mod iso_fortran_env utility_functions_mod module~~math_functions_mod~~UsesGraph module~math_functions_mod math_functions_mod module~special_functions_mod special_functions_mod module~math_functions_mod->module~special_functions_mod iso_fortran_env iso_fortran_env module~math_functions_mod->iso_fortran_env module~utility_functions_mod utility_functions_mod module~math_functions_mod->module~utility_functions_mod module~utility_functions_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~math_functions_mod~~UsedByGraph module~math_functions_mod math_functions_mod module~radial_coupling_terms_mod radial_coupling_terms_mod module~radial_coupling_terms_mod->module~math_functions_mod module~coupling_matrix_mod coupling_matrix_mod module~coupling_matrix_mod->module~math_functions_mod module~boundary_conditions_mod boundary_conditions_mod module~boundary_conditions_mod->module~math_functions_mod module~propagators PROPAGATORS module~propagators->module~radial_coupling_terms_mod program~scattering SCATTERING program~scattering->module~radial_coupling_terms_mod program~scattering->module~coupling_matrix_mod program~scattering->module~boundary_conditions_mod program~scattering->module~propagators Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Functions is_sum_even ispline percival_seaton_coefficient triangle_inequality_holds zero_projections_3j_condition Subroutines modified_bessel_k_ratio riccati_bessel_j riccati_bessel_y spline Functions public  function is_sum_even (x, y, z) result(sum_even) checks if the sum of 3 integers is an even integer Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x variables to check if the sum is even integer(kind=int32), intent(in) :: y variables to check if the sum is even integer(kind=int32), intent(in) :: z variables to check if the sum is even Return Value logical (out) result: true/false public  function ispline (u_, N_, x_, y_, b_, c_, d_) result(spl_result) returns interpolated value at guven u_ point\nnumber of points and ascending order of x is not checked since\nispline is called after \"spline\" where these checks are done Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: u_ point at which the tabulated value is interpolated integer(kind=int32), intent(in) :: N_ number of grid points real(kind=dp), intent(in) :: x_ (N_) grid points real(kind=dp), intent(in) :: y_ (N_) tabulated values real(kind=dp), intent(in) :: b_ (N_) arrays with coefficients of the spline function real(kind=dp), intent(in) :: c_ (N_) arrays with coefficients of the spline function real(kind=dp), intent(in) :: d_ (N_) arrays with coefficients of the spline function Return Value real(kind=dp) interpolated value at u_ public  function percival_seaton_coefficient (j_, j_prime_, lambda_, omega_) result(percival_seaton_coefficient_) calculates Percival-Seaton coefficients (body-fixed variant) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: j_ pre-collisional rotational angular momentum integer(kind=int32), intent(in) :: j_prime_ post-collisional rotational angular momentum integer(kind=int32), intent(in) :: lambda_ Legendre expansion coefficient  \\lambda integer(kind=int32), intent(in) :: omega_ \\bar{\\Omega} Return Value real(kind=dp) (out) result: percival seaton coefficient in the body-fixed frame public  function triangle_inequality_holds (x, y, z) result(holds) check if the triangle inequality for 3 variables hols Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x variables to check the triangle inequality integer(kind=int32), intent(in) :: y variables to check the triangle inequality integer(kind=int32), intent(in) :: z variables to check the triangle inequality Return Value logical (out) result: true/false public  function zero_projections_3j_condition (x, y, z) result(is_valid) checks the condition for nonvanishing 3-j symbol with zero projections:\ntriangle inequality on x,y,z and if the sum x+y+z is an even integer Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x variables to check for 3-j symbol conditions integer(kind=int32), intent(in) :: y variables to check for 3-j symbol conditions integer(kind=int32), intent(in) :: z variables to check for 3-j symbol conditions Return Value logical (out) result: true/false if conditions are met Subroutines public  subroutine modified_bessel_k_ratio (l_, x_, ratio_) calculates the ratio of the modified Bessel function of the second\nkind K_{l_ + 1/2}(x) and its first derivative (Eq. ...)\nUses ikv function from special_functions.f90 Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: l_ l - order of the function (without the 1/2 factor!) real(kind=dp), intent(in) :: x_ x - argument of the function real(kind=dp), intent(inout) :: ratio_ ratio of the modified Bessel function of the second kind to its derivative public  subroutine riccati_bessel_j (l_, x_, j_, jp_) calculates the Riccati-Bessel function of the first kind and its\nfirst derivative. Calls the rctj function from special_functions.f90 Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: l_ l - order of the Riccati-Bessel function of the first kind real(kind=dp), intent(in) :: x_ x - argument of the Riccati-Bessel function of the first kind real(kind=dp), intent(inout) :: j_ j_{l} (x) - Riccati-Bessel funciton of the first kind real(kind=dp), intent(inout) :: jp_ j_{l}' (x) - derivative of the Riccati-Bessel funciton of the first kind public  subroutine riccati_bessel_y (l_, x_, y_, yp_) calculates the Riccati-Bessel function of the second kind and its\nfirst derivative. Calls the rcty function from special_functions.f90 Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: l_ l - order of the Riccati-Bessel function of the second kind real(kind=dp), intent(in) :: x_ x - argument of the Riccati-Bessel function of the second kind real(kind=dp), intent(inout) :: y_ y_{l} (x) - Riccati-Bessel funciton of the second kind real(kind=dp), intent(inout) :: yp_ y_{l}' (x) - derivative of the Riccati-Bessel funciton of the second kind public  subroutine spline (N_, x_, y_, b_, c_, d_) determines b, c and d coefficients of the cubic spline function\ny(x) = y_i + b_i * dx + c_i * dx&#94;2 + d_i * dx&#94;3,\nwhere dx = x - x_i, and x_i <= x < x_i+1.\nThe algorithm is based on\nGerald, C., and Wheatley, P., \"Applied Numerical Analysis\", Addison-Wesley, 1994. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: N_ number of grid points real(kind=dp), intent(in) :: x_ (N_) grid points (ascending order) real(kind=dp), intent(in) :: y_ (N_) tabulated values real(kind=dp), intent(out) :: b_ (N_) arrays with coefficients of the spline function real(kind=dp), intent(out) :: c_ (N_) arrays with coefficients of the spline function real(kind=dp), intent(out) :: d_ (N_) arrays with coefficients of the spline function","tags":"","loc":"module/math_functions_mod.html"},{"title":"unitarity_check_mod – the SCATTERING code","text":"This module contains subroutines that check the unitarity condition\nof the S-matrix (see Eq. (13) in \"Solution of coupled equations\") Uses iso_fortran_env io_mod utility_functions_mod module~~unitarity_check_mod~~UsesGraph module~unitarity_check_mod unitarity_check_mod iso_fortran_env iso_fortran_env module~unitarity_check_mod->iso_fortran_env module~utility_functions_mod utility_functions_mod module~unitarity_check_mod->module~utility_functions_mod module~io_mod io_mod module~unitarity_check_mod->module~io_mod module~utility_functions_mod->iso_fortran_env module~io_mod->iso_fortran_env module~io_mod->module~utility_functions_mod module~array_operations_mod array_operations_mod module~io_mod->module~array_operations_mod module~array_operations_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~unitarity_check_mod~~UsedByGraph module~unitarity_check_mod unitarity_check_mod program~scattering SCATTERING program~scattering->module~unitarity_check_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Functions check_unitarity_for_each_channel Subroutines calculate_sum_of_squares_for_each_channel handle_unitarity_output_message unitarity_check Functions public  function check_unitarity_for_each_channel (sum_of_squares) result(is_unitary_) checks if the calculated sum of squares equals 1 for each channel Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: sum_of_squares (:)  \\sum_{\\gamma'} \\Bigl|{S}&#94;{Jp}_{\\gamma, \\gamma'}\\Bigr|&#94;{2}  Return Value logical (output) if .true. unitarity is fulfilled, .false. otherwise Subroutines public  subroutine calculate_sum_of_squares_for_each_channel (s_matrix_real, s_matrix_imag, sum_of_squares_) calculates the sum\n \\sum_{\\gamma'} \\Bigl|{S}&#94;{Jp}_{\\gamma, \\gamma'}\\Bigr|&#94;{2} \nfor all \\gamma channels Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: s_matrix_real (:,:) real part of the S-matrix real(kind=dp), intent(in) :: s_matrix_imag (:,:) imaginary part of the S-matrix real(kind=dp), intent(out) :: sum_of_squares_ (:) (output)  \\sum_{\\gamma'} \\Bigl|{S}&#94;{Jp}_{\\gamma, \\gamma'}\\Bigr|&#94;{2}  public  subroutine handle_unitarity_output_message (is_unitary) handle printing messages depending on the outcome of unitarity check Arguments Type Intent Optional Attributes Name logical, intent(in) :: is_unitary if .true. unitarity is fulfilled, .false. otherwise public  subroutine unitarity_check (number_of_open_channels, s_matrix_real, s_matrix_imag, is_unitary) checks the unitarity of the S-matrix\n(Eq. (13) in \"Solution of coupled equations\") Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: number_of_open_channels number of open channels real(kind=dp), intent(in) :: s_matrix_real (number_of_open_channels,number_of_open_channels) real part of the S-matrix real(kind=dp), intent(in) :: s_matrix_imag (number_of_open_channels,number_of_open_channels) imaginary part of the S-matrix logical, intent(inout) :: is_unitary (output) if .true. unitarity is fulfilled, .false. otherwise","tags":"","loc":"module/unitarity_check_mod.html"},{"title":"array_operations_mod – the SCATTERING code","text":"this module provides supplementary functions and subroutines to handle\nmatrix allocation, invertion, appending etc. Uses iso_fortran_env module~~array_operations_mod~~UsesGraph module~array_operations_mod array_operations_mod iso_fortran_env iso_fortran_env module~array_operations_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: array_operations_allocate_submod array_operations_append_submod array_operations_fill_symmetric_matrix_submod array_operations_invert_symmetric_matrix_submod module~~array_operations_mod~~UsedByGraph module~array_operations_mod array_operations_mod module~io_mod io_mod module~io_mod->module~array_operations_mod program~scattering SCATTERING program~scattering->module~array_operations_mod program~scattering->module~io_mod module~propagators PROPAGATORS program~scattering->module~propagators module~boundary_conditions_mod boundary_conditions_mod program~scattering->module~boundary_conditions_mod module~coupling_matrix_mod coupling_matrix_mod program~scattering->module~coupling_matrix_mod module~unitarity_check_mod unitarity_check_mod program~scattering->module~unitarity_check_mod module~statetostatexs statetostateXS program~scattering->module~statetostatexs module~channels_mod channels_mod program~scattering->module~channels_mod module~radial_coupling_terms_mod radial_coupling_terms_mod program~scattering->module~radial_coupling_terms_mod module~propagators->module~array_operations_mod module~propagators->module~io_mod module~propagators->module~radial_coupling_terms_mod module~boundary_conditions_mod->module~array_operations_mod module~boundary_conditions_mod->module~io_mod module~array_operations_fill_symmetric_matrix_submod array_operations_fill_symmetric_matrix_submod module~array_operations_fill_symmetric_matrix_submod->module~array_operations_mod module~array_operations_append_submod array_operations_append_submod module~array_operations_append_submod->module~array_operations_mod module~array_operations_invert_symmetric_matrix_submod array_operations_invert_symmetric_matrix_submod module~array_operations_invert_symmetric_matrix_submod->module~array_operations_mod module~array_operations_allocate_submod array_operations_allocate_submod module~array_operations_allocate_submod->module~array_operations_mod module~coupling_matrix_mod->module~io_mod module~unitarity_check_mod->module~io_mod module~statetostatexs->module~io_mod module~channels_mod->module~io_mod module~radial_coupling_terms_mod->module~io_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces allocate_1d allocate_2d allocate_3d append fill_symmetric_matrix invert_symmetric_matrix Interfaces public        interface allocate_1d public pure module subroutine allocate_1d_dp(array_, size_) allocate a 1d array and fill it with 0s (double precision version) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), allocatable :: array_ (:) integer(kind=int32), intent(in) :: size_ public pure module subroutine allocate_1d_int32(array_, size_) allocate a 1d array and fill it with 0s (integer version) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), allocatable :: array_ (:) integer(kind=int32), intent(in) :: size_ public pure module subroutine allocate_1d_sp(array_, size_) allocate a 1d array and fill it with 0s (single precision version) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout), allocatable :: array_ (:) integer(kind=int32), intent(in) :: size_ public        interface allocate_2d public pure module subroutine allocate_2d_dp(array_, size1_, size2_) allocate a 2d array and fill it with 0s (double precision version) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), allocatable :: array_ (:,:) integer(kind=int32), intent(in) :: size1_ integer(kind=int32), intent(in) :: size2_ public pure module subroutine allocate_2d_int32(array_, size1_, size2_) allocate a 2d array and fill it with 0s (integer version) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), allocatable :: array_ (:,:) integer(kind=int32), intent(in) :: size1_ integer(kind=int32), intent(in) :: size2_ public pure module subroutine allocate_2d_sp(array_, size1_, size2_) allocate a 2d array and fill it with 0s (single precision version) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout), allocatable :: array_ (:,:) integer(kind=int32), intent(in) :: size1_ integer(kind=int32), intent(in) :: size2_ public        interface allocate_3d public pure module subroutine allocate_3d_dp(array_, size1_, size2_, size3_) allocate a 3d array and fill it with 0s (double precision version) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), allocatable :: array_ (:,:,:) integer(kind=int32), intent(in) :: size1_ integer(kind=int32), intent(in) :: size2_ integer(kind=int32), intent(in) :: size3_ public pure module subroutine allocate_3d_int32(array_, size1_, size2_, size3_) allocate a 3d array and fill it with 0s (integer version) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), allocatable :: array_ (:,:,:) integer(kind=int32), intent(in) :: size1_ integer(kind=int32), intent(in) :: size2_ integer(kind=int32), intent(in) :: size3_ public pure module subroutine allocate_3d_sp(array_, size1_, size2_, size3_) allocate a 3d array and fill it with 0s (single precision version) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout), allocatable :: array_ (:,:,:) integer(kind=int32), intent(in) :: size1_ integer(kind=int32), intent(in) :: size2_ integer(kind=int32), intent(in) :: size3_ public        interface append public pure module subroutine append_dp(array_, element_) append element to an array (double precision version) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), allocatable :: array_ (:) real(kind=dp), intent(in) :: element_ public pure module subroutine append_int32(array_, element_) append element to an array (integer version) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), allocatable :: array_ (:) integer(kind=int32), intent(in) :: element_ public pure module subroutine append_sp(array_, element_) append element to an array (single precision version) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout), allocatable :: array_ (:) real(kind=sp), intent(in) :: element_ public        interface fill_symmetric_matrix public module subroutine fill_symmetric_matrix_dp(matrix_, upper_lower_) fill the upper/lower triangle of a symmetric matrix (double precision version) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: matrix_ (:,:) character(len=1), intent(in) :: upper_lower_ public module subroutine fill_symmetric_matrix_int32(matrix_, upper_lower_) fill the upper/lower triangle of a symmetric matrix (integer version) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: matrix_ (:,:) character(len=1), intent(in) :: upper_lower_ public module subroutine fill_symmetric_matrix_sp(matrix_, upper_lower_) fill the upper/lower triangle of a symmetric matrix (single precision version) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: matrix_ (:,:) character(len=1), intent(in) :: upper_lower_ public        interface invert_symmetric_matrix public module subroutine invert_symmetric_matrix_dp(matrix_) invert a symmetric matrix using DSYTRI method (double precision version) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: matrix_ (:,:) public module subroutine invert_symmetric_matrix_int32(matrix_) invert a symmetric matrix using DSYTRI method (integer version) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: matrix_ (:,:) public module subroutine invert_symmetric_matrix_sp(matrix_) invert a symmetric matrix using DSYTRI method (single precision version) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: matrix_ (:,:)","tags":"","loc":"module/array_operations_mod.html"},{"title":"coupling_matrix_mod – the SCATTERING code","text":"this module provides functions calculating the algebraic coefficients\n g_{{\\lambda},\\gamma,\\gamma'}&#94;{Jp}  entering the coupling matrix:\nsee Eq. 1 in the \"Coupling Matrix\" section. The data is organized as follows:\n- number of non-zero terms of the coupling matrix due to\n  \\bar{\\Omega} = \\bar{\\Omega}' condition is saved as\n  \"number_of_nonzero_coupling_matrix_elements\"\n- number of non-vanishing terms in the sum over \\lambda\n  in Eq. 1 in the \"Coupling Matrix\" section is saved in a\n  \"nonzero_terms_per_element\" array which is of\n  \"number_of_nonzero_coupling_matrix_elements\" size\n- a total number of non-vanishing   g_{{\\lambda},\\gamma,\\gamma'}&#94;{Jp} \n  coefficients is saved in \"number_of_nonzero_coupling_coefficients\"\n- all non-vanishing   g_{{\\lambda},\\gamma,\\gamma'}&#94;{Jp} \n  coefficients are saved in \"nonzero_coupling_coefficients\" array,\n  which is of \"number_of_nonzero_coupling_coefficients\" size\n- corresponding \\lambda value for each non-vanishing coefficient\n  is saved as an index to \"l1tab\" in the \"nonzero_legendre_indices\"\n  array (which is of \"number_of_nonzero_coupling_coefficients\" size) Uses iso_fortran_env io_mod utility_functions_mod math_functions_mod module~~coupling_matrix_mod~~UsesGraph module~coupling_matrix_mod coupling_matrix_mod iso_fortran_env iso_fortran_env module~coupling_matrix_mod->iso_fortran_env module~math_functions_mod math_functions_mod module~coupling_matrix_mod->module~math_functions_mod module~utility_functions_mod utility_functions_mod module~coupling_matrix_mod->module~utility_functions_mod module~io_mod io_mod module~coupling_matrix_mod->module~io_mod module~math_functions_mod->iso_fortran_env module~math_functions_mod->module~utility_functions_mod module~special_functions_mod special_functions_mod module~math_functions_mod->module~special_functions_mod module~utility_functions_mod->iso_fortran_env module~io_mod->iso_fortran_env module~io_mod->module~utility_functions_mod module~array_operations_mod array_operations_mod module~io_mod->module~array_operations_mod module~array_operations_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~coupling_matrix_mod~~UsedByGraph module~coupling_matrix_mod coupling_matrix_mod program~scattering SCATTERING program~scattering->module~coupling_matrix_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines check_nonzero_coupling_matrix_elements prepare_coupling_matrix_elements print_coupling_matrix_elements_summary process_single_matrix_element Subroutines public  subroutine check_nonzero_coupling_matrix_elements (channels_level_indices, channels_omega_values, number_of_nonzero_coupling_matrix_elements, number_of_nonzero_coupling_coefficients) checks the number of non-zero coupling matrix elements due to\nthe \\bar{\\Omega} = \\bar{\\Omega}' condition,\n\"number_of_nonzero_coupling_matrix_elements\",\nand the total number of non-zero algebraic coefficients,\n g_{{\\lambda},\\gamma,\\gamma'}&#94;{Jp} , in the whole matrix,\n\"number_of_nonzero_coupling_coefficients\". Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: channels_level_indices (:) holds the indices pointing to the basis arrays integer(kind=int32), intent(in) :: channels_omega_values (:) holds all values of \\bar{\\Omega} integer(kind=int32), intent(out) :: number_of_nonzero_coupling_matrix_elements number of non-zero terms in the sum () for each non-zero element of the coupling matrix integer(kind=int32), intent(out) :: number_of_nonzero_coupling_coefficients number of all non-zero algberaix coefficients in the whole coupling matrix public  subroutine prepare_coupling_matrix_elements (channels_level_indices, channels_omega_values, nonzero_terms_per_element, nonzero_legendre_indices, nonzero_coupling_coefficients) -- nonzero_terms_per_element - number of non-vanishing terms in\n   the sum over \\lambda in Eq. 1 in the \"Coupling Matrix\" section\n-- nonzero_legendre_indices - corresponding \\lambda value for\n   each non-vanishing coefficient is saved as an index to \"l1tab\"\n-- nonzero_coupling_coefficients --  holds all non-vanishing\n    g_{{\\lambda},\\gamma,\\gamma'}&#94;{Jp}  coefficients Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: channels_level_indices (:) holds the indices pointing to the basis arrays integer(kind=int32), intent(in) :: channels_omega_values (:) holds all values of \\bar{\\Omega} integer(kind=int32), intent(inout) :: nonzero_terms_per_element (:) keeps the number of non-vanishing elements of the sum over \\lambda\nfor each non-zero element of the coupling matrix integer(kind=int32), intent(inout) :: nonzero_legendre_indices (:) holds indices pointing to l1tab, which correspond to\nthe non-vanishing elements of the sum over \\lambda\nfor each non-zero element of the coupling matrix; real(kind=dp), intent(inout) :: nonzero_coupling_coefficients (:) holds the values of the non-zero algebraic coefficients public  subroutine print_coupling_matrix_elements_summary (number_of_channels, number_of_nonzero_coupling_matrix_elements, number_of_nonzero_coupling_coefficients) print a shor summary on the number of non-zero matrix elements\nof the coupling matrix Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: number_of_channels size of the basis integer(kind=int32), intent(in) :: number_of_nonzero_coupling_matrix_elements number of non-zero terms in the sum () for each non-zero element\nof the coupling matrix integer(kind=int32), intent(in) :: number_of_nonzero_coupling_coefficients number of all non-zero algberaix coefficients in the whole\ncoupling matrix public  subroutine process_single_matrix_element (j_, j_prime_, omega_, count_nonzero_coupling_coefficients, count_nonzero_legendre_terms, nonzero_legendre_indices, nonzero_coupling_coefficients) calculates the non-zero algebraic coefficients\n g_{{\\lambda},\\gamma,\\gamma'}&#94;{Jp}  for a single matrix\nelement - see Eq. (1) in the \"Coupling matrix\" section;\nalgebraic coefficients are saved to nonzero_coupling_coefficients\narray; corresponding indices to l1tab are saved to\nnonzero_legendre_indices array Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: j_ pre-collisional rotational angular momentum integer(kind=int32), intent(in) :: j_prime_ post-collisional rotational angular momentum integer(kind=int32), intent(in) :: omega_ \\bar{\\Omega} integer(kind=int32), intent(inout) :: count_nonzero_coupling_coefficients running index counting non-zero coupling coefficients,\n g_{{\\lambda},\\gamma,\\gamma'}&#94;{Jp}  in the whole matrix;\nincremented in this subroutine integer(kind=int32), intent(inout) :: count_nonzero_legendre_terms number of non-zero terms in Legendre expansion for a single\nmatrix element of the interaction potential integer(kind=int32), intent(inout) :: nonzero_legendre_indices (:) holds indices pointing to l1tab, which correspond to\nthe non-vanishing elements of the sum over \\lambda\nfor each non-zero element of the coupling matrix; real(kind=dp), intent(inout) :: nonzero_coupling_coefficients (:) holds values of the non-zero algebraic coefficients","tags":"","loc":"module/coupling_matrix_mod.html"},{"title":"statetostateXS – the SCATTERING code","text":"This modules contains the subroutine that calculates the state-to-state XS Uses iso_fortran_env io_mod utility_functions_mod module~~statetostatexs~~UsesGraph module~statetostatexs statetostateXS iso_fortran_env iso_fortran_env module~statetostatexs->iso_fortran_env module~utility_functions_mod utility_functions_mod module~statetostatexs->module~utility_functions_mod module~io_mod io_mod module~statetostatexs->module~io_mod module~utility_functions_mod->iso_fortran_env module~io_mod->iso_fortran_env module~io_mod->module~utility_functions_mod module~array_operations_mod array_operations_mod module~io_mod->module~array_operations_mod module~array_operations_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~statetostatexs~~UsedByGraph module~statetostatexs statetostateXS program~scattering SCATTERING program~scattering->module~statetostatexs Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines CROSSSECTION check_dtol_otol print_largest_partial_xs Subroutines public  subroutine CROSSSECTION (jj, nopen, number_of_channels, number_of_open_basis_levels, open_basis_levels, open_basis_wavevectors, srmatrix, simatrix, channels_level_indices, channels_l_values, xs_array) calculate the state-to-state cross-section Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: jj total angular momentum integer(kind=int32), intent(in) :: nopen number of open channels integer(kind=int32), intent(in) :: number_of_channels size of the basis integer(kind=int32), intent(in) :: number_of_open_basis_levels number of all possible state-to-state XS integer(kind=int32), intent(in) :: open_basis_levels (number_of_open_basis_levels) holds indices to the basis arrays which correspond to open channels real(kind=dp), intent(in) :: open_basis_wavevectors (number_of_open_basis_levels) holds wavenumbers k_{i} real(kind=dp), intent(in) :: srmatrix (nopen,nopen) real and imaginary parts of the S-matrix real(kind=dp), intent(in) :: simatrix (nopen,nopen) real and imaginary parts of the S-matrix integer(kind=int32), intent(in) :: channels_level_indices (number_of_channels) holds the indices pointing to the basis arrays integer(kind=int32), intent(in) :: channels_l_values (number_of_channels) holds all values of l real(kind=dp), intent(inout) :: xs_array (number_of_open_basis_levels*number_of_open_basis_levels) array holding all XSs public  subroutine check_dtol_otol (maxXSdiag, maxXSoff, ncacdiag, ncacoff, terminate) check if the dtol/otol condition on partial XS is already fulfilled Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: maxXSdiag largest elastic and inelastic XS real(kind=dp), intent(in) :: maxXSoff largest elastic and inelastic XS integer(kind=int32), intent(inout) :: ncacdiag number of consecutive blocks for which dtol/otol condition is already\nfulfilled. Gets incremented within the subroutine integer(kind=int32), intent(inout) :: ncacoff number of consecutive blocks for which dtol/otol condition is already\nfulfilled. Gets incremented within the subroutine logical, intent(inout) :: terminate if .true. the dtol/otol condition is fulfilled;\nJ-tot loop is terminated public  subroutine print_largest_partial_xs (jj, maxXSdiag, maxXSoff, jinddiag, jindoff1, jindoff2, number_of_open_basis_levels, open_basis_levels) print the largest partial elastic and inelastic state-to-state XS\nin given J-block Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: jj total angular momentum real(kind=dp), intent(in) :: maxXSdiag the largest partial elastic state-to-state XS in this J-block real(kind=dp), intent(in) :: maxXSoff the largest partial inelastic state-to-state XS in this J-block integer(kind=int32), intent(in) :: jinddiag index pointing indirectly to quantum numbers associated with\nthe largest partial elastic state-to-state XS in this J-block integer(kind=int32), intent(in) :: jindoff1 indices pointing indirectly to quantum numbers associated with\nthe largest partial inelastic state-to-state XS in this J-block integer(kind=int32), intent(in) :: jindoff2 indices pointing indirectly to quantum numbers associated with\nthe largest partial inelastic state-to-state XS in this J-block integer(kind=int32), intent(in) :: number_of_open_basis_levels number of all possible state-to-state XS (size of open_basis_levels array) integer(kind=int32), intent(in) :: open_basis_levels (number_of_open_basis_levels) holds indices to the basis arrays which correspond to open channels","tags":"","loc":"module/statetostatexs.html"},{"title":"boundary_conditions_mod – the SCATTERING code","text":"This module contains subroutines that transform the asymptotic\nlog-derivative matrix into the scattering S-matrix\n(see \"Solution of coupled equations\" section) Uses utility_functions_mod io_mod fwigxjpf array_operations_mod iso_fortran_env math_functions_mod module~~boundary_conditions_mod~~UsesGraph module~boundary_conditions_mod boundary_conditions_mod module~io_mod io_mod module~boundary_conditions_mod->module~io_mod module~math_functions_mod math_functions_mod module~boundary_conditions_mod->module~math_functions_mod fwigxjpf fwigxjpf module~boundary_conditions_mod->fwigxjpf module~utility_functions_mod utility_functions_mod module~boundary_conditions_mod->module~utility_functions_mod iso_fortran_env iso_fortran_env module~boundary_conditions_mod->iso_fortran_env module~array_operations_mod array_operations_mod module~boundary_conditions_mod->module~array_operations_mod module~io_mod->module~utility_functions_mod module~io_mod->iso_fortran_env module~io_mod->module~array_operations_mod module~math_functions_mod->module~utility_functions_mod module~math_functions_mod->iso_fortran_env module~special_functions_mod special_functions_mod module~math_functions_mod->module~special_functions_mod module~utility_functions_mod->iso_fortran_env module~array_operations_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~boundary_conditions_mod~~UsedByGraph module~boundary_conditions_mod boundary_conditions_mod program~scattering SCATTERING program~scattering->module~boundary_conditions_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines calculate_k_matrix calculate_s_matrix calculate_sf_matrix_from_bf_matrix Subroutines public  subroutine calculate_k_matrix (number_of_channels, log_der_matrix, number_of_open_channels, channels_level_indices, channels_l_values, r_, k_matrix) calculates the K-matrix from log-derivative matrix using Eq. (4) in\n\"Solution of coupled equations\" Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: number_of_channels y-matrix is of number_of_channels x number_of_channels size real(kind=dp), intent(in) :: log_der_matrix (number_of_channels,number_of_channels) asymptotic log-derivative matrix integer(kind=int32), intent(in) :: number_of_open_channels number of open channels integer(kind=int32), intent(in) :: channels_level_indices (number_of_channels) holds the indices pointing to the basis arrays integer(kind=int32), intent(in) :: channels_l_values (number_of_channels) holds all values of l real(kind=dp), intent(in) :: r_ Rmax real(kind=dp), intent(inout) :: k_matrix (number_of_open_channels,number_of_open_channels) K-matrix public  subroutine calculate_s_matrix (number_of_open_channels, k_matrix, s_matrix_real, s_matrix_imag) calculates S-matrix from open-open portion of the K-matrix using\nEq. (12) in \"Solution of coupled equations\" Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: number_of_open_channels number of open channels real(kind=dp), intent(in) :: k_matrix (number_of_open_channels,number_of_open_channels) K-matrix real(kind=dp), intent(inout) :: s_matrix_real (number_of_open_channels,number_of_open_channels) (output) real part of the S-matrix real(kind=dp), intent(inout) :: s_matrix_imag (number_of_open_channels,number_of_open_channels) (output) imaginary part of the S-matrix public  subroutine calculate_sf_matrix_from_bf_matrix (number_of_channels, total_angular_momentum_, channels_level_indices, channels_omega_values, channels_l_values, bf_matrix, sf_matrix) takes as an input matrix in the body-fixed frame and transforms it \nto the spec-fixed frame; iterates over all matrix elements\nand calls calculate_single_SF_element Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: number_of_channels size of the basis integer(kind=int32), intent(in) :: total_angular_momentum_ total angular momentum integer(kind=int32), intent(in) :: channels_level_indices (number_of_channels) holds the indices pointing to the basis arrays integer(kind=int32), intent(in) :: channels_omega_values (number_of_channels) holds all values of \\bar{\\Omega} integer(kind=int32), intent(in) :: channels_l_values (number_of_channels) holds all values of l real(kind=dp), intent(in) :: bf_matrix (number_of_channels,number_of_channels) matrix in the BF frame real(kind=dp), intent(inout) :: sf_matrix (number_of_channels,number_of_channels) (output) matrix in the SF frame","tags":"","loc":"module/boundary_conditions_mod.html"},{"title":"PROPAGATORS – the SCATTERING code","text":"this modules contains the subroutines used by the propagator:\n1. cenitrfugal_matrix - prepares the centrifugal term (Eq. (6.19))\n2. pes_contribution   - prepares the interaction energy term (Eq. (6.21))\n3. radtermvalue - returns the value of a radial coupling term at given R\n4. calculate_log_der_matrix - calculates the log-derivative matrix (Eq. 6.29)\n5. pes_diagonalization - diagonalizes the coupling matrix from rmin to rmax\n6. numerov - renormalized Numerov's algorithm Uses iso_fortran_env io_mod array_operations_mod radial_coupling_terms_mod module~~propagators~~UsesGraph module~propagators PROPAGATORS iso_fortran_env iso_fortran_env module~propagators->iso_fortran_env module~radial_coupling_terms_mod radial_coupling_terms_mod module~propagators->module~radial_coupling_terms_mod module~array_operations_mod array_operations_mod module~propagators->module~array_operations_mod module~io_mod io_mod module~propagators->module~io_mod module~radial_coupling_terms_mod->iso_fortran_env module~radial_coupling_terms_mod->module~io_mod module~math_functions_mod math_functions_mod module~radial_coupling_terms_mod->module~math_functions_mod module~utility_functions_mod utility_functions_mod module~radial_coupling_terms_mod->module~utility_functions_mod module~array_operations_mod->iso_fortran_env module~io_mod->iso_fortran_env module~io_mod->module~array_operations_mod module~io_mod->module~utility_functions_mod module~math_functions_mod->iso_fortran_env module~math_functions_mod->module~utility_functions_mod module~special_functions_mod special_functions_mod module~math_functions_mod->module~special_functions_mod module~utility_functions_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~propagators~~UsedByGraph module~propagators PROPAGATORS program~scattering SCATTERING program~scattering->module~propagators Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines calculate_log_der_matrix cenitrfugal_matrix numerov pes_contribution Subroutines public  subroutine calculate_log_der_matrix (h, y_dim, tt_min, tt_n, tt_plus, r_n, r_plus, log_der_matrix) calculates the log-derivative matrix from Eq. (6.29)\ncalled by numerov and log_derivative at the end of the propagation Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: h step of the propagation integer(kind=int32), intent(in) :: y_dim dimension of the log-derivative matrix real(kind=dp), intent(in) :: tt_min (y_dim,y_dim) T-matrix at R_{max - 1} real(kind=dp), intent(in) :: tt_n (y_dim,y_dim) T-matrix at R_{max} real(kind=dp), intent(in) :: tt_plus (y_dim,y_dim) T-matrix at R_{max + 1} real(kind=dp), intent(in) :: r_n (y_dim,y_dim) R-matrix at R_{max} real(kind=dp), intent(in) :: r_plus (y_dim,y_dim) R-matrix at R_{max + 1} real(kind=dp), intent(inout) :: log_der_matrix (y_dim,y_dim) log-derivative matrix public  subroutine cenitrfugal_matrix (number_of_channels, jj, channels_level_indices, channels_omega_values, centmatrix) calculates the (R* 2) centrifugal matrix from Eq. (6.19)\nonly called once at the beginning of the calculations Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: number_of_channels size of the basis integer(kind=int32), intent(in) :: jj total angular momentum integer(kind=int32), intent(in) :: channels_level_indices (number_of_channels) holds the indices pointing to the basis arrays integer(kind=int32), intent(in) :: channels_omega_values (number_of_channels) holds all values of \\bar{\\Omega} real(kind=dp), intent(out) :: centmatrix (number_of_channels,number_of_channels) (output) - (R* 2) centrifugal matrix public  subroutine numerov (channels_level_indices, channels_omega_values, number_of_nonzero_coupling_matrix_elements, number_of_nonzero_coupling_coefficients, nonzero_terms_per_element, nonzero_legendre_indices, nonzero_coupling_coefficients, nsteps, number_of_channels, jj, log_der_matrix) renormalized Numerov propagator Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: channels_level_indices (number_of_channels) holds the indices pointing to the basis arrays integer(kind=int32), intent(in) :: channels_omega_values (number_of_channels) holds all values of \\bar{\\Omega} integer(kind=int32), intent(in) :: number_of_nonzero_coupling_matrix_elements number of non-zero terms in the sum () for each non-zero element of the coupling matrix integer(kind=int32), intent(in) :: number_of_nonzero_coupling_coefficients number of all non-zero algberaix coefficients in the whole coupling matrix integer(kind=int32), intent(in) :: nonzero_terms_per_element (number_of_nonzero_coupling_matrix_elements) keeps the number of non-zero terms in the sum (Eq. (6.21)) for\neach non-zero element of W/V integer(kind=int32), intent(in) :: nonzero_legendre_indices (number_of_nonzero_coupling_coefficients) holds the proper indices pointing to l1/l2/lltabs, which\ncorrespond to the non-vanishing elements of the sum  (Eq. (6.21))\nfor each non-zero element of W/V real(kind=dp), intent(in) :: nonzero_coupling_coefficients (number_of_nonzero_coupling_coefficients) holds the values of the non-zero algebraic coefficients integer(kind=int32), intent(in) :: nsteps number of steps from rmin to rmax integer(kind=int32), intent(in) :: number_of_channels size of the basis integer(kind=int32), intent(in) :: jj total angular momentum real(kind=dp), intent(inout) :: log_der_matrix (:,:) resulting log-derivative matrix at RMAX public  subroutine pes_contribution (number_of_channels, jj, r, channels_level_indices, channels_omega_values, number_of_nonzero_coupling_matrix_elements, number_of_nonzero_coupling_coefficients, nonzero_terms_per_element, nonzero_legendre_indices, nonzero_coupling_coefficients, vmatrix) calculates the contribution from the PES in (X) at given R Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: number_of_channels size of the basis integer(kind=int32), intent(in) :: jj total angular momentum real(kind=dp), intent(in) :: r intermolecular distance integer(kind=int32), intent(in) :: channels_level_indices (number_of_channels) holds the indices pointing to the basis arrays integer(kind=int32), intent(in) :: channels_omega_values (number_of_channels) holds all values of \\bar{\\Omega} integer(kind=int32), intent(in) :: number_of_nonzero_coupling_matrix_elements number of non-zero terms in the sum () for each non-zero element of the coupling matrix integer(kind=int32), intent(in) :: number_of_nonzero_coupling_coefficients number of all non-zero algberaix coefficients in the whole coupling matrix integer(kind=int32), intent(in) :: nonzero_terms_per_element (number_of_nonzero_coupling_matrix_elements) keeps the number of non-zero terms in the sum (Eq. (6.21)) for\neach non-zero element of W/V integer(kind=int32), intent(in) :: nonzero_legendre_indices (number_of_nonzero_coupling_coefficients) holds the proper indices pointing to l1/l2/lltabs, which\ncorrespond to the non-vanishing elements of the sum  (Eq. (6.21))\nfor each non-zero element of W/V real(kind=dp), intent(in) :: nonzero_coupling_coefficients (number_of_nonzero_coupling_coefficients) holds the values of the non-zero algebraic coefficients real(kind=dp), intent(out) :: vmatrix (number_of_channels,number_of_channels) (output) - the PES contribution to the coupling matrix","tags":"","loc":"module/propagators.html"},{"title":"utility_functions_mod – the SCATTERING code","text":"utility_functions_mod contains functions which handle writing \nmessages/errors/warnings on screen, formatting headers, summary of the \ncalculations and a few other supporting functions. Uses iso_fortran_env module~~utility_functions_mod~~UsesGraph module~utility_functions_mod utility_functions_mod iso_fortran_env iso_fortran_env module~utility_functions_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~utility_functions_mod~~UsedByGraph module~utility_functions_mod utility_functions_mod module~io_mod io_mod module~io_mod->module~utility_functions_mod module~statetostatexs statetostateXS module~statetostatexs->module~utility_functions_mod module~statetostatexs->module~io_mod module~math_functions_mod math_functions_mod module~math_functions_mod->module~utility_functions_mod module~coupling_matrix_mod coupling_matrix_mod module~coupling_matrix_mod->module~utility_functions_mod module~coupling_matrix_mod->module~io_mod module~coupling_matrix_mod->module~math_functions_mod module~unitarity_check_mod unitarity_check_mod module~unitarity_check_mod->module~utility_functions_mod module~unitarity_check_mod->module~io_mod module~boundary_conditions_mod boundary_conditions_mod module~boundary_conditions_mod->module~utility_functions_mod module~boundary_conditions_mod->module~io_mod module~boundary_conditions_mod->module~math_functions_mod module~channels_mod channels_mod module~channels_mod->module~utility_functions_mod module~channels_mod->module~io_mod module~array_operations_fill_symmetric_matrix_submod array_operations_fill_symmetric_matrix_submod module~array_operations_fill_symmetric_matrix_submod->module~utility_functions_mod program~scattering SCATTERING program~scattering->module~utility_functions_mod program~scattering->module~io_mod program~scattering->module~statetostatexs program~scattering->module~coupling_matrix_mod program~scattering->module~unitarity_check_mod program~scattering->module~boundary_conditions_mod program~scattering->module~channels_mod module~radial_coupling_terms_mod radial_coupling_terms_mod program~scattering->module~radial_coupling_terms_mod module~propagators PROPAGATORS program~scattering->module~propagators module~radial_coupling_terms_mod->module~utility_functions_mod module~radial_coupling_terms_mod->module~io_mod module~radial_coupling_terms_mod->module~math_functions_mod module~propagators->module~io_mod module~propagators->module~radial_coupling_terms_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces incorrect_value Functions float_to_character integer_to_character to_lowercase Subroutines alloc_status file_io_status time_count_summary write_error write_header write_message write_warning Interfaces public        interface incorrect_value interface for the following message: incorrect value encountered:\n  variable_name = variable_value private  subroutine incorrect_value_ch(name_, value_, unit_) incorrect value encountered:\n  variable_name = variable_value Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name_ name of the variable character(len=*), intent(in) :: value_ value of the variable integer(kind=int32), intent(in), optional :: unit_ optional, unit where the message will be written private  subroutine incorrect_value_int32(name_, value_, unit_) incorrect value encountered:\n  variable_name = variable_value Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name_ name of the variable integer(kind=int32), intent(in) :: value_ value of the variable integer(kind=int32), intent(in), optional :: unit_ optional, unit where the message will be written private  subroutine incorrect_value_sp(name_, value_, unit_) incorrect value encountered:\n  variable_name = variable_value Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name_ name of the variable real(kind=sp), intent(in) :: value_ value of the variable integer(kind=int32), intent(in), optional :: unit_ optional, unit where the message will be written private  subroutine incorrect_value_dp(name_, value_, unit_) incorrect value encountered:\n  variable_name = variable_value Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name_ name of the variable real(kind=dp), intent(in) :: value_ value of the variable integer(kind=int32), intent(in), optional :: unit_ optional, unit where the message will be written Functions public  function float_to_character (f, format_string) result(res) Converts a floating-point number to a character string. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: f input floating-point number character(len=*), intent(in), optional :: format_string Optional format string. Return Value character(len=64) Output character string. public  function integer_to_character (i) result(res) transfers integer to a character Arguments Type Intent Optional Attributes Name integer, intent(in) :: i input integer Return Value character(len=32) output character public  function to_lowercase (str) result(low_str) forces lowercase on given string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str input string Return Value character(len=len) output (lowercase) string Subroutines public  subroutine alloc_status (istat_, message_, op_, unit_) check the status after allocation Arguments Type Intent Optional Attributes Name integer(kind=int32) :: istat_ result of stat=istat in (de)allocate character(len=*), intent(in) :: message_ a message to be written character(len=1), intent(in) :: op_ 'a' for allocation, 'd' for deallocation integer(kind=int32), intent(in), optional :: unit_ optional, unit where the message will be written public  subroutine file_io_status (istat_, iomsg_, channel_, op_, unit_) check the status during various io operations on files Arguments Type Intent Optional Attributes Name integer(kind=int32) :: istat_ result of iostat in open/read/write/close character(len=*), intent(in) :: iomsg_ result of iomsg in open/read/write/close integer(kind=int32), intent(in) :: channel_ name of the file character(len=1), intent(in) :: op_ 'o' for opening of the file, 'r' for reading, 'w' for writing,\n'c' for closing integer(kind=int32), intent(in), optional :: unit_ optional, unit where the message will be written public  subroutine time_count_summary (start_, stop_, time_, message_) print the message about the time it took to complete a single task Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: start_ initial time real(kind=dp), intent(in) :: stop_ final time real(kind=dp), intent(out) :: time_ stop_ - start_ character(len=*), intent(in), optional :: message_ (optional) a message to print instead of a default\n\"Completed in ... s\" public  subroutine write_error (message_, unit_) writes an error message on a chosen unit Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message_ a message to be written integer(kind=int32), intent(in), optional :: unit_ optional, unit where the message will be written public  subroutine write_header (header_type, opt_integer_) writes headers on screen Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: header_type specifies the type of the header: 'main', 'input_read',\n'input_check', 'input_summary', 'initialization', 'check_norm',\n'save_basis', 'save_pes', 'radial_terms', 'save_radial_terms',\n'reconstruction' integer(kind=int32), intent(in), optional :: opt_integer_ optional integer used in case \"block\" to pass jtot value public  subroutine write_message (message_, unit_) writes a message on a chosen unit Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message_ a message to be written integer(kind=int32), intent(in), optional :: unit_ optional, unit where the message will be written public  subroutine write_warning (message_, unit_) writes a warning message on a chosen unit Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message_ a message to be written integer(kind=int32), intent(in), optional :: unit_ optional, unit where the message will be written","tags":"","loc":"module/utility_functions_mod.html"},{"title":"channels_mod – the SCATTERING code","text":"This module provides subroutines that set the number of channels in the\nblock, save quantum numbers for each channel (both in body- and space-fixed\ncases) and print quantum numbers on screen Uses iso_fortran_env io_mod utility_functions_mod module~~channels_mod~~UsesGraph module~channels_mod channels_mod iso_fortran_env iso_fortran_env module~channels_mod->iso_fortran_env module~utility_functions_mod utility_functions_mod module~channels_mod->module~utility_functions_mod module~io_mod io_mod module~channels_mod->module~io_mod module~utility_functions_mod->iso_fortran_env module~io_mod->iso_fortran_env module~io_mod->module~utility_functions_mod module~array_operations_mod array_operations_mod module~io_mod->module~array_operations_mod module~array_operations_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~channels_mod~~UsedByGraph module~channels_mod channels_mod program~scattering SCATTERING program~scattering->module~channels_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Functions calculate_largest_wavenumber count_open_channels_in_block Subroutines print_channels set_body_fixed_channels set_number_of_channels set_space_fixed_channels Functions public  function calculate_largest_wavenumber (channels_level_indices) result(largest_wavenumber_) Calculates the largest wave number in the block;\ncalled only if there are any open channels Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: channels_level_indices (:) holds the indices pointing to the basis arrays Return Value real(kind=dp) (output) the largest wave number (wavmax) in the block public  function count_open_channels_in_block (channels_level_indices) result(number_of_open_channels_) counts the energetically accessible channels in the given block Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: channels_level_indices (:) holds the indices pointing to the basis arrays Return Value integer(kind=int32) (output) number of open channels Subroutines public  subroutine print_channels (parity_exponent_, channels_level_indices, channels_omega_values) prints information about body-fixed channels on screen Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: parity_exponent_ parity exponent of the block (0 if p = +1, 1 if p = -1) integer(kind=int32), intent(inout) :: channels_level_indices (:) holds the indices pointing to the basis arrays integer(kind=int32), intent(inout) :: channels_omega_values (:) holds all values of \\bar{\\Omega} public  subroutine set_body_fixed_channels (total_angular_momentum_, parity_exponent_, channels_level_indices, channels_omega_values) Prepares the channels_level_indices array which holds indices that refer to the\nbasis arrays: v1level/j1level/elevel, and channels_omega_values which holds values\nof \\bar{\\Omega} Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: total_angular_momentum_ total angular momentum integer(kind=int32), intent(in) :: parity_exponent_ parity exponent of the block (0 if p = +1, 1 if p = -1) integer(kind=int32), intent(inout) :: channels_level_indices (:) holds the indices pointing to the basis arrays integer(kind=int32), intent(inout) :: channels_omega_values (:) holds all values of \\bar{\\Omega} public  subroutine set_number_of_channels (total_angular_momentum_, number_of_channels_even_parity_block, number_of_channels_odd_parity_block) determine the number of scattering channels in each parity block \nfor given total angular momentum in both body-fixed and\nspace-fixed frames Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: total_angular_momentum_ total angular momentum integer(kind=int32), intent(out) :: number_of_channels_even_parity_block number of channels in the p = 1 (even parity) block integer(kind=int32), intent(out) :: number_of_channels_odd_parity_block number of channels in the p = -1 (odd parity) block public  subroutine set_space_fixed_channels (total_angular_momentum_, parity_exponent_, channels_l_values) Prepares the channels_l_values array which holds values of\norbital angular momentum, l, a space-fixed-frame quantum number. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: total_angular_momentum_ total angular momentum integer(kind=int32), intent(in) :: parity_exponent_ parity exponent of the block (0 if p = +1, 1 if p = -1) integer(kind=int32), intent(inout) :: channels_l_values (:) holds all values of l","tags":"","loc":"module/channels_mod.html"},{"title":"array_operations_invert_symmetric_matrix_submod – the SCATTERING code","text":"a submodule for append subroutines Uses Ancestors: array_operations_mod module~~array_operations_invert_symmetric_matrix_submod~~UsesGraph module~array_operations_invert_symmetric_matrix_submod array_operations_invert_symmetric_matrix_submod module~array_operations_mod array_operations_mod module~array_operations_invert_symmetric_matrix_submod->module~array_operations_mod iso_fortran_env iso_fortran_env module~array_operations_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"module/array_operations_invert_symmetric_matrix_submod.html"},{"title":"array_operations_append_submod – the SCATTERING code","text":"a submodule for append subroutines Uses Ancestors: array_operations_mod module~~array_operations_append_submod~~UsesGraph module~array_operations_append_submod array_operations_append_submod module~array_operations_mod array_operations_mod module~array_operations_append_submod->module~array_operations_mod iso_fortran_env iso_fortran_env module~array_operations_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"module/array_operations_append_submod.html"},{"title":"array_operations_fill_symmetric_matrix_submod – the SCATTERING code","text":"a submodule for append subroutines Uses utility_functions_mod Ancestors: array_operations_mod module~~array_operations_fill_symmetric_matrix_submod~~UsesGraph module~array_operations_fill_symmetric_matrix_submod array_operations_fill_symmetric_matrix_submod module~utility_functions_mod utility_functions_mod module~array_operations_fill_symmetric_matrix_submod->module~utility_functions_mod module~array_operations_mod array_operations_mod module~array_operations_fill_symmetric_matrix_submod->module~array_operations_mod iso_fortran_env iso_fortran_env module~utility_functions_mod->iso_fortran_env module~array_operations_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"module/array_operations_fill_symmetric_matrix_submod.html"},{"title":"array_operations_allocate_submod – the SCATTERING code","text":"a submodule for allocate subroutines Uses Ancestors: array_operations_mod module~~array_operations_allocate_submod~~UsesGraph module~array_operations_allocate_submod array_operations_allocate_submod module~array_operations_mod array_operations_mod module~array_operations_allocate_submod->module~array_operations_mod iso_fortran_env iso_fortran_env module~array_operations_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"module/array_operations_allocate_submod.html"},{"title":"SCATTERING – the SCATTERING code","text":"Uses unitarity_check_mod utility_functions_mod coupling_matrix_mod channels_mod PROPAGATORS boundary_conditions_mod io_mod statetostateXS array_operations_mod radial_coupling_terms_mod iso_fortran_env program~~scattering~~UsesGraph program~scattering SCATTERING module~unitarity_check_mod unitarity_check_mod program~scattering->module~unitarity_check_mod module~coupling_matrix_mod coupling_matrix_mod program~scattering->module~coupling_matrix_mod module~propagators PROPAGATORS program~scattering->module~propagators module~channels_mod channels_mod program~scattering->module~channels_mod module~boundary_conditions_mod boundary_conditions_mod program~scattering->module~boundary_conditions_mod module~io_mod io_mod program~scattering->module~io_mod module~statetostatexs statetostateXS program~scattering->module~statetostatexs module~utility_functions_mod utility_functions_mod program~scattering->module~utility_functions_mod module~array_operations_mod array_operations_mod program~scattering->module~array_operations_mod module~radial_coupling_terms_mod radial_coupling_terms_mod program~scattering->module~radial_coupling_terms_mod iso_fortran_env iso_fortran_env program~scattering->iso_fortran_env module~unitarity_check_mod->module~io_mod module~unitarity_check_mod->module~utility_functions_mod module~unitarity_check_mod->iso_fortran_env module~coupling_matrix_mod->module~io_mod module~coupling_matrix_mod->module~utility_functions_mod module~coupling_matrix_mod->iso_fortran_env module~math_functions_mod math_functions_mod module~coupling_matrix_mod->module~math_functions_mod module~propagators->module~io_mod module~propagators->module~array_operations_mod module~propagators->module~radial_coupling_terms_mod module~propagators->iso_fortran_env module~channels_mod->module~io_mod module~channels_mod->module~utility_functions_mod module~channels_mod->iso_fortran_env module~boundary_conditions_mod->module~io_mod module~boundary_conditions_mod->module~utility_functions_mod module~boundary_conditions_mod->module~array_operations_mod module~boundary_conditions_mod->iso_fortran_env module~boundary_conditions_mod->module~math_functions_mod fwigxjpf fwigxjpf module~boundary_conditions_mod->fwigxjpf module~io_mod->module~utility_functions_mod module~io_mod->module~array_operations_mod module~io_mod->iso_fortran_env module~statetostatexs->module~io_mod module~statetostatexs->module~utility_functions_mod module~statetostatexs->iso_fortran_env module~utility_functions_mod->iso_fortran_env module~array_operations_mod->iso_fortran_env module~radial_coupling_terms_mod->module~io_mod module~radial_coupling_terms_mod->module~utility_functions_mod module~radial_coupling_terms_mod->iso_fortran_env module~radial_coupling_terms_mod->module~math_functions_mod module~math_functions_mod->module~utility_functions_mod module~math_functions_mod->iso_fortran_env module~special_functions_mod special_functions_mod module~math_functions_mod->module~special_functions_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Calls program~~scattering~~CallsGraph program~scattering SCATTERING proc~integer_to_character integer_to_character program~scattering->proc~integer_to_character proc~set_space_fixed_channels set_space_fixed_channels program~scattering->proc~set_space_fixed_channels proc~etotal ETOTAL program~scattering->proc~etotal proc~set_body_fixed_channels set_body_fixed_channels program~scattering->proc~set_body_fixed_channels proc~print_coupling_matrix_elements_summary print_coupling_matrix_elements_summary program~scattering->proc~print_coupling_matrix_elements_summary proc~calculate_largest_wavenumber calculate_largest_wavenumber program~scattering->proc~calculate_largest_wavenumber proc~calculate_k_matrix calculate_k_matrix program~scattering->proc~calculate_k_matrix proc~calculate_s_matrix calculate_s_matrix program~scattering->proc~calculate_s_matrix proc~crosssection CROSSSECTION program~scattering->proc~crosssection fwig_table_free fwig_table_free program~scattering->fwig_table_free fwig_table_init fwig_table_init program~scattering->fwig_table_init fwig_temp_init fwig_temp_init program~scattering->fwig_temp_init proc~file_io_status file_io_status program~scattering->proc~file_io_status proc~count_open_basis_levels count_open_basis_levels program~scattering->proc~count_open_basis_levels proc~prepare_coupling_matrix_elements prepare_coupling_matrix_elements program~scattering->proc~prepare_coupling_matrix_elements interface~allocate_2d allocate_2d program~scattering->interface~allocate_2d proc~numerov numerov program~scattering->proc~numerov proc~calculate_sf_matrix_from_bf_matrix calculate_sf_matrix_from_bf_matrix program~scattering->proc~calculate_sf_matrix_from_bf_matrix proc~read_radial_coupling_terms read_radial_coupling_terms program~scattering->proc~read_radial_coupling_terms proc~reduce_radial_coupling_terms reduce_radial_coupling_terms program~scattering->proc~reduce_radial_coupling_terms interface~allocate_1d allocate_1d program~scattering->interface~allocate_1d proc~write_message write_message program~scattering->proc~write_message proc~units_conversion units_conversion program~scattering->proc~units_conversion proc~interpolate_radial_coupling_terms interpolate_radial_coupling_terms program~scattering->proc~interpolate_radial_coupling_terms proc~print_channels print_channels program~scattering->proc~print_channels proc~check_nonzero_coupling_matrix_elements check_nonzero_coupling_matrix_elements program~scattering->proc~check_nonzero_coupling_matrix_elements proc~float_to_character float_to_character program~scattering->proc~float_to_character proc~check_dtol_otol check_dtol_otol program~scattering->proc~check_dtol_otol proc~set_number_of_channels set_number_of_channels program~scattering->proc~set_number_of_channels proc~count_open_channels_in_block count_open_channels_in_block program~scattering->proc~count_open_channels_in_block fwig_temp_free fwig_temp_free program~scattering->fwig_temp_free proc~read_input_file read_input_file program~scattering->proc~read_input_file proc~write_header write_header program~scattering->proc~write_header proc~save_open_basis_levels save_open_basis_levels program~scattering->proc~save_open_basis_levels proc~time_count_summary time_count_summary program~scattering->proc~time_count_summary proc~unitarity_check unitarity_check program~scattering->proc~unitarity_check interface~append append program~scattering->interface~append proc~print_largest_partial_xs print_largest_partial_xs program~scattering->proc~print_largest_partial_xs proc~write_error write_error proc~set_space_fixed_channels->proc~write_error proc~print_coupling_matrix_elements_summary->proc~integer_to_character proc~print_coupling_matrix_elements_summary->proc~write_message proc~wavenumber_from_energy wavenumber_from_energy proc~calculate_largest_wavenumber->proc~wavenumber_from_energy proc~is_open is_open proc~calculate_largest_wavenumber->proc~is_open dgesv dgesv proc~calculate_k_matrix->dgesv proc~modified_bessel_k_ratio modified_bessel_k_ratio proc~calculate_k_matrix->proc~modified_bessel_k_ratio proc~calculate_k_matrix->proc~wavenumber_from_energy proc~riccati_bessel_y riccati_bessel_y proc~calculate_k_matrix->proc~riccati_bessel_y dgemm dgemm proc~calculate_k_matrix->dgemm proc~riccati_bessel_j riccati_bessel_j proc~calculate_k_matrix->proc~riccati_bessel_j proc~calculate_k_matrix->proc~is_open interface~invert_symmetric_matrix invert_symmetric_matrix proc~calculate_s_matrix->interface~invert_symmetric_matrix proc~calculate_s_matrix->dgemm interface~fill_symmetric_matrix fill_symmetric_matrix proc~calculate_s_matrix->interface~fill_symmetric_matrix proc~crosssection->interface~allocate_1d proc~crosssection->proc~time_count_summary proc~file_io_status->proc~integer_to_character proc~file_io_status->proc~write_error proc~count_open_basis_levels->proc~is_open proc~process_single_matrix_element process_single_matrix_element proc~prepare_coupling_matrix_elements->proc~process_single_matrix_element proc~numerov->proc~etotal proc~numerov->interface~allocate_2d proc~numerov->proc~write_message proc~numerov->proc~float_to_character proc~calculate_log_der_matrix calculate_log_der_matrix proc~numerov->proc~calculate_log_der_matrix proc~numerov->interface~invert_symmetric_matrix proc~numerov->interface~fill_symmetric_matrix proc~cenitrfugal_matrix cenitrfugal_matrix proc~numerov->proc~cenitrfugal_matrix proc~pes_contribution pes_contribution proc~numerov->proc~pes_contribution proc~read_radial_coupling_terms->proc~file_io_status proc~reduce_radial_coupling_terms->proc~integer_to_character proc~reduce_radial_coupling_terms->proc~write_message proc~spline spline proc~interpolate_radial_coupling_terms->proc~spline proc~print_channels->proc~write_message proc~print_channels->proc~wavenumber_from_energy proc~print_channels->proc~is_open proc~zero_projections_3j_condition zero_projections_3j_condition proc~check_nonzero_coupling_matrix_elements->proc~zero_projections_3j_condition proc~count_open_channels_in_block->proc~is_open proc~read_input_file->proc~file_io_status proc~read_input_file->interface~allocate_1d interface~allocate_3d allocate_3d proc~read_input_file->interface~allocate_3d proc~input_summary input_summary proc~read_input_file->proc~input_summary proc~input_check input_check proc~read_input_file->proc~input_check proc~write_header->proc~write_message interface~incorrect_value incorrect_value proc~write_header->interface~incorrect_value proc~write_header->proc~write_error proc~save_open_basis_levels->proc~wavenumber_from_energy proc~save_open_basis_levels->proc~is_open proc~time_count_summary->proc~write_message proc~unitarity_check->proc~write_header proc~handle_unitarity_output_message handle_unitarity_output_message proc~unitarity_check->proc~handle_unitarity_output_message proc~calculate_sum_of_squares_for_each_channel calculate_sum_of_squares_for_each_channel proc~unitarity_check->proc~calculate_sum_of_squares_for_each_channel proc~check_unitarity_for_each_channel check_unitarity_for_each_channel proc~unitarity_check->proc~check_unitarity_for_each_channel proc~print_largest_partial_xs->proc~integer_to_character proc~print_largest_partial_xs->proc~write_message proc~print_largest_partial_xs->proc~float_to_character proc~calculate_log_der_matrix->interface~invert_symmetric_matrix proc~calculate_log_der_matrix->dgemm proc~calculate_log_der_matrix->interface~fill_symmetric_matrix proc~write_error->proc~write_message proc~modified_bessel_k_ratio->proc~integer_to_character proc~ikv ikv proc~modified_bessel_k_ratio->proc~ikv proc~write_warning write_warning proc~modified_bessel_k_ratio->proc~write_warning proc~handle_unitarity_output_message->proc~write_message proc~handle_unitarity_output_message->proc~write_warning proc~wavenumber_from_energy->proc~etotal proc~wavenumber_from_energy->proc~write_error proc~riccati_bessel_y->proc~integer_to_character proc~riccati_bessel_y->proc~write_warning proc~rcty rcty proc~riccati_bessel_y->proc~rcty proc~process_single_matrix_element->proc~zero_projections_3j_condition proc~percival_seaton_coefficient percival_seaton_coefficient proc~process_single_matrix_element->proc~percival_seaton_coefficient proc~spline->proc~integer_to_character proc~spline->proc~write_error proc~riccati_bessel_j->proc~integer_to_character proc~riccati_bessel_j->proc~write_warning proc~rctj rctj proc~riccati_bessel_j->proc~rctj proc~cenitrfugal_matrix->interface~fill_symmetric_matrix dfloat dfloat proc~cenitrfugal_matrix->dfloat proc~is_open->proc~etotal proc~pes_contribution->interface~fill_symmetric_matrix proc~get_radial_coupling_term_value get_radial_coupling_term_value proc~pes_contribution->proc~get_radial_coupling_term_value proc~is_sum_even is_sum_even proc~zero_projections_3j_condition->proc~is_sum_even proc~triangle_inequality_holds triangle_inequality_holds proc~zero_projections_3j_condition->proc~triangle_inequality_holds proc~input_summary->proc~integer_to_character proc~input_summary->proc~etotal proc~input_summary->proc~write_message proc~input_summary->proc~float_to_character proc~input_check->proc~integer_to_character proc~input_check->proc~write_message proc~input_check->interface~incorrect_value proc~input_check->proc~write_error proc~msta1 msta1 proc~ikv->proc~msta1 proc~msta2 msta2 proc~ikv->proc~msta2 fwig3jj fwig3jj proc~percival_seaton_coefficient->fwig3jj proc~write_warning->proc~write_message proc~rctj->proc~msta1 proc~rctj->proc~msta2 proc~ispline ispline proc~get_radial_coupling_term_value->proc~ispline proc~envj envj proc~msta1->proc~envj proc~ispline->proc~float_to_character proc~ispline->proc~write_warning proc~msta2->proc~envj Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables BF_log_der_matrix SF_log_der_matrix channels_l_values channels_level_indices channels_omega_values err_message iblock icheck icount icount2 ij ilevel io_status iomega iopen iopen2 isize_ isize_2 jinddiag jindoff1 jindoff2 jtot_ k_matrix largest_wavevector len_even len_odd lmat_len lmax lmin ltmp maxXSdiag maxXSoff ncacdiag ncacoff nonzero_coupling_coefficients nonzero_legendre_indices nonzero_terms_per_element nsteps number_of_channels number_of_nonzero_coupling_coefficients number_of_nonzero_coupling_matrix_elements number_of_open_basis_levels number_of_open_channels omegamax open_basis_levels open_basis_wavevectors parity_exponent parity_exponenttmp partial_line s_matrix_imag s_matrix_real size_even size_odd smatcheckarr terminate time_coupling time_coupling_start time_coupling_stop time_init time_init_stop time_jtot time_jtot_start time_jtot_stop time_parity time_parity_start time_parity_stop time_total time_total_start time_total_stop unitarity_block_check wavvdepth wv xs_block xs_jtot xs_line xs_total Source Code SCATTERING Variables Type Attributes Name Initial real(kind=dp), allocatable :: BF_log_der_matrix (:,:) real(kind=dp), allocatable :: SF_log_der_matrix (:,:) integer, allocatable :: channels_l_values (:) integer, allocatable :: channels_level_indices (:) integer, allocatable :: channels_omega_values (:) character(len=200) :: err_message integer(kind=int32) :: iblock integer(kind=int32) :: icheck integer(kind=int32) :: icount integer(kind=int32) :: icount2 integer(kind=int32) :: ij integer(kind=int32) :: ilevel integer(kind=int32) :: io_status integer(kind=int32) :: iomega integer(kind=int32) :: iopen integer(kind=int32) :: iopen2 integer(kind=int32) :: isize_ integer(kind=int32) :: isize_2 integer(kind=int32) :: jinddiag integer(kind=int32) :: jindoff1 integer(kind=int32) :: jindoff2 integer(kind=int32) :: jtot_ real(kind=dp), allocatable :: k_matrix (:,:) real(kind=dp) :: largest_wavevector integer(kind=int32) :: len_even integer(kind=int32) :: len_odd integer(kind=int32) :: lmat_len integer(kind=int32) :: lmax integer(kind=int32) :: lmin integer(kind=int32) :: ltmp real(kind=dp) :: maxXSdiag real(kind=dp) :: maxXSoff integer(kind=int32) :: ncacdiag integer(kind=int32) :: ncacoff real(kind=dp), allocatable :: nonzero_coupling_coefficients (:) integer, allocatable :: nonzero_legendre_indices (:) integer, allocatable :: nonzero_terms_per_element (:) integer(kind=int32) :: nsteps integer(kind=int32) :: number_of_channels integer(kind=int32) :: number_of_nonzero_coupling_coefficients integer(kind=int32) :: number_of_nonzero_coupling_matrix_elements integer(kind=int32) :: number_of_open_basis_levels integer(kind=int32) :: number_of_open_channels integer(kind=int32) :: omegamax integer, allocatable :: open_basis_levels (:) real(kind=dp), allocatable :: open_basis_wavevectors (:) integer(kind=int32) :: parity_exponent integer(kind=int32) :: parity_exponenttmp character(len=200) :: partial_line real(kind=dp), allocatable :: s_matrix_imag (:,:) real(kind=dp), allocatable :: s_matrix_real (:,:) integer(kind=int32) :: size_even integer(kind=int32) :: size_odd integer, allocatable :: smatcheckarr (:) logical :: terminate real(kind=dp) :: time_coupling real(kind=dp) :: time_coupling_start real(kind=dp) :: time_coupling_stop real(kind=dp) :: time_init real(kind=dp) :: time_init_stop real(kind=dp) :: time_jtot real(kind=dp) :: time_jtot_start real(kind=dp) :: time_jtot_stop real(kind=dp) :: time_parity real(kind=dp) :: time_parity_start real(kind=dp) :: time_parity_stop real(kind=dp) :: time_total real(kind=dp) :: time_total_start real(kind=dp) :: time_total_stop logical :: unitarity_block_check real(kind=dp) :: wavvdepth real(kind=dp), allocatable :: wv (:) real(kind=dp), allocatable :: xs_block (:) real(kind=dp), allocatable :: xs_jtot (:) character(len=200) :: xs_line real(kind=dp), allocatable :: xs_total (:) Source Code program SCATTERING use , intrinsic :: iso_fortran_env , only : int32 , sp => real32 , dp => real64 use io_mod use radial_coupling_terms_mod , only : read_radial_coupling_terms , & reduce_radial_coupling_terms , interpolate_radial_coupling_terms use channels_mod , only : set_number_of_channels , set_body_fixed_channels , & set_space_fixed_channels , count_open_channels_in_block , & calculate_largest_wavenumber , print_channels use coupling_matrix_mod use PROPAGATORS use boundary_conditions_mod , only : calculate_sf_matrix_from_bf_matrix , & calculate_k_matrix , calculate_s_matrix use unitarity_check_mod , only : unitarity_check use statetostateXS use utility_functions_mod , only : write_header , file_io_status , & write_message , float_to_character , integer_to_character , time_count_summary use array_operations_mod , only : append !---------------------------------------------------------------------------! implicit none !---------------------------------------------------------------------------! character ( len = 200 ) :: err_message , partial_line , xs_line integer ( int32 ) :: number_of_nonzero_coupling_matrix_elements , & number_of_nonzero_coupling_coefficients , number_of_channels , size_even , & size_odd , number_of_open_basis_levels , iblock , jtot_ , parity_exponent , & parity_exponenttmp , nsteps , number_of_open_channels , ncacdiag , ncacoff , & omegamax , lmin , lmax , ltmp , lmat_len , len_even , len_odd , jinddiag , & jindoff1 , jindoff2 , ij , ilevel , iomega , iopen , iopen2 , isize_ , isize_2 , & icheck , icount , icount2 , io_status real ( dp ) :: largest_wavevector , wavvdepth , maxXSdiag , maxXSoff , time_total_start , & time_total_stop , time_total , time_init_stop , time_init , time_jtot_start , & time_jtot_stop , time_jtot , time_parity_start , time_parity_stop , & time_parity , time_coupling_start , time_coupling_stop , time_coupling logical :: unitarity_block_check , terminate integer , allocatable :: channels_level_indices (:), channels_omega_values (:),& channels_l_values (:), open_basis_levels (:), nonzero_terms_per_element (:),& nonzero_legendre_indices (:), smatcheckarr (:) real ( dp ), allocatable :: wv (:), open_basis_wavevectors (:), & nonzero_coupling_coefficients (:), xs_total (:), xs_block (:), xs_jtot (:) real ( dp ), allocatable :: BF_log_der_matrix (:,:), SF_log_der_matrix (:,:), & k_matrix (:,:), s_matrix_real (:,:), s_matrix_imag (:,:) !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! ! Initizalization: start the time count !---------------------------------------------------------------------------! call cpu_time ( time_total_start ) !---------------------------------------------------------------------------! ! Initialize fwigxjpf library !---------------------------------------------------------------------------! call fwig_table_init ( 2 * 100 , 9 ) call fwig_temp_init ( 2 * 100 ) !---------------------------------------------------------------------------! ! Print the header !---------------------------------------------------------------------------! call write_header ( \"main\" ) !---------------------------------------------------------------------------! ! Read the input file !---------------------------------------------------------------------------! call read_input_file !---------------------------------------------------------------------------! ! S-matrix file: write input parameters and basis levels !---------------------------------------------------------------------------! open ( 11 , file = trim ( smatrixfile ), form = 'unformatted' , iostat = io_status , & iomsg = err_message ) call file_io_status ( io_status , err_message , 11 , \"o\" ) !---------------------------------------------------------------------------! write ( 11 ) label , 2 , nlevel , reducedmass write ( 11 ) ( v1array ( ilevel ), j1array ( ilevel ), ilevel = 1 , nlevel ) write ( 11 ) ( elevel ( ilevel ), ilevel = 1 , nlevel ) write ( 11 ) initial , energy !---------------------------------------------------------------------------! ! Prepare the file with the partial XS !---------------------------------------------------------------------------! if ( parity_exponent == 1 ) then open ( 12 , file = trim ( partialfile ), form = 'formatted' , status = 'unknown' , & iostat = io_status , iomsg = err_message ) call file_io_status ( io_status , err_message , 12 , \"o\" ) !------------------------------------------------------------------------! call write_message ( \"  jtot  iblock  v1_f  j1_f  <-  v1_i  j1_i'\" // & repeat ( \" \" , 14 ) // \"K.E.\" // repeat ( \" \" , 16 ) // \"XS\" , unit_ = 12 ) !------------------------------------------------------------------------! endif !---------------------------------------------------------------------------! ! Convert units: starting now, everything is in atomic units !---------------------------------------------------------------------------! call units_conversion !---------------------------------------------------------------------------! ! Read the radial terms of the potential from external file !---------------------------------------------------------------------------! call read_radial_coupling_terms !---------------------------------------------------------------------------! ! Reduce matrix elements that are not needed !---------------------------------------------------------------------------! call reduce_radial_coupling_terms !---------------------------------------------------------------------------! ! Interpolate radial terms !---------------------------------------------------------------------------! call interpolate_radial_coupling_terms !---------------------------------------------------------------------------! ! Search for energetically accessible levels and prepare the arrays that are ! needed in the calculations of the state-to-state XS !---------------------------------------------------------------------------! number_of_open_basis_levels = count_open_basis_levels () call allocate_1d ( open_basis_levels , number_of_open_basis_levels ) call allocate_1d ( open_basis_wavevectors , number_of_open_basis_levels ) call save_open_basis_levels ( number_of_open_basis_levels , open_basis_levels , & open_basis_wavevectors ) !---------------------------------------------------------------------------! ! xs array summed over all blocks !---------------------------------------------------------------------------! call allocate_1d ( xs_total , & number_of_open_basis_levels * number_of_open_basis_levels ) !---------------------------------------------------------------------------! ! xs array a single JTOT value !---------------------------------------------------------------------------! call allocate_1d ( xs_jtot , & number_of_open_basis_levels * number_of_open_basis_levels ) !---------------------------------------------------------------------------! ! xs array a single parity block !---------------------------------------------------------------------------! call allocate_1d ( xs_block , & number_of_open_basis_levels * number_of_open_basis_levels ) !---------------------------------------------------------------------------! ! Initialization is finished !---------------------------------------------------------------------------! call cpu_time ( time_init_stop ) if ( prntlvl . ge . 2 ) call time_count_summary ( time_total_start , time_init_stop , & time_init , \"Initialization completed in \" ) !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! ! Prepare J-blocks !---------------------------------------------------------------------------! ! If JTOTMAX=-1 is called, iterate until convergence is achieved: ! this is managed by ncacdiag and ncacoff !---------------------------------------------------------------------------! ncacdiag = 0 ncacoff = 0 iblock = 0 terminate = . false . !---------------------------------------------------------------------------! ! Loop over total angular momentum !---------------------------------------------------------------------------! call write_message ( repeat ( \"*\" , 90 )) call write_message ( repeat ( \" \" , 28 ) // \"*** Loop over JTOT: ***\" ) !---------------------------------------------------------------------------! do jtot_ = jtotmin , jtotmax , jtotstep !------------------------------------------------------------------------! call write_header ( \"block\" , opt_integer_ = jtot_ ) !------------------------------------------------------------------------! call cpu_time ( time_jtot_start ) !------------------------------------------------------------------------! xs_jtot = 0 call set_number_of_channels ( jtot_ , size_even , size_odd ) !------------------------------------------------------------------------! do parity_exponent = 0 , 1 !---------------------------------------------------------------------! call cpu_time ( time_parity_start ) !---------------------------------------------------------------------! select case ( parity_exponent ) case ( 0 ) number_of_channels = size_even case ( 1 ) number_of_channels = size_odd end select !---------------------------------------------------------------------! if ( number_of_channels == 0 ) cycle !---------------------------------------------------------------------! ! Summary of the current block !---------------------------------------------------------------------! iblock = iblock + 1 if ( prntlvl . ge . 1 ) then call write_message ( \"Block number: \" // integer_to_character ( iblock )) call write_message ( \"jtot: \" // & trim ( adjustl ( integer_to_character ( jtot_ ))) // \" parity: \" // & trim ( adjustl ( integer_to_character (( - 1 ) ** parity_exponent ) ))) call write_message ( \"Number of scattering channels: \" // & integer_to_character ( number_of_channels )) endif !---------------------------------------------------------------------! ! Prepare of the basis for each J/p block: ! channels_omega_values holds all values of omega (BF_) ! channels_l_values holds all values of l (SF_) ! channels_level_indices holds the indices which refer to the basis arrays: !   --   v1level/j1level/elevel !---------------------------------------------------------------------! call allocate_1d ( channels_omega_values , number_of_channels ) call allocate_1d ( channels_l_values , number_of_channels ) call allocate_1d ( channels_level_indices , number_of_channels ) !---------------------------------------------------------------------! ! Prepare channels_omega_values, channels_level_indices and channels_l_values !---------------------------------------------------------------------! call set_body_fixed_channels ( jtot_ , parity_exponent , channels_level_indices , & channels_omega_values ) call set_space_fixed_channels ( jtot_ , parity_exponent , channels_l_values ) !---------------------------------------------------------------------! ! Print the BF quantum numbers on screen !---------------------------------------------------------------------! if ( prntlvl . ge . 1 ) call print_channels ( parity_exponent , & channels_level_indices , channels_omega_values ) !---------------------------------------------------------------------! ! Determine the number of open (energetically accessible) channels !---------------------------------------------------------------------! number_of_open_channels = count_open_channels_in_block ( channels_level_indices ) !---------------------------------------------------------------------! ! If there are no open channels, skip this block !---------------------------------------------------------------------! if ( number_of_open_channels == 0 ) then call write_message ( repeat ( '-' , 90 )) call write_message ( \"No open channels for block no.\" // & integer_to_character ( iblock ) ) call write_message ( repeat ( '-' , 90 )) cycle endif !---------------------------------------------------------------------! ! Determine the largest wavevector in the block !---------------------------------------------------------------------! largest_wavevector = calculate_largest_wavenumber ( channels_level_indices ) !---------------------------------------------------------------------! ! Determine the number of steps on the intermolecular (R) grid ! This is done either directly (if dr > 0) ! or through the number of steps per half de Broglie wavelength !---------------------------------------------------------------------! wavvdepth = dsqrt ( 2 * reducedmass * vdepth ) if ( dr <= 0 ) then nsteps = nint (( Rmax - Rmin ) / PI * (( largest_wavevector + wavvdepth ) * steps )) else nsteps = nint (( Rmax - Rmin ) / dr ) + 1 endif !---------------------------------------------------------------------! ! Prepare the coupling matrix !---------------------------------------------------------------------! call cpu_time ( time_coupling_start ) call check_nonzero_coupling_matrix_elements ( channels_level_indices , & channels_omega_values , number_of_nonzero_coupling_matrix_elements , & number_of_nonzero_coupling_coefficients ) call allocate_1d ( nonzero_terms_per_element , number_of_nonzero_coupling_matrix_elements ) call allocate_1d ( nonzero_coupling_coefficients , number_of_nonzero_coupling_coefficients ) call allocate_1d ( nonzero_legendre_indices , number_of_nonzero_coupling_coefficients ) call prepare_coupling_matrix_elements ( channels_level_indices , & channels_omega_values , nonzero_terms_per_element , & nonzero_legendre_indices , nonzero_coupling_coefficients ) if ( prntlvl . ge . 2 ) call print_coupling_matrix_elements_summary ( & number_of_channels , number_of_nonzero_coupling_matrix_elements , & number_of_nonzero_coupling_coefficients ) call cpu_time ( time_coupling_stop ) if ( prntlvl . ge . 2 ) call write_message ( \"Calculations of the coupling \" // & \"matrix took \" // trim ( adjustl ( float_to_character ( & time_coupling_stop - time_coupling_start , \"(E14.8)\" ))) // \" seconds\" ) !---------------------------------------------------------------------! ! Prepare the log-derivative matrix (Eqs. 6.29 and 6.43) ! and the K-matrix (Eq. 6.53) !---------------------------------------------------------------------! call allocate_2d ( BF_log_der_matrix , number_of_channels , number_of_channels ) call allocate_2d ( SF_log_der_matrix , number_of_channels , number_of_channels ) call allocate_2d ( k_matrix , number_of_open_channels , number_of_open_channels ) !---------------------------------------------------------------------! ! Call the propagator: !---------------------------------------------------------------------! call numerov ( channels_level_indices , channels_omega_values , & number_of_nonzero_coupling_matrix_elements , & number_of_nonzero_coupling_coefficients , nonzero_terms_per_element ,& nonzero_legendre_indices , nonzero_coupling_coefficients , nsteps , & number_of_channels , jtot_ , BF_log_der_matrix ) call write_message ( \"Coupled equations were solved from \" // & trim ( adjustl ( float_to_character ( Rmin , \"(F10.4)\" ))) // \" a.u. to \" // & trim ( adjustl ( float_to_character ( Rmax , \"(F10.4)\" ))) // \" a.u. in \" // & trim ( adjustl ( integer_to_character ( nsteps ))) // \" steps (dr = \" // & trim ( adjustl ( float_to_character (( rmax - rmin ) / dble ( nsteps - 1 ), & \"(E14.8)\" ))) // \" a.u.)\" ) !---------------------------------------------------------------------! ! Transform the log-derivative matrix to the SF frame !---------------------------------------------------------------------! call calculate_sf_matrix_from_bf_matrix ( number_of_channels , jtot_ , & channels_level_indices , channels_omega_values , channels_l_values , & BF_log_der_matrix , SF_log_der_matrix ) !---------------------------------------------------------------------! ! Get the K-matrix from log-derivative matrix (Eq. 6.53) !---------------------------------------------------------------------! call calculate_k_matrix ( number_of_channels , SF_log_der_matrix , & number_of_open_channels , channels_level_indices , channels_l_values ,& rmax , k_matrix ) !---------------------------------------------------------------------! ! Get the S-matrix from the K-matrix (Eq. 6.57) !---------------------------------------------------------------------! call allocate_2d ( s_matrix_real , number_of_open_channels , number_of_open_channels ) call allocate_2d ( s_matrix_imag , number_of_open_channels , number_of_open_channels ) call calculate_s_matrix ( number_of_open_channels , k_matrix , s_matrix_real , s_matrix_imag ) !---------------------------------------------------------------------! ! Array of wavevectors (necessary for the XS calculations) !---------------------------------------------------------------------! call allocate_1d ( wv , number_of_open_channels ) do iopen = 1 , number_of_open_channels wv ( iopen ) = dsqrt (( 2 * reducedmass * & ( ETOTAL () - elevel ( channels_level_indices ( iopen ))))) / bohrtoangstrom enddo !---------------------------------------------------------------------! ! S-matrix is written to the binary S-matrix file !---------------------------------------------------------------------! write ( 11 ) jtot_ , parity_exponent , number_of_open_channels write ( 11 ) ( channels_level_indices ( iopen ), channels_l_values ( iopen ),& wv ( iopen ), iopen = 1 , number_of_open_channels ) write ( 11 ) (( s_matrix_real ( iopen , iopen2 ), iopen2 = 1 , iopen ),& iopen = 1 , number_of_open_channels ) write ( 11 ) (( s_matrix_imag ( iopen , iopen2 ), iopen2 = 1 , iopen ),& iopen = 1 , number_of_open_channels ) !---------------------------------------------------------------------! ! Check if the S-matrices are unitary !---------------------------------------------------------------------! call unitarity_check ( number_of_open_channels , s_matrix_real , s_matrix_imag , unitarity_block_check ) !---------------------------------------------------------------------! ! If the unitary is not fulfilled, keep the information about this block !---------------------------------------------------------------------! if (. not .( unitarity_block_check )) then call append ( smatcheckarr , jtot_ ) endif !---------------------------------------------------------------------! ! Calculate all available cross-sections !---------------------------------------------------------------------! call CROSSSECTION ( jtot_ , number_of_open_channels , number_of_channels , & number_of_open_basis_levels , open_basis_levels , & open_basis_wavevectors , s_matrix_real , s_matrix_imag , channels_level_indices , & channels_l_values , xs_block ) !---------------------------------------------------------------------! ! Print the results from this parity block to the partial XS file ! and add the calculated partial XS to the xs_jtot array !---------------------------------------------------------------------! do icount = 1 , number_of_open_basis_levels do icount2 = 1 , number_of_open_basis_levels if ( parity_exponent == 1 ) then write ( partial_line , & \"(I6,2X,I6,2X,I4,2X,I4,6X,I4,2X,I4,2X,E16.8,2X,E16.8)\" ) & jtot_ , iblock , v1array ( open_basis_levels ( icount2 )), & j1array ( open_basis_levels ( icount2 )), & v1array ( open_basis_levels ( icount )), & j1array ( open_basis_levels ( icount )), & ( etotal () - elevel ( open_basis_levels ( icount ))) * hartreetocm , & xs_block (( icount - 1 ) * number_of_open_basis_levels + icount2 ) call write_message ( partial_line , unit_ = 12 ) endif xs_jtot (( icount - 1 ) * number_of_open_basis_levels + icount2 ) = & xs_jtot (( icount - 1 ) * number_of_open_basis_levels + icount2 ) & + xs_block (( icount - 1 ) * number_of_open_basis_levels + icount2 ) enddo enddo !---------------------------------------------------------------------! ! Check the time after each parity block: !---------------------------------------------------------------------! call cpu_time ( time_parity_stop ) if ( prntlvl . ge . 2 ) call time_count_summary ( time_parity_start , & time_parity_stop , time_parity , \"Parity block completed in \" ) !---------------------------------------------------------------------! ! ... end of the loop over parity !---------------------------------------------------------------------! call write_message ( repeat ( \" \" , 43 ) // \"***\" ) enddo !------------------------------------------------------------------------! ! Add the cross-sections from this Jtot block: !------------------------------------------------------------------------! do icount = 1 , number_of_open_basis_levels do icount2 = 1 , number_of_open_basis_levels xs_total (( icount - 1 ) * number_of_open_basis_levels + icount2 ) = & xs_total (( icount - 1 ) * number_of_open_basis_levels + icount2 ) & + xs_jtot (( icount - 1 ) * number_of_open_basis_levels + icount2 ) enddo enddo !------------------------------------------------------------------------! ! Determine the largest partial elastic/inelastic XS in this Jtot block: !------------------------------------------------------------------------! jinddiag = 0 jindoff1 = 0 jindoff2 = 0 maxXSdiag = 0.0_dp maxXSoff = 0.0_dp do icount = 1 , number_of_open_basis_levels do icount2 = 1 , number_of_open_basis_levels if ( open_basis_levels ( icount2 ) == open_basis_levels ( icount )) then if (( xs_jtot (( icount - 1 ) * number_of_open_basis_levels + icount2 )). gt . maxXSdiag ) then maxXSdiag = xs_jtot (( icount - 1 ) * number_of_open_basis_levels + icount2 ) jinddiag = icount endif else if (( xs_jtot (( icount - 1 ) * number_of_open_basis_levels + icount2 )). gt . maxXSoff ) then maxXSoff = xs_jtot (( icount - 1 ) * number_of_open_basis_levels + icount2 ) jindoff1 = icount jindoff2 = icount2 endif endif enddo enddo !-----------------------------------------------------------------------! call print_largest_partial_xs ( jtot_ , maxXSdiag , maxXSoff , jinddiag , & jindoff1 , jindoff2 , number_of_open_basis_levels , open_basis_levels ) !-----------------------------------------------------------------------! if ( jtotmax == 999999 ) then call check_dtol_otol ( maxXSdiag , maxXSoff , ncacdiag , ncacoff , terminate ) endif !------------------------------------------------------------------------! ! Check the time after each JTOT block: !------------------------------------------------------------------------! call cpu_time ( time_jtot_stop ) !------------------------------------------------------------------------! ! Print all the XS after current JTOT block !------------------------------------------------------------------------! if ( prntlvl . ge . 3 ) then call write_message ( \"Cross sections for J: \" // & trim ( adjustl ( integer_to_character ( jtot_ ))) // \" and energy: \" // & trim ( adjustl ( float_to_character ( ETOTAL () * hartreetocm , \"(F10.4)\" ))) & // \" cm-1\" ) call write_message ( \"  v1_f  j1_f  <-  v1_i  j1_i\" // repeat ( \" \" , 14 ) & // \"K.E.\" // repeat ( \" \" , 16 ) // \"XS\" ) do icount = 1 , number_of_open_basis_levels do icount2 = 1 , number_of_open_basis_levels write ( xs_line , \"(2X,I4,2X,I4,6X,I4,2X,I4,2X,E16.8,2X,E16.8)\" ) & v1array ( open_basis_levels ( icount2 )), & j1array ( open_basis_levels ( icount2 )), & v1array ( open_basis_levels ( icount )), & j1array ( open_basis_levels ( icount )), & ( etotal () - elevel ( open_basis_levels ( icount ))) * hartreetocm , & xs_total (( icount - 1 ) * number_of_open_basis_levels + icount2 ) call write_message ( xs_line ) enddo enddo endif !------------------------------------------------------------------------! if ( prntlvl . ge . 2 ) call time_count_summary ( time_jtot_start , & time_jtot_stop , time_jtot , \"JTOT block completed in \" ) !------------------------------------------------------------------------! ! terminate the loop if dtol/otol condition is satisfied !------------------------------------------------------------------------! if ( terminate ) exit enddo call write_message ( repeat ( '*' , 90 )) call write_message ( repeat ( \" \" , 31 ) // \"Loop over JTOT finished\" ) call write_message ( repeat ( '*' , 90 )) call write_message ( \"*\" // repeat ( \" \" , 40 ) // \"SUMMARY\" // repeat ( \" \" , 41 ) & // \"*\" ) call write_message ( repeat ( '*' , 90 )) !---------------------------------------------------------------------------! ! if for some JTOTs the S-matrix did not fulfill the unitary check, ! these are listed here !---------------------------------------------------------------------------! if ( allocated ( smatcheckarr )) then print * call write_message ( repeat ( \"-\" , 90 )) call write_message ( repeat ( \" \" , 37 ) // \"*** WARNING ***\" ) call write_message ( repeat ( \"-\" , 90 )) call write_message ( \"Check unitarity of the S-matrix in the following \" // & \"JTOT blocks:\" ) do icheck = 1 , size ( smatcheckarr ) call write_message ( \"JTOT:\" // repeat ( \" \" , 8 ) // integer_to_character ( & smatcheckarr ( icheck ))) enddo call write_message ( repeat ( \"-\" , 90 )) print * endif !---------------------------------------------------------------------------! ! Print all the calculated XS !---------------------------------------------------------------------------! call write_message ( \"Final state-to-state XS\" ) call write_message ( \"  v1_f  j1_f  <-  v1_i  j1_i\" // repeat ( \" \" , 14 ) // & \"K.E.\" // repeat ( \" \" , 16 ) // \"XS\" ) do icount = 1 , number_of_open_basis_levels do icount2 = 1 , number_of_open_basis_levels write ( xs_line , \"(2X,I4,2X,I4,6X,I4,2X,I4,2X,E16.8,2X,E16.8)\" ) & v1array ( open_basis_levels ( icount2 )), & j1array ( open_basis_levels ( icount2 )), & v1array ( open_basis_levels ( icount )), & j1array ( open_basis_levels ( icount )), & ( etotal () - elevel ( open_basis_levels ( icount ))) * hartreetocm , & xs_total (( icount - 1 ) * number_of_open_basis_levels + icount2 ) call write_message ( xs_line ) enddo enddo !---------------------------------------------------------------------------! call fwig_temp_free (); call fwig_table_free (); !---------------------------------------------------------------------------! ! Stop the time count !---------------------------------------------------------------------------! call cpu_time ( time_total_stop ) call time_count_summary ( time_total_start , time_total_stop , time_total , & \"Total CPU time: \" ) close ( 11 ) close ( 12 ) !---------------------------------------------------------------------------! end program SCATTERING","tags":"","loc":"program/scattering.html"},{"title":"radial_coupling_terms_mod.f90 – the SCATTERING code","text":"This file depends on sourcefile~~radial_coupling_terms_mod.f90~~EfferentGraph sourcefile~radial_coupling_terms_mod.f90 radial_coupling_terms_mod.f90 sourcefile~input_reader_mod.f90 input_reader_mod.f90 sourcefile~radial_coupling_terms_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~utility_functions_mod.f90 utility_functions_mod.f90 sourcefile~radial_coupling_terms_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~math_functions_mod.f90 math_functions_mod.f90 sourcefile~radial_coupling_terms_mod.f90->sourcefile~math_functions_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~array_operations_mod.f90 array_operations_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~array_operations_mod.f90 sourcefile~math_functions_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~special_functions_mod.f90 special_functions_mod.f90 sourcefile~math_functions_mod.f90->sourcefile~special_functions_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~radial_coupling_terms_mod.f90~~AfferentGraph sourcefile~radial_coupling_terms_mod.f90 radial_coupling_terms_mod.f90 sourcefile~propagator_mod.f90 propagator_mod.f90 sourcefile~propagator_mod.f90->sourcefile~radial_coupling_terms_mod.f90 sourcefile~scattering.f90 scattering.f90 sourcefile~scattering.f90->sourcefile~radial_coupling_terms_mod.f90 sourcefile~scattering.f90->sourcefile~propagator_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules radial_coupling_terms_mod Source Code radial_coupling_terms_mod.f90 Source Code module radial_coupling_terms_mod !! This module provides all functions that handle radial coupling terms !! of the PES. It covers: !! 1. reading radial coupling terms from external file (\"read_radial_coupling_terms\", !!    \"skip_header_lines\", \"read_and_validate_lambda\", \"read_potential_data\", !!    \"validate_r_range\") !! 2. reducing the number of read coupling terms to retain only necessary !!    couplings (\"reduce_radial_coupling_terms\", \"print_pes_quantum_numbers\", !!    \"reduce_coupling_terms\", \"find_reduced_term\") !! 3. interpolation of radial coupling terms (\"interpolate_radial_coupling_terms\") !! 4. providing value of the interpolated radial coupling term (\"get_radial_coupling_term_value\") !!--------------------------------------------------------------------------! use , intrinsic :: iso_fortran_env , only : int32 , sp => real32 , dp => real64 use io_mod use utility_functions_mod , only : file_io_status , write_error , write_message ,& time_count_summary use math_functions_mod , only : spline , ispline !---------------------------------------------------------------------------! implicit none !---------------------------------------------------------------------------! private public :: read_radial_coupling_terms , reduce_radial_coupling_terms , & interpolate_radial_coupling_terms , get_radial_coupling_term_value !---------------------------------------------------------------------------! contains !---------------------------------------------------------------------------! !                            Reading procedures !---------------------------------------------------------------------------! subroutine read_radial_coupling_terms !! reads the radial coupling terms from the external file. !! The file is assumed to be formatted as described in !! \"Supplying radial terms\" section. !! The read radial coupling terms are kept in vmat/read_vmat3D !---------------------------------------------------------------------! character ( len = 200 ) :: err_message integer ( int32 ) :: nrtmp , l1 , iskip_ , lambda_index_ , ir , icol , io_status !---------------------------------------------------------------------! open ( pes_file_unit , file = trim ( potentialfile ), form = 'formatted' , & status = 'old' , iostat = io_status , iomsg = err_message ) call file_io_status ( io_status , err_message , pes_file_unit , 'o' ) !---------------------------------------------------------------------! ! Skip the informative lines at the beginning !---------------------------------------------------------------------! call skip_header_lines !---------------------------------------------------------------------! do lambda_index_ = 1 , nterms call read_and_validate_lambda ( lambda_index_ ) call read_potential_data ( lambda_index_ ) enddo !---------------------------------------------------------------------! close ( pes_file_unit , iostat = io_status , iomsg = err_message ) call file_io_status ( io_status , err_message , pes_file_unit , 'c' ) !---------------------------------------------------------------------! ! Check if supplied radial terms cover a sufficient range of R !---------------------------------------------------------------------! call validate_r_range !---------------------------------------------------------------------! end subroutine read_radial_coupling_terms !---------------------------------------------------------------------------! subroutine skip_header_lines !! skip the first n_skip_lines (read on input) lines in the pes_file !---------------------------------------------------------------------! integer ( int32 ) :: line_index_ !---------------------------------------------------------------------! do line_index_ = 1 , n_skip_lines read ( pes_file_unit , * ) enddo !---------------------------------------------------------------------! end subroutine skip_header_lines !---------------------------------------------------------------------------! subroutine read_and_validate_lambda ( lambda_index_ ) !! read the value of lambda and compare with expected value !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: lambda_index_ !---------------------------------------------------------------------! integer ( int32 ) :: lambda_ !---------------------------------------------------------------------! read ( pes_file_unit , * ) lambda_ if ( lambda_ . ne . l1tab ( lambda_index_ )) then close ( pes_file_unit ) close ( s_matrix_unit ) if ( ipart . eq . 1 ) close ( partial_file_unit ) call write_error ( \"read_radial_coupling_terms: lambda = \" // & trim ( adjustl ( integer_to_character ( lambda_ ))) // & \" differs from expected value in l1tab (\" // & trim ( adjustl ( integer_to_character ( lambda_index_ ))) // \") = \" // & trim ( adjustl ( integer_to_character ( l1tab ( lambda_index_ ))))) endif !---------------------------------------------------------------------! end subroutine read_and_validate_lambda !---------------------------------------------------------------------------! subroutine read_potential_data ( lambda_index_ ) !! read the intermolecular distance and radial coupling terms formatted !! in columns; iterate over number of tabulated ]](R\\ points; !! immediately convert \\R\\ and radial coupling terms to a.u. !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: lambda_index_ !---------------------------------------------------------------------! integer ( int32 ) :: r_index_ , column_index_ real ( dp ) :: read_line ( totalcol + 1 ) !---------------------------------------------------------------------! do r_index_ = 1 , nr read ( pes_file_unit , * ) ( read_line ( column_index_ ), & column_index_ = 1 , totalcol + 1 ) rmat ( r_index_ ) = read_line ( 1 ) * radial_term_distance_converter do column_index_ = 1 , totalcol read_vmat3D ( r_index_ , lambda_index_ , column_index_ ) & = read_line ( column_index_ + 1 ) * radial_term_energy_converter enddo enddo !---------------------------------------------------------------------! end subroutine read_potential_data !---------------------------------------------------------------------------! subroutine validate_r_range !! check if read R values are consistent with rmin and rmax !---------------------------------------------------------------------! if ( rmin < rmat ( 1 )) then close ( s_matrix_unit ) if ( ipart . eq . 1 ) close ( partial_file_unit ) call write_error ( \"rmin value provided by the user (\" // & trim ( adjustl ( float_to_character ( rmin , \"(F10.4)\" ))) // & \") is smaller than rmin supplied in \" // & trim ( adjustl ( potentialfile )) // \" ( \" // & trim ( adjustl ( float_to_character ( rmat ( 1 ), \"(F10.4)\" ))) // \")\" ) endif !---------------------------------------------------------------------! if ( rmax > rmat ( nr )) then close ( s_matrix_unit ) if ( ipart . eq . 1 ) close ( partial_file_unit ) call write_error ( \"rmax value provided by the user (\" // & trim ( adjustl ( float_to_character ( rmax , \"(F10.4)\" ))) // & \") is larger than rmax supplied in \" // & trim ( adjustl ( potentialfile )) // \" ( \" // & trim ( adjustl ( float_to_character ( rmat ( nr ), \"(F10.4)\" ))) // \")\" ) endif !---------------------------------------------------------------------! end subroutine validate_r_range !---------------------------------------------------------------------------! !                            Reducing procedures !---------------------------------------------------------------------------! subroutine reduce_radial_coupling_terms !! Reduces the read_vmat3D matrix to retain only the necessary coupling terms. !---------------------------------------------------------------------! integer ( int32 ) :: lambda_index_ , radial_index_ , coupling_index_ !---------------------------------------------------------------------! if ( totalcol /= ncoupl ) then call write_message ( \"Reducing the number of the radial coupling terms...\" ) call print_pes_quantum_numbers ( \"Original\" , totalcol ) call reduce_coupling_terms () call print_pes_quantum_numbers ( \"Reduced\" , ncoupl ) call write_message ( \"Reduced \" // & trim ( adjustl ( integer_to_character ( totalcol ))) // & \" radial terms to \" // trim ( adjustl ( integer_to_character ( ncoupl )))) else !------------------------------------------------------------------! ! if there is nothing to be reduced, copy read_vmat3d to vmat3d !------------------------------------------------------------------! vmat3D = read_vmat3D endif !---------------------------------------------------------------------! deallocate ( read_vmat3D ) !---------------------------------------------------------------------! end subroutine reduce_radial_coupling_terms !---------------------------------------------------------------------------! subroutine reduce_coupling_terms !! Reduces the coupling terms based on the existence of couplings. !---------------------------------------------------------------------! integer ( int32 ) :: lambda_index_ , r_index_ , coupling_index_ !---------------------------------------------------------------------! do lambda_index_ = 1 , nterms do r_index_ = 1 , nr do coupling_index_ = 1 , ncoupl vmat3D ( r_index_ , lambda_index_ , coupling_index_ ) = & find_reduced_term ( r_index_ , lambda_index_ , coupling_index_ ) enddo enddo enddo !---------------------------------------------------------------------! end subroutine reduce_coupling_terms !---------------------------------------------------------------------------! function find_reduced_term ( r_index_ , lambda_index_ , coupling_index_ ) & result ( reduced_term ) !! Finds and returns the reduced term for the given indices. !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: r_index_ !! index interating over intermolecular grid integer ( int32 ), intent ( in ) :: lambda_index_ !! index interating over Legendre expansion terms integer ( int32 ), intent ( in ) :: coupling_index_ !! index interating over necessary couplings real ( dp ) :: reduced_term !! (output) sought value of the coupling term !---------------------------------------------------------------------! integer ( int32 ) :: column_index_ !---------------------------------------------------------------------! reduced_term = 0.0_dp do column_index_ = 1 , totalcol !---------------------------------------------------------------------! ! iterate over quantum numbers describing all couplings ! (v1/j1/v1p/j1ppes) until necessary couplings are found !---------------------------------------------------------------------! if (( reduced_j1pes ( coupling_index_ ) == j1pes ( column_index_ )). and . & ( reduced_j1ppes ( coupling_index_ ) == j1ppes ( column_index_ )). and . & ( reduced_v1pes ( coupling_index_ ) == v1pes ( column_index_ )). and . & ( reduced_v1ppes ( coupling_index_ ) == v1ppes ( column_index_ ))) then reduced_term = read_vmat3D ( r_index_ , lambda_index_ , column_index_ ) exit endif enddo !---------------------------------------------------------------------! end function find_reduced_term !---------------------------------------------------------------------------! subroutine print_pes_quantum_numbers ( set_type , col_count ) !! Prints quantum numbers describing radial coupling terms of the PES !! based on the provided set type and column count. !---------------------------------------------------------------------! character ( len =* ), intent ( in ) :: set_type !! \"Original\" or \"reduced\" - describes the set of quantum numbers integer ( int32 ), intent ( in ) :: col_count !! number of coupling terms !---------------------------------------------------------------------! integer ( int32 ) :: column_index_ !---------------------------------------------------------------------! if ( prntlvl >= 3 ) then call write_message ( \"*** \" // trim ( set_type ) // & \" number of quantum numbers describing radial coupling terms: \" & // trim ( adjustl ( integer_to_character ( col_count ))) // \" ***\" ) call write_message ( \"Set of quantum numbers:\" ) call write_message ( \"       v1  j1  v1`  j1`\" ) select case ( set_type ) case ( \"Original\" ) do column_index_ = 1 , col_count write ( * , \"(5X,2(2X,I2),2(2X,I2))\" ) v1pes ( column_index_ ), & j1pes ( column_index_ ), v1ppes ( column_index_ ), & j1ppes ( column_index_ ) enddo case ( \"Reduced\" ) do column_index_ = 1 , col_count write ( * , \"(5X,2(2X,I2),2(2X,I2))\" ) & reduced_v1pes ( column_index_ ), & reduced_j1pes ( column_index_ ), & reduced_v1ppes ( column_index_ ), & reduced_j1ppes ( column_index_ ) enddo end select endif end subroutine print_pes_quantum_numbers !---------------------------------------------------------------------------! !                        Interpolation procedure !---------------------------------------------------------------------------! subroutine interpolate_radial_coupling_terms !! Interpolates the radial coupling terms using cubic spline functions. !! The resulting spline coefficients for each coupling term !! are stored in bmat3D, cmat3D, and dmat3D matrices. !---------------------------------------------------------------------! integer ( int32 ) :: lambda_index_ , coupling_index_ !---------------------------------------------------------------------! do lambda_index_ = 1 , nterms do coupling_index_ = 1 , ncoupl !---------------------------------------------------------------! ! Compute spline coefficients for each coupling term !---------------------------------------------------------------! call SPLINE ( nr , rmat , vmat3D (:, lambda_index_ , coupling_index_ ), & spline_coeff_b , spline_coeff_c , spline_coeff_d ) !---------------------------------------------------------------! ! Store coefficients in the respective matrices !---------------------------------------------------------------! bmat3D (:, lambda_index_ , coupling_index_ ) = spline_coeff_b cmat3D (:, lambda_index_ , coupling_index_ ) = spline_coeff_c dmat3D (:, lambda_index_ , coupling_index_ ) = spline_coeff_d enddo enddo !---------------------------------------------------------------------! end subroutine interpolate_radial_coupling_terms !---------------------------------------------------------------------------! !                     Radial coupling term value !---------------------------------------------------------------------------! subroutine get_radial_coupling_term_value ( intermolecular_distance , & lambda_ , v_ , j_ , v_prime_ , j_prime_ , radial_term_value_ ) !! Returns the interpolated value of a specific radial coupling term !! at a given distance. !---------------------------------------------------------------------! real ( dp ), intent ( in ) :: intermolecular_distance !! Intermolecular distance, \\R\\ integer ( int32 ), intent ( in ) :: lambda_ !! Legendre expansion index integer ( int32 ), intent ( in ) :: v_ !! pre-collisional vibrational quantum number integer ( int32 ), intent ( in ) :: j_ !! pre-collisional rotational quantum number integer ( int32 ), intent ( in ) :: v_prime_ !! post-collisional vibrational quantum number integer ( int32 ), intent ( in ) :: j_prime_ !! post-collisional rotational quantum number real ( dp ), intent ( out ) :: radial_term_value_ !! Value of the radial coupling coefficient !---------------------------------------------------------------------! integer ( int32 ) :: lambda_index , coupling_index !---------------------------------------------------------------------! lambda_index = find_lambda_index ( lambda_ ) !---------------------------------------------------------------------! if ( lambda_index == 0 ) then call handle_lambda_index_error ( lambda_ ) return endif !---------------------------------------------------------------------! coupling_index = find_coupling_index ( v_ , j_ , v_prime_ , j_prime_ ) !---------------------------------------------------------------------! if ( coupling_index == 0 ) then call handle_coupling_index_error ( v_ , j_ , v_prime_ , j_prime_ ) return endif !---------------------------------------------------------------------! radial_term_value_ = ISPLINE ( intermolecular_distance , nr , rmat , & vmat3D (:, lambda_index , coupling_index ), & bmat3D (:, lambda_index , coupling_index ), & cmat3D (:, lambda_index , coupling_index ), & dmat3D (:, lambda_index , coupling_index )) !---------------------------------------------------------------------! end subroutine get_radial_coupling_term_value !---------------------------------------------------------------------------! function find_lambda_index ( lambda_ ) result ( result_index_ ) !! Locate give \\\\lambda\\ value in l1tab !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: lambda_ !! Legendre expansion index, \\\\lambda\\ integer ( int32 ) :: result_index_ !! Index pointing to  \\\\lambda\\ in l1tab !---------------------------------------------------------------------! integer ( int32 ) :: lambda_index_ !---------------------------------------------------------------------! result_index_ = 0 do lambda_index_ = 1 , nterms if ( l1tab ( lambda_index_ ) == lambda_ ) then result_index_ = lambda_index_ exit endif enddo !---------------------------------------------------------------------! end function find_lambda_index !---------------------------------------------------------------------------! subroutine handle_lambda_index_error ( lambda_ ) !! handle error when the \\\\lambda\\ is not found in l1tab !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: lambda_ !! Legendre expansion index, \\\\lambda\\ !---------------------------------------------------------------------! call write_error ( \"Radial coupling terms with lambda = \" // & trim ( adjustl ( integer_to_character ( lambda_ ))) // \" not found in l1tab\" ) !---------------------------------------------------------------------! end subroutine handle_lambda_index_error !---------------------------------------------------------------------------! function find_coupling_index ( v_ , j_ , v_prime_ , j_prime_ ) result ( result_index_ ) !! Locate the correct quantum number that describes the v/j coupling; !! Note that coupling terms are symmetric with respect to the change !! of pre- and post-collisional quantum numbers !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: v_ !! pre-collisional vibrational quantum number integer ( int32 ), intent ( in ) :: j_ !! pre-collisional rotational quantum number integer ( int32 ), intent ( in ) :: v_prime_ !! post-collisional vibrational quantum number integer ( int32 ), intent ( in ) :: j_prime_ !! post-collisional rotational quantum number integer ( int32 ) :: result_index_ !! Index pointing to  \\v, j, v&#94;{\\prime}, j&#94;{\\prime}\\ in reduced_* arrays !---------------------------------------------------------------------! integer ( int32 ) :: coupling_index_ !---------------------------------------------------------------------! result_index_ = 0 do coupling_index_ = 1 , ncoupl if (((( reduced_v1pes ( coupling_index_ ) == v_ ). and . & ( reduced_j1pes ( coupling_index_ ). eq . j_ ). and . & ( reduced_v1ppes ( coupling_index_ ). eq . v_prime_ ). and . & ( reduced_j1ppes ( coupling_index_ ). eq . j_prime_ )) & . or . & (( reduced_v1pes ( coupling_index_ ). eq . v_prime_ ). and . & ( reduced_j1pes ( coupling_index_ ). eq . j_prime_ ). and . & ( reduced_v1ppes ( coupling_index_ ). eq . v_ ). and . & ( reduced_j1ppes ( coupling_index_ ). eq . j_ ))) ) then result_index_ = coupling_index_ exit endif enddo !---------------------------------------------------------------------! end function find_coupling_index !---------------------------------------------------------------------------! subroutine handle_coupling_index_error ( v_ , j_ , v_prime_ , j_prime_ ) !! handle error when the appropriate coupling term is not found !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: v_ !! pre-collisional vibrational quantum number integer ( int32 ), intent ( in ) :: j_ !! pre-collisional rotational quantum number integer ( int32 ), intent ( in ) :: v_prime_ !! post-collisional vibrational quantum number integer ( int32 ), intent ( in ) :: j_prime_ !! post-collisional rotational quantum number !---------------------------------------------------------------------! call write_error ( \"Coupling term with v = \" // & trim ( adjustl ( integer_to_character ( v_ ))) // \", j = \" // & trim ( adjustl ( integer_to_character ( j_ ))) // \", v` = \" // & trim ( adjustl ( integer_to_character ( v_prime_ ))) // \", j1` = \" // & trim ( adjustl ( integer_to_character ( j_prime_ ))) // \" not found\" ) !---------------------------------------------------------------------! end subroutine handle_coupling_index_error !------------------------------------------------------------------------------! end module radial_coupling_terms_mod","tags":"","loc":"sourcefile/radial_coupling_terms_mod.f90.html"},{"title":"special_functions_mod.f90 – the SCATTERING code","text":"Files dependent on this one sourcefile~~special_functions_mod.f90~~AfferentGraph sourcefile~special_functions_mod.f90 special_functions_mod.f90 sourcefile~math_functions_mod.f90 math_functions_mod.f90 sourcefile~math_functions_mod.f90->sourcefile~special_functions_mod.f90 sourcefile~radial_coupling_terms_mod.f90 radial_coupling_terms_mod.f90 sourcefile~radial_coupling_terms_mod.f90->sourcefile~math_functions_mod.f90 sourcefile~boundary_conditions_mod.f90 boundary_conditions_mod.f90 sourcefile~boundary_conditions_mod.f90->sourcefile~math_functions_mod.f90 sourcefile~coupling_matrix_mod.f90 coupling_matrix_mod.f90 sourcefile~coupling_matrix_mod.f90->sourcefile~math_functions_mod.f90 sourcefile~propagator_mod.f90 propagator_mod.f90 sourcefile~propagator_mod.f90->sourcefile~radial_coupling_terms_mod.f90 sourcefile~scattering.f90 scattering.f90 sourcefile~scattering.f90->sourcefile~radial_coupling_terms_mod.f90 sourcefile~scattering.f90->sourcefile~boundary_conditions_mod.f90 sourcefile~scattering.f90->sourcefile~coupling_matrix_mod.f90 sourcefile~scattering.f90->sourcefile~propagator_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules special_functions_mod Source Code special_functions_mod.f90 Source Code module special_functions_mod !! This module holds rctj, rcty, envj, msta1, msta2, ikv, gamma from !! special_functions library, donwloaded from: !! https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html !!  Author: !! !!    Original FORTRAN77 version by Shanjie Zhang, Jianming Jin. !!    FORTRAN90 version by John Burkardt. !! !!  Reference: !! !!    Shanjie Zhang, Jianming Jin, !!    Computation of Special Functions, !!    Wiley, 1996, !!    ISBN: 0-471-11963-6, !!    LC: QA351.C45. !!--------------------------------------------------------------------------! implicit none !--------------------------------------------------------------------------! contains !--------------------------------------------------------------------------! subroutine rctj ( n , x , nm , rj , dj ) !------------------------------------------------------------------------! !! computes Riccati-Bessel function of the first kind, and derivatives. !------------------------------------------------------------------------! !  Licensing: ! !    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, !    they give permission to incorporate this routine into a user program !    provided that the copyright is acknowledged. ! !  Modified: ! !    18 July 2012 ! !  Author: ! !    Shanjie Zhang,Jianming Jin ! !  Reference: ! !    Shanjie Zhang,Jianming Jin, !    Computation of Special Functions, !    Wiley,1996, !    ISBN: 0-471-11963-6, !    LC: QA351.C45. ! !  Parameters: ! !    Input,integer(kind = 4) N,the order of jn(x). ! !    Input,real(kind = 8) X,the argument. ! !    Output,integer(kind = 4) NM,the highest order computed. ! !    Output,real(kind = 8) RJ(0:N),the values of x jn(x). ! !    Output,real(kind = 8) DJ(0:N),the values of [x jn(x)]'. !------------------------------------------------------------------------! implicit none integer ( kind = 4 ) n real ( kind = 8 ) cs real ( kind = 8 ) dj ( 0 : n ) real ( kind = 8 ) f real ( kind = 8 ) f0 real ( kind = 8 ) f1 integer ( kind = 4 ) k integer ( kind = 4 ) m ! ---------------------------------------------------------------------- ! commented because the functions are now in the same module !\t\t  integer(kind = 4) msta1 !\t\t  integer(kind = 4) msta2 ! ---------------------------------------------------------------------- integer ( kind = 4 ) nm real ( kind = 8 ) rj ( 0 : n ) real ( kind = 8 ) rj0 real ( kind = 8 ) rj1 real ( kind = 8 ) x nm = n if ( abs ( x ) < 1.0D-100 ) then do k = 0 , n rj ( k ) = 0.0D+00 dj ( k ) = 0.0D+00 end do dj ( 0 ) = 1.0D+00 return end if rj ( 0 ) = sin ( x ) rj ( 1 ) = rj ( 0 ) / x - cos ( x ) rj0 = rj ( 0 ) rj1 = rj ( 1 ) if ( 2 <= n ) then m = msta1 ( x , 200 ) if ( m < n ) then nm = m else m = msta2 ( x , n , 15 ) end if f0 = 0.0D+00 f1 = 1.0D-100 do k = m , 0 , - 1 f = ( 2.0D+00 * k + 3.0D+00 ) * f1 / x - f0 if ( k <= nm ) then rj ( k ) = f end if f0 = f1 f1 = f end do if ( abs ( rj1 ) < abs ( rj0 )) then cs = rj0 / f else cs = rj1 / f0 end if do k = 0 , nm rj ( k ) = cs * rj ( k ) end do end if dj ( 0 ) = cos ( x ) do k = 1 , nm dj ( k ) = - k * rj ( k ) / x + rj ( k - 1 ) end do return end !------------------------------------------------------------------------! subroutine rcty ( n , x , nm , ry , dy ) !------------------------------------------------------------------------! !! computes Riccati-Bessel function of the second kind, and derivatives. !------------------------------------------------------------------------! ! !  Licensing: ! !    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, !    they give permission to incorporate this routine into a user program !    provided that the copyright is acknowledged. ! !  Modified: ! !    18 July 2012 ! !  Author: ! !    Shanjie Zhang,Jianming Jin ! !  Reference: ! !    Shanjie Zhang,Jianming Jin, !    Computation of Special Functions, !    Wiley,1996, !    ISBN: 0-471-11963-6, !    LC: QA351.C45. ! !  Parameters: ! !    Input,integer(kind = 4) N,the order of yn(x). ! !    Input,real(kind = 8) X,the argument. ! !    Output,integer(kind = 4) NM,the highest order computed. ! !    Output,real(kind = 8) RY(0:N),the values of x yn(x). ! !    Output,real(kind = 8) DY(0:N),the values of [x yn(x)]'. !------------------------------------------------------------------------! implicit none integer ( kind = 4 ) n real ( kind = 8 ) dy ( 0 : n ) integer ( kind = 4 ) k integer ( kind = 4 ) nm real ( kind = 8 ) rf0 real ( kind = 8 ) rf1 real ( kind = 8 ) rf2 real ( kind = 8 ) ry ( 0 : n ) real ( kind = 8 ) x nm = n if ( x < 1.0D-60 ) then do k = 0 , n ry ( k ) = - 1.0D+300 dy ( k ) = 1.0D+300 end do ry ( 0 ) = - 1.0D+00 dy ( 0 ) = 0.0D+00 return end if ry ( 0 ) = - cos ( x ) ry ( 1 ) = ry ( 0 ) / x - sin ( x ) rf0 = ry ( 0 ) rf1 = ry ( 1 ) do k = 2 , n rf2 = ( 2.0D+00 * k - 1.0D+00 ) * rf1 / x - rf0 if ( 1.0D+300 < abs ( rf2 )) then exit end if ry ( k ) = rf2 rf0 = rf1 rf1 = rf2 end do nm = k - 1 dy ( 0 ) = sin ( x ) do k = 1 , nm dy ( k ) = - k * ry ( k ) / x + ry ( k - 1 ) end do return end !------------------------------------------------------------------------! subroutine gamma ( x , ga ) !------------------------------------------------------------------------! !! evaluates the Gamma function. !------------------------------------------------------------------------! !  Licensing: ! !    The original FORTRAN77 version of this routine is copyrighted by !    Shanjie Zhang and Jianming Jin.  However, they give permission to !    incorporate this routine into a user program that the copyright !    is acknowledged. ! !  Modified: ! !    08 September 2007 ! !  Author: ! !    Original FORTRAN77 version by Shanjie Zhang, Jianming Jin. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    Shanjie Zhang, Jianming Jin, !    Computation of Special Functions, !    Wiley, 1996, !    ISBN: 0-471-11963-6, !    LC: QA351.C45 ! !  Parameters: ! !    Input, real ( kind = 8 ) X, the argument. !    X must not be 0, or any negative integer. ! !    Output, real ( kind = 8 ) GA, the value of the Gamma function. !------------------------------------------------------------------------! implicit none real ( kind = 8 ), dimension ( 26 ) :: g = ( / & 1.0D+00 , & 0.5772156649015329D+00 , & - 0.6558780715202538D+00 , & - 0.420026350340952D-01 , & 0.1665386113822915D+00 , & - 0.421977345555443D-01 , & - 0.96219715278770D-02 , & 0.72189432466630D-02 , & - 0.11651675918591D-02 , & - 0.2152416741149D-03 , & 0.1280502823882D-03 , & - 0.201348547807D-04 , & - 0.12504934821D-05 , & 0.11330272320D-05 , & - 0.2056338417D-06 , & 0.61160950D-08 , & 0.50020075D-08 , & - 0.11812746D-08 , & 0.1043427D-09 , & 0.77823D-11 , & - 0.36968D-11 , & 0.51D-12 , & - 0.206D-13 , & - 0.54D-14 , & 0.14D-14 , & 0.1D-15 / ) real ( kind = 8 ) ga real ( kind = 8 ) gr integer ( kind = 4 ) k integer ( kind = 4 ) m integer ( kind = 4 ) m1 real ( kind = 8 ), parameter :: pi = 3.141592653589793D+00 real ( kind = 8 ) r real ( kind = 8 ) x real ( kind = 8 ) z if ( x == aint ( x ) ) then if ( 0.0D+00 < x ) then ga = 1.0D+00 m1 = int ( x ) - 1 do k = 2 , m1 ga = ga * k end do else ga = 1.0D+300 end if else if ( 1.0D+00 < abs ( x ) ) then z = abs ( x ) m = int ( z ) r = 1.0D+00 do k = 1 , m r = r * ( z - real ( k , kind = 8 ) ) end do z = z - real ( m , kind = 8 ) else z = x end if gr = g ( 26 ) do k = 25 , 1 , - 1 gr = gr * z + g ( k ) end do ga = 1.0D+00 / ( gr * z ) if ( 1.0D+00 < abs ( x ) ) then ga = ga * r if ( x < 0.0D+00 ) then ga = - pi / ( x * ga * sin ( pi * x ) ) end if end if end if return end !------------------------------------------------------------------------! subroutine ikv ( v , x , vm , bi , di , bk , dk ) !------------------------------------------------------------------------! !! computes modified Bessel function Iv(x) and Kv(x) and their derivatives. !------------------------------------------------------------------------! !  Licensing: ! !    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, !    they give permission to incorporate this routine into a user program !    provided that the copyright is acknowledged. ! !  Modified: ! !    17 July 2012 ! !  Author: ! !    Shanjie Zhang, Jianming Jin ! !  Reference: ! !    Shanjie Zhang, Jianming Jin, !    Computation of Special Functions, !    Wiley, 1996, !    ISBN: 0-471-11963-6, !    LC: QA351.C45. ! !  Parameters: ! !    Input, real ( kind = 8 ) V, the order of Iv(x) and Kv(x). !    V = N + V0. ! !    Input, real ( kind = 8 ) X, the argument. ! !    Output, real ( kind = 8 ) VM, the highest order computed. ! !    Output, real ( kind = 8 ) BI(0:N), DI(0:N), BK(0:N), DK(0:N), the !    values of In+v0(x), In+v0'(x), Kn+v0(x), Kn+v0'(x). !------------------------------------------------------------------------! implicit none real ( kind = 8 ) a1 real ( kind = 8 ) a2 real ( kind = 8 ) bi ( 0 : * ) real ( kind = 8 ) bi0 real ( kind = 8 ) bk ( 0 : * ) real ( kind = 8 ) bk0 real ( kind = 8 ) bk1 real ( kind = 8 ) bk2 real ( kind = 8 ) ca real ( kind = 8 ) cb real ( kind = 8 ) cs real ( kind = 8 ) ct real ( kind = 8 ) di ( 0 : * ) real ( kind = 8 ) dk ( 0 : * ) real ( kind = 8 ) f real ( kind = 8 ) f1 real ( kind = 8 ) f2 real ( kind = 8 ) gan real ( kind = 8 ) gap integer ( kind = 4 ) k integer ( kind = 4 ) k0 integer ( kind = 4 ) m ! ---------------------------------------------------------------------- ! commented because the functions are now in the same module !\t\t  integer(kind = 4) msta1 !\t\t  integer(kind = 4) msta2 ! ---------------------------------------------------------------------- integer ( kind = 4 ) n real ( kind = 8 ) pi real ( kind = 8 ) piv real ( kind = 8 ) r real ( kind = 8 ) r1 real ( kind = 8 ) r2 real ( kind = 8 ) sum real ( kind = 8 ) v real ( kind = 8 ) v0 real ( kind = 8 ) v0n real ( kind = 8 ) v0p real ( kind = 8 ) vm real ( kind = 8 ) vt real ( kind = 8 ) w0 real ( kind = 8 ) wa real ( kind = 8 ) ww real ( kind = 8 ) x real ( kind = 8 ) x2 pi = 3.141592653589793D+00 x2 = x * x n = int ( v ) v0 = v - n if ( n == 0 ) then n = 1 end if if ( x < 1.0D-100 ) then do k = 0 , n bi ( k ) = 0.0D+00 di ( k ) = 0.0D+00 bk ( k ) = - 1.0D+300 dk ( k ) = 1.0D+300 end do if ( v == 0.0D+00 ) then bi ( 0 ) = 1.0D+00 di ( 1 ) = 0.5D+00 end if vm = v return end if piv = pi * v0 vt = 4.0D+00 * v0 * v0 if ( v0 == 0.0D+00 ) then a1 = 1.0D+00 else v0p = 1.0D+00 + v0 call gamma ( v0p , gap ) a1 = ( 0.5D+00 * x ) ** v0 / gap end if if ( x < 3 5.0D+00 ) then k0 = 14 else if ( x < 5 0.0D+00 ) then k0 = 10 else k0 = 8 end if if ( x <= 1 8.0D+00 ) then bi0 = 1.0D+00 r = 1.0D+00 do k = 1 , 30 r = 0.25D+00 * r * x2 / ( k * ( k + v0 ) ) bi0 = bi0 + r if ( abs ( r / bi0 ) < 1.0D-15 ) then exit end if end do bi0 = bi0 * a1 else ca = exp ( x ) / sqrt ( 2.0D+00 * pi * x ) sum = 1.0D+00 r = 1.0D+00 do k = 1 , k0 r = - 0.125D+00 * r * ( vt - ( 2.0D+00 * k - 1.0D+00 ) ** 2 ) / ( k * x ) sum = sum + r end do bi0 = ca * sum end if m = msta1 ( x , 200 ) if ( m < n ) then n = m else m = msta2 ( x , n , 15 ) end if f2 = 0.0D+00 f1 = 1.0D-100 do k = m , 0 , - 1 f = 2.0D+00 * ( v0 + k + 1.0D+00 ) / x * f1 + f2 if ( k <= n ) then bi ( k ) = f end if f2 = f1 f1 = f end do cs = bi0 / f do k = 0 , n bi ( k ) = cs * bi ( k ) end do di ( 0 ) = v0 / x * bi ( 0 ) + bi ( 1 ) do k = 1 , n di ( k ) = - ( k + v0 ) / x * bi ( k ) + bi ( k - 1 ) end do if ( x <= 9.0D+00 ) then if ( v0 == 0.0D+00 ) then ct = - log ( 0.5D+00 * x ) - 0.5772156649015329D+00 cs = 0.0D+00 w0 = 0.0D+00 r = 1.0D+00 do k = 1 , 50 w0 = w0 + 1.0D+00 / k r = 0.25D+00 * r / ( k * k ) * x2 cs = cs + r * ( w0 + ct ) wa = abs ( cs ) if ( abs ( ( wa - ww ) / wa ) < 1.0D-15 ) then exit end if ww = wa end do bk0 = ct + cs else v0n = 1.0D+00 - v0 call gamma ( v0n , gan ) a2 = 1.0D+00 / ( gan * ( 0.5D+00 * x ) ** v0 ) a1 = ( 0.5D+00 * x ) ** v0 / gap sum = a2 - a1 r1 = 1.0D+00 r2 = 1.0D+00 do k = 1 , 120 r1 = 0.25D+00 * r1 * x2 / ( k * ( k - v0 ) ) r2 = 0.25D+00 * r2 * x2 / ( k * ( k + v0 ) ) sum = sum + a2 * r1 - a1 * r2 wa = abs ( sum ) if ( abs ( ( wa - ww ) / wa ) < 1.0D-15 ) then exit end if ww = wa end do bk0 = 0.5D+00 * pi * sum / sin ( piv ) end if else cb = exp ( - x ) * sqrt ( 0.5D+00 * pi / x ) sum = 1.0D+00 r = 1.0D+00 do k = 1 , k0 r = 0.125D+00 * r * ( vt - ( 2.0D+00 * k - 1.0D+00 ) ** 2 ) / ( k * x ) sum = sum + r end do bk0 = cb * sum end if bk1 = ( 1.0D+00 / x - bi ( 1 ) * bk0 ) / bi ( 0 ) bk ( 0 ) = bk0 bk ( 1 ) = bk1 do k = 2 , n bk2 = 2.0D+00 * ( v0 + k - 1.0D+00 ) / x * bk1 + bk0 bk ( k ) = bk2 bk0 = bk1 bk1 = bk2 end do dk ( 0 ) = v0 / x * bk ( 0 ) - bk ( 1 ) do k = 1 , n dk ( k ) = - ( k + v0 ) / x * bk ( k ) - bk ( k - 1 ) end do vm = n + v0 return end !------------------------------------------------------------------------! function envj ( n , x ) !------------------------------------------------------------------------! !! utility function used by MSTA1 and MSTA2. !------------------------------------------------------------------------! !  Discussion: ! !    ENVJ estimates -log(Jn(x)) from the estimate !    Jn(x) approx 1/sqrt(2*pi*n) *(e*x/(2*n))&#94;n ! !  Licensing: ! !    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, !    they give permission to incorporate this routine into a user program !    provided that the copyright is acknowledged. ! !  Modified: ! !    14 January 2016 ! !  Author: ! !    Shanjie Zhang,Jianming Jin !    Modifications suggested by Vincent Lafage,11 January 2016. ! !  Reference: ! !    Shanjie Zhang,Jianming Jin, !    Computation of Special Functions, !    Wiley,1996, !    ISBN: 0-471-11963-6, !    LC: QA351.C45. ! !  Parameters: ! !    Input,integer(kind = 4) N,the order of the Bessel function. ! !    Input,real(kind = 8) X,the absolute value of the argument. ! !    Output,real(kind = 8) ENVJ,the value. !------------------------------------------------------------------------! implicit none real ( kind = 8 ) envj real ( kind = 8 ) logten integer ( kind = 4 ) n real ( kind = 8 ) n_r8 real ( kind = 8 ) r8_gamma_log real ( kind = 8 ) x ! !  Original code ! if (. true .) then envj = 0.5D+00 * log10 ( 6.28D+00 * n ) & - n * log10 ( 1.36D+00 * x / n ) ! !  Modification suggested by Vincent Lafage. ! else n_r8 = real ( n , kind = 8 ) logten = log ( 1 0.0D+00 ) envj = r8_gamma_log ( n_r8 + 1.0D+00 ) / logten - n_r8 * log10 ( x ) end if return end !------------------------------------------------------------------------! function msta1 ( x , mp ) !------------------------------------------------------------------------! !! determines a backward recurrence starting point for Jn(x). !------------------------------------------------------------------------! !  Discussion: ! !    This procedure determines the starting point for backward !    recurrence such that the magnitude of !    Jn(x) at that point is about 10&#94;(-MP). ! !  Licensing: ! !    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, !    they give permission to incorporate this routine into a user program !    provided that the copyright is acknowledged. ! !  Modified: ! !    08 July 2012 ! !  Author: ! !    Shanjie Zhang,Jianming Jin ! !  Reference: ! !    Shanjie Zhang,Jianming Jin, !    Computation of Special Functions, !    Wiley,1996, !    ISBN: 0-471-11963-6, !    LC: QA351.C45. ! !  Parameters: ! !    Input,real(kind = 8) X,the argument. ! !    Input,integer(kind = 4) MP,the negative logarithm of the !    desired magnitude. ! !    Output,integer(kind = 4) MSTA1,the starting point. !------------------------------------------------------------------------! implicit none real ( kind = 8 ) a0 !---------------------------------------------------------------------- ! commented because the envj is in the same module !\t\t  real(kind = 8) envj !----------------------------------------------------------------------- real ( kind = 8 ) f real ( kind = 8 ) f0 real ( kind = 8 ) f1 integer ( kind = 4 ) it integer ( kind = 4 ) mp integer ( kind = 4 ) msta1 integer ( kind = 4 ) n0 integer ( kind = 4 ) n1 integer ( kind = 4 ) nn real ( kind = 8 ) x a0 = abs ( x ) n0 = int ( 1.1D+00 * a0 ) + 1 f0 = envj ( n0 , a0 ) - mp n1 = n0 + 5 f1 = envj ( n1 , a0 ) - mp do it = 1 , 20 nn = n1 - ( n1 - n0 ) / ( 1.0D+00 - f0 / f1 ) f = envj ( nn , a0 ) - mp if ( abs ( nn - n1 ) < 1 ) then exit end if n0 = n1 f0 = f1 n1 = nn f1 = f end do msta1 = nn return end !------------------------------------------------------------------------! function msta2 ( x , n , mp ) !------------------------------------------------------------------------! !! determines a backward recurrence starting point for Jn(x). !------------------------------------------------------------------------! !  Discussion: ! !    This procedure determines the starting point for a backward !    recurrence such that all Jn(x) has MP significant digits. ! !    Jianming Jin supplied a modification to this code on 12 January 2016. ! !  Licensing: ! !    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, !    they give permission to incorporate this routine into a user program !    provided that the copyright is acknowledged. ! !  Modified: ! !    14 January 2016 ! !  Author: ! !    Shanjie Zhang,Jianming Jin ! !  Reference: ! !    Shanjie Zhang,Jianming Jin, !    Computation of Special Functions, !    Wiley,1996, !    ISBN: 0-471-11963-6, !    LC: QA351.C45. ! !  Parameters: ! !    Input,real(kind = 8) X,the argument of Jn(x). ! !    Input,integer(kind = 4) N,the order of Jn(x). ! !    Input,integer(kind = 4) MP,the number of significant digits. ! !    Output,integer(kind = 4) MSTA2,the starting point. !------------------------------------------------------------------------! implicit none real ( kind = 8 ) a0 real ( kind = 8 ) ejn !---------------------------------------------------------------------- ! commented because the envj is in the same module !\t\t  real(kind = 8) envj !---------------------------------------------------------------------- real ( kind = 8 ) f real ( kind = 8 ) f0 real ( kind = 8 ) f1 real ( kind = 8 ) hmp integer ( kind = 4 ) it integer ( kind = 4 ) mp integer ( kind = 4 ) msta2 integer ( kind = 4 ) n integer ( kind = 4 ) n0 integer ( kind = 4 ) n1 integer ( kind = 4 ) nn real ( kind = 8 ) obj real ( kind = 8 ) x a0 = abs ( x ) hmp = 0.5D+00 * mp ejn = envj ( n , a0 ) if ( ejn <= hmp ) then obj = mp ! !  Original code: ! !   n0 = int(1.1D+00 * a0) ! !  Updated code: ! n0 = int ( 1.1D+00 * a0 ) + 1 else obj = hmp + ejn n0 = n end if f0 = envj ( n0 , a0 ) - obj n1 = n0 + 5 f1 = envj ( n1 , a0 ) - obj do it = 1 , 20 nn = n1 - ( n1 - n0 ) / ( 1.0D+00 - f0 / f1 ) f = envj ( nn , a0 ) - obj if ( abs ( nn - n1 ) < 1 ) then exit end if n0 = n1 f0 = f1 n1 = nn f1 = f end do msta2 = nn + 10 return end !------------------------------------------------------------------------! end module special_functions_mod","tags":"","loc":"sourcefile/special_functions_mod.f90.html"},{"title":"input_reader_mod.f90 – the SCATTERING code","text":"This file depends on sourcefile~~input_reader_mod.f90~~EfferentGraph sourcefile~input_reader_mod.f90 input_reader_mod.f90 sourcefile~utility_functions_mod.f90 utility_functions_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~array_operations_mod.f90 array_operations_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~array_operations_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~input_reader_mod.f90~~AfferentGraph sourcefile~input_reader_mod.f90 input_reader_mod.f90 sourcefile~channels_mod.f90 channels_mod.f90 sourcefile~channels_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~boundary_conditions_mod.f90 boundary_conditions_mod.f90 sourcefile~boundary_conditions_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~propagator_mod.f90 propagator_mod.f90 sourcefile~propagator_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~radial_coupling_terms_mod.f90 radial_coupling_terms_mod.f90 sourcefile~propagator_mod.f90->sourcefile~radial_coupling_terms_mod.f90 sourcefile~sts_xs_mod.f90 sts_xs_mod.f90 sourcefile~sts_xs_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~coupling_matrix_mod.f90 coupling_matrix_mod.f90 sourcefile~coupling_matrix_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~radial_coupling_terms_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~unitarity_check_mod.f90 unitarity_check_mod.f90 sourcefile~unitarity_check_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~scattering.f90 scattering.f90 sourcefile~scattering.f90->sourcefile~input_reader_mod.f90 sourcefile~scattering.f90->sourcefile~channels_mod.f90 sourcefile~scattering.f90->sourcefile~boundary_conditions_mod.f90 sourcefile~scattering.f90->sourcefile~propagator_mod.f90 sourcefile~scattering.f90->sourcefile~sts_xs_mod.f90 sourcefile~scattering.f90->sourcefile~coupling_matrix_mod.f90 sourcefile~scattering.f90->sourcefile~radial_coupling_terms_mod.f90 sourcefile~scattering.f90->sourcefile~unitarity_check_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules io_mod Source Code input_reader_mod.f90 Source Code module io_mod !! this module provides following functions and subroutines: !! 1. input_file - reads the input file prepared by the user !! 2. input_check - checks the variables supplied in the input file !! 3. input_summary - summary of the input variables !! 5. etotal (function) - returns the total energy of the system !! 6. wavenumber_from_energy (function) - returns the wavenumber !! 7. units_conversion - converts all physical quantities to atomic units !! 8. count_available_xs (function) - counts energetically accessible !!    levels in the basis !! 9. jaccess (function) - returns jopen and waveopen - arrays needed for !!    calculations of the state-to-state XS !---------------------------------------------------------------------------! use , intrinsic :: iso_fortran_env , only : int32 , sp => real32 , dp => real64 use utility_functions_mod , only : file_io_status , write_error , write_message ,& incorrect_value , integer_to_character , float_to_character use array_operations_mod , only : allocate_1d , allocate_2d , allocate_3d !------------------------------------------------------------------------------! implicit none !------------------------------------------------------------------------------! character ( len = 80 ) :: label , potentialfile , smatrixfile , partialfile integer ( int32 ) :: ietoterel , jtotmin , jtotmax , jtotstep , steps , ncac , & initial , nlevel , nr , nterms , ncoupl , totalcol , n_skip_lines , iunits , & ipart , prntlvl , saveeigenvectors , nmodlevels real ( dp ) :: reducedmass , energy , rmin , rmax , dr , vdepth , dtol , otol , & radial_term_distance_converter , radial_term_energy_converter !---------------------------------------------------------------------------! integer ( int32 ), parameter :: input_unit = 5 integer ( int32 ), parameter :: pes_file_unit = 8 integer ( int32 ), parameter :: s_matrix_unit = 11 integer ( int32 ), parameter :: partial_file_unit = 12 !---------------------------------------------------------------------------! real ( dp ), parameter :: amutoau = 182 2.8884862d0 real ( dp ), parameter :: bohrtoangstrom = 0.5291772109d0 real ( dp ), parameter :: hartreetocm = 21947 4.631363d0 real ( dp ), parameter :: pi = dacos ( - 1.d0 ) real ( dp ), parameter :: unitary_tolerance = 1e-6_dp !---------------------------------------------------------------------------! integer ( int32 ), allocatable :: v1array (:), j1array (:), l1tab (:), l2tab (:), & lltab (:), v1pes (:), j1pes (:), v1ppes (:), j1ppes (:), reduced_v1pes (:), & reduced_j1pes (:), reduced_v1ppes (:), reduced_j1ppes (:) real ( dp ), allocatable :: elevel (:), rmat (:), spline_coeff_b (:), & spline_coeff_c (:), spline_coeff_d (:), vmat (:,:), & bmat (:,:), cmat (:,:), dmat (:,:), read_vmat3D (:,:,:), vmat3D (:,:,:), & bmat3D (:,:,:), cmat3D (:,:,:), dmat3D (:,:,:) logical :: pes_file_exists , units_converted = . false . !------------------------------------------------------------------------------! contains subroutine read_input_file !! reads the input file prepared by the user using NAMELIST feature !! the code uses 3 namelists: input, basis and potential !------------------------------------------------------------------------! character ( len = 200 ) :: err_message integer ( int32 ) :: ilevel , iilevel , icoupl , icol , il , io_status !------------------------------------------------------------------------! namelist / INPUT / label , reducedmass , ietoterel , energy , & jtotmin , jtotmax , jtotstep , rmin , rmax , dr , steps , vdepth , & ncac , dtol , otol , nlevel , initial , nr , nterms , totalcol , & n_skip_lines , iunits , potentialfile , smatrixfile , ipart , partialfile , & prntlvl namelist / BASIS / v1array , j1array , elevel namelist / POTENTIAL / l1tab , l2tab , lltab , v1pes , j1pes , v1ppes , j1ppes !------------------------------------------------------------------------------! ! Pre-declaration of variables                                                 ! !------------------------------------------------------------------------------! ! The most important variables (if they are not specified, the code stops):    ! !------------------------------------------------------------------------------! reducedmass = - 1.0_dp energy = - 1.0_dp rmin = - 1.0_dp rmax = - 1.0_dp nlevel = - 1 initial = - 1 nr = - 1 nterms = - 1 !------------------------------------------------------------------------------! ! Additional variables (the code runs with the pre-declared values):           ! !------------------------------------------------------------------------------! ietoterel = 0 jtotmin = 0 jtotmax = - 1 jtotstep = 1 dr = - 1.0_dp steps = 10 vdepth = 0.0_dp ncac = 1 dtol = 0.1_dp otol = 0.1_dp totalcol = 1 n_skip_lines = 0 iunits = 0 potentialfile = 'RadialTerms.dat' smatrixfile = 'SmatrixFile.dat' ipart = 0 partialfile = 'PartialFile.dat' prntlvl = 2 !------------------------------------------------------------------------------! open ( unit = 5 , action = 'read' , form = 'formatted' , access = 'sequential' , & status = 'old' , iostat = io_status , iomsg = err_message ) call file_io_status ( io_status , err_message , 5 , 'o' ) !------------------------------------------------------------------------------! ! Read the input namelist:                                                     ! !------------------------------------------------------------------------------! read ( unit = 5 , nml = INPUT , iostat = io_status , iomsg = err_message ) call file_io_status ( io_status , err_message , 5 , 'r' ) !------------------------------------------------------------------------------! ! Check if the variables from input namelist are supplied correctly:           ! !------------------------------------------------------------------------------! call input_check ( 1 ) if ( jtotmax . eq . - 1 ) jtotmax = 999999 call allocate_1d ( v1array , nlevel ) call allocate_1d ( j1array , nlevel ) call allocate_1d ( elevel , nlevel ) call allocate_1d ( l1tab , nterms ) call allocate_1d ( v1pes , totalcol ) call allocate_1d ( v1ppes , totalcol ) call allocate_1d ( j1pes , totalcol ) call allocate_1d ( j1ppes , totalcol ) select case ( iunits ) case ( 0 ) radial_term_distance_converter = 1.0_dp case ( 1 ) radial_term_distance_converter = bohrtoangstrom end select radial_term_energy_converter = 1.0_dp / hartreetocm !------------------------------------------------------------------------------! ! Read the basis namelist & check if the values were supplied correctly:       ! !------------------------------------------------------------------------------! read ( unit = 5 , nml = BASIS , iostat = io_status , iomsg = err_message ) call file_io_status ( io_status , err_message , 5 , 'r' ) call input_check ( 2 ) !------------------------------------------------------------------------------! ! If itype = 2/4 the code reads all the totalcol coupling terms, but some of   ! ! them will not be used in the calculations. Here, the code prepares           ! ! the arrays of ncoupl size, that will hold only the necessary terms           ! !------------------------------------------------------------------------------! ncoupl = nlevel * ( nlevel + 1 ) / 2 call allocate_1d ( reduced_j1pes , ncoupl ) call allocate_1d ( reduced_j1ppes , ncoupl ) call allocate_1d ( reduced_v1pes , ncoupl ) call allocate_1d ( reduced_v1ppes , ncoupl ) icoupl = 0 do ilevel = 1 , nlevel do iilevel = ilevel , nlevel icoupl = icoupl + 1 reduced_v1pes ( icoupl ) = v1array ( ilevel ) reduced_j1pes ( icoupl ) = j1array ( ilevel ) reduced_v1ppes ( icoupl ) = v1array ( iilevel ) reduced_j1ppes ( icoupl ) = j1array ( iilevel ) enddo enddo !------------------------------------------------------------------------------! ! Read the potential namelist & check if the values were supplied correctly:   ! !------------------------------------------------------------------------------! read ( unit = 5 , nml = POTENTIAL , iostat = io_status , iomsg = err_message ) call file_io_status ( io_status , err_message , 5 , 'r' ) call input_check ( 3 ) close ( 5 ) !------------------------------------------------------------------------------! ! Prepare the arrays that are needed for interpolation of the coupling terms:  ! !------------------------------------------------------------------------------! call allocate_1d ( rmat , nr ) call allocate_1d ( spline_coeff_b , nr ) call allocate_1d ( spline_coeff_c , nr ) call allocate_1d ( spline_coeff_d , nr ) call allocate_3d ( read_vmat3D , nr , nterms , totalcol ) call allocate_3d ( vmat3D , nr , nterms , ncoupl ) call allocate_3d ( bmat3D , nr , nterms , ncoupl ) call allocate_3d ( cmat3D , nr , nterms , ncoupl ) call allocate_3d ( dmat3D , nr , nterms , ncoupl ) !------------------------------------------------------------------------------! ! Summarize the input parameters:                                              ! !------------------------------------------------------------------------------! call input_summary end subroutine read_input_file !------------------------------------------------------------------------------! subroutine input_check ( nmlistind ) !! checks if the supplied input parameters are correct !------------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: nmlistind !! nmlistind = 1: namelist INPUT !! nmlistind = 2: namelist BASIS !! nmlistind = 3: namelist POTENTIAL !------------------------------------------------------------------------! integer ( int32 ) :: ilevel , il , icol !------------------------------------------------------------------------! if ( nmlistind . eq . 1 ) then !------------------------------------------------------------------------! ! Namelist input: !------------------------------------------------------------------------! if ( reducedmass . lt . 0 ) then call incorrect_value ( \"reducedmass\" , reducedmass , 5 ) endif if (( ietoterel . ne . 0 ). and .( ietoterel . ne . 1 )) then call incorrect_value ( \"ietoterel\" , ietoterel , 5 ) endif if ( energy . lt . 0 ) then call incorrect_value ( \"energy\" , energy , 5 ) endif if ( rmin . le . 0 ) then call incorrect_value ( \"rmin\" , rmin , 5 ) endif if ( rmax . le . 0 ) then call incorrect_value ( \"rmax\" , rmax , 5 ) endif if ( rmax . lt . rmin ) then call incorrect_value ( \"rmax/rmin\" , rmax / rmin , 5 ) endif if ( steps . le . 0.d0 ) then call incorrect_value ( \"steps\" , steps , 5 ) endif if ( vdepth . lt . 0.d0 ) then call incorrect_value ( \"vdepth\" , vdepth , 5 ) endif if ( jtotmin . lt . 0 ) then call incorrect_value ( \"jtotmin\" , jtotmin , 5 ) endif if ( jtotmax . lt . 0 ) then if ( ncac . lt . 0 ) then call write_message ( \"JTOTMAX < 0:\" ) call incorrect_value ( \"ncac\" , ncac , 5 ) endif if ( dtol . lt . 0 ) then call write_message ( \"JTOTMAX < 0:\" ) call incorrect_value ( \"dtol\" , dtol , 5 ) endif if ( otol . lt . 0 ) then call write_message ( \"JTOTMAX < 0:\" ) call incorrect_value ( \"otol\" , otol , 5 ) endif else if ( jtotmax . lt . jtotmin ) then call write_message ( \"jtotmax is smaller than jtotmin\" ) call incorrect_value ( \"jtotmax/jtotmin\" , & real ( jtotmax / jtotmin , dp ), 5 ) endif endif if ( nlevel . le . 0 ) then call incorrect_value ( \"nlevel\" , nlevel , 5 ) endif if ( ietoterel . eq . 1 ) then if ( initial . le . 0 ) then call write_message ( \"ietoterel = 1:\" ) call incorrect_value ( \"initial\" , initial , 5 ) endif if ( initial . gt . nlevel ) then call write_message ( \"ietoterel = 1:\" ) call write_message ( \"nlevel = \" // integer_to_character ( nlevel )) call incorrect_value ( \"initial > nlevel\" , initial , 5 ) endif endif if ( nr . le . 0 ) then call incorrect_value ( \"nr\" , nr , 5 ) endif if ( nterms . le . 0 ) then call incorrect_value ( \"nterms\" , nterms , 5 ) endif if ( totalcol . le . 0 ) then call incorrect_value ( \"totalcol\" , totalcol , 5 ) endif if ( n_skip_lines . lt . 0 ) then call incorrect_value ( \"n_skip_lines\" , n_skip_lines , 5 ) endif if (( iunits . ne . 0 ). and .( iunits . ne . 1 )) then call incorrect_value ( \"iunits\" , iunits , 5 ) endif inquire ( file = potentialfile , exist = pes_file_exists ) if ( pes_file_exists . eqv .. false .) then call write_error ( trim ( adjustl ( potentialfile )) // \" does not exist\" ) endif if (( ipart . ne . 0 ). and .( ipart . ne . 1 )) then call incorrect_value ( \"ipart\" , ipart , 5 ) endif if ( prntlvl . lt . 0 ) then call incorrect_value ( \"prntlvl\" , prntlvl , 5 ) endif !------------------------------------------------------------------------! else if ( nmlistind . eq . 2 ) then !------------------------------------------------------------------------! ! Namelist basis: !------------------------------------------------------------------------! do ilevel = 1 , nlevel if ( v1array ( ilevel ). lt . 0 ) then call incorrect_value ( \"v1array(\" // integer_to_character ( ilevel ) // \")\" , v1array ( ilevel ), 5 ) endif if ( j1array ( ilevel ). lt . 0 ) then call incorrect_value ( \"j1array(\" // integer_to_character ( ilevel ) // \")\" , j1array ( ilevel ), 5 ) endif if ( elevel ( ilevel ). lt . 0.0_dp ) then call incorrect_value ( \"elevel(\" // integer_to_character ( ilevel ) // \")\" , elevel ( ilevel ), 5 ) endif enddo !------------------------------------------------------------------------! else if ( nmlistind . eq . 3 ) then !------------------------------------------------------------------------! ! Namelist potential: !------------------------------------------------------------------------! do il = 1 , nterms if ( l1tab ( il ). lt . 0 ) then call incorrect_value ( \"l1tab(\" // integer_to_character ( il ) // \")\" , l1tab ( il ), 5 ) endif enddo do icol = 1 , totalcol if ( v1pes ( icol ). lt . 0 ) then call incorrect_value ( \"v1pes(\" // integer_to_character ( icol ) // \")\" , v1pes ( icol ), 5 ) endif if ( j1pes ( icol ). lt . 0 ) then call incorrect_value ( \"j1pes(\" // integer_to_character ( icol ) // \")\" , j1pes ( icol ), 5 ) endif if ( v1ppes ( icol ). lt . 0 ) then call incorrect_value ( \"vp1pes(\" // integer_to_character ( icol ) // \")\" , v1ppes ( icol ), 5 ) endif if ( j1ppes ( icol ). lt . 0 ) then call incorrect_value ( \"j1ppes(\" // integer_to_character ( icol ) // \")\" , j1ppes ( icol ), 5 ) endif enddo endif !------------------------------------------------------------------------! end subroutine input_check !------------------------------------------------------------------------------! subroutine input_summary !! summarize the input parameters for the current run !------------------------------------------------------------------------! integer ( int32 ) :: ilevel !------------------------------------------------------------------------! call write_message ( \"User-supplied label: \" // label ) call write_message ( \"Reduced mass: \" // & trim ( adjustl ( float_to_character ( reducedmass , \"(F10.4)\" ))) // \" a.m.u.\" ) call write_message ( \"*** Energy levels in the basis set: ***\" ) call write_message ( \"   v       j            Energy (cm&#94;{-1})\" ) do ilevel = 1 , nlevel write ( * , \"(I4,4X,I4,16X,F12.4)\" ) v1array ( ilevel ), j1array ( ilevel ), elevel ( ilevel ) enddo write ( * , \"(44X,A3)\" ) \"***\" if ( jtotmax . ne . 999999 ) then call write_message ( \"The equations will be solved \" // & \"for total angular momentum J from \" // & trim ( adjustl ( integer_to_character ( jtotmin ))) // \" to \" & // trim ( adjustl ( integer_to_character ( jtotmax ))) // \" with step \" // & trim ( adjustl ( integer_to_character ( jtotstep )))) else call write_message ( \"The loop over JTOT will be performed from \" // & trim ( adjustl ( integer_to_character ( jtotmin ))) // \" with step \" // & trim ( adjustl ( integer_to_character ( jtotstep ))) // \" until \" // & trim ( adjustl ( integer_to_character ( ncac ))) // & \" consecutive JTOT-blocks contribute less than \" // & trim ( adjustl ( float_to_character ( dtol , \"(E10.4)\" ))) // & \" A&#94;2 to the elastic XS and less than \" // & trim ( adjustl ( float_to_character ( otol , \"(E10.4)\" ))) // & \" A&#94;2 to the inelastic XS\" ) endif if ( ietoterel . eq . 0 ) then call write_message ( \"The calculations will be performed for the total energy equal to \" & // trim ( adjustl ( float_to_character ( ETOTAL (), \"(F10.4)\" ))) // \" cm-1\" ) else if ( ietoterel . eq . 1 ) then call write_message ( \"Relative kinetic energy of the colliding system: \" // & trim ( adjustl ( float_to_character ( energy , \"(F10.4)\" ))) // \" cm-1\" ) call write_message ( \"The kinetic energy is calculated with respect to the\" // & \" v = \" // trim ( adjustl ( integer_to_character ( v1array ( initial )))) // & \" j = \" // trim ( adjustl ( integer_to_character ( j1array ( initial )))) // & \" level in the basis set with the rotational energy \" // & trim ( adjustl ( float_to_character ( elevel ( initial ), \"(F10.4)\" ))) & // \" cm-1.\" ) call write_message ( \"This gives the total energy equal to \" // & trim ( adjustl ( float_to_character ( ETOTAL (), \"(F10.4)\" ))) // \" cm-1\" ) endif if ( ipart . eq . 1 ) then call write_message ( \"Partial cross sections will be saved into \" // partialfile ) endif call write_message ( \"S-matrix elements will be saved into \" // smatrixfile ) !------------------------------------------------------------------------! end subroutine input_summary !------------------------------------------------------------------------------! subroutine units_conversion !! converts all physical quantities to atomic units !------------------------------------------------------------------------! integer ( int32 ) :: ilevel !------------------------------------------------------------------------! reducedmass = reducedmass * amutoau energy = energy / hartreetocm vdepth = vdepth / hartreetocm !------------------------------------------------------------------------! do ilevel = 1 , nlevel elevel ( ilevel ) = elevel ( ilevel ) / hartreetocm enddo !------------------------------------------------------------------------! units_converted = . true . !------------------------------------------------------------------------! end subroutine units_conversion !------------------------------------------------------------------------------! function ETOTAL () result ( etot_ ) !! returns the total energy !------------------------------------------------------------------------! real ( dp ) :: etot_ !------------------------------------------------------------------------! if ( ietoterel . eq . 0 ) then etot_ = energy else if ( ietoterel . eq . 1 ) then etot_ = energy + elevel ( initial ) endif !------------------------------------------------------------------------! end function !------------------------------------------------------------------------------! function wavenumber_from_energy ( energy_ ) result ( k_ ) !! returns the wavenumber, \\k_{a}\\, given the energy of a given state, !! \\E_{a}\\; calls etot() function; atomic units in the whole function !! \\ k_{a} = \\sqrt(2 \\mu (E_{tot} - E_{a}) \\ !! since it uses reducedmass and etotal(), the function checks !! if units are already converted !------------------------------------------------------------------------! real ( dp ), intent ( in ) :: energy_ !! energy of a given state, \\ E_{a} \\, in a.u. real ( dp ) :: k_ !! wavenumber, \\k_{a}\\, in a.u. !------------------------------------------------------------------------! if ( units_converted ) then !---------------------------------------------------------------------! ! abs() is for closed channels, see... !---------------------------------------------------------------------! k_ = dsqrt ( 2 * reducedmass * abs ( ETOTAL () - energy_ )) else call write_error ( \"wavenumber_from_energy called but units are not \" // & \"converted yet\" ) endif !------------------------------------------------------------------------! end function !------------------------------------------------------------------------------! function is_open ( energy_ ) result ( is_open_ ) !! checks if a channel/level is energetically accessible (open) !! by comparing energy with etotal() !------------------------------------------------------------------------! real ( dp ), intent ( in ) :: energy_ !! level/channel energy logical :: is_open_ !------------------------------------------------------------------------! is_open_ = ( energy_ <= ETOTAL () ) !------------------------------------------------------------------------! end function is_open !------------------------------------------------------------------------------! function count_open_basis_levels () result ( open_ ) !! counts the energetically accessible levels in the basis !------------------------------------------------------------------------! integer ( int32 ) :: open_ , ilevel !------------------------------------------------------------------------! open_ = 0 do ilevel = 1 , nlevel if ( is_open ( elevel ( ilevel ))) open_ = open_ + 1 enddo !------------------------------------------------------------------------! end function count_open_basis_levels !------------------------------------------------------------------------------! subroutine save_open_basis_levels ( number_of_open_basis_levels , & open_basis_levels , open_basis_wavevectors ) !! saves indices to open levels in the basis and corresponding !! wavenumbers (in A&#94;2) !------------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: number_of_open_basis_levels !! number of energetically accessible levels in the basis integer ( int32 ), intent ( inout ) :: open_basis_levels ( number_of_open_basis_levels ) !! array holding indices to energetically accessible levels in the basis real ( dp ), intent ( inout ) :: open_basis_wavevectors ( number_of_open_basis_levels ) !! array holding wavevectors calculated w.r.t energetically accessible levels in the basis !------------------------------------------------------------------------! integer ( int32 ) :: count_ , ilevel !------------------------------------------------------------------------! count_ = 0 do ilevel = 1 , nlevel if ( is_open ( elevel ( ilevel ))) then count_ = count_ + 1 open_basis_levels ( count_ ) = ilevel open_basis_wavevectors ( count_ ) = & wavenumber_from_energy ( elevel ( ilevel )) / bohrtoangstrom endif enddo !------------------------------------------------------------------------! end subroutine save_open_basis_levels !------------------------------------------------------------------------------! end module io_mod","tags":"","loc":"sourcefile/input_reader_mod.f90.html"},{"title":"math_functions_mod.f90 – the SCATTERING code","text":"This file depends on sourcefile~~math_functions_mod.f90~~EfferentGraph sourcefile~math_functions_mod.f90 math_functions_mod.f90 sourcefile~utility_functions_mod.f90 utility_functions_mod.f90 sourcefile~math_functions_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~special_functions_mod.f90 special_functions_mod.f90 sourcefile~math_functions_mod.f90->sourcefile~special_functions_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~math_functions_mod.f90~~AfferentGraph sourcefile~math_functions_mod.f90 math_functions_mod.f90 sourcefile~radial_coupling_terms_mod.f90 radial_coupling_terms_mod.f90 sourcefile~radial_coupling_terms_mod.f90->sourcefile~math_functions_mod.f90 sourcefile~boundary_conditions_mod.f90 boundary_conditions_mod.f90 sourcefile~boundary_conditions_mod.f90->sourcefile~math_functions_mod.f90 sourcefile~coupling_matrix_mod.f90 coupling_matrix_mod.f90 sourcefile~coupling_matrix_mod.f90->sourcefile~math_functions_mod.f90 sourcefile~propagator_mod.f90 propagator_mod.f90 sourcefile~propagator_mod.f90->sourcefile~radial_coupling_terms_mod.f90 sourcefile~scattering.f90 scattering.f90 sourcefile~scattering.f90->sourcefile~radial_coupling_terms_mod.f90 sourcefile~scattering.f90->sourcefile~boundary_conditions_mod.f90 sourcefile~scattering.f90->sourcefile~coupling_matrix_mod.f90 sourcefile~scattering.f90->sourcefile~propagator_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules math_functions_mod Source Code math_functions_mod.f90 Source Code module math_functions_mod !! this module holds 4 types of functions: !! -- algebraic functions: percival_seaton_coefficient !! -- geometric functions: triangle_inequality_holds, is_sum_even, zero_projections_3j_condition !! -- bessel functions: groups functions: riccati_bessel_j, bessely and modified_bessel_k_ratio !!    that call special functions from special_functions.f90 library !! -- interpolation procedures: spline and ispline functions for interpolating data !! -- additional functions: rctj, rcty, envj, msta1, msta2, ikv, gamma from !!    special_functions library !---------------------------------------------------------------------------! use , intrinsic :: iso_fortran_env , only : int32 , sp => real32 , dp => real64 use utility_functions_mod , only : write_error , write_warning , & integer_to_character , float_to_character , time_count_summary use special_functions_mod , only : rctj , rcty , envj , msta1 , msta2 , ikv , gamma !---------------------------------------------------------------------------! implicit none contains !---------------------------------------------------------------------------! !                           Algebraic functions !---------------------------------------------------------------------------! function percival_seaton_coefficient ( j_ , j_prime_ , lambda_ , omega_ ) & result ( percival_seaton_coefficient_ ) !! calculates Percival-Seaton coefficients (body-fixed variant) !! \\begin{equation} !! \\label{eq:algebraic_coeffs} !! g_{{\\lambda},\\gamma,\\gamma'}&#94;{Jp} = \\delta_{\\bar{\\Omega},\\bar{\\Omega}'} (-1)&#94;{\\bar{\\Omega}} \\sqrt{(2j+1)(2j'+1)} !! \\begin{pmatrix} !!   j & j' & \\lambda \\\\ 0 & 0 & 0 !! \\end{pmatrix} !! \\begin{pmatrix} !! j & j' & \\lambda \\\\ \\bar{\\Omega} & -\\bar{\\Omega} & 0 \\end{pmatrix}. !! \\end{equation} !------------------------------------------------------------------------! use fwigxjpf , only : fwig3jj !------------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: j_ !! pre-collisional rotational angular momentum integer ( int32 ), intent ( in ) :: j_prime_ !! post-collisional rotational angular momentum integer ( int32 ), intent ( in ) :: omega_ !! \\\\bar{\\Omega}\\ integer ( int32 ), intent ( in ) :: lambda_ !! Legendre expansion coefficient \\ \\lambda\\ real ( dp ) :: percival_seaton_coefficient_ !! (out) result: percival seaton coefficient in the body-fixed frame !------------------------------------------------------------------------! percival_seaton_coefficient_ = ( - 1.0_dp ) ** ( omega_ ) * sqrt ( & real (( 2 * j_ + 1 ) * ( 2 * j_prime_ + 1 ), dp )) & * fwig3jj ( 2 * j_ , 2 * j_prime_ , 2 * lambda_ , 0 , 0 , 0 ) & * fwig3jj ( 2 * j_ , 2 * j_prime_ , 2 * lambda_ , & 2 * omega_ , - 2 * omega_ , 0 ) !------------------------------------------------------------------------! end function percival_seaton_coefficient !---------------------------------------------------------------------------! !                           Geometric functions !---------------------------------------------------------------------------! function triangle_inequality_holds ( x , y , z ) result ( holds ) !! check if the triangle inequality for 3 variables hols !------------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: x , y , z !! variables to check the triangle inequality logical :: holds !! (out) result: true/false !------------------------------------------------------------------------! holds = ( ( x + y >= z ) . and . ( x + z >= y ) . and . ( y + z >= x ) ) !------------------------------------------------------------------------! end function triangle_inequality_holds !---------------------------------------------------------------------------! function is_sum_even ( x , y , z ) result ( sum_even ) !! checks if the sum of 3 integers is an even integer !------------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: x , y , z !! variables to check if the sum is even logical :: sum_even !! (out) result: true/false !------------------------------------------------------------------------! sum_even = ( modulo ( x + y + z , 2 ) == 0 ) !------------------------------------------------------------------------! end function is_sum_even !---------------------------------------------------------------------------! function zero_projections_3j_condition ( x , y , z ) result ( is_valid ) !! checks the condition for nonvanishing 3-j symbol with zero projections: !! triangle inequality on x,y,z and if the sum x+y+z is an even integer !------------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: x , y , z !! variables to check for 3-j symbol conditions logical :: is_valid !! (out) result: true/false if conditions are met !------------------------------------------------------------------------! is_valid = ( triangle_inequality_holds ( x , y , z ) . and . is_sum_even ( x , y , z )) !------------------------------------------------------------------------! end function zero_projections_3j_condition !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! !                             Bessel functions ! these functions handle calling to specific subroutines from ! special_functions.f90 library !---------------------------------------------------------------------------! subroutine riccati_bessel_j ( l_ , x_ , j_ , jp_ ) !! calculates the Riccati-Bessel function of the first kind and its !! first derivative. Calls the rctj function from special_functions.f90 !------------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: l_ !! l - order of the Riccati-Bessel function of the first kind real ( dp ), intent ( in ) :: x_ !! x - argument of the Riccati-Bessel function of the first kind real ( dp ), intent ( inout ) :: j_ !! j_{l} (x) - Riccati-Bessel funciton of the first kind real ( dp ), intent ( inout ) :: jp_ !! j_{l}' (x) - derivative of the Riccati-Bessel funciton of the first kind !------------------------------------------------------------------------! integer ( int32 ) :: highest_order_ real ( dp ), dimension ( l_ + 1 ) :: rj_ , dj_ !------------------------------------------------------------------------! if ( l_ == 0 ) then call rctj ( l_ + 1 , x_ , highest_order_ , rj_ , dj_ ) else call rctj ( l_ , x_ , highest_order_ , rj_ , dj_ ) endif if ( highest_order_ < l_ ) then !---------------------------------------------------------------------! call write_warning ( \"riccati_bessel_j: maximum order of Riccati-Bessel function:\" & // trim ( adjustl ( integer_to_character ( highest_order_ ))) // \"is smaller than \" // & \"requested order l = \" // trim ( adjustl ( integer_to_character ( l_ ))) ) !---------------------------------------------------------------------! j_ = rj_ ( highest_order_ ) jp_ = dj_ ( highest_order_ ) else j_ = rj_ ( l_ + 1 ) jp_ = dj_ ( l_ + 1 ) endif !------------------------------------------------------------------------! end subroutine riccati_bessel_j !---------------------------------------------------------------------------! subroutine riccati_bessel_y ( l_ , x_ , y_ , yp_ ) !! calculates the Riccati-Bessel function of the second kind and its !! first derivative. Calls the rcty function from special_functions.f90 !------------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: l_ !! l - order of the Riccati-Bessel function of the second kind real ( dp ), intent ( in ) :: x_ !! x - argument of the Riccati-Bessel function of the second kind real ( dp ), intent ( inout ) :: y_ !! y_{l} (x) - Riccati-Bessel funciton of the second kind real ( dp ), intent ( inout ) :: yp_ !! y_{l}' (x) - derivative of the Riccati-Bessel funciton of the second kind !------------------------------------------------------------------------! integer ( int32 ) :: highest_order_ real ( dp ), dimension ( l_ + 1 ) :: ry_ , dy_ !------------------------------------------------------------------------! if ( l_ == 0 ) then call rcty ( l_ + 1 , x_ , highest_order_ , ry_ , dy_ ) else call rcty ( l_ , x_ , highest_order_ , ry_ , dy_ ) endif y_ = ry_ ( l_ + 1 ) yp_ = dy_ ( l_ + 1 ) !------------------------------------------------------------------------! if ( highest_order_ < l_ ) then !---------------------------------------------------------------------! call write_warning ( \"riccati_bessel_j: maximum order of Riccati-Bessel function:\" & // trim ( adjustl ( integer_to_character ( highest_order_ ))) // \"is smaller than \" // & \"requested order l = \" // trim ( adjustl ( integer_to_character ( l_ ))) ) !---------------------------------------------------------------------! y_ = ry_ ( highest_order_ ) yp_ = dy_ ( highest_order_ ) else y_ = ry_ ( l_ + 1 ) yp_ = dy_ ( l_ + 1 ) endif !------------------------------------------------------------------------! end subroutine riccati_bessel_y !---------------------------------------------------------------------------! subroutine modified_bessel_k_ratio ( l_ , x_ , ratio_ ) !! calculates the ratio of the modified Bessel function of the second !! kind K_{l_ + 1/2}(x) and its first derivative (Eq. ...) !! Uses ikv function from special_functions.f90 !------------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: l_ !! l - order of the function (without the 1/2 factor!) real ( dp ), intent ( in ) :: x_ !! x - argument of the function real ( dp ), intent ( inout ) :: ratio_ !! ratio of the modified Bessel function of the second kind to its derivative !------------------------------------------------------------------------! integer ( int32 ) :: highest_order_ real ( dp ) :: order_ , highest_order_real_ real ( dp ), dimension ( l_ + 1 ) :: bi_arr_ , di_arr_ , bk_arr_ , dk_arr_ !------------------------------------------------------------------------! order_ = real ( l_ , dp ) + 0.5_dp call ikv ( order_ , x_ , highest_order_real_ , bi_arr_ , di_arr_ , bk_arr_ , dk_arr_ ) highest_order_ = nint ( highest_order_real_ - 0.5_dp ) !------------------------------------------------------------------------! if ( highest_order_ < l_ ) then !---------------------------------------------------------------------! call write_warning ( \"modified_bessel_k_ratio: maximum order of modified Bessel function:\" & // trim ( adjustl ( integer_to_character ( highest_order_ ))) // \"is smaller than \" // & \"requested order l = \" // trim ( adjustl ( integer_to_character ( l_ ))) ) !---------------------------------------------------------------------! ratio_ = dk_arr_ ( highest_order_ ) / bk_arr_ ( highest_order_ ) else ratio_ = dk_arr_ ( l_ + 1 ) / bk_arr_ ( l_ + 1 ) endif !------------------------------------------------------------------------! end subroutine modified_bessel_k_ratio !---------------------------------------------------------------------------! !                          Interpolation procedures !---------------------------------------------------------------------------! subroutine spline ( N_ , x_ , y_ , b_ , c_ , d_ ) !! determines b, c and d coefficients of the cubic spline function !! y(x) = y_i + b_i * dx + c_i * dx&#94;2 + d_i * dx&#94;3, !! where dx = x - x_i, and x_i <= x < x_i+1. !! The algorithm is based on !! Gerald, C., and Wheatley, P., \"Applied Numerical Analysis\", Addison-Wesley, 1994. !------------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: N_ !! number of grid points real ( dp ), intent ( in ) :: x_ ( N_ ) !! grid points (ascending order) real ( dp ), intent ( in ) :: y_ ( N_ ) !! tabulated values real ( dp ), intent ( out ) :: b_ ( N_ ), c_ ( N_ ), d_ ( N_ ) !! arrays with coefficients of the spline function !------------------------------------------------------------------------! integer ( int32 ) :: i_ , j_ real ( dp ) :: w_ real ( dp ) :: diff_x_ ( N_ - 1 ) !------------------------------------------------------------------------! ! check if the number of points is larger than 4 !------------------------------------------------------------------------! if ( N_ < 4 ) then call write_error ( \"spline function called with \" // & trim ( adjustl ( integer_to_character ( N_ ))) // \" points\" ) endif !------------------------------------------------------------------------! ! check if x is sorted in ascending order !------------------------------------------------------------------------! do i_ = 2 , N_ if ( x_ ( i_ ) <= x_ ( i_ - 1 )) then call write_error ( \"spline: x values are not in ascending order \" // & \" at index \" // trim ( adjustl ( integer_to_character ( i_ )))) endif end do !------------------------------------------------------------------------! diff_x_ = x_ ( 2 : N_ ) - x_ ( 1 : N_ - 1 ) !------------------------------------------------------------------------! b_ ( 2 : N_ - 1 ) = 2.0_dp * ( diff_x_ ( 1 : N_ - 2 ) + diff_x_ ( 2 : N_ - 1 )) b_ ( 1 ) = - diff_x_ ( 1 ) b_ ( N_ ) = - diff_x_ ( N_ - 1 ) c_ ( 2 : N_ - 1 ) = ( y_ ( 3 : N_ ) - y_ ( 2 : N_ - 1 ) ) / diff_x_ ( 2 : N_ - 1 ) & - ( y_ ( 2 : N_ - 1 ) - y_ ( 1 : N_ - 2 ) ) / diff_x_ ( 1 : N_ - 2 ) c_ ( 1 ) = c_ ( 3 ) / ( x_ ( 4 ) - x_ ( 2 )) - c_ ( 2 ) / ( x_ ( 3 ) - x_ ( 1 )) c_ ( N_ ) = c_ ( N_ - 1 ) / ( x_ ( N_ ) - x_ ( N_ - 2 )) - c_ ( N_ - 2 ) / ( x_ ( N_ - 1 ) - x_ ( N_ - 3 )) c_ ( 1 ) = c_ ( 1 ) / ( x_ ( 4 ) - x_ ( 1 )) * diff_x_ ( 1 ) ** 2 c_ ( N_ ) = - c_ ( N_ ) / ( x_ ( N_ ) - x_ ( N_ - 3 )) * diff_x_ ( N_ - 1 ) ** 2 do i_ = 2 , N_ w_ = diff_x_ ( i_ - 1 ) / b_ ( i_ - 1 ) b_ ( i_ ) = b_ ( i_ ) - w_ * diff_x_ ( i_ - 1 ) c_ ( i_ ) = c_ ( i_ ) - w_ * c_ ( i_ - 1 ) end do c_ ( N_ ) = c_ ( N_ ) / b_ ( N_ ) do j_ = 1 , N_ - 1 i_ = N_ - j_ c_ ( i_ ) = ( c_ ( i_ ) - diff_x_ ( i_ ) * c_ ( i_ + 1 )) / b_ ( i_ ) end do b_ ( 1 : N_ - 1 ) = ( y_ ( 2 : N_ ) - y_ ( 1 : N_ - 1 ) ) / diff_x_ ( 1 : N_ - 1 ) & - ( 2.0_dp * c_ ( 1 : N_ - 1 ) + c_ ( 2 : N_ ) ) * diff_x_ ( 1 : N_ - 1 ) d_ ( 1 : N_ - 1 ) = ( c_ ( 2 : N_ ) - c_ ( 1 : N_ - 1 ) ) / diff_x_ ( 1 : N_ - 1 ) c_ = c_ * 3.0_dp end subroutine spline !---------------------------------------------------------------------------! function ispline ( u_ , N_ , x_ , y_ , b_ , c_ , d_ ) result ( spl_result ) !! returns interpolated value at guven u_ point !! number of points and ascending order of x is not checked since !! ispline is called after \"spline\" where these checks are done !------------------------------------------------------------------------! real ( dp ), intent ( in ) :: u_ !! point at which the tabulated value is interpolated integer ( int32 ), intent ( in ) :: N_ !! number of grid points real ( dp ), intent ( in ) :: x_ ( N_ ) !! grid points real ( dp ), intent ( in ) :: y_ ( N_ ) !! tabulated values real ( dp ), intent ( in ) :: b_ ( N_ ), c_ ( N_ ), d_ ( N_ ) !! arrays with coefficients of the spline function real ( dp ) :: spl_result !! interpolated value at u_ !------------------------------------------------------------------------! integer ( int32 ) :: k_ , l_ , mid_ real ( dp ) :: dx_ !------------------------------------------------------------------------! if ( u_ > x_ ( N_ )) then call write_warning ( \"ispline: point u_ = \" // & trim ( adjustl ( float_to_character ( u_ ))) // \" exceeds the original \" & // \"grid: x(N) = \" // trim ( adjustl ( float_to_character ( x_ ( N_ ))))) spl_result = y_ ( N_ ) else if ( u_ < x_ ( 1 ) ) then call write_warning ( \"ispline: point u_ = \" // & trim ( adjustl ( float_to_character ( u_ ))) // \" exceeds the original \" & // \"grid: x(1) = \" // trim ( adjustl ( float_to_character ( x_ ( 1 ))))) spl_result = y_ ( 1 ) else !---------------------------------------------------------------------! l_ = 1 k_ = N_ + 1 do while ( k_ > l_ + 1 ) mid_ = nint ( ( l_ + k_ ) / 2.0_dp ) if ( x_ ( mid_ ) > u_ ) then k_ = mid_ else l_ = mid_ endif end do dx_ = u_ - x_ ( l_ ) spl_result = y_ ( l_ ) + dx_ * ( b_ ( l_ ) + dx_ * ( c_ ( l_ ) + d_ ( l_ ) * dx_ )) !---------------------------------------------------------------------! endif !------------------------------------------------------------------------! end function ispline !------------------------------------------------------------------------------! end module math_functions_mod","tags":"","loc":"sourcefile/math_functions_mod.f90.html"},{"title":"unitarity_check_mod.f90 – the SCATTERING code","text":"This file depends on sourcefile~~unitarity_check_mod.f90~~EfferentGraph sourcefile~unitarity_check_mod.f90 unitarity_check_mod.f90 sourcefile~input_reader_mod.f90 input_reader_mod.f90 sourcefile~unitarity_check_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~utility_functions_mod.f90 utility_functions_mod.f90 sourcefile~unitarity_check_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~array_operations_mod.f90 array_operations_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~array_operations_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~unitarity_check_mod.f90~~AfferentGraph sourcefile~unitarity_check_mod.f90 unitarity_check_mod.f90 sourcefile~scattering.f90 scattering.f90 sourcefile~scattering.f90->sourcefile~unitarity_check_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules unitarity_check_mod Source Code unitarity_check_mod.f90 Source Code module unitarity_check_mod !! This module contains subroutines that check the unitarity condition !! of the S-matrix (see Eq. (13) in \"Solution of coupled equations\") !---------------------------------------------------------------------------! use , intrinsic :: iso_fortran_env , only : int32 , sp => real32 , dp => real64 use io_mod , only : unitary_tolerance use utility_functions_mod , only : write_warning , write_header , write_message !---------------------------------------------------------------------------! implicit none !---------------------------------------------------------------------------! contains !------------------------------------------------------------------------! subroutine unitarity_check ( number_of_open_channels , s_matrix_real , & s_matrix_imag , is_unitary ) !! checks the unitarity of the S-matrix !! (Eq. (13) in \"Solution of coupled equations\") !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: number_of_open_channels !! number of open channels real ( dp ), intent ( in ) :: s_matrix_real ( number_of_open_channels , number_of_open_channels ) !! real part of the S-matrix real ( dp ), intent ( in ) :: s_matrix_imag ( number_of_open_channels , number_of_open_channels ) !! imaginary part of the S-matrix logical , intent ( inout ) :: is_unitary !! (output) if .true. unitarity is fulfilled, .false. otherwise !---------------------------------------------------------------------! integer ( int32 ) :: channel_index real ( dp ) :: sum_of_squares ( number_of_open_channels ) !---------------------------------------------------------------------! is_unitary = . true . !---------------------------------------------------------------------! call write_header ( \"unitarity\" ) !---------------------------------------------------------------------! ! Calculating sum of squares for each channel !---------------------------------------------------------------------! call calculate_sum_of_squares_for_each_channel ( s_matrix_real , & s_matrix_imag , sum_of_squares ) !---------------------------------------------------------------------! ! Checking unitarity for each channel !---------------------------------------------------------------------! is_unitary = check_unitarity_for_each_channel ( sum_of_squares ) !---------------------------------------------------------------------! ! Handling the output message based on unitarity check !---------------------------------------------------------------------! call handle_unitarity_output_message ( is_unitary ) !---------------------------------------------------------------------! end subroutine unitarity_check !------------------------------------------------------------------------! subroutine calculate_sum_of_squares_for_each_channel ( s_matrix_real , & s_matrix_imag , sum_of_squares_ ) !! calculates the sum !! \\ \\sum\\_{\\gamma'} \\Bigl|{S}&#94;{Jp}\\_{\\gamma, \\gamma'}\\Bigr|&#94;{2} \\ !! for all \\\\gamma\\ channels !---------------------------------------------------------------------! real ( dp ), intent ( in ) :: s_matrix_real (:,:) !! real part of the S-matrix real ( dp ), intent ( in ) :: s_matrix_imag (:,:) !! imaginary part of the S-matrix real ( dp ), intent ( out ) :: sum_of_squares_ (:) !! (output) \\ \\sum\\_{\\gamma'} \\Bigl|{S}&#94;{Jp}\\_{\\gamma, \\gamma'}\\Bigr|&#94;{2} \\ !---------------------------------------------------------------------! integer ( int32 ) :: channel_index_ !---------------------------------------------------------------------! do channel_index_ = 1 , size ( s_matrix_real , 1 ) sum_of_squares_ ( channel_index_ ) = & sum ( s_matrix_real ( channel_index_ , :) ** 2 & + s_matrix_imag ( channel_index_ , :) ** 2 ) enddo !---------------------------------------------------------------------! end subroutine calculate_sum_of_squares_for_each_channel !------------------------------------------------------------------------! function check_unitarity_for_each_channel ( sum_of_squares ) & result ( is_unitary_ ) !! checks if the calculated sum of squares equals 1 for each channel !---------------------------------------------------------------------! real ( dp ), intent ( in ) :: sum_of_squares (:) !! \\ \\sum\\_{\\gamma'} \\Bigl|{S}&#94;{Jp}\\_{\\gamma, \\gamma'}\\Bigr|&#94;{2} \\ logical :: is_unitary_ !! (output) if .true. unitarity is fulfilled, .false. otherwise !---------------------------------------------------------------------! integer :: channel_index !---------------------------------------------------------------------! is_unitary_ = . true . do channel_index = 1 , size ( sum_of_squares ) if ( abs ( sum_of_squares ( channel_index ) - 1.0_dp ) > unitary_tolerance ) then is_unitary_ = . false . exit endif end do !---------------------------------------------------------------------! end function check_unitarity_for_each_channel !------------------------------------------------------------------------! subroutine handle_unitarity_output_message ( is_unitary ) !! handle printing messages depending on the outcome of unitarity check !---------------------------------------------------------------------! logical , intent ( in ) :: is_unitary !! if .true. unitarity is fulfilled, .false. otherwise !---------------------------------------------------------------------! if ( is_unitary ) then call write_message ( \"S-matrix unitary condition fulfilled\" ) else call write_warning ( \"Unitary condition is not fulfilled for one or more channels\" ) call write_message ( \"Consider increasing the STEPS parameter\" ) endif !---------------------------------------------------------------------! end subroutine handle_unitarity_output_message !---------------------------------------------------------------------------! end module unitarity_check_mod","tags":"","loc":"sourcefile/unitarity_check_mod.f90.html"},{"title":"array_operations_mod.f90 – the SCATTERING code","text":"Files dependent on this one sourcefile~~array_operations_mod.f90~~AfferentGraph sourcefile~array_operations_mod.f90 array_operations_mod.f90 sourcefile~propagator_mod.f90 propagator_mod.f90 sourcefile~propagator_mod.f90->sourcefile~array_operations_mod.f90 sourcefile~input_reader_mod.f90 input_reader_mod.f90 sourcefile~propagator_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~radial_coupling_terms_mod.f90 radial_coupling_terms_mod.f90 sourcefile~propagator_mod.f90->sourcefile~radial_coupling_terms_mod.f90 sourcefile~array_operations_append_submod.f90 array_operations_append_submod.f90 sourcefile~array_operations_append_submod.f90->sourcefile~array_operations_mod.f90 sourcefile~boundary_conditions_mod.f90 boundary_conditions_mod.f90 sourcefile~boundary_conditions_mod.f90->sourcefile~array_operations_mod.f90 sourcefile~boundary_conditions_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~array_operations_invert_symmetric_matrix_submod.f90 array_operations_invert_symmetric_matrix_submod.f90 sourcefile~array_operations_invert_symmetric_matrix_submod.f90->sourcefile~array_operations_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~array_operations_mod.f90 sourcefile~scattering.f90 scattering.f90 sourcefile~scattering.f90->sourcefile~array_operations_mod.f90 sourcefile~scattering.f90->sourcefile~propagator_mod.f90 sourcefile~scattering.f90->sourcefile~boundary_conditions_mod.f90 sourcefile~scattering.f90->sourcefile~input_reader_mod.f90 sourcefile~channels_mod.f90 channels_mod.f90 sourcefile~scattering.f90->sourcefile~channels_mod.f90 sourcefile~sts_xs_mod.f90 sts_xs_mod.f90 sourcefile~scattering.f90->sourcefile~sts_xs_mod.f90 sourcefile~coupling_matrix_mod.f90 coupling_matrix_mod.f90 sourcefile~scattering.f90->sourcefile~coupling_matrix_mod.f90 sourcefile~unitarity_check_mod.f90 unitarity_check_mod.f90 sourcefile~scattering.f90->sourcefile~unitarity_check_mod.f90 sourcefile~scattering.f90->sourcefile~radial_coupling_terms_mod.f90 sourcefile~array_operations_fill_symmetric_matrix_submod.f90 array_operations_fill_symmetric_matrix_submod.f90 sourcefile~array_operations_fill_symmetric_matrix_submod.f90->sourcefile~array_operations_mod.f90 sourcefile~array_operations_allocate_submod.f90 array_operations_allocate_submod.f90 sourcefile~array_operations_allocate_submod.f90->sourcefile~array_operations_mod.f90 sourcefile~channels_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~sts_xs_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~coupling_matrix_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~unitarity_check_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~radial_coupling_terms_mod.f90->sourcefile~input_reader_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules array_operations_mod Source Code array_operations_mod.f90 Source Code module array_operations_mod !! this module provides supplementary functions and subroutines to handle !! matrix allocation, invertion, appending etc. !---------------------------------------------------------------------------! use , intrinsic :: iso_fortran_env , only : int32 , sp => real32 , dp => real64 implicit none !---------------------------------------------------------------------------! interface allocate_1d pure module subroutine allocate_1d_int32 ( array_ , size_ ) !! allocate a 1d array and fill it with 0s (integer version) integer ( int32 ), intent ( inout ), allocatable :: array_ (:) integer ( int32 ), intent ( in ) :: size_ end subroutine allocate_1d_int32 pure module subroutine allocate_1d_sp ( array_ , size_ ) !! allocate a 1d array and fill it with 0s (single precision version) real ( sp ), intent ( inout ), allocatable :: array_ (:) integer ( int32 ), intent ( in ) :: size_ end subroutine allocate_1d_sp pure module subroutine allocate_1d_dp ( array_ , size_ ) !! allocate a 1d array and fill it with 0s (double precision version) real ( dp ), intent ( inout ), allocatable :: array_ (:) integer ( int32 ), intent ( in ) :: size_ end subroutine allocate_1d_dp end interface !---------------------------------------------------------------------------! interface allocate_2d pure module subroutine allocate_2d_int32 ( array_ , size1_ , size2_ ) !! allocate a 2d array and fill it with 0s (integer version) integer ( int32 ), intent ( inout ), allocatable :: array_ (:,:) integer ( int32 ), intent ( in ) :: size1_ , size2_ end subroutine allocate_2d_int32 pure module subroutine allocate_2d_sp ( array_ , size1_ , size2_ ) !! allocate a 2d array and fill it with 0s (single precision version) real ( sp ), intent ( inout ), allocatable :: array_ (:,:) integer ( int32 ), intent ( in ) :: size1_ , size2_ end subroutine allocate_2d_sp pure module subroutine allocate_2d_dp ( array_ , size1_ , size2_ ) !! allocate a 2d array and fill it with 0s (double precision version) real ( dp ), intent ( inout ), allocatable :: array_ (:,:) integer ( int32 ), intent ( in ) :: size1_ , size2_ end subroutine allocate_2d_dp end interface !---------------------------------------------------------------------------! interface allocate_3d pure module subroutine allocate_3d_int32 ( array_ , size1_ , size2_ , size3_ ) !! allocate a 3d array and fill it with 0s (integer version) integer ( int32 ), intent ( inout ), allocatable :: array_ (:,:,:) integer ( int32 ), intent ( in ) :: size1_ , size2_ , size3_ end subroutine allocate_3d_int32 pure module subroutine allocate_3d_sp ( array_ , size1_ , size2_ , size3_ ) !! allocate a 3d array and fill it with 0s (single precision version) real ( sp ), intent ( inout ), allocatable :: array_ (:,:,:) integer ( int32 ), intent ( in ) :: size1_ , size2_ , size3_ end subroutine allocate_3d_sp pure module subroutine allocate_3d_dp ( array_ , size1_ , size2_ , size3_ ) !! allocate a 3d array and fill it with 0s (double precision version) real ( dp ), intent ( inout ), allocatable :: array_ (:,:,:) integer ( int32 ), intent ( in ) :: size1_ , size2_ , size3_ end subroutine allocate_3d_dp end interface !---------------------------------------------------------------------------! interface append pure module subroutine append_int32 ( array_ , element_ ) !! append element to an array (integer version) integer ( int32 ), intent ( inout ), allocatable :: array_ (:) integer ( int32 ), intent ( in ) :: element_ end subroutine append_int32 pure module subroutine append_sp ( array_ , element_ ) !! append element to an array (single precision version) real ( sp ), intent ( inout ), allocatable :: array_ (:) real ( sp ), intent ( in ) :: element_ end subroutine append_sp pure module subroutine append_dp ( array_ , element_ ) !! append element to an array (double precision version) real ( dp ), intent ( inout ), allocatable :: array_ (:) real ( dp ), intent ( in ) :: element_ end subroutine append_dp end interface !---------------------------------------------------------------------------! !   interface print_square_matrix !      module subroutine print_square_matrix_int32(matrix_, tol_) !         !! print elements of the square matrix with given tolerance (integer version) !         integer(int32), intent(in)     :: matrix_(:,:) !         real(dp), optional, intent(in) :: tol_ !      end subroutine print_square_matrix_int32 !      module subroutine print_square_matrix_sp(matrix_, tol_) !         !! print elements of the square matrix with given tolerance (single precision version) !         real(sp), intent(in)           :: matrix_(:,:) !         real(dp), optional, intent(in) :: tol_ !      end subroutine print_square_matrix_sp !      module subroutine print_square_matrix_dp(matrix_, tol_) !         !! print elements of the square matrix with given tolerance (double precision version) !         real(dp), intent(in)           :: matrix_(:,:) !         real(dp), optional, intent(in) :: tol_ !      end subroutine print_square_matrix_dp !   end interface !---------------------------------------------------------------------------! interface invert_symmetric_matrix module subroutine invert_symmetric_matrix_int32 ( matrix_ ) !! invert a symmetric matrix using DSYTRI method (integer version) integer ( int32 ), intent ( inout ) :: matrix_ (:,:) end subroutine invert_symmetric_matrix_int32 module subroutine invert_symmetric_matrix_sp ( matrix_ ) !! invert a symmetric matrix using DSYTRI method (single precision version) real ( sp ), intent ( inout ) :: matrix_ (:,:) end subroutine invert_symmetric_matrix_sp module subroutine invert_symmetric_matrix_dp ( matrix_ ) !! invert a symmetric matrix using DSYTRI method (double precision version) real ( dp ), intent ( inout ) :: matrix_ (:,:) end subroutine invert_symmetric_matrix_dp end interface !---------------------------------------------------------------------------! interface fill_symmetric_matrix module subroutine fill_symmetric_matrix_int32 ( matrix_ , upper_lower_ ) !! fill the upper/lower triangle of a symmetric matrix (integer version) integer ( int32 ), intent ( inout ) :: matrix_ (:,:) character ( len = 1 ), intent ( in ) :: upper_lower_ end subroutine fill_symmetric_matrix_int32 module subroutine fill_symmetric_matrix_sp ( matrix_ , upper_lower_ ) !! fill the upper/lower triangle of a symmetric matrix (single precision version) real ( sp ), intent ( inout ) :: matrix_ (:,:) character ( len = 1 ), intent ( in ) :: upper_lower_ end subroutine fill_symmetric_matrix_sp module subroutine fill_symmetric_matrix_dp ( matrix_ , upper_lower_ ) !! fill the upper/lower triangle of a symmetric matrix (double precision version) real ( dp ), intent ( inout ) :: matrix_ (:,:) character ( len = 1 ), intent ( in ) :: upper_lower_ end subroutine fill_symmetric_matrix_dp end interface !---------------------------------------------------------------------------! end module array_operations_mod","tags":"","loc":"sourcefile/array_operations_mod.f90.html"},{"title":"array_operations_invert_symmetric_matrix_submod.f90 – the SCATTERING code","text":"This file depends on sourcefile~~array_operations_invert_symmetric_matrix_submod.f90~~EfferentGraph sourcefile~array_operations_invert_symmetric_matrix_submod.f90 array_operations_invert_symmetric_matrix_submod.f90 sourcefile~array_operations_mod.f90 array_operations_mod.f90 sourcefile~array_operations_invert_symmetric_matrix_submod.f90->sourcefile~array_operations_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules array_operations_invert_symmetric_matrix_submod Source Code array_operations_invert_symmetric_matrix_submod.f90 Source Code submodule ( array_operations_mod ) array_operations_invert_symmetric_matrix_submod !! a submodule for append subroutines implicit none contains module subroutine invert_symmetric_matrix_int32 ( matrix_ ) !! invert a symmetric matrix using DSYTRI method (integer version) integer ( int32 ), intent ( inout ) :: matrix_ (:,:) !---------------------------------------------------------------------! write ( * , * ) \"Integer version of Lapack inversion procedures does not exist\" write ( * , * ) \"Convert the integer arrays to real\" stop !---------------------------------------------------------------------! end subroutine invert_symmetric_matrix_int32 module subroutine invert_symmetric_matrix_sp ( matrix_ ) !! invert a symmetric matrix using SSYTRI method (single precision version) real ( sp ), intent ( inout ) :: matrix_ (:,:) !---------------------------------------------------------------------! integer ( int32 ) :: size_1_ , size_2_ , size_ , lwork_ , nb_ , ok_ , ILAENV integer ( int32 ), allocatable :: pivot_ (:) real ( sp ), allocatable :: work_ (:) !---------------------------------------------------------------------! size_1_ = size ( matrix_ , dim = 1 ) size_2_ = size ( matrix_ , dim = 2 ) if ( size_1_ . eq . size_2_ ) then size_ = size_1_ else print * , \"Error in invert_symmetric_matrix_dp: size in dim = 1 (\" , size_1_ ,& \") is different than in dim = 2 (\" , size_2_ , \")\" print * , \"Adapt this subroutine to rectangle matrices\" stop endif !---------------------------------------------------------------------! if ( allocated ( pivot_ )) deallocate ( pivot_ ) allocate ( pivot_ ( size_ )) !---------------------------------------------------------------------! nb_ = ILAENV ( 1 , 'SSYTRF' , 'L' , size_ , - 1 , - 1 , - 1 ) lwork_ = nb_ * size_ if ( allocated ( work_ )) deallocate ( work_ ) allocate ( work_ ( lwork_ )) work_ = 0 !---------------------------------------------------------------------! call SSYTRF ( 'L' , size_ , matrix_ , size_ , pivot_ , work_ , lwork_ , ok_ ) if ( ok_ /= 0 ) then write ( * , * ) \"DSYTRF failed with status:\" , ok_ stop endif !---------------------------------------------------------------------! call SSYTRI ( 'L' , size_ , matrix_ , size_ , pivot_ , work_ , ok_ ) if ( ok_ /= 0 ) then write ( * , * ) \"DSYTRI failed with status:\" , ok_ stop endif !---------------------------------------------------------------------! end subroutine invert_symmetric_matrix_sp module subroutine invert_symmetric_matrix_dp ( matrix_ ) !! invert a symmetric matrix using DSYTRI method (double precision version) real ( dp ), intent ( inout ) :: matrix_ (:,:) !---------------------------------------------------------------------! integer ( int32 ) :: size_1_ , size_2_ , size_ , lwork_ , nb_ , ok_ , ILAENV integer ( int32 ), allocatable :: pivot_ (:) real ( dp ), allocatable :: work_ (:) !---------------------------------------------------------------------! size_1_ = size ( matrix_ , dim = 1 ) size_2_ = size ( matrix_ , dim = 2 ) if ( size_1_ . eq . size_2_ ) then size_ = size_1_ else print * , \"Error in invert_symmetric_matrix_dp: size in dim = 1 (\" , size_1_ ,& \") is different than in dim = 2 (\" , size_2_ , \")\" print * , \"Adapt this subroutine to rectangle matrices\" stop endif !---------------------------------------------------------------------! if ( allocated ( pivot_ )) deallocate ( pivot_ ) allocate ( pivot_ ( size_ )) !---------------------------------------------------------------------! nb_ = ILAENV ( 1 , 'DSYTRF' , 'L' , size_ , - 1 , - 1 , - 1 ) lwork_ = nb_ * size_ if ( allocated ( work_ )) deallocate ( work_ ) allocate ( work_ ( lwork_ )) work_ = 0 !---------------------------------------------------------------------! call DSYTRF ( 'L' , size_ , matrix_ , size_ , pivot_ , work_ , lwork_ , ok_ ) if ( ok_ /= 0 ) then write ( * , * ) \"DSYTRF failed with status:\" , ok_ stop endif !---------------------------------------------------------------------! call DSYTRI ( 'L' , size_ , matrix_ , size_ , pivot_ , work_ , ok_ ) if ( ok_ /= 0 ) then write ( * , * ) \"DSYTRI failed with status:\" , ok_ stop endif !---------------------------------------------------------------------! end subroutine invert_symmetric_matrix_dp end submodule array_operations_invert_symmetric_matrix_submod","tags":"","loc":"sourcefile/array_operations_invert_symmetric_matrix_submod.f90.html"},{"title":"array_operations_append_submod.f90 – the SCATTERING code","text":"This file depends on sourcefile~~array_operations_append_submod.f90~~EfferentGraph sourcefile~array_operations_append_submod.f90 array_operations_append_submod.f90 sourcefile~array_operations_mod.f90 array_operations_mod.f90 sourcefile~array_operations_append_submod.f90->sourcefile~array_operations_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules array_operations_append_submod Source Code array_operations_append_submod.f90 Source Code submodule ( array_operations_mod ) array_operations_append_submod !! a submodule for append subroutines implicit none contains pure module subroutine append_int32 ( array_ , element_ ) !! append element to an array (intger version) integer ( int32 ), allocatable , intent ( inout ) :: array_ (:) integer ( int32 ), intent ( in ) :: element_ !---------------------------------------------------------------------! integer ( int32 ), allocatable :: tmp_array_ (:) !---------------------------------------------------------------------! if ( allocated ( array_ )) then allocate ( tmp_array_ ( size ( array_ ) + 1 )) tmp_array_ (: size ( array_ )) = array_ (:) tmp_array_ ( size ( array_ ) + 1 ) = element_ deallocate ( array_ ) allocate ( array_ ( size ( tmp_array_ ))) call move_alloc ( tmp_array_ , array_ ) else allocate ( array_ ( 1 )) array_ ( 1 ) = element_ endif end subroutine append_int32 pure module subroutine append_sp ( array_ , element_ ) !! append element to an array (single precision version) real ( sp ), allocatable , intent ( inout ) :: array_ (:) real ( sp ), intent ( in ) :: element_ !---------------------------------------------------------------------! real ( sp ), allocatable :: tmp_array_ (:) !---------------------------------------------------------------------! if ( allocated ( array_ )) then allocate ( tmp_array_ ( size ( array_ ) + 1 )) tmp_array_ (: size ( array_ )) = array_ (:) tmp_array_ ( size ( array_ ) + 1 ) = element_ deallocate ( array_ ) allocate ( array_ ( size ( tmp_array_ ))) call move_alloc ( tmp_array_ , array_ ) else allocate ( array_ ( 1 )) array_ ( 1 ) = element_ endif end subroutine append_sp pure module subroutine append_dp ( array_ , element_ ) !! append element to an array (double precision version) real ( dp ), allocatable , intent ( inout ) :: array_ (:) real ( dp ), intent ( in ) :: element_ !---------------------------------------------------------------------! real ( dp ), allocatable :: tmp_array_ (:) !---------------------------------------------------------------------! if ( allocated ( array_ )) then allocate ( tmp_array_ ( size ( array_ ) + 1 )) tmp_array_ (: size ( array_ )) = array_ (:) tmp_array_ ( size ( array_ ) + 1 ) = element_ deallocate ( array_ ) allocate ( array_ ( size ( tmp_array_ ))) call move_alloc ( tmp_array_ , array_ ) else allocate ( array_ ( 1 )) array_ ( 1 ) = element_ endif end subroutine append_dp end submodule array_operations_append_submod","tags":"","loc":"sourcefile/array_operations_append_submod.f90.html"},{"title":"coupling_matrix_mod.f90 – the SCATTERING code","text":"This file depends on sourcefile~~coupling_matrix_mod.f90~~EfferentGraph sourcefile~coupling_matrix_mod.f90 coupling_matrix_mod.f90 sourcefile~utility_functions_mod.f90 utility_functions_mod.f90 sourcefile~coupling_matrix_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~math_functions_mod.f90 math_functions_mod.f90 sourcefile~coupling_matrix_mod.f90->sourcefile~math_functions_mod.f90 sourcefile~input_reader_mod.f90 input_reader_mod.f90 sourcefile~coupling_matrix_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~math_functions_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~special_functions_mod.f90 special_functions_mod.f90 sourcefile~math_functions_mod.f90->sourcefile~special_functions_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~array_operations_mod.f90 array_operations_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~array_operations_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~coupling_matrix_mod.f90~~AfferentGraph sourcefile~coupling_matrix_mod.f90 coupling_matrix_mod.f90 sourcefile~scattering.f90 scattering.f90 sourcefile~scattering.f90->sourcefile~coupling_matrix_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules coupling_matrix_mod Source Code coupling_matrix_mod.f90 Source Code module coupling_matrix_mod !! this module provides functions calculating the algebraic coefficients !! \\ g\\_{{\\lambda},\\gamma,\\gamma'}&#94;{Jp} \\ entering the coupling matrix: !! see Eq. 1 in the \"Coupling Matrix\" section. The data is organized as follows: !! - number of non-zero terms of the coupling matrix due to !!   \\\\bar{\\Omega} = \\bar{\\Omega}'\\ condition is saved as !!   \"number_of_nonzero_coupling_matrix_elements\" !! - number of non-vanishing terms in the sum over \\\\lambda\\ !!   in Eq. 1 in the \"Coupling Matrix\" section is saved in a !!   \"nonzero_terms_per_element\" array which is of !!   \"number_of_nonzero_coupling_matrix_elements\" size !! - a _total_ number of non-vanishing  \\ g\\_{{\\lambda},\\gamma,\\gamma'}&#94;{Jp} \\ !!   coefficients is saved in \"number_of_nonzero_coupling_coefficients\" !! - _all_ non-vanishing  \\ g\\_{{\\lambda},\\gamma,\\gamma'}&#94;{Jp} \\ !!   coefficients are saved in \"nonzero_coupling_coefficients\" array, !!   which is of \"number_of_nonzero_coupling_coefficients\" size !! - corresponding \\\\lambda\\ value for each non-vanishing coefficient !!   is saved as an index to \"l1tab\" in the \"nonzero_legendre_indices\" !!   array (which is of \"number_of_nonzero_coupling_coefficients\" size) !---------------------------------------------------------------------------! use , intrinsic :: iso_fortran_env , only : int32 , sp => real32 , dp => real64 use utility_functions_mod , only : write_error , write_message , integer_to_character use io_mod use math_functions_mod , only : percival_seaton_coefficient , & triangle_inequality_holds , is_sum_even , zero_projections_3j_condition !---------------------------------------------------------------------------! implicit none !---------------------------------------------------------------------------! contains !------------------------------------------------------------------------------! subroutine check_nonzero_coupling_matrix_elements ( channels_level_indices ,& channels_omega_values , number_of_nonzero_coupling_matrix_elements , & number_of_nonzero_coupling_coefficients ) !! checks the number of non-zero coupling matrix elements due to !! the \\bar{\\Omega} = \\bar{\\Omega}' condition, !! \"number_of_nonzero_coupling_matrix_elements\", !! and the total number of non-zero algebraic coefficients, !! \\ g\\_{{\\lambda},\\gamma,\\gamma'}&#94;{Jp} \\, in the whole matrix, !! \"number_of_nonzero_coupling_coefficients\". !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: channels_level_indices (:) !! holds the indices pointing to the basis arrays integer ( int32 ), intent ( in ) :: channels_omega_values (:) !! holds all values of \\bar{\\Omega} integer ( int32 ), intent ( out ) :: number_of_nonzero_coupling_matrix_elements !! number of non-zero terms in the sum () for each non-zero element of the coupling matrix integer ( int32 ), intent ( out ) :: number_of_nonzero_coupling_coefficients !! number of all non-zero algberaix coefficients in the whole coupling matrix !---------------------------------------------------------------------! integer ( int32 ) :: count_nonzero_coupling_matrix_elements , & count_nonzero_coupling_coefficients , j_ , j_prime_ , omega_ , & omega_prime_ , lambda_ , channel_index_1_ , channel_index_2_ , legendre_term_index_ !---------------------------------------------------------------------! count_nonzero_coupling_coefficients = 0 count_nonzero_coupling_matrix_elements = 0 do channel_index_1_ = 1 , size ( channels_level_indices ) j_ = j1array ( channels_level_indices ( channel_index_1_ )) omega_ = channels_omega_values ( channel_index_1_ ) do channel_index_2_ = 1 , channel_index_1_ j_prime_ = j1array ( channels_level_indices ( channel_index_2_ )) omega_prime_ = channels_omega_values ( channel_index_2_ ) !---------------------------------------------------------------! if ( omega_ /= omega_prime_ ) cycle !---------------------------------------------------------------! count_nonzero_coupling_matrix_elements = & count_nonzero_coupling_matrix_elements + 1 do legendre_term_index_ = 1 , nterms lambda_ = l1tab ( legendre_term_index_ ) if (. not . zero_projections_3j_condition ( j_ , j_prime_ , lambda_ )) cycle count_nonzero_coupling_coefficients = & count_nonzero_coupling_coefficients + 1 enddo enddo enddo !---------------------------------------------------------------------! number_of_nonzero_coupling_coefficients = count_nonzero_coupling_coefficients number_of_nonzero_coupling_matrix_elements = count_nonzero_coupling_matrix_elements !---------------------------------------------------------------------! end subroutine check_nonzero_coupling_matrix_elements !------------------------------------------------------------------------------! subroutine prepare_coupling_matrix_elements ( channels_level_indices , & channels_omega_values , nonzero_terms_per_element , & nonzero_legendre_indices , nonzero_coupling_coefficients ) !! prepares: !! -- nonzero_terms_per_element - number of non-vanishing terms in !!    the sum over \\\\lambda\\ in Eq. 1 in the \"Coupling Matrix\" section !! -- nonzero_legendre_indices - corresponding \\\\lambda\\ value for !!    each non-vanishing coefficient is saved as an index to \"l1tab\" !! -- nonzero_coupling_coefficients --  holds _all_ non-vanishing !!    \\ g\\_{{\\lambda},\\gamma,\\gamma'}&#94;{Jp} \\ coefficients !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: channels_level_indices (:) !! holds the indices pointing to the basis arrays integer ( int32 ), intent ( in ) :: channels_omega_values (:) !! holds all values of \\bar{\\Omega} integer ( int32 ), intent ( inout ) :: nonzero_terms_per_element (:) !! keeps the number of non-vanishing elements of the sum over \\\\lambda\\ !! for each non-zero element of the coupling matrix integer ( int32 ), intent ( inout ) :: nonzero_legendre_indices (:) !! holds indices pointing to l1tab, which correspond to !! the non-vanishing elements of the sum over \\\\lambda\\ !! for each non-zero element of the coupling matrix; real ( dp ), intent ( inout ) :: nonzero_coupling_coefficients (:) !! holds the values of the non-zero algebraic coefficients !---------------------------------------------------------------------! integer ( int32 ) :: count_nonzero_coupling_matrix_elements , & count_nonzero_coupling_coefficients , count_nonzero_legendre_terms , & j_ , j_prime_ , omega_ , omega_prime_ , lambda_ , channel_index_1_ , & channel_index_2_ , legendre_term_index_ real ( dp ) :: pscoeff !---------------------------------------------------------------------! nonzero_terms_per_element = 0 nonzero_legendre_indices = 0 nonzero_coupling_coefficients = 0 count_nonzero_coupling_coefficients = 0 count_nonzero_coupling_matrix_elements = 0 !---------------------------------------------------------------------! do channel_index_1_ = 1 , size ( channels_level_indices ) j_ = j1array ( channels_level_indices ( channel_index_1_ )) omega_ = channels_omega_values ( channel_index_1_ ) do channel_index_2_ = 1 , channel_index_1_ j_prime_ = j1array ( channels_level_indices ( channel_index_2_ )) omega_prime_ = channels_omega_values ( channel_index_2_ ) if ( omega_ /= omega_prime_ ) cycle !---------------------------------------------------------------! ! passed \\bar{\\Omega} = \\bar{\\Omega}' condition !---------------------------------------------------------------! count_nonzero_coupling_matrix_elements = & count_nonzero_coupling_matrix_elements + 1 !---------------------------------------------------------------! ! process a single matrix element: ! determine non-zero terms in the sum over legendre polynomials ! for this element; these are saved to ... !---------------------------------------------------------------! call process_single_matrix_element ( j_ , j_prime_ , omega_ , & count_nonzero_coupling_coefficients , & count_nonzero_legendre_terms , nonzero_legendre_indices , & nonzero_coupling_coefficients ) nonzero_terms_per_element ( count_nonzero_coupling_matrix_elements )& = count_nonzero_legendre_terms enddo enddo !---------------------------------------------------------------------! end subroutine prepare_coupling_matrix_elements !------------------------------------------------------------------------------! !------------------------------------------------------------------------------! subroutine process_single_matrix_element ( j_ , j_prime_ , omega_ , & count_nonzero_coupling_coefficients , count_nonzero_legendre_terms , & nonzero_legendre_indices , nonzero_coupling_coefficients ) !! calculates the non-zero algebraic coefficients !! \\ g\\_{{\\lambda},\\gamma,\\gamma'}&#94;{Jp} \\ for a single matrix !! element - see Eq. (1) in the \"Coupling matrix\" section; !! algebraic coefficients are saved to nonzero_coupling_coefficients !! array; corresponding indices to l1tab are saved to !! nonzero_legendre_indices array !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: j_ !! pre-collisional rotational angular momentum integer ( int32 ), intent ( in ) :: j_prime_ !! post-collisional rotational angular momentum integer ( int32 ), intent ( in ) :: omega_ !! \\\\bar{\\Omega}\\ integer ( int32 ), intent ( inout ) :: count_nonzero_coupling_coefficients !! running index counting non-zero coupling coefficients, !! \\ g\\_{{\\lambda},\\gamma,\\gamma'}&#94;{Jp} \\ in the whole matrix; !! incremented in this subroutine integer ( int32 ), intent ( inout ) :: count_nonzero_legendre_terms !! number of non-zero terms in Legendre expansion for a single !! matrix element of the interaction potential integer ( int32 ), intent ( inout ) :: nonzero_legendre_indices (:) !! holds indices pointing to l1tab, which correspond to !! the non-vanishing elements of the sum over \\\\lambda\\ !! for each non-zero element of the coupling matrix; real ( dp ), intent ( inout ) :: nonzero_coupling_coefficients (:) !! holds values of the non-zero algebraic coefficients !---------------------------------------------------------------------! integer ( int32 ) :: legendre_term_index_ , lambda_ real ( dp ) :: pscoeff !---------------------------------------------------------------------! count_nonzero_legendre_terms = 0 do legendre_term_index_ = 1 , nterms lambda_ = l1tab ( legendre_term_index_ ) !------------------------------------------------------------! ! check the condition on 3-j symbol with zero projections !------------------------------------------------------------! if (. not . zero_projections_3j_condition ( j_ , j_prime_ , lambda_ )) cycle !------------------------------------------------------------! count_nonzero_coupling_coefficients = & count_nonzero_coupling_coefficients + 1 !------------------------------------------------------------! ! calculate the Percival-Seaton coefficient !------------------------------------------------------------! pscoeff = percival_seaton_coefficient ( j_ , j_prime_ , lambda_ , omega_ ) !------------------------------------------------------------! ! save the Percival-Seaton coefficient !------------------------------------------------------------! nonzero_coupling_coefficients ( & count_nonzero_coupling_coefficients ) = pscoeff !------------------------------------------------------------! ! save indices to l1tab corresponding to \\\\lambda\\ !------------------------------------------------------------! nonzero_legendre_indices ( count_nonzero_coupling_coefficients )& = legendre_term_index_ !------------------------------------------------------------! count_nonzero_legendre_terms = count_nonzero_legendre_terms + 1 enddo !---------------------------------------------------------------------! end subroutine process_single_matrix_element !------------------------------------------------------------------------------! !------------------------------------------------------------------------------! subroutine print_coupling_matrix_elements_summary ( number_of_channels , & number_of_nonzero_coupling_matrix_elements , & number_of_nonzero_coupling_coefficients ) !! print a shor summary on the number of non-zero matrix elements !! of the coupling matrix !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: number_of_channels !! size of the basis integer ( int32 ), intent ( in ) :: number_of_nonzero_coupling_matrix_elements !! number of non-zero terms in the sum () for each non-zero element !! of the coupling matrix integer ( int32 ), intent ( in ) :: number_of_nonzero_coupling_coefficients !! number of all non-zero algberaix coefficients in the whole !! coupling matrix !---------------------------------------------------------------------! call write_message ( repeat ( \"*\" , 90 )) call write_message ( repeat ( \" \" , 5 ) // \"Size of the coupling matrix: \" // & integer_to_character ( number_of_channels )) call write_message ( repeat ( \" \" , 5 ) // \"Number of non-zero elements \" // & \"of the potential matrix: \" // integer_to_character ( & number_of_nonzero_coupling_matrix_elements )) call write_message ( repeat ( \" \" , 5 ) // \"Number of non-zero elements \" // & \" of the coupling matrix: \" // integer_to_character ( & number_of_nonzero_coupling_coefficients )) call write_message ( repeat ( '*' , 90 )) !---------------------------------------------------------------------! end subroutine print_coupling_matrix_elements_summary !------------------------------------------------------------------------------! !------------------------------------------------------------------------------! end module coupling_matrix_mod","tags":"","loc":"sourcefile/coupling_matrix_mod.f90.html"},{"title":"sts_xs_mod.f90 – the SCATTERING code","text":"This file depends on sourcefile~~sts_xs_mod.f90~~EfferentGraph sourcefile~sts_xs_mod.f90 sts_xs_mod.f90 sourcefile~input_reader_mod.f90 input_reader_mod.f90 sourcefile~sts_xs_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~utility_functions_mod.f90 utility_functions_mod.f90 sourcefile~sts_xs_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~array_operations_mod.f90 array_operations_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~array_operations_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~sts_xs_mod.f90~~AfferentGraph sourcefile~sts_xs_mod.f90 sts_xs_mod.f90 sourcefile~scattering.f90 scattering.f90 sourcefile~scattering.f90->sourcefile~sts_xs_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules statetostateXS Source Code sts_xs_mod.f90 Source Code module statetostateXS !! This modules contains the subroutine that calculates the state-to-state XS !---------------------------------------------------------------------------! use , intrinsic :: iso_fortran_env , only : int32 , sp => real32 , dp => real64 use io_mod use utility_functions_mod , only : write_message , time_count_summary implicit none contains !---------------------------------------------------------------------------! subroutine CROSSSECTION ( jj , nopen , number_of_channels , & number_of_open_basis_levels , open_basis_levels , & open_basis_wavevectors , srmatrix , simatrix , channels_level_indices , & channels_l_values , xs_array ) !! calculate the state-to-state cross-section !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: jj !! total angular momentum integer ( int32 ), intent ( in ) :: nopen !! number of open channels integer ( int32 ), intent ( in ) :: number_of_channels !! size of the basis integer ( int32 ), intent ( in ) :: number_of_open_basis_levels !! number of all possible state-to-state XS integer ( int32 ), intent ( in ) :: open_basis_levels ( number_of_open_basis_levels ) !! holds indices to the basis arrays which correspond to open channels real ( dp ), intent ( in ) :: open_basis_wavevectors ( number_of_open_basis_levels ) !! holds wavenumbers k_{i} real ( dp ), intent ( in ) :: srmatrix ( nopen , nopen ), simatrix ( nopen , nopen ) !! real and imaginary parts of the S-matrix integer ( int32 ), intent ( in ) :: channels_level_indices ( number_of_channels ) !! holds the indices pointing to the basis arrays integer ( int32 ), intent ( in ) :: channels_l_values ( number_of_channels ) !! holds all values of l real ( dp ), intent ( inout ) :: xs_array ( number_of_open_basis_levels * number_of_open_basis_levels ) !! array holding all XSs !---------------------------------------------------------------------! integer ( int32 ) :: jinit , jfin , njoccur , njpoccur , v1lev , j1lev , & v1plev , j1plev , ltmp , lptmp , iinit , ifin , ioccur1 , ioccur2 , ii , & il , ilp real ( dp ) :: waveinit , xssum , telr , teli , telsq , time_start , time_finish , xs_time integer ( int32 ), allocatable :: jblockarr (:), jpblockarr (:) !---------------------------------------------------------------------! call CPU_TIME ( time_start ) xs_array = 0 !---------------------------------------------------------------------! do iinit = 1 , number_of_open_basis_levels jinit = open_basis_levels ( iinit ) v1lev = v1array ( jinit ) j1lev = j1array ( jinit ) waveinit = open_basis_wavevectors ( iinit ) do ifin = 1 , number_of_open_basis_levels jfin = open_basis_levels ( ifin ) v1plev = v1array ( jfin ) j1plev = j1array ( jfin ) njoccur = 0 njpoccur = 0 do ii = 1 , number_of_channels if (( j1array ( channels_level_indices ( ii )). eq . j1lev )& . and .( v1array ( channels_level_indices ( ii )). eq . v1lev )) then njoccur = njoccur + 1 endif if ( j1array ( channels_level_indices ( ii )). eq . j1plev & . and .( v1array ( channels_level_indices ( ii )). eq . v1plev )) then njpoccur = njpoccur + 1 endif enddo call allocate_1d ( jblockarr , njoccur ) call allocate_1d ( jpblockarr , njpoccur ) ioccur1 = 0 ioccur2 = 0 do ii = 1 , number_of_channels if (( j1array ( channels_level_indices ( ii )). eq . j1lev )& . and .( v1array ( channels_level_indices ( ii )). eq . v1lev )) then ioccur1 = ioccur1 + 1 jblockarr ( ioccur1 ) = ii endif if ( j1array ( channels_level_indices ( ii )). eq . j1plev & . and .( v1array ( channels_level_indices ( ii )). eq . v1plev )) then ioccur2 = ioccur2 + 1 jpblockarr ( ioccur2 ) = ii endif enddo xssum = 0.d0 do il = 1 , njoccur ltmp = channels_l_values ( jblockarr ( il )) do ilp = 1 , njpoccur lptmp = channels_l_values ( jpblockarr ( ilp )) if (( j1lev . eq . j1plev ). and .( v1lev . eq . v1plev )) then if ( ltmp . eq . lptmp ) then telr = 1.d0 - srmatrix ( jblockarr ( il ),& jpblockarr ( ilp )) teli = - simatrix ( jblockarr ( il ), jpblockarr ( ilp )) telsq = telr ** 2.d0 + teli ** 2.d0 xssum = xssum + telsq else telr = - srmatrix ( jblockarr ( il ), jpblockarr ( ilp )) teli = - simatrix ( jblockarr ( il ), jpblockarr ( ilp )) telsq = telr ** 2.d0 + teli ** 2.d0 xssum = xssum + telsq endif else telr = - srmatrix ( jblockarr ( il ), jpblockarr ( ilp )) teli = - simatrix ( jblockarr ( il ), jpblockarr ( ilp )) telsq = telr ** 2.d0 + teli ** 2.d0 xssum = xssum + telsq endif enddo enddo xssum = xssum * ( 2.d0 * jj + 1.d0 ) xs_array (( iinit - 1 ) * number_of_open_basis_levels + ifin ) = xssum * pi / & (( 2.d0 * j1lev + 1.d0 ) * waveinit ** 2.d0 ) enddo enddo !---------------------------------------------------------------------! CALL CPU_TIME ( time_finish ) if ( prntlvl . ge . 2 ) call time_count_summary ( time_start , time_finish , & xs_time , \"Cross-sections calculations completed in \" ) end !------------------------------------------------------------------------------! !------------------------------------------------------------------------------! subroutine print_largest_partial_xs ( jj , maxXSdiag , maxXSoff , jinddiag , jindoff1 , & jindoff2 , number_of_open_basis_levels , open_basis_levels ) !! print the largest partial elastic and inelastic state-to-state XS !! in given J-block !---------------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: jj !! total angular momentum real ( dp ), intent ( in ) :: maxXSdiag !! the largest partial elastic state-to-state XS in this J-block real ( dp ), intent ( in ) :: maxXSoff !! the largest partial inelastic state-to-state XS in this J-block integer ( int32 ), intent ( in ) :: jinddiag !! index pointing indirectly to quantum numbers associated with !! the largest partial elastic state-to-state XS in this J-block integer ( int32 ), intent ( in ) :: jindoff1 , jindoff2 !! indices pointing indirectly to quantum numbers associated with !! the largest partial inelastic state-to-state XS in this J-block integer ( int32 ), intent ( in ) :: number_of_open_basis_levels !! number of all possible state-to-state XS (size of open_basis_levels array) integer ( int32 ), intent ( in ) :: open_basis_levels ( number_of_open_basis_levels ) !! holds indices to the basis arrays which correspond to open channels !---------------------------------------------------------------------------! character ( len = 200 ) :: header_line , line !---------------------------------------------------------------------------! if (( prntlvl . eq . 1 ). or .( prntlvl . eq . 2 )) then call write_message ( \"Largest partial elastic state-to-state for JTOT = \" // & trim ( adjustl ( integer_to_character ( jj ))) // \": \" // & trim ( adjustl ( float_to_character ( maxXSdiag )))) call write_message ( \"Largest partial inelastic state-to-state for JTOT = \" // & trim ( adjustl ( integer_to_character ( jj ))) // \": \" // & trim ( adjustl ( float_to_character ( maxXSoff )))) call write_message ( repeat ( \" \" , 43 ) // \"***\" ) else if ( prntlvl . ge . 3 ) then !------------------------------------------------------------------------! call write_message ( \"Largest partial elastic state-to-state for JTOT = \" // & integer_to_character ( jj ) ) write ( header_line , \"(2x,a4,2x,a4,2x,a2,2x,a4,2x,a4,16x,a2)\" ) \"v1_f\" , & \"j1_f\" , \"<-\" , \"v1_i\" , \"j1_i\" , \"XS\" call write_message ( header_line ) write ( line , \"(2X,I4,2X,I4,6X,I4,2X,I4,2X,E16.8)\" ) & v1array ( open_basis_levels ( jinddiag )), j1array ( open_basis_levels ( jinddiag )), & v1array ( open_basis_levels ( jinddiag )), j1array ( open_basis_levels ( jinddiag )), maxXSdiag call write_message ( line ) !------------------------------------------------------------------------! call write_message ( \"Largest partial inelastic state-to-state for JTOT = \" // & integer_to_character ( jj ) ) call write_message ( header_line ) write ( line , \"(2X,I4,2X,I4,6X,I4,2X,I4,2X,E16.8)\" ) & v1array ( open_basis_levels ( jindoff2 )), j1array ( open_basis_levels ( jindoff2 )), & v1array ( open_basis_levels ( jindoff1 )), j1array ( open_basis_levels ( jindoff1 )), maxXSoff call write_message ( line ) call write_message ( repeat ( \" \" , 43 ) // \"***\" ) !------------------------------------------------------------------------! endif end subroutine print_largest_partial_xs !------------------------------------------------------------------------------! !------------------------------------------------------------------------------! subroutine check_dtol_otol ( maxXSdiag , maxXSoff , ncacdiag , ncacoff , terminate ) !! check if the dtol/otol condition on partial XS is already fulfilled !---------------------------------------------------------------------------! real ( dp ), intent ( in ) :: maxXSdiag , maxXSoff !! largest elastic and inelastic XS integer ( int32 ), intent ( inout ) :: ncacdiag , ncacoff !! number of consecutive blocks for which dtol/otol condition is already !! fulfilled. Gets incremented within the subroutine logical , intent ( inout ) :: terminate !! if .true. the dtol/otol condition is fulfilled; !! J-tot loop is terminated !---------------------------------------------------------------------------! integer ( int32 ) :: icount , icount2 logical :: diagcontr , offcontr !---------------------------------------------------------------------------! terminate = . false . !---------------------------------------------------------------------------! ! diagcontr and offcontr check if dtol and otol are fulfilled, respectively !---------------------------------------------------------------------------! diagcontr = . false . offcontr = . false . !---------------------------------------------------------------------------! if ( maxXSdiag . le . dtol ) diagcontr = . true . if ( maxXSoff . le . otol ) offcontr = . true . !---------------------------------------------------------------------------! if ( diagcontr ) then ncacdiag = ncacdiag + 1 else ncacdiag = 0 endif !------------------------------------------------------------------------------! if ( offcontr ) then ncacoff = ncacoff + 1 else ncacoff = 0 endif !------------------------------------------------------------------------------! ! Finish the calculations if both contributions are smaller than the limits:   ! !------------------------------------------------------------------------------! if (( ncacdiag . ge . ncac ). and .( ncacoff . ge . ncac )) terminate = . true . !------------------------------------------------------------------------------! end subroutine check_dtol_otol !------------------------------------------------------------------------------! !------------------------------------------------------------------------------! end module statetostateXS","tags":"","loc":"sourcefile/sts_xs_mod.f90.html"},{"title":"scattering.f90 – the SCATTERING code","text":"This file depends on sourcefile~~scattering.f90~~EfferentGraph sourcefile~scattering.f90 scattering.f90 sourcefile~channels_mod.f90 channels_mod.f90 sourcefile~scattering.f90->sourcefile~channels_mod.f90 sourcefile~sts_xs_mod.f90 sts_xs_mod.f90 sourcefile~scattering.f90->sourcefile~sts_xs_mod.f90 sourcefile~propagator_mod.f90 propagator_mod.f90 sourcefile~scattering.f90->sourcefile~propagator_mod.f90 sourcefile~boundary_conditions_mod.f90 boundary_conditions_mod.f90 sourcefile~scattering.f90->sourcefile~boundary_conditions_mod.f90 sourcefile~coupling_matrix_mod.f90 coupling_matrix_mod.f90 sourcefile~scattering.f90->sourcefile~coupling_matrix_mod.f90 sourcefile~unitarity_check_mod.f90 unitarity_check_mod.f90 sourcefile~scattering.f90->sourcefile~unitarity_check_mod.f90 sourcefile~utility_functions_mod.f90 utility_functions_mod.f90 sourcefile~scattering.f90->sourcefile~utility_functions_mod.f90 sourcefile~input_reader_mod.f90 input_reader_mod.f90 sourcefile~scattering.f90->sourcefile~input_reader_mod.f90 sourcefile~radial_coupling_terms_mod.f90 radial_coupling_terms_mod.f90 sourcefile~scattering.f90->sourcefile~radial_coupling_terms_mod.f90 sourcefile~array_operations_mod.f90 array_operations_mod.f90 sourcefile~scattering.f90->sourcefile~array_operations_mod.f90 sourcefile~channels_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~channels_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~sts_xs_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~sts_xs_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~propagator_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~propagator_mod.f90->sourcefile~radial_coupling_terms_mod.f90 sourcefile~propagator_mod.f90->sourcefile~array_operations_mod.f90 sourcefile~boundary_conditions_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~boundary_conditions_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~boundary_conditions_mod.f90->sourcefile~array_operations_mod.f90 sourcefile~math_functions_mod.f90 math_functions_mod.f90 sourcefile~boundary_conditions_mod.f90->sourcefile~math_functions_mod.f90 sourcefile~coupling_matrix_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~coupling_matrix_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~coupling_matrix_mod.f90->sourcefile~math_functions_mod.f90 sourcefile~unitarity_check_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~unitarity_check_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~array_operations_mod.f90 sourcefile~radial_coupling_terms_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~radial_coupling_terms_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~radial_coupling_terms_mod.f90->sourcefile~math_functions_mod.f90 sourcefile~math_functions_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~special_functions_mod.f90 special_functions_mod.f90 sourcefile~math_functions_mod.f90->sourcefile~special_functions_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Programs SCATTERING Source Code scattering.f90 Source Code program SCATTERING use , intrinsic :: iso_fortran_env , only : int32 , sp => real32 , dp => real64 use io_mod use radial_coupling_terms_mod , only : read_radial_coupling_terms , & reduce_radial_coupling_terms , interpolate_radial_coupling_terms use channels_mod , only : set_number_of_channels , set_body_fixed_channels , & set_space_fixed_channels , count_open_channels_in_block , & calculate_largest_wavenumber , print_channels use coupling_matrix_mod use PROPAGATORS use boundary_conditions_mod , only : calculate_sf_matrix_from_bf_matrix , & calculate_k_matrix , calculate_s_matrix use unitarity_check_mod , only : unitarity_check use statetostateXS use utility_functions_mod , only : write_header , file_io_status , & write_message , float_to_character , integer_to_character , time_count_summary use array_operations_mod , only : append !---------------------------------------------------------------------------! implicit none !---------------------------------------------------------------------------! character ( len = 200 ) :: err_message , partial_line , xs_line integer ( int32 ) :: number_of_nonzero_coupling_matrix_elements , & number_of_nonzero_coupling_coefficients , number_of_channels , size_even , & size_odd , number_of_open_basis_levels , iblock , jtot_ , parity_exponent , & parity_exponenttmp , nsteps , number_of_open_channels , ncacdiag , ncacoff , & omegamax , lmin , lmax , ltmp , lmat_len , len_even , len_odd , jinddiag , & jindoff1 , jindoff2 , ij , ilevel , iomega , iopen , iopen2 , isize_ , isize_2 , & icheck , icount , icount2 , io_status real ( dp ) :: largest_wavevector , wavvdepth , maxXSdiag , maxXSoff , time_total_start , & time_total_stop , time_total , time_init_stop , time_init , time_jtot_start , & time_jtot_stop , time_jtot , time_parity_start , time_parity_stop , & time_parity , time_coupling_start , time_coupling_stop , time_coupling logical :: unitarity_block_check , terminate integer , allocatable :: channels_level_indices (:), channels_omega_values (:),& channels_l_values (:), open_basis_levels (:), nonzero_terms_per_element (:),& nonzero_legendre_indices (:), smatcheckarr (:) real ( dp ), allocatable :: wv (:), open_basis_wavevectors (:), & nonzero_coupling_coefficients (:), xs_total (:), xs_block (:), xs_jtot (:) real ( dp ), allocatable :: BF_log_der_matrix (:,:), SF_log_der_matrix (:,:), & k_matrix (:,:), s_matrix_real (:,:), s_matrix_imag (:,:) !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! ! Initizalization: start the time count !---------------------------------------------------------------------------! call cpu_time ( time_total_start ) !---------------------------------------------------------------------------! ! Initialize fwigxjpf library !---------------------------------------------------------------------------! call fwig_table_init ( 2 * 100 , 9 ) call fwig_temp_init ( 2 * 100 ) !---------------------------------------------------------------------------! ! Print the header !---------------------------------------------------------------------------! call write_header ( \"main\" ) !---------------------------------------------------------------------------! ! Read the input file !---------------------------------------------------------------------------! call read_input_file !---------------------------------------------------------------------------! ! S-matrix file: write input parameters and basis levels !---------------------------------------------------------------------------! open ( 11 , file = trim ( smatrixfile ), form = 'unformatted' , iostat = io_status , & iomsg = err_message ) call file_io_status ( io_status , err_message , 11 , \"o\" ) !---------------------------------------------------------------------------! write ( 11 ) label , 2 , nlevel , reducedmass write ( 11 ) ( v1array ( ilevel ), j1array ( ilevel ), ilevel = 1 , nlevel ) write ( 11 ) ( elevel ( ilevel ), ilevel = 1 , nlevel ) write ( 11 ) initial , energy !---------------------------------------------------------------------------! ! Prepare the file with the partial XS !---------------------------------------------------------------------------! if ( parity_exponent == 1 ) then open ( 12 , file = trim ( partialfile ), form = 'formatted' , status = 'unknown' , & iostat = io_status , iomsg = err_message ) call file_io_status ( io_status , err_message , 12 , \"o\" ) !------------------------------------------------------------------------! call write_message ( \"  jtot  iblock  v1_f  j1_f  <-  v1_i  j1_i'\" // & repeat ( \" \" , 14 ) // \"K.E.\" // repeat ( \" \" , 16 ) // \"XS\" , unit_ = 12 ) !------------------------------------------------------------------------! endif !---------------------------------------------------------------------------! ! Convert units: starting now, everything is in atomic units !---------------------------------------------------------------------------! call units_conversion !---------------------------------------------------------------------------! ! Read the radial terms of the potential from external file !---------------------------------------------------------------------------! call read_radial_coupling_terms !---------------------------------------------------------------------------! ! Reduce matrix elements that are not needed !---------------------------------------------------------------------------! call reduce_radial_coupling_terms !---------------------------------------------------------------------------! ! Interpolate radial terms !---------------------------------------------------------------------------! call interpolate_radial_coupling_terms !---------------------------------------------------------------------------! ! Search for energetically accessible levels and prepare the arrays that are ! needed in the calculations of the state-to-state XS !---------------------------------------------------------------------------! number_of_open_basis_levels = count_open_basis_levels () call allocate_1d ( open_basis_levels , number_of_open_basis_levels ) call allocate_1d ( open_basis_wavevectors , number_of_open_basis_levels ) call save_open_basis_levels ( number_of_open_basis_levels , open_basis_levels , & open_basis_wavevectors ) !---------------------------------------------------------------------------! ! xs array summed over all blocks !---------------------------------------------------------------------------! call allocate_1d ( xs_total , & number_of_open_basis_levels * number_of_open_basis_levels ) !---------------------------------------------------------------------------! ! xs array a single JTOT value !---------------------------------------------------------------------------! call allocate_1d ( xs_jtot , & number_of_open_basis_levels * number_of_open_basis_levels ) !---------------------------------------------------------------------------! ! xs array a single parity block !---------------------------------------------------------------------------! call allocate_1d ( xs_block , & number_of_open_basis_levels * number_of_open_basis_levels ) !---------------------------------------------------------------------------! ! Initialization is finished !---------------------------------------------------------------------------! call cpu_time ( time_init_stop ) if ( prntlvl . ge . 2 ) call time_count_summary ( time_total_start , time_init_stop , & time_init , \"Initialization completed in \" ) !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! ! Prepare J-blocks !---------------------------------------------------------------------------! ! If JTOTMAX=-1 is called, iterate until convergence is achieved: ! this is managed by ncacdiag and ncacoff !---------------------------------------------------------------------------! ncacdiag = 0 ncacoff = 0 iblock = 0 terminate = . false . !---------------------------------------------------------------------------! ! Loop over total angular momentum !---------------------------------------------------------------------------! call write_message ( repeat ( \"*\" , 90 )) call write_message ( repeat ( \" \" , 28 ) // \"*** Loop over JTOT: ***\" ) !---------------------------------------------------------------------------! do jtot_ = jtotmin , jtotmax , jtotstep !------------------------------------------------------------------------! call write_header ( \"block\" , opt_integer_ = jtot_ ) !------------------------------------------------------------------------! call cpu_time ( time_jtot_start ) !------------------------------------------------------------------------! xs_jtot = 0 call set_number_of_channels ( jtot_ , size_even , size_odd ) !------------------------------------------------------------------------! do parity_exponent = 0 , 1 !---------------------------------------------------------------------! call cpu_time ( time_parity_start ) !---------------------------------------------------------------------! select case ( parity_exponent ) case ( 0 ) number_of_channels = size_even case ( 1 ) number_of_channels = size_odd end select !---------------------------------------------------------------------! if ( number_of_channels == 0 ) cycle !---------------------------------------------------------------------! ! Summary of the current block !---------------------------------------------------------------------! iblock = iblock + 1 if ( prntlvl . ge . 1 ) then call write_message ( \"Block number: \" // integer_to_character ( iblock )) call write_message ( \"jtot: \" // & trim ( adjustl ( integer_to_character ( jtot_ ))) // \" parity: \" // & trim ( adjustl ( integer_to_character (( - 1 ) ** parity_exponent ) ))) call write_message ( \"Number of scattering channels: \" // & integer_to_character ( number_of_channels )) endif !---------------------------------------------------------------------! ! Prepare of the basis for each J/p block: ! channels_omega_values holds all values of omega (BF_) ! channels_l_values holds all values of l (SF_) ! channels_level_indices holds the indices which refer to the basis arrays: !   --   v1level/j1level/elevel !---------------------------------------------------------------------! call allocate_1d ( channels_omega_values , number_of_channels ) call allocate_1d ( channels_l_values , number_of_channels ) call allocate_1d ( channels_level_indices , number_of_channels ) !---------------------------------------------------------------------! ! Prepare channels_omega_values, channels_level_indices and channels_l_values !---------------------------------------------------------------------! call set_body_fixed_channels ( jtot_ , parity_exponent , channels_level_indices , & channels_omega_values ) call set_space_fixed_channels ( jtot_ , parity_exponent , channels_l_values ) !---------------------------------------------------------------------! ! Print the BF quantum numbers on screen !---------------------------------------------------------------------! if ( prntlvl . ge . 1 ) call print_channels ( parity_exponent , & channels_level_indices , channels_omega_values ) !---------------------------------------------------------------------! ! Determine the number of open (energetically accessible) channels !---------------------------------------------------------------------! number_of_open_channels = count_open_channels_in_block ( channels_level_indices ) !---------------------------------------------------------------------! ! If there are no open channels, skip this block !---------------------------------------------------------------------! if ( number_of_open_channels == 0 ) then call write_message ( repeat ( '-' , 90 )) call write_message ( \"No open channels for block no.\" // & integer_to_character ( iblock ) ) call write_message ( repeat ( '-' , 90 )) cycle endif !---------------------------------------------------------------------! ! Determine the largest wavevector in the block !---------------------------------------------------------------------! largest_wavevector = calculate_largest_wavenumber ( channels_level_indices ) !---------------------------------------------------------------------! ! Determine the number of steps on the intermolecular (R) grid ! This is done either directly (if dr > 0) ! or through the number of steps per half de Broglie wavelength !---------------------------------------------------------------------! wavvdepth = dsqrt ( 2 * reducedmass * vdepth ) if ( dr <= 0 ) then nsteps = nint (( Rmax - Rmin ) / PI * (( largest_wavevector + wavvdepth ) * steps )) else nsteps = nint (( Rmax - Rmin ) / dr ) + 1 endif !---------------------------------------------------------------------! ! Prepare the coupling matrix !---------------------------------------------------------------------! call cpu_time ( time_coupling_start ) call check_nonzero_coupling_matrix_elements ( channels_level_indices , & channels_omega_values , number_of_nonzero_coupling_matrix_elements , & number_of_nonzero_coupling_coefficients ) call allocate_1d ( nonzero_terms_per_element , number_of_nonzero_coupling_matrix_elements ) call allocate_1d ( nonzero_coupling_coefficients , number_of_nonzero_coupling_coefficients ) call allocate_1d ( nonzero_legendre_indices , number_of_nonzero_coupling_coefficients ) call prepare_coupling_matrix_elements ( channels_level_indices , & channels_omega_values , nonzero_terms_per_element , & nonzero_legendre_indices , nonzero_coupling_coefficients ) if ( prntlvl . ge . 2 ) call print_coupling_matrix_elements_summary ( & number_of_channels , number_of_nonzero_coupling_matrix_elements , & number_of_nonzero_coupling_coefficients ) call cpu_time ( time_coupling_stop ) if ( prntlvl . ge . 2 ) call write_message ( \"Calculations of the coupling \" // & \"matrix took \" // trim ( adjustl ( float_to_character ( & time_coupling_stop - time_coupling_start , \"(E14.8)\" ))) // \" seconds\" ) !---------------------------------------------------------------------! ! Prepare the log-derivative matrix (Eqs. 6.29 and 6.43) ! and the K-matrix (Eq. 6.53) !---------------------------------------------------------------------! call allocate_2d ( BF_log_der_matrix , number_of_channels , number_of_channels ) call allocate_2d ( SF_log_der_matrix , number_of_channels , number_of_channels ) call allocate_2d ( k_matrix , number_of_open_channels , number_of_open_channels ) !---------------------------------------------------------------------! ! Call the propagator: !---------------------------------------------------------------------! call numerov ( channels_level_indices , channels_omega_values , & number_of_nonzero_coupling_matrix_elements , & number_of_nonzero_coupling_coefficients , nonzero_terms_per_element ,& nonzero_legendre_indices , nonzero_coupling_coefficients , nsteps , & number_of_channels , jtot_ , BF_log_der_matrix ) call write_message ( \"Coupled equations were solved from \" // & trim ( adjustl ( float_to_character ( Rmin , \"(F10.4)\" ))) // \" a.u. to \" // & trim ( adjustl ( float_to_character ( Rmax , \"(F10.4)\" ))) // \" a.u. in \" // & trim ( adjustl ( integer_to_character ( nsteps ))) // \" steps (dr = \" // & trim ( adjustl ( float_to_character (( rmax - rmin ) / dble ( nsteps - 1 ), & \"(E14.8)\" ))) // \" a.u.)\" ) !---------------------------------------------------------------------! ! Transform the log-derivative matrix to the SF frame !---------------------------------------------------------------------! call calculate_sf_matrix_from_bf_matrix ( number_of_channels , jtot_ , & channels_level_indices , channels_omega_values , channels_l_values , & BF_log_der_matrix , SF_log_der_matrix ) !---------------------------------------------------------------------! ! Get the K-matrix from log-derivative matrix (Eq. 6.53) !---------------------------------------------------------------------! call calculate_k_matrix ( number_of_channels , SF_log_der_matrix , & number_of_open_channels , channels_level_indices , channels_l_values ,& rmax , k_matrix ) !---------------------------------------------------------------------! ! Get the S-matrix from the K-matrix (Eq. 6.57) !---------------------------------------------------------------------! call allocate_2d ( s_matrix_real , number_of_open_channels , number_of_open_channels ) call allocate_2d ( s_matrix_imag , number_of_open_channels , number_of_open_channels ) call calculate_s_matrix ( number_of_open_channels , k_matrix , s_matrix_real , s_matrix_imag ) !---------------------------------------------------------------------! ! Array of wavevectors (necessary for the XS calculations) !---------------------------------------------------------------------! call allocate_1d ( wv , number_of_open_channels ) do iopen = 1 , number_of_open_channels wv ( iopen ) = dsqrt (( 2 * reducedmass * & ( ETOTAL () - elevel ( channels_level_indices ( iopen ))))) / bohrtoangstrom enddo !---------------------------------------------------------------------! ! S-matrix is written to the binary S-matrix file !---------------------------------------------------------------------! write ( 11 ) jtot_ , parity_exponent , number_of_open_channels write ( 11 ) ( channels_level_indices ( iopen ), channels_l_values ( iopen ),& wv ( iopen ), iopen = 1 , number_of_open_channels ) write ( 11 ) (( s_matrix_real ( iopen , iopen2 ), iopen2 = 1 , iopen ),& iopen = 1 , number_of_open_channels ) write ( 11 ) (( s_matrix_imag ( iopen , iopen2 ), iopen2 = 1 , iopen ),& iopen = 1 , number_of_open_channels ) !---------------------------------------------------------------------! ! Check if the S-matrices are unitary !---------------------------------------------------------------------! call unitarity_check ( number_of_open_channels , s_matrix_real , s_matrix_imag , unitarity_block_check ) !---------------------------------------------------------------------! ! If the unitary is not fulfilled, keep the information about this block !---------------------------------------------------------------------! if (. not .( unitarity_block_check )) then call append ( smatcheckarr , jtot_ ) endif !---------------------------------------------------------------------! ! Calculate all available cross-sections !---------------------------------------------------------------------! call CROSSSECTION ( jtot_ , number_of_open_channels , number_of_channels , & number_of_open_basis_levels , open_basis_levels , & open_basis_wavevectors , s_matrix_real , s_matrix_imag , channels_level_indices , & channels_l_values , xs_block ) !---------------------------------------------------------------------! ! Print the results from this parity block to the partial XS file ! and add the calculated partial XS to the xs_jtot array !---------------------------------------------------------------------! do icount = 1 , number_of_open_basis_levels do icount2 = 1 , number_of_open_basis_levels if ( parity_exponent == 1 ) then write ( partial_line , & \"(I6,2X,I6,2X,I4,2X,I4,6X,I4,2X,I4,2X,E16.8,2X,E16.8)\" ) & jtot_ , iblock , v1array ( open_basis_levels ( icount2 )), & j1array ( open_basis_levels ( icount2 )), & v1array ( open_basis_levels ( icount )), & j1array ( open_basis_levels ( icount )), & ( etotal () - elevel ( open_basis_levels ( icount ))) * hartreetocm , & xs_block (( icount - 1 ) * number_of_open_basis_levels + icount2 ) call write_message ( partial_line , unit_ = 12 ) endif xs_jtot (( icount - 1 ) * number_of_open_basis_levels + icount2 ) = & xs_jtot (( icount - 1 ) * number_of_open_basis_levels + icount2 ) & + xs_block (( icount - 1 ) * number_of_open_basis_levels + icount2 ) enddo enddo !---------------------------------------------------------------------! ! Check the time after each parity block: !---------------------------------------------------------------------! call cpu_time ( time_parity_stop ) if ( prntlvl . ge . 2 ) call time_count_summary ( time_parity_start , & time_parity_stop , time_parity , \"Parity block completed in \" ) !---------------------------------------------------------------------! ! ... end of the loop over parity !---------------------------------------------------------------------! call write_message ( repeat ( \" \" , 43 ) // \"***\" ) enddo !------------------------------------------------------------------------! ! Add the cross-sections from this Jtot block: !------------------------------------------------------------------------! do icount = 1 , number_of_open_basis_levels do icount2 = 1 , number_of_open_basis_levels xs_total (( icount - 1 ) * number_of_open_basis_levels + icount2 ) = & xs_total (( icount - 1 ) * number_of_open_basis_levels + icount2 ) & + xs_jtot (( icount - 1 ) * number_of_open_basis_levels + icount2 ) enddo enddo !------------------------------------------------------------------------! ! Determine the largest partial elastic/inelastic XS in this Jtot block: !------------------------------------------------------------------------! jinddiag = 0 jindoff1 = 0 jindoff2 = 0 maxXSdiag = 0.0_dp maxXSoff = 0.0_dp do icount = 1 , number_of_open_basis_levels do icount2 = 1 , number_of_open_basis_levels if ( open_basis_levels ( icount2 ) == open_basis_levels ( icount )) then if (( xs_jtot (( icount - 1 ) * number_of_open_basis_levels + icount2 )). gt . maxXSdiag ) then maxXSdiag = xs_jtot (( icount - 1 ) * number_of_open_basis_levels + icount2 ) jinddiag = icount endif else if (( xs_jtot (( icount - 1 ) * number_of_open_basis_levels + icount2 )). gt . maxXSoff ) then maxXSoff = xs_jtot (( icount - 1 ) * number_of_open_basis_levels + icount2 ) jindoff1 = icount jindoff2 = icount2 endif endif enddo enddo !-----------------------------------------------------------------------! call print_largest_partial_xs ( jtot_ , maxXSdiag , maxXSoff , jinddiag , & jindoff1 , jindoff2 , number_of_open_basis_levels , open_basis_levels ) !-----------------------------------------------------------------------! if ( jtotmax == 999999 ) then call check_dtol_otol ( maxXSdiag , maxXSoff , ncacdiag , ncacoff , terminate ) endif !------------------------------------------------------------------------! ! Check the time after each JTOT block: !------------------------------------------------------------------------! call cpu_time ( time_jtot_stop ) !------------------------------------------------------------------------! ! Print all the XS after current JTOT block !------------------------------------------------------------------------! if ( prntlvl . ge . 3 ) then call write_message ( \"Cross sections for J: \" // & trim ( adjustl ( integer_to_character ( jtot_ ))) // \" and energy: \" // & trim ( adjustl ( float_to_character ( ETOTAL () * hartreetocm , \"(F10.4)\" ))) & // \" cm-1\" ) call write_message ( \"  v1_f  j1_f  <-  v1_i  j1_i\" // repeat ( \" \" , 14 ) & // \"K.E.\" // repeat ( \" \" , 16 ) // \"XS\" ) do icount = 1 , number_of_open_basis_levels do icount2 = 1 , number_of_open_basis_levels write ( xs_line , \"(2X,I4,2X,I4,6X,I4,2X,I4,2X,E16.8,2X,E16.8)\" ) & v1array ( open_basis_levels ( icount2 )), & j1array ( open_basis_levels ( icount2 )), & v1array ( open_basis_levels ( icount )), & j1array ( open_basis_levels ( icount )), & ( etotal () - elevel ( open_basis_levels ( icount ))) * hartreetocm , & xs_total (( icount - 1 ) * number_of_open_basis_levels + icount2 ) call write_message ( xs_line ) enddo enddo endif !------------------------------------------------------------------------! if ( prntlvl . ge . 2 ) call time_count_summary ( time_jtot_start , & time_jtot_stop , time_jtot , \"JTOT block completed in \" ) !------------------------------------------------------------------------! ! terminate the loop if dtol/otol condition is satisfied !------------------------------------------------------------------------! if ( terminate ) exit enddo call write_message ( repeat ( '*' , 90 )) call write_message ( repeat ( \" \" , 31 ) // \"Loop over JTOT finished\" ) call write_message ( repeat ( '*' , 90 )) call write_message ( \"*\" // repeat ( \" \" , 40 ) // \"SUMMARY\" // repeat ( \" \" , 41 ) & // \"*\" ) call write_message ( repeat ( '*' , 90 )) !---------------------------------------------------------------------------! ! if for some JTOTs the S-matrix did not fulfill the unitary check, ! these are listed here !---------------------------------------------------------------------------! if ( allocated ( smatcheckarr )) then print * call write_message ( repeat ( \"-\" , 90 )) call write_message ( repeat ( \" \" , 37 ) // \"*** WARNING ***\" ) call write_message ( repeat ( \"-\" , 90 )) call write_message ( \"Check unitarity of the S-matrix in the following \" // & \"JTOT blocks:\" ) do icheck = 1 , size ( smatcheckarr ) call write_message ( \"JTOT:\" // repeat ( \" \" , 8 ) // integer_to_character ( & smatcheckarr ( icheck ))) enddo call write_message ( repeat ( \"-\" , 90 )) print * endif !---------------------------------------------------------------------------! ! Print all the calculated XS !---------------------------------------------------------------------------! call write_message ( \"Final state-to-state XS\" ) call write_message ( \"  v1_f  j1_f  <-  v1_i  j1_i\" // repeat ( \" \" , 14 ) // & \"K.E.\" // repeat ( \" \" , 16 ) // \"XS\" ) do icount = 1 , number_of_open_basis_levels do icount2 = 1 , number_of_open_basis_levels write ( xs_line , \"(2X,I4,2X,I4,6X,I4,2X,I4,2X,E16.8,2X,E16.8)\" ) & v1array ( open_basis_levels ( icount2 )), & j1array ( open_basis_levels ( icount2 )), & v1array ( open_basis_levels ( icount )), & j1array ( open_basis_levels ( icount )), & ( etotal () - elevel ( open_basis_levels ( icount ))) * hartreetocm , & xs_total (( icount - 1 ) * number_of_open_basis_levels + icount2 ) call write_message ( xs_line ) enddo enddo !---------------------------------------------------------------------------! call fwig_temp_free (); call fwig_table_free (); !---------------------------------------------------------------------------! ! Stop the time count !---------------------------------------------------------------------------! call cpu_time ( time_total_stop ) call time_count_summary ( time_total_start , time_total_stop , time_total , & \"Total CPU time: \" ) close ( 11 ) close ( 12 ) !---------------------------------------------------------------------------! end program SCATTERING !------------------------------------------------------------------------------! !------------------------------------------------------------------------------!","tags":"","loc":"sourcefile/scattering.f90.html"},{"title":"array_operations_fill_symmetric_matrix_submod.f90 – the SCATTERING code","text":"This file depends on sourcefile~~array_operations_fill_symmetric_matrix_submod.f90~~EfferentGraph sourcefile~array_operations_fill_symmetric_matrix_submod.f90 array_operations_fill_symmetric_matrix_submod.f90 sourcefile~array_operations_mod.f90 array_operations_mod.f90 sourcefile~array_operations_fill_symmetric_matrix_submod.f90->sourcefile~array_operations_mod.f90 sourcefile~utility_functions_mod.f90 utility_functions_mod.f90 sourcefile~array_operations_fill_symmetric_matrix_submod.f90->sourcefile~utility_functions_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules array_operations_fill_symmetric_matrix_submod Source Code array_operations_fill_symmetric_matrix_submod.f90 Source Code submodule ( array_operations_mod ) array_operations_fill_symmetric_matrix_submod !! a submodule for append subroutines use utility_functions_mod , only : to_lowercase implicit none contains module subroutine fill_symmetric_matrix_int32 ( matrix_ , upper_lower_ ) !! Fill the upper/lower triangle of a symmetric matrix (integer). integer , intent ( inout ) :: matrix_ (:,:) character ( len = 1 ), intent ( in ) :: upper_lower_ !---------------------------------------------------------------------! integer :: i_ , size_1_ , size_2_ , size_ !---------------------------------------------------------------------! size_1_ = size ( matrix_ , dim = 1 ) size_2_ = size ( matrix_ , dim = 2 ) if ( size_1_ . eq . size_2_ ) then size_ = size_1_ else print * , \"Error in fill_symmetric_matrix_int: size in dim = 1 (\" , size_1_ ,& \") is different than in dim = 2 (\" , size_2_ , \")\" print * , \"Adapt this subroutine to rectangle matrices\" stop endif !---------------------------------------------------------------------! select case ( to_lowercase ( upper_lower_ )) case ( 'l' ) do i_ = 1 , size_ - 1 matrix_ ( i_ + 1 : size_ , i_ ) = matrix_ ( i_ , i_ + 1 : size_ ) enddo case ( 'u' ) do i_ = 1 , size_ - 1 matrix_ ( i_ , i_ + 1 : size_ ) = matrix_ ( i_ + 1 : size_ , i_ ) enddo case default write ( * , * ) \"Invalid argument to fill_symmetric_matrix_int32 subroutine\" write ( * , * ) \"upper_lower_:\" , upper_lower_ write ( * , * ) \"'u' or 'l' expected\" stop end select !---------------------------------------------------------------------! end subroutine fill_symmetric_matrix_int32 module subroutine fill_symmetric_matrix_sp ( matrix_ , upper_lower_ ) !! Fill the upper/lower triangle of a symmetric matrix (single precision). real ( sp ), intent ( inout ) :: matrix_ (:,:) character ( len = 1 ), intent ( in ) :: upper_lower_ !---------------------------------------------------------------------! integer :: i_ , size_1_ , size_2_ , size_ !---------------------------------------------------------------------! size_1_ = size ( matrix_ , dim = 1 ) size_2_ = size ( matrix_ , dim = 2 ) if ( size_1_ . eq . size_2_ ) then size_ = size_1_ else print * , \"Error in fill_symmetric_matrix_sp: size in dim = 1 (\" , size_1_ ,& \") is different than in dim = 2 (\" , size_2_ , \")\" print * , \"Adapt this subroutine to rectangle matrices\" stop endif !---------------------------------------------------------------------! select case ( to_lowercase ( upper_lower_ )) case ( 'l' ) do i_ = 1 , size_ - 1 matrix_ ( i_ + 1 : size_ , i_ ) = matrix_ ( i_ , i_ + 1 : size_ ) enddo case ( 'u' ) do i_ = 1 , size_ - 1 matrix_ ( i_ , i_ + 1 : size_ ) = matrix_ ( i_ + 1 : size_ , i_ ) enddo case default write ( * , * ) \"Invalid argument to fill_symmetric_matrix_sp subroutine\" write ( * , * ) \"upper_lower_:\" , upper_lower_ write ( * , * ) \"'u' or 'l' expected\" stop end select !---------------------------------------------------------------------! end subroutine fill_symmetric_matrix_sp module subroutine fill_symmetric_matrix_dp ( matrix_ , upper_lower_ ) !! fill the upper/lower triangle of a symmetric matrix real ( dp ), intent ( inout ) :: matrix_ (:,:) character ( len = 1 ), intent ( in ) :: upper_lower_ !---------------------------------------------------------------------! integer :: i_ , size_1_ , size_2_ , size_ !---------------------------------------------------------------------! size_1_ = size ( matrix_ , dim = 1 ) size_2_ = size ( matrix_ , dim = 2 ) if ( size_1_ . eq . size_2_ ) then size_ = size_1_ else print * , \"Error in fill_symmetric_matrix_dp: size in dim = 1 (\" , size_1_ ,& \") is different than in dim = 2 (\" , size_2_ , \")\" print * , \"Adapt this subroutine to rectangle matrices\" stop endif !---------------------------------------------------------------------! select case ( to_lowercase ( upper_lower_ )) case ( 'l' ) do i_ = 1 , size_ - 1 matrix_ ( i_ + 1 : size_ , i_ ) = matrix_ ( i_ , i_ + 1 : size_ ) enddo case ( 'u' ) do i_ = 1 , size_ - 1 matrix_ ( i_ , i_ + 1 : size_ ) = matrix_ ( i_ + 1 : size_ , i_ ) enddo case default write ( * , * ) \"Invalid argument of the fill_symetric_matrix_dp subroutine\" write ( * , * ) \"upper_lower_\" , upper_lower_ write ( * , * ) \"'u' or 'l' expected\" stop end select !---------------------------------------------------------------------! end subroutine fill_symmetric_matrix_dp end submodule array_operations_fill_symmetric_matrix_submod","tags":"","loc":"sourcefile/array_operations_fill_symmetric_matrix_submod.f90.html"},{"title":"boundary_conditions_mod.f90 – the SCATTERING code","text":"This file depends on sourcefile~~boundary_conditions_mod.f90~~EfferentGraph sourcefile~boundary_conditions_mod.f90 boundary_conditions_mod.f90 sourcefile~input_reader_mod.f90 input_reader_mod.f90 sourcefile~boundary_conditions_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~math_functions_mod.f90 math_functions_mod.f90 sourcefile~boundary_conditions_mod.f90->sourcefile~math_functions_mod.f90 sourcefile~array_operations_mod.f90 array_operations_mod.f90 sourcefile~boundary_conditions_mod.f90->sourcefile~array_operations_mod.f90 sourcefile~utility_functions_mod.f90 utility_functions_mod.f90 sourcefile~boundary_conditions_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~array_operations_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~math_functions_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~special_functions_mod.f90 special_functions_mod.f90 sourcefile~math_functions_mod.f90->sourcefile~special_functions_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~boundary_conditions_mod.f90~~AfferentGraph sourcefile~boundary_conditions_mod.f90 boundary_conditions_mod.f90 sourcefile~scattering.f90 scattering.f90 sourcefile~scattering.f90->sourcefile~boundary_conditions_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules boundary_conditions_mod Source Code boundary_conditions_mod.f90 Source Code module boundary_conditions_mod !! This module contains subroutines that transform the asymptotic !! log-derivative matrix into the scattering S-matrix !! (see \"Solution of coupled equations\" section) !---------------------------------------------------------------------------! use , intrinsic :: iso_fortran_env , only : int32 , sp => real32 , dp => real64 use io_mod use fwigxjpf , only : fwig3jj use math_functions_mod , only : riccati_bessel_j , riccati_bessel_y , & modified_bessel_k_ratio use utility_functions_mod , only : write_warning , write_header use array_operations_mod , only : invert_symmetric_matrix , fill_symmetric_matrix !---------------------------------------------------------------------------! implicit none !---------------------------------------------------------------------------! private public :: calculate_sf_matrix_from_bf_matrix , calculate_k_matrix , & calculate_s_matrix !---------------------------------------------------------------------------! contains !---------------------------------------------------------------------------! function p_coeff ( total_angular_momentum_ , j_ , l_ , omega_ ) result ( p_coeff_ ) !! calculates the P coefficients from Eq. (3) in !! \"Solution of coupled equations\" !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: total_angular_momentum_ !! total angular momentum integer ( int32 ), intent ( in ) :: j_ !! rotational quantum number integer ( int32 ), intent ( in ) :: l_ !! orbital angular momentum integer ( int32 ), intent ( in ) :: omega_ !! projection of j on the BF-Z axis real ( dp ) :: p_coeff_ !! result - P function (Eq. (3) in \"Solution of coupled equations\") !---------------------------------------------------------------------! real ( dp ) :: delta_ !---------------------------------------------------------------------! delta_ = 0.d0 if ( omega_ == 0 ) delta_ = 1.0_dp p_coeff_ = ( - 1.0_dp ) ** ( total_angular_momentum_ + omega_ ) * dsqrt ( 2.0_dp )& * dsqrt ( real ( 2 * l_ + 1 , dp )) & * fwig3jj ( 2 * j_ , 2 * total_angular_momentum_ , 2 * l_ , & 2 * omega_ , - 2 * omega_ , 0 ) / dsqrt ( 1.0_dp + delta_ ) !---------------------------------------------------------------------! end function p_coeff !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine calculate_single_SF_element ( number_of_channels , & total_angular_momentum_ , v_ , j_ , vp_ , jp_ , l_ , lp_ , & channels_level_indices , channels_omega_values , bf_matrix , sf_element ) !! calculates a single space-fixed matrix element from Eq. (2) in !! \"Solution of coupled equations\" !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: number_of_channels !! size of the basis integer ( int32 ), intent ( in ) :: total_angular_momentum_ !! total angular momentum integer ( int32 ), intent ( in ) :: v_ , j_ , vp_ , jp_ !! vibrational and rotational quantum numbers integer ( int32 ), intent ( in ) :: l_ , lp_ !! orbital angular momenta integer ( int32 ), intent ( in ) :: channels_level_indices ( number_of_channels ) !! holds the indices pointing to the basis arrays integer ( int32 ), intent ( in ) :: channels_omega_values ( number_of_channels ) !! holds all values of \\bar{\\Omega} real ( dp ), intent ( in ) :: bf_matrix ( number_of_channels , number_of_channels ) !! matrix in the BF frame real ( dp ), intent ( out ) :: sf_element !! (output) matrix element in the SF frame !---------------------------------------------------------------------! integer ( int32 ) :: channel_index_1_ , channel_index_2_ real ( dp ) :: p_coeff_outer , p_coeff_inner , sum_outer , sum_inner !---------------------------------------------------------------------! sum_outer = 0.0_dp do channel_index_1_ = 1 , number_of_channels if ( v1array ( channels_level_indices ( channel_index_1_ )) /= v_ . or . & j1array ( channels_level_indices ( channel_index_1_ )) /= j_ ) cycle p_coeff_outer = p_coeff ( total_angular_momentum_ , j_ , l_ , & channels_omega_values ( channel_index_1_ )) sum_inner = 0.0_dp do channel_index_2_ = 1 , number_of_channels if ( v1array ( channels_level_indices ( channel_index_2_ )) /= vp_ . or . & j1array ( channels_level_indices ( channel_index_2_ )) /= jp_ ) cycle p_coeff_inner = p_coeff ( total_angular_momentum_ , jp_ , lp_ , & channels_omega_values ( channel_index_2_ )) sum_inner = sum_inner + p_coeff_inner * bf_matrix ( channel_index_1_ , channel_index_2_ ) end do sum_outer = sum_outer + p_coeff_outer * sum_inner end do sf_element = sum_outer !---------------------------------------------------------------------! end subroutine calculate_single_SF_element !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine calculate_sf_matrix_from_bf_matrix ( number_of_channels , & total_angular_momentum_ , channels_level_indices , & channels_omega_values , channels_l_values , bf_matrix , sf_matrix ) !! takes as an input matrix in the body-fixed frame and transforms it !! to the spec-fixed frame; iterates over all matrix elements !! and calls calculate_single_SF_element !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: number_of_channels !! size of the basis integer ( int32 ), intent ( in ) :: total_angular_momentum_ !! total angular momentum integer ( int32 ), intent ( in ) :: channels_level_indices ( number_of_channels ) !! holds the indices pointing to the basis arrays integer ( int32 ), intent ( in ) :: channels_omega_values ( number_of_channels ) !! holds all values of \\bar{\\Omega} integer ( int32 ), intent ( in ) :: channels_l_values ( number_of_channels ) !! holds all values of l real ( dp ), intent ( in ) :: bf_matrix ( number_of_channels , number_of_channels ) !! matrix in the BF frame real ( dp ), intent ( inout ) :: sf_matrix ( number_of_channels , number_of_channels ) !! (output) matrix in the SF frame !---------------------------------------------------------------------! integer ( int32 ) :: l_ , lp_ , omega_ , omegap_ , v1_ , j1_ , v1p_ , j1p_ , channel_index_1_ , channel_index_2_ real ( dp ) :: single_sf_element !---------------------------------------------------------------------! do channel_index_1_ = 1 , number_of_channels v1_ = v1array ( channels_level_indices ( channel_index_1_ )) j1_ = j1array ( channels_level_indices ( channel_index_1_ )) l_ = channels_l_values ( channel_index_1_ ) do channel_index_2_ = 1 , number_of_channels v1p_ = v1array ( channels_level_indices ( channel_index_2_ )) j1p_ = j1array ( channels_level_indices ( channel_index_2_ )) lp_ = channels_l_values ( channel_index_2_ ) call calculate_single_SF_element ( number_of_channels , & total_angular_momentum_ , v1_ , j1_ , v1p_ , j1p_ , l_ , lp_ , & channels_level_indices , channels_omega_values , bf_matrix , & single_sf_element ) sf_matrix ( channel_index_1_ , channel_index_2_ ) = single_sf_element enddo enddo !---------------------------------------------------------------------! end subroutine calculate_sf_matrix_from_bf_matrix !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine calculate_k_matrix ( number_of_channels , log_der_matrix , & number_of_open_channels , channels_level_indices , channels_l_values , & r_ , k_matrix ) !! calculates the K-matrix from log-derivative matrix using Eq. (4) in !! \"Solution of coupled equations\" !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: number_of_channels !! y-matrix is of number_of_channels x number_of_channels size real ( dp ), intent ( in ) :: log_der_matrix ( number_of_channels , number_of_channels ) !! asymptotic log-derivative matrix integer ( int32 ), intent ( in ) :: number_of_open_channels !! number of open channels integer ( int32 ), intent ( in ) :: channels_level_indices ( number_of_channels ) !! holds the indices pointing to the basis arrays integer ( int32 ), intent ( in ) :: channels_l_values ( number_of_channels ) !! holds all values of l real ( dp ), intent ( in ) :: r_ !! Rmax real ( dp ), intent ( inout ) :: k_matrix ( number_of_open_channels , number_of_open_channels ) !! K-matrix !---------------------------------------------------------------------! integer ( int32 ) :: open_channel_index_ , closed_channel_index_ , & channel_index_ , status_ , l_ real ( dp ) :: wavenumber , x , j_element_ , jp_element_ , n_element_ , & np_element_ , ratio integer ( int32 ) :: open_channels_indices ( number_of_open_channels ) integer ( int32 ) :: closed_channels_indices ( number_of_channels - number_of_open_channels ) real ( dp ) :: diag_n_matrix ( number_of_channels , number_of_channels ), & diag_np_matrix ( number_of_channels , number_of_channels ), & diag_j_matrix ( number_of_channels , number_of_open_channels ), & diag_jp_matrix ( number_of_channels , number_of_open_channels ) !---------------------------------------------------------------------! ! diag_j_matrix   -  diagonal J matrix (Eqs. 5, 7) ! diag_jp_matrix  -  diagonal J`matrix (derivative of J) ! diag_n_matrix   -  diagonal N matrix (Eqs. 6, 8) ! diag_np_matrix  -  diagonal N`matrix (derivative of N) !---------------------------------------------------------------------! diag_j_matrix = 0 diag_jp_matrix = 0 diag_n_matrix = 0 diag_np_matrix = 0 !---------------------------------------------------------------------! open_channel_index_ = 0 closed_channel_index_ = 0 !---------------------------------------------------------------------! ! save indices to open and closed channels ! this is because channels might not be sorted eneregetically !---------------------------------------------------------------------! do channel_index_ = 1 , number_of_channels if ( is_open ( elevel ( channels_level_indices ( channel_index_ )))) then open_channel_index_ = open_channel_index_ + 1 open_channels_indices ( open_channel_index_ ) = channel_index_ else closed_channel_index_ = closed_channel_index_ + 1 closed_channels_indices ( closed_channel_index_ ) = channel_index_ endif enddo !---------------------------------------------------------------------! ! Prepare J, J', N and N' matrices (Eqs. 5-6) ! open channels: !---------------------------------------------------------------------! do open_channel_index_ = 1 , number_of_open_channels wavenumber = wavenumber_from_energy ( & elevel ( channels_level_indices ( open_channels_indices ( open_channel_index_ )))) x = wavenumber * r_ l_ = channels_l_values ( open_channels_indices ( open_channel_index_ )) call riccati_bessel_j ( & l_ , x , j_element_ , jp_element_ ) diag_j_matrix ( open_channel_index_ , open_channel_index_ ) & = ( wavenumber ) ** ( - 0.5d0 ) * j_element_ diag_jp_matrix ( open_channel_index_ , open_channel_index_ ) & = ( wavenumber ) ** ( 0.5d0 ) * jp_element_ call riccati_bessel_y ( l_ , x , n_element_ , np_element_ ) diag_n_matrix ( open_channel_index_ , open_channel_index_ ) & = ( wavenumber ) ** ( - 0.5d0 ) * n_element_ diag_np_matrix ( open_channel_index_ , open_channel_index_ ) & = ( wavenumber ) ** ( 0.5d0 ) * np_element_ enddo !---------------------------------------------------------------------! ! Prepare J, J', N and N' matrices (Eqs. 7-8) ! closed channels: !---------------------------------------------------------------------! do closed_channel_index_ = 1 , number_of_channels - number_of_open_channels wavenumber = wavenumber_from_energy ( & elevel ( channels_level_indices ( closed_channels_indices ( closed_channel_index_ )))) x = wavenumber * r_ l_ = channels_l_values ( closed_channels_indices ( closed_channel_index_ )) call modified_bessel_k_ratio ( l_ , x , ratio ) !------------------------------------------------------------------! ! substitution for closed channels, (Eqs. 10 - 11) !------------------------------------------------------------------! diag_n_matrix ( number_of_open_channels + closed_channel_index_ , & number_of_open_channels + closed_channel_index_ ) = 1.d0 diag_np_matrix ( number_of_open_channels + closed_channel_index_ , & number_of_open_channels + closed_channel_index_ ) = wavenumber * ratio enddo !---------------------------------------------------------------------! -----------------------> consider a separate function call DGEMM ( 'N' , 'N' , number_of_channels , number_of_channels , & number_of_channels , 1.0d0 , log_der_matrix , number_of_channels , diag_n_matrix , & number_of_channels , - 1.d0 , diag_np_matrix , number_of_channels ) call DGEMM ( 'N' , 'N' , number_of_channels , number_of_open_channels , & number_of_channels , - 1.0d0 , log_der_matrix , number_of_channels , diag_j_matrix , & number_of_channels , 1.d0 , diag_jp_matrix , number_of_channels ) !---------------------------------------------------------------------! call DGESV ( number_of_channels , number_of_open_channels , diag_np_matrix , & number_of_channels , diag_j_matrix , diag_jp_matrix , number_of_channels , status_ ) !---------------------------------------------------------------------! k_matrix = diag_jp_matrix ( 1 : number_of_open_channels , 1 : number_of_open_channels ) !---------------------------------------------------------------------! end subroutine calculate_k_matrix !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine calculate_s_matrix ( number_of_open_channels , k_matrix , & s_matrix_real , s_matrix_imag ) !! calculates S-matrix from open-open portion of the K-matrix using !! Eq. (12) in \"Solution of coupled equations\" !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: number_of_open_channels !! number of open channels real ( dp ), intent ( in ) :: k_matrix ( number_of_open_channels , number_of_open_channels ) !! K-matrix real ( dp ), intent ( inout ) :: s_matrix_real ( number_of_open_channels , number_of_open_channels ) !! (output) real part of the S-matrix real ( dp ), intent ( inout ) :: s_matrix_imag ( number_of_open_channels , number_of_open_channels ) !! (output) imaginary part of the S-matrix !---------------------------------------------------------------------! integer ( int32 ) :: open_channel_index_1_ , open_channel_index_2_ real ( dp ) :: s_tmp_matrix ( number_of_open_channels , number_of_open_channels ) !---------------------------------------------------------------------! s_matrix_real = 0 s_matrix_imag = 0 !---------------------------------------------------------------------! call DGEMM ( 'N' , 'N' , number_of_open_channels , number_of_open_channels , & number_of_open_channels , 0.5d0 , k_matrix , number_of_open_channels , & k_matrix , number_of_open_channels , 0.d0 , s_tmp_matrix , number_of_open_channels ) !---------------------------------------------------------------------! do open_channel_index_1_ = 1 , number_of_open_channels s_tmp_matrix ( open_channel_index_1_ , open_channel_index_1_ ) = & s_tmp_matrix ( open_channel_index_1_ , open_channel_index_1_ ) + 0.5d0 enddo !---------------------------------------------------------------------! call invert_symmetric_matrix ( s_tmp_matrix ) call fill_symmetric_matrix ( s_tmp_matrix , 'u' ) !---------------------------------------------------------------------! call DGEMM ( 'N' , 'N' , number_of_open_channels , number_of_open_channels , & number_of_open_channels , - 1.0d0 , s_tmp_matrix , number_of_open_channels ,& k_matrix , number_of_open_channels , 0.d0 , s_matrix_imag , number_of_open_channels ) !---------------------------------------------------------------------! do open_channel_index_1_ = 1 , number_of_open_channels do open_channel_index_2_ = 1 , number_of_open_channels s_matrix_real ( open_channel_index_1_ , open_channel_index_2_ ) = & s_tmp_matrix ( open_channel_index_1_ , open_channel_index_2_ ) enddo s_matrix_real ( open_channel_index_1_ , open_channel_index_1_ ) = & s_matrix_real ( open_channel_index_1_ , open_channel_index_1_ ) - 1.d0 enddo !---------------------------------------------------------------------! end subroutine calculate_s_matrix !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! end module boundary_conditions_mod","tags":"","loc":"sourcefile/boundary_conditions_mod.f90.html"},{"title":"propagator_mod.f90 – the SCATTERING code","text":"This file depends on sourcefile~~propagator_mod.f90~~EfferentGraph sourcefile~propagator_mod.f90 propagator_mod.f90 sourcefile~input_reader_mod.f90 input_reader_mod.f90 sourcefile~propagator_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~array_operations_mod.f90 array_operations_mod.f90 sourcefile~propagator_mod.f90->sourcefile~array_operations_mod.f90 sourcefile~radial_coupling_terms_mod.f90 radial_coupling_terms_mod.f90 sourcefile~propagator_mod.f90->sourcefile~radial_coupling_terms_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~array_operations_mod.f90 sourcefile~utility_functions_mod.f90 utility_functions_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~radial_coupling_terms_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~radial_coupling_terms_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~math_functions_mod.f90 math_functions_mod.f90 sourcefile~radial_coupling_terms_mod.f90->sourcefile~math_functions_mod.f90 sourcefile~math_functions_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~special_functions_mod.f90 special_functions_mod.f90 sourcefile~math_functions_mod.f90->sourcefile~special_functions_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~propagator_mod.f90~~AfferentGraph sourcefile~propagator_mod.f90 propagator_mod.f90 sourcefile~scattering.f90 scattering.f90 sourcefile~scattering.f90->sourcefile~propagator_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules PROPAGATORS Source Code propagator_mod.f90 Source Code module PROPAGATORS !! this modules contains the subroutines used by the propagator: !! 1. cenitrfugal_matrix - prepares the centrifugal term (Eq. (6.19)) !! 2. pes_contribution   - prepares the interaction energy term (Eq. (6.21)) !! 3. radtermvalue - returns the value of a radial coupling term at given R !! 4. calculate_log_der_matrix - calculates the log-derivative matrix (Eq. 6.29) !! 5. pes_diagonalization - diagonalizes the coupling matrix from rmin to rmax !! 6. numerov - renormalized Numerov's algorithm !----------------------------------------------------------------------------! use , intrinsic :: iso_fortran_env , only : int32 , sp => real32 , dp => real64 use io_mod use array_operations_mod , only : invert_symmetric_matrix , fill_symmetric_matrix use radial_coupling_terms_mod , only : get_radial_coupling_term_value implicit none contains !---------------------------------------------------------------------------! subroutine cenitrfugal_matrix ( number_of_channels , jj , & channels_level_indices , channels_omega_values , centmatrix ) !! calculates the (R**2)*centrifugal matrix from Eq. (6.19) !! only called once at the beginning of the calculations !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: number_of_channels !! size of the basis integer ( int32 ), intent ( in ) :: jj !! total angular momentum integer ( int32 ), intent ( in ) :: channels_level_indices ( number_of_channels ) !! holds the indices pointing to the basis arrays integer ( int32 ), intent ( in ) :: channels_omega_values ( number_of_channels ) !! holds all values of \\bar{\\Omega} real ( dp ), intent ( out ) :: centmatrix ( number_of_channels , number_of_channels ) !! (output) - (R**2)*centrifugal matrix !---------------------------------------------------------------------! integer ( int32 ) :: omegatmp , omegaptmp , v1tmp , j1tmp , v1ptmp , j1ptmp , & ii , ij real ( dp ) :: centtmp , delta1 , delta2 !---------------------------------------------------------------------! centmatrix = 0 do ii = 1 , number_of_channels v1tmp = v1array ( channels_level_indices ( ii )) j1tmp = j1array ( channels_level_indices ( ii )) omegatmp = channels_omega_values ( ii ) delta1 = 0.d0 if ( omegatmp . eq . 0 ) delta1 = 1.d0 do ij = 1 , ii v1ptmp = v1array ( channels_level_indices ( ij )) j1ptmp = j1array ( channels_level_indices ( ij )) omegaptmp = channels_omega_values ( ij ) delta2 = 0.d0 if ( omegaptmp . eq . 0 ) delta2 = 1.d0 if ( v1tmp . ne . v1ptmp ) cycle if ( j1tmp . ne . j1ptmp ) cycle if ( abs ( omegatmp - omegaptmp ). gt . 1 ) cycle if ( omegatmp . eq . omegaptmp ) then centmatrix ( ii , ij ) = jj * ( jj + 1 ) + j1tmp * ( j1tmp + 1 ) - 2 * omegatmp ** 2 else if ( omegatmp - omegaptmp . eq . 1 ) then centtmp = - dsqrt ( dfloat (( jj * ( jj + 1 ) - & omegatmp * ( omegatmp - 1 )) * ( j1tmp * ( j1tmp + 1 )& - omegatmp * ( omegatmp - 1 )))) centmatrix ( ii , ij ) = centtmp * dsqrt ( 1.d0 + delta1 ) * dsqrt ( 1.d0 + delta2 ) else if ( omegatmp - omegaptmp . eq . - 1 ) then centtmp = - dsqrt ( dfloat (( jj * ( jj + 1 ) - omegatmp * ( omegatmp + 1 )) & * ( j1tmp * ( j1tmp + 1 ) - omegatmp * ( omegatmp + 1 )))) centmatrix ( ii , ij ) = centtmp * dsqrt ( 1.d0 + delta1 ) * dsqrt ( 1.d0 + delta2 ) endif enddo enddo !---------------------------------------------------------------------! call fill_symmetric_matrix ( centmatrix , 'u' ) !---------------------------------------------------------------------! end subroutine !------------------------------------------------------------------------------! subroutine pes_contribution ( number_of_channels , jj , r , & channels_level_indices , channels_omega_values , & number_of_nonzero_coupling_matrix_elements , & number_of_nonzero_coupling_coefficients , & nonzero_terms_per_element , nonzero_legendre_indices , & nonzero_coupling_coefficients , vmatrix ) !! calculates the contribution from the PES in (X) at given R !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: number_of_channels !! size of the basis integer ( int32 ), intent ( in ) :: jj !! total angular momentum real ( dp ), intent ( in ) :: r !! intermolecular distance integer ( int32 ), intent ( in ) :: channels_level_indices ( number_of_channels ) !! holds the indices pointing to the basis arrays integer ( int32 ), intent ( in ) :: channels_omega_values ( number_of_channels ) !! holds all values of \\bar{\\Omega} integer ( int32 ), intent ( in ) :: number_of_nonzero_coupling_matrix_elements !! number of non-zero terms in the sum () for each non-zero element of the coupling matrix integer ( int32 ), intent ( in ) :: number_of_nonzero_coupling_coefficients !! number of all non-zero algberaix coefficients in the whole coupling matrix integer ( int32 ), intent ( in ) :: nonzero_terms_per_element ( number_of_nonzero_coupling_matrix_elements ) !! keeps the number of non-zero terms in the sum (Eq. (6.21)) for !! each non-zero element of W/V integer ( int32 ), intent ( in ) :: nonzero_legendre_indices ( number_of_nonzero_coupling_coefficients ) !! holds the proper indices pointing to l1/l2/lltabs, which !! correspond to the non-vanishing elements of the sum  (Eq. (6.21)) !! for each non-zero element of W/V real ( dp ), intent ( in ) :: nonzero_coupling_coefficients ( number_of_nonzero_coupling_coefficients ) !! holds the values of the non-zero algebraic coefficients real ( dp ), intent ( out ) :: vmatrix ( number_of_channels , number_of_channels ) !! (output) - the PES contribution to the coupling matrix !---------------------------------------------------------------------! integer ( int32 ) :: indvl , inonzero_coupling_matrix_elements , omegatmp , omegaptmp , l1 , & nonzerolam , v1tmp , j1tmp , v1ptmp , j1ptmp , ii , ij , il real ( dp ) :: erot , sumtemp , pscoeff , v !---------------------------------------------------------------------! vmatrix = 0 indvl = 0 inonzero_coupling_matrix_elements = 0 !---------------------------------------------------------------------! do ii = 1 , number_of_channels v1tmp = v1array ( channels_level_indices ( ii )) j1tmp = j1array ( channels_level_indices ( ii )) omegatmp = channels_omega_values ( ii ) erot = elevel ( channels_level_indices ( ii )) do ij = 1 , ii v1ptmp = v1array ( channels_level_indices ( ij )) j1ptmp = j1array ( channels_level_indices ( ij )) omegaptmp = channels_omega_values ( ij ) if ( omegatmp . ne . omegaptmp ) cycle inonzero_coupling_matrix_elements = inonzero_coupling_matrix_elements + 1 nonzerolam = nonzero_terms_per_element ( inonzero_coupling_matrix_elements ) sumtemp = 0.d0 do il = 1 , nonzerolam indvl = indvl + 1 l1 = l1tab ( nonzero_legendre_indices ( indvl )) pscoeff = nonzero_coupling_coefficients ( indvl ) call get_radial_coupling_term_value ( r , l1 , v1tmp , j1tmp , v1ptmp , j1ptmp , v ) sumtemp = sumtemp + pscoeff * v enddo vmatrix ( ii , ij ) = - 2 * reducedmass * sumtemp enddo vmatrix ( ii , ii ) = vmatrix ( ii , ii ) - ( 2 * reducedmass * erot ) enddo !---------------------------------------------------------------------! call fill_symmetric_matrix ( vmatrix , 'u' ) !---------------------------------------------------------------------! end subroutine pes_contribution !------------------------------------------------------------------------------! !------------------------------------------------------------------------------! subroutine calculate_log_der_matrix ( h , y_dim , tt_min , tt_n , tt_plus , r_n , r_plus , log_der_matrix ) !! calculates the log-derivative matrix from Eq. (6.29) !! called by numerov and log_derivative at the end of the propagation !---------------------------------------------------------------------! real ( dp ), intent ( in ) :: h !! step of the propagation integer ( int32 ), intent ( in ) :: y_dim !! dimension of the log-derivative matrix real ( dp ), intent ( in ) :: tt_min ( y_dim , y_dim ) !! T-matrix at R_{max - 1} real ( dp ), intent ( in ) :: tt_n ( y_dim , y_dim ) !! T-matrix at R_{max} real ( dp ), intent ( in ) :: tt_plus ( y_dim , y_dim ) !! T-matrix at R_{max + 1} real ( dp ), intent ( in ) :: r_n ( y_dim , y_dim ) !! R-matrix at R_{max} real ( dp ), intent ( in ) :: r_plus ( y_dim , y_dim ) !! R-matrix at R_{max + 1} real ( dp ), intent ( inout ) :: log_der_matrix ( y_dim , y_dim ) !! log-derivative matrix !---------------------------------------------------------------------! integer ( int32 ) :: i , j real ( dp ) :: a ( y_dim , y_dim ), b ( y_dim , y_dim ), c ( y_dim , y_dim ), & d ( y_dim , y_dim ), e ( y_dim , y_dim ), f ( y_dim , y_dim ), g ( y_dim , y_dim ), & ab ( y_dim , y_dim ), abc ( y_dim , y_dim ), de ( y_dim , y_dim ), & def ( y_dim , y_dim ), bra ( y_dim , y_dim ) !---------------------------------------------------------------------! log_der_matrix = 0 !---------------------------------------------------------------------! do i = 1 , y_dim do j = 1 , y_dim a ( i , j ) = - tt_plus ( i , j ) b ( i , j ) = - tt_plus ( i , j ) c ( i , j ) = r_plus ( i , j ) d ( i , j ) = - tt_min ( i , j ) e ( i , j ) = - tt_min ( i , j ) f ( i , j ) = r_n ( i , j ) g ( i , j ) = - tt_n ( i , j ) end do a ( i , i ) = 0.5 + a ( i , i ) b ( i , i ) = 1. + b ( i , i ) d ( i , i ) = 0.5 + d ( i , i ) e ( i , i ) = 1. + e ( i , i ) g ( i , i ) = 1. + g ( i , i ) end do !---------------------------------------------------------------------! call invert_symmetric_matrix ( b ) call fill_symmetric_matrix ( b , \"u\" ) call invert_symmetric_matrix ( e ) call fill_symmetric_matrix ( e , \"u\" ) call invert_symmetric_matrix ( f ) call fill_symmetric_matrix ( f , \"u\" ) !---------------------------------------------------------------------! CALL DGEMM ( 'N' , 'N' , y_dim , y_dim , y_dim , 1.0d0 ,& a , y_dim , b , y_dim , 0.d0 , ab , y_dim ) CALL DGEMM ( 'N' , 'N' , y_dim , y_dim , y_dim , 1.0d0 ,& ab , y_dim , c , y_dim , 0.d0 , abc , y_dim ) CALL DGEMM ( 'N' , 'N' , y_dim , y_dim , y_dim , 1.0d0 ,& d , y_dim , e , y_dim , 0.d0 , de , y_dim ) CALL DGEMM ( 'N' , 'N' , y_dim , y_dim , y_dim , 1.0d0 ,& de , y_dim , f , y_dim , 0.d0 , DEF , y_dim ) !----------------------------------------------------------------------! bra = abc - def !---------------------------------------------------------------------! CALL DGEMM ( 'N' , 'N' , y_dim , y_dim , y_dim , dble ( 1.d0 / h ), bra ,& y_dim , g , y_dim , 0.d0 , log_der_matrix , y_dim ) !---------------------------------------------------------------------! end subroutine calculate_log_der_matrix !------------------------------------------------------------------------! subroutine numerov ( channels_level_indices , channels_omega_values , & number_of_nonzero_coupling_matrix_elements , & number_of_nonzero_coupling_coefficients , nonzero_terms_per_element , & nonzero_legendre_indices , nonzero_coupling_coefficients , nsteps , & number_of_channels , jj , log_der_matrix ) !! renormalized Numerov propagator !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: number_of_channels !! size of the basis integer ( int32 ), intent ( in ) :: channels_level_indices ( number_of_channels ) !! holds the indices pointing to the basis arrays integer ( int32 ), intent ( in ) :: channels_omega_values ( number_of_channels ) !! holds all values of \\bar{\\Omega} integer ( int32 ), intent ( in ) :: number_of_nonzero_coupling_matrix_elements !! number of non-zero terms in the sum () for each non-zero element of the coupling matrix integer ( int32 ), intent ( in ) :: number_of_nonzero_coupling_coefficients !! number of all non-zero algberaix coefficients in the whole coupling matrix integer ( int32 ), intent ( in ) :: nonzero_terms_per_element ( number_of_nonzero_coupling_matrix_elements ) !! keeps the number of non-zero terms in the sum (Eq. (6.21)) for !! each non-zero element of W/V integer ( int32 ), intent ( in ) :: nonzero_legendre_indices ( number_of_nonzero_coupling_coefficients ) !! holds the proper indices pointing to l1/l2/lltabs, which !! correspond to the non-vanishing elements of the sum  (Eq. (6.21)) !! for each non-zero element of W/V real ( dp ), intent ( in ) :: nonzero_coupling_coefficients ( number_of_nonzero_coupling_coefficients ) !! holds the values of the non-zero algebraic coefficients integer ( int32 ), intent ( in ) :: nsteps !! number of steps from rmin to rmax integer ( int32 ), intent ( in ) :: jj !! total angular momentum real ( dp ), intent ( inout ) :: log_der_matrix (:,:) !! resulting log-derivative matrix at RMAX !---------------------------------------------------------------------! integer ( int32 ) :: i , ii , ij real ( dp ) :: start , finish , r , step_numerov real ( dp ), allocatable , dimension (:,:) :: umatrix , r_temp , rmatrix , & t_minus , t_center , t_plus , r_center , r_plus , w_tmp , v_tmp real ( dp ), dimension ( number_of_channels , number_of_channels ) :: & cent_mat , v_mat , w_mat , t_mat , u_left , u_right !---------------------------------------------------------------------! CALL CPU_TIME ( start ) !---------------------------------------------------------------------! ! Calculate the centrifugal term !---------------------------------------------------------------------! call cenitrfugal_matrix ( number_of_channels , jj , channels_level_indices , & channels_omega_values , cent_mat ) step_numerov = ( rmax - rmin ) / dble ( nsteps - 1 ) call allocate_2d ( R_temp , number_of_channels , number_of_channels ) !---------------------------------------------------------------------! ! Calculate the PES contribution at rmin !---------------------------------------------------------------------! call pes_contribution ( number_of_channels , jj , rmin , & channels_level_indices , channels_omega_values , & number_of_nonzero_coupling_matrix_elements , & number_of_nonzero_coupling_coefficients , & nonzero_terms_per_element , nonzero_legendre_indices , & nonzero_coupling_coefficients , v_mat ) !---------------------------------------------------------------------! ! Coupling matrix W at rmin !---------------------------------------------------------------------! w_mat = v_mat - ( 1. / rmin ** 2. ) * cent_mat !---------------------------------------------------------------------! ! T-matrix (Eq. 6.23) !---------------------------------------------------------------------! do ii = 1 , number_of_channels do ij = 1 , number_of_channels t_mat ( ii , ij ) = - (( step_numerov ** 2. ) / 1 2. ) * ( w_mat ( ii , ij )) enddo t_mat ( ii , ii ) = - (( step_numerov ** 2. ) / 1 2. ) * & ( 2 * reducedmass * ETOTAL ()) + t_mat ( ii , ii ) enddo !---------------------------------------------------------------------! ! U-matrix (Eq. 6.25) !---------------------------------------------------------------------! do ii = 1 , number_of_channels do ij = 1 , number_of_channels u_left ( ii , ij ) = - t_mat ( ii , ij ) end do u_left ( ii , ii ) = 1.d0 + u_left ( ii , ii ) end do call invert_symmetric_matrix ( u_left ) call fill_symmetric_matrix ( u_left , 'u' ) !---------------------------------------------------------------------! ! R-matrix at rmin + 1 = U-matrix at rmin !---------------------------------------------------------------------! do ii = 1 , number_of_channels do ij = 1 , number_of_channels r_temp ( ii , ij ) = 1 2.d0 * u_left ( ii , ij ) enddo r_temp ( ii , ii ) = r_temp ( ii , ii ) - 1 0.d0 enddo !---------------------------------------------------------------------! ! Continue the propagation to rmax !---------------------------------------------------------------------! do i = 2 , nsteps !------------------------------------------------------------------! ! Coupling matrix W at R !------------------------------------------------------------------! R = rmin + ( i - 1 ) * step_numerov call allocate_2d ( rmatrix , number_of_channels , number_of_channels ) call allocate_2d ( umatrix , number_of_channels , number_of_channels ) call pes_contribution ( number_of_channels , jj , R , & channels_level_indices , channels_omega_values , & number_of_nonzero_coupling_matrix_elements , & number_of_nonzero_coupling_coefficients , & nonzero_terms_per_element , nonzero_legendre_indices , & nonzero_coupling_coefficients , v_mat ) w_mat = v_mat - ( 1. / R ** 2. ) * cent_mat !------------------------------------------------------------------! ! T-matrix at R (6.18) !------------------------------------------------------------------! do ii = 1 , number_of_channels do ij = 1 , number_of_channels t_mat ( ii , ij ) = - (( step_numerov ** 2. ) / 1 2. ) * ( w_mat ( ii , ij )) enddo t_mat ( ii , ii ) = - (( step_numerov ** 2. ) / 1 2. ) * & ( 2 * reducedmass * ETOTAL ()) + t_mat ( ii , ii ) enddo !------------------------------------------------------------------! ! U-matrix at R (6.20) !------------------------------------------------------------------! do ii = 1 , number_of_channels do ij = 1 , number_of_channels u_left ( ii , ij ) = - t_mat ( ii , ij ) end do u_left ( ii , ii ) = 1.d0 + u_left ( ii , ii ) end do call invert_symmetric_matrix ( u_left ) call fill_symmetric_matrix ( u_left , 'u' ) do ii = 1 , number_of_channels do ij = 1 , number_of_channels umatrix ( ii , ij ) = 1 2.d0 * u_left ( ii , ij ) enddo umatrix ( ii , ii ) = umatrix ( ii , ii ) - 1 0.d0 enddo call invert_symmetric_matrix ( r_temp ) call fill_symmetric_matrix ( r_temp , 'u' ) !------------------------------------------------------------------! ! Prepare T at Rmax - 1 and R at Rmax !------------------------------------------------------------------! if ( i == nsteps - 1 ) then call allocate_2d ( v_tmp , number_of_channels , number_of_channels ) call allocate_2d ( w_tmp , number_of_channels , number_of_channels ) call allocate_2d ( t_minus , number_of_channels , number_of_channels ) call pes_contribution ( number_of_channels , jj , r , & channels_level_indices , channels_omega_values , & number_of_nonzero_coupling_matrix_elements , & number_of_nonzero_coupling_coefficients , & nonzero_terms_per_element , nonzero_legendre_indices , & nonzero_coupling_coefficients , v_tmp ) w_tmp = v_tmp - ( 1. / R ** 2. ) * cent_mat do ii = 1 , number_of_channels do ij = 1 , number_of_channels t_minus ( ii , ij ) = - (( step_numerov ** 2. ) / 1 2. ) * & ( w_tmp ( ii , ij )) enddo t_minus ( ii , ii ) = - (( step_numerov ** 2. ) / 1 2. ) * & ( 2 * reducedmass * ETOTAL ()) + t_minus ( ii , ii ) enddo call allocate_2d ( r_center , number_of_channels , number_of_channels ) r_center = umatrix - r_temp !---------------------------------------------------------------! ! Prepare T at Rmax and R max + 1, and R at Rmax + 1 !---------------------------------------------------------------! else if ( i == nsteps ) then call allocate_2d ( v_tmp , number_of_channels , number_of_channels ) call allocate_2d ( w_tmp , number_of_channels , number_of_channels ) call allocate_2d ( t_center , number_of_channels , number_of_channels ) call pes_contribution ( number_of_channels , jj , r , & channels_level_indices , channels_omega_values , & number_of_nonzero_coupling_matrix_elements , & number_of_nonzero_coupling_coefficients , & nonzero_terms_per_element , nonzero_legendre_indices , & nonzero_coupling_coefficients , v_tmp ) w_tmp = v_tmp - ( 1. / R ** 2. ) * cent_mat do ii = 1 , number_of_channels do ij = 1 , number_of_channels t_center ( ii , ij ) = - (( step_numerov ** 2. ) / 1 2. ) * & ( w_tmp ( ii , ij )) enddo t_center ( ii , ii ) = - (( step_numerov ** 2. ) / 1 2. ) * & ( 2 * reducedmass * ETOTAL ()) + t_center ( ii , ii ) enddo call allocate_2d ( r_plus , number_of_channels , number_of_channels ) r_plus = umatrix - r_temp r = rmax + step_numerov call allocate_2d ( v_tmp , number_of_channels , number_of_channels ) call allocate_2d ( t_plus , number_of_channels , number_of_channels ) call allocate_2d ( w_tmp , number_of_channels , number_of_channels ) call pes_contribution ( number_of_channels , jj , r , & channels_level_indices , channels_omega_values , & number_of_nonzero_coupling_matrix_elements , & number_of_nonzero_coupling_coefficients , & nonzero_terms_per_element , nonzero_legendre_indices , & nonzero_coupling_coefficients , v_tmp ) w_tmp = v_tmp - ( 1. / R ** 2. ) * cent_mat do ii = 1 , number_of_channels do ij = 1 , number_of_channels t_plus ( ii , ij ) = - (( step_numerov ** 2. ) / 1 2. ) * & ( w_tmp ( ii , ij )) enddo t_plus ( ii , ii ) = - (( step_numerov ** 2. ) / 1 2. ) * & ( 2 * reducedmass * ETOTAL ()) + t_plus ( ii , ii ) enddo end if !------------------------------------------------------------------! ! R-matrix at R_{n+1} (Eq. 6.28) !------------------------------------------------------------------! rmatrix = umatrix - r_temp call allocate_2d ( r_temp , number_of_channels , number_of_channels ) !------------------------------------------------------------------! ! Move R_{n+1} to R_{n} !------------------------------------------------------------------! r_temp = rmatrix end do CALL CPU_TIME ( finish ) !---------------------------------------------------------------------! ! Eq. (6.29) !---------------------------------------------------------------------! call calculate_log_der_matrix ( step_numerov , number_of_channels , & t_minus , t_center , t_plus , r_center , r_plus , log_der_matrix ) !---------------------------------------------------------------------! if ( prntlvl . ge . 2 ) then call write_message ( \"Numerov propagator took \" // & trim ( adjustl ( float_to_character ( finish - start , \"(E14.8)\" ))) // & \" seconds\" ) endif !---------------------------------------------------------------------! end subroutine numerov !------------------------------------------------------------------------------! end module PROPAGATORS","tags":"","loc":"sourcefile/propagator_mod.f90.html"},{"title":"utility_functions_mod.f90 – the SCATTERING code","text":"Files dependent on this one sourcefile~~utility_functions_mod.f90~~AfferentGraph sourcefile~utility_functions_mod.f90 utility_functions_mod.f90 sourcefile~coupling_matrix_mod.f90 coupling_matrix_mod.f90 sourcefile~coupling_matrix_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~input_reader_mod.f90 input_reader_mod.f90 sourcefile~coupling_matrix_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~math_functions_mod.f90 math_functions_mod.f90 sourcefile~coupling_matrix_mod.f90->sourcefile~math_functions_mod.f90 sourcefile~channels_mod.f90 channels_mod.f90 sourcefile~channels_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~channels_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~sts_xs_mod.f90 sts_xs_mod.f90 sourcefile~sts_xs_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~sts_xs_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~boundary_conditions_mod.f90 boundary_conditions_mod.f90 sourcefile~boundary_conditions_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~boundary_conditions_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~boundary_conditions_mod.f90->sourcefile~math_functions_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~math_functions_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~unitarity_check_mod.f90 unitarity_check_mod.f90 sourcefile~unitarity_check_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~unitarity_check_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~radial_coupling_terms_mod.f90 radial_coupling_terms_mod.f90 sourcefile~radial_coupling_terms_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~radial_coupling_terms_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~radial_coupling_terms_mod.f90->sourcefile~math_functions_mod.f90 sourcefile~scattering.f90 scattering.f90 sourcefile~scattering.f90->sourcefile~utility_functions_mod.f90 sourcefile~scattering.f90->sourcefile~coupling_matrix_mod.f90 sourcefile~scattering.f90->sourcefile~channels_mod.f90 sourcefile~scattering.f90->sourcefile~sts_xs_mod.f90 sourcefile~scattering.f90->sourcefile~boundary_conditions_mod.f90 sourcefile~scattering.f90->sourcefile~input_reader_mod.f90 sourcefile~scattering.f90->sourcefile~unitarity_check_mod.f90 sourcefile~scattering.f90->sourcefile~radial_coupling_terms_mod.f90 sourcefile~propagator_mod.f90 propagator_mod.f90 sourcefile~scattering.f90->sourcefile~propagator_mod.f90 sourcefile~array_operations_fill_symmetric_matrix_submod.f90 array_operations_fill_symmetric_matrix_submod.f90 sourcefile~array_operations_fill_symmetric_matrix_submod.f90->sourcefile~utility_functions_mod.f90 sourcefile~propagator_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~propagator_mod.f90->sourcefile~radial_coupling_terms_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules utility_functions_mod Source Code utility_functions_mod.f90 Source Code module utility_functions_mod !! utility_functions_mod contains functions which handle writing !! messages/errors/warnings on screen, formatting headers, summary of the !! calculations and a few other supporting functions. !---------------------------------------------------------------------------! use , intrinsic :: iso_fortran_env , only : int32 , sp => real32 , dp => real64 , & output_unit !---------------------------------------------------------------------------! implicit none private public :: write_header , write_message , write_warning , write_error , time_count_summary , & alloc_status , file_io_status , incorrect_value , to_lowercase , & integer_to_character , float_to_character !---------------------------------------------------------------------------! character ( len =* ), parameter :: letters = & \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\" character ( len =* ), parameter :: uppercase = letters ( 1 : 26 ) character ( len =* ), parameter :: lowercase = letters ( 27 :) !---------------------------------------------------------------------------! interface incorrect_value !! interface for the following message: !! ``incorrect value encountered: !!   variable_name = variable_value`` module procedure incorrect_value_ch !! for character variables module procedure incorrect_value_int32 !! for integer variables module procedure incorrect_value_sp !! for single precision variables module procedure incorrect_value_dp !! for double precision variables end interface !---------------------------------------------------------------------------! contains !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine write_message ( message_ , unit_ ) !! writes a message on a chosen unit !---------------------------------------------------------------------! character ( len = * ), intent ( in ) :: message_ !! a message to be written integer ( int32 ), optional , intent ( in ) :: unit_ !! optional, unit where the message will be written !---------------------------------------------------------------------! if ( present ( unit_ )) then write ( unit_ , '(a)' ) trim ( message_ ) else write ( output_unit , '(a)' ) trim ( message_ ) endif !---------------------------------------------------------------------! end subroutine write_message !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine write_warning ( message_ , unit_ ) !! writes a warning message on a chosen unit !---------------------------------------------------------------------! character ( len = * ), intent ( in ) :: message_ !! a message to be written integer ( int32 ), optional , intent ( in ) :: unit_ !! optional, unit where the message will be written !---------------------------------------------------------------------! call write_message ( 'Warning: ' // trim ( message_ ), unit_ ) !---------------------------------------------------------------------! end subroutine write_warning !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine write_error ( message_ , unit_ ) !! writes an error message on a chosen unit !---------------------------------------------------------------------! character ( len = * ), intent ( in ) :: message_ !! a message to be written integer ( int32 ), optional , intent ( in ) :: unit_ !! optional, unit where the message will be written !---------------------------------------------------------------------! call write_message ( 'Error: ' // trim ( message_ ), unit_ ) stop !---------------------------------------------------------------------! end subroutine write_error !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine write_header ( header_type , opt_integer_ ) !! writes headers on screen character ( len = * ), intent ( in ) :: header_type !! specifies the type of the header: 'main', 'input_read', !! 'input_check', 'input_summary', 'initialization', 'check_norm', !! 'save_basis', 'save_pes', 'radial_terms', 'save_radial_terms', !! 'reconstruction' integer ( int32 ), optional , intent ( in ) :: opt_integer_ !! optional integer used in case \"block\" to pass jtot value !---------------------------------------------------------------------! character ( len = 100 ) :: header_star , header_str character ( len = 10 ) :: tmp_str_ integer ( int32 ) :: len_str_ !---------------------------------------------------------------------! select case ( trim ( header_type )) case ( 'main' ) write ( header_star , fmt = \"(a90)\" ) repeat ( \"*\" , 90 ) call write_message ( header_star ) call write_message ( header_star ) write ( header_str , fmt = '(a,25x,a43,20x,a)' ) & '*' , 'BIGOS quantum scattering package, vs. 0.00.' , '*' call write_message ( header_str ) write ( header_str , fmt = '(a,36x,a19,33x,a)' ) & '*' , 'the SCATTERING code' , '*' call write_message ( header_str ) write ( header_str , fmt = '(a,29x,a31,28x,a)' ) & '*' , 'adjusted for H2-He calculations' , '*' call write_message ( header_str ) write ( header_str , fmt = '(a,37x,a17,34x,a)' ) & '*' , 'by Hubert Jozwiak' , '*' call write_message ( header_str ) write ( header_str , fmt = '(a,40x,a11,37x,a)' ) & '*' , '20/12/2023 ' , '*' call write_message ( header_str ) call write_message ( header_star ) case ( 'block' ) call write_message ( repeat ( '*' , 90 )) if ( present ( opt_integer_ )) then write ( tmp_str_ , \"(i10)\" ) opt_integer_ len_str_ = len_trim ( tmp_str_ ) write ( * , '(\"*\", A, \"JTOT = \", A, A, \"*\")' ) & repeat ( ' ' , 40 - len_str_ ), tmp_str_ , repeat ( ' ' , 41 ) call write_message ( repeat ( '*' , 90 )) else call write_error ( \"**** JTOT value not provided in \" // & \"write_header_block ****\" ) endif case ( 'unitarity' ) call write_message ( repeat ( \" \" , 43 ) // \"***\" ) call write_message ( \"Check of the unitarity of the S-matrix:\" ) call write_message ( repeat ( \" \" , 34 ) // \"*** S-matrix elements: ***\" ) call write_message ( \"   ROW   COL\" // repeat ( \" \" , 15 ) // \"S**2\" // & repeat ( \" \" , 17 ) // \"RE (S)\" // repeat ( \" \" , 17 ) // \"IM (S)\" ) case default call incorrect_value ( 'header_type (write_header)' , header_type ) end select !---------------------------------------------------------------------! end subroutine write_header !   !---------------------------------------------------------------------------! !   !---------------------------------------------------------------------------! !      subroutine write_summary(total_, inp_read_, inp_check_, inp_summary_,    & !          units_, grids_, system_, normalization_, pes_save_, basis_save_,     & !          radterm_calcs_, radterm_save_, reconstruct_) !         !! writes the summary on screen !         !---------------------------------------------------------------------! !         real(dp), intent(in)           :: total_, inp_read_, inp_check_,      & !           inp_summary_, units_, grids_, system_, normalization_, pes_save_,   & !           basis_save_, radterm_calcs_, radterm_save_, reconstruct_ !            !! total time of the run & time intervals for smaller tasks !            !! completed by the code; if a task wasn't invoked, print '---' !            !! on screen !         !---------------------------------------------------------------------! !         real(dp), parameter  :: zero_tolerance = 1.0e-12_dp !         !---------------------------------------------------------------------! !         character(len = 100) :: header_star, header_str, line !         !---------------------------------------------------------------------! !         call write_message('') !         write(header_star, fmt = '(a72)') repeat('*', 72) !         call write_message(header_star) !         write(header_str, fmt = '(a,23x,a,x,es11.4,x,a,22x,a)')               & !                 '*','Finished in',total_,'s','*' !         call write_message(header_str) !         call write_message(header_star) !         if (inp_read_.gt.zero_tolerance) then !            write(line, fmt = '(a,24x,es11.4,x,a,22x,a)')                      & !                    '* Input read', inp_read_, 's', '*' !         else !            write(line, fmt = '(a,24x,6x,a,26x,a)')                            & !                    '* Input read', '---', '*' !         endif !         call write_message(line) !         if (inp_check_.gt.zero_tolerance) then !            write(line, fmt = '(a,23x,es11.4,x,a,22x,a)')                      & !                    '* Input check', inp_check_, 's', '*' !         else !            write(line, fmt = '(a,23x,6x,a,26x,a)')                            & !                    '* Input check', '---', '*' !         endif !         call write_message(line) !         if (inp_summary_.gt.zero_tolerance) then !            write(line, fmt = '(a,21x,es11.4,x,a,22x,a)')                      & !                    '* Input summary', inp_summary_, 's', '*' !         else !            write(line, fmt = '(a,21x,6x,a,26x,a)')                            & !                    '* Input summary', '---', '*' !         endif !         call write_message(line) !         if (units_.gt.zero_tolerance) then !            write(line, fmt = '(a,17x,es11.4,x,a,22x,a)')                      & !                    '* Units preparation', units_, 's', '*' !         else !            write(line, fmt = '(a,17x,6x,a,26x,a)')                            & !                    '* Units preparation', '---', '*' !         endif !         call write_message(line) !         if (grids_.gt.zero_tolerance) then !            write(line, fmt = '(a,17x,es11.4,x,a,22x,a)')                      & !                    '* Grids preparation', grids_, 's', '*' !         else !            write(line, fmt = '(a,17x,6x,a,26x,a)')                            & !                    '* Grids preparation', '---', '*' !         endif !         call write_message(line) !         if (system_.gt.zero_tolerance) then !            write(line, fmt = '(a,11x,es11.4,x,a,22x,a)')                      & !                    '* PES & basis preparation', system_, 's', '*' !         else !            write(line, fmt = '(a,11x,6x,a,26x,a)')                            & !                    '* PES & basis preparation', '---', '*' !         endif !         call write_message(line) !         if (normalization_.gt.zero_tolerance) then !            write(line, fmt = '(a,15x,es11.4,x,a,22x,a)')                      & !                    '* Normalization check', normalization_, 's', '*' !         else !            write(line, fmt = '(a,15x,6x,a,26x,a)')                            & !                    '* Normalization check', '---', '*' !         endif !         call write_message(line) !         if (pes_save_.gt.zero_tolerance) then !            write(line, fmt = '(a,24x,es11.4,x,a,22x,a)')                      & !                    '* Saving PES', pes_save_, 's', '*' !         else !            write(line, fmt = '(a,24x,6x,a,26x,a)')                            & !                    '* Saving PES', '---', '*' !         endif !         call write_message(line) !         if (basis_save_.gt.zero_tolerance) then !            write(line, fmt = '(a,22x,es11.4,x,a,22x,a)')                      & !                    '* Saving basis', basis_save_, 's', '*' !         else !            write(line, fmt = '(a,22x,6x,a,26x,a)')                            & !                    '* Saving basis', '---', '*' !         endif !         call write_message(line) !         if (radterm_calcs_.gt.zero_tolerance) then !            write(line, fmt = '(a,9x,es11.4,x,a,22x,a)')                       & !                    '* Radial terms calculations', radterm_calcs_, 's', '*' !         else !            write(line, fmt = '(a,9x,6x,a,26x,a)')                             & !                    '* Radial terms calculations', '---', '*' !         endif !         call write_message(line) !         if (radterm_save_.gt.zero_tolerance) then !            write(line, fmt = '(a,15x,es11.4,x,a,22x,a)')                      & !                    '* Saving radial terms', radterm_save_, 's', '*' !         else !            write(line, fmt = '(a,15x,6x,a,26x,a)')                            & !                    '* Saving radial terms', '---', '*' !         endif !         call write_message(line) !         if (reconstruct_.gt.zero_tolerance) then !            write(line, fmt = '(a,9x,es11.4,x,a,22x,a)')                       & !                    '* Reconstruction of the PES', reconstruct_, 's', '*' !         else !            write(line, fmt = '(a,9x,6x,a,26x,a)')                             & !                    '* Reconstruction of the PES', '---', '*' !         endif !         call write_message(line) !         write(line, fmt = '(a,24x,es11.4,x,a,22x,a)')                         & !                 '* Total time', total_, 's', '*' !         call write_message(line) !         call write_message(header_star) !         !---------------------------------------------------------------------! !      end subroutine write_summary !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine time_count_summary ( start_ , stop_ , time_ , message_ ) !! print the message about the time it took to complete a single task !---------------------------------------------------------------------! real ( dp ), intent ( in ) :: start_ !! initial time real ( dp ), intent ( in ) :: stop_ !! final time real ( dp ), intent ( out ) :: time_ !! stop_ - start_ character ( len = * ), optional , intent ( in ) :: message_ !! (optional) a message to print instead of a default !! \"Completed in ... s\" !---------------------------------------------------------------------! character ( len = 12 ) :: default_message = 'Completed in' character ( len = 100 ) :: time_msg !---------------------------------------------------------------------! time_ = stop_ - start_ if ( present ( message_ )) then write ( time_msg , fmt = '(a,x,a,es11.4,x,a)' ) & '--' , trim ( message_ ), time_ , 's' else write ( time_msg , fmt = '(a,x,a,es11.4,x,a)' ) & '--' , default_message , time_ , 's' endif call write_message ( time_msg ) !---------------------------------------------------------------------! end subroutine time_count_summary !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine alloc_status ( istat_ , message_ , op_ , unit_ ) !! check the status after allocation !---------------------------------------------------------------------! integer ( int32 ) :: istat_ !! result of stat=istat in (de)allocate character ( len = * ), intent ( in ) :: message_ !! a message to be written character ( len = 1 ), intent ( in ) :: op_ !! 'a' for allocation, 'd' for deallocation integer ( int32 ), optional , intent ( in ) :: unit_ !! optional, unit where the message will be written !---------------------------------------------------------------------! character ( len = :), allocatable :: add_prefix_ !---------------------------------------------------------------------! add_prefix_ = '' if ( istat_ /= 0 ) then select case ( op_ ) case ( 'a' ) add_prefix_ = 'memory allocation: ' // trim ( message_ ) case ( 'd' ) add_prefix_ = 'memory deallocation: ' // trim ( message_ ) case default call write_error & ( 'Incorrect op_ argument in alloc_status subroutine (' & // trim ( op_ ) // ')' ) end select call write_error ( add_prefix_ , unit_ ) endif !---------------------------------------------------------------------! end subroutine alloc_status !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine file_io_status ( istat_ , iomsg_ , channel_ , op_ , unit_ ) !! check the status during various io operations on files !---------------------------------------------------------------------! integer ( int32 ) :: istat_ !! result of iostat in open/read/write/close character ( len = * ), intent ( in ) :: iomsg_ !! result of iomsg in open/read/write/close integer ( int32 ), intent ( in ) :: channel_ !! name of the file character ( len = 1 ), intent ( in ) :: op_ !! 'o' for opening of the file, 'r' for reading, 'w' for writing, !! 'c' for closing integer ( int32 ), optional , intent ( in ) :: unit_ !! optional, unit where the message will be written !---------------------------------------------------------------------! character ( len = :), allocatable :: add_prefix_ !---------------------------------------------------------------------! add_prefix_ = '' if ( istat_ /= 0 ) then select case ( op_ ) case ( 'o' ) add_prefix_ = 'opening file on channel: ' // & integer_to_character ( channel_ ) case ( 'r' ) add_prefix_ = 'reading file on channel: ' // & integer_to_character ( channel_ ) case ( 'w' ) add_prefix_ = 'writing to file on channel: ' // & integer_to_character ( channel_ ) case ( 'c' ) add_prefix_ = 'closing file on channel: ' // & integer_to_character ( channel_ ) case default call write_error & ( 'Incorrect op_ argument in file_io_status subroutine (' & // trim ( op_ ) // ')' ) end select call write_error ( trim ( add_prefix_ ) // \" with message: \" // iomsg_ , unit_ ) endif !---------------------------------------------------------------------! end subroutine file_io_status !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine incorrect_value_ch ( name_ , value_ , unit_ ) !! ``incorrect value encountered: !!   variable_name = variable_value`` !---------------------------------------------------------------------! character ( len = * ), intent ( in ) :: name_ !! name of the variable character ( len = * ), intent ( in ) :: value_ !! value of the variable integer ( int32 ), optional , intent ( in ) :: unit_ !! optional, unit where the message will be written !---------------------------------------------------------------------! character ( len = :), allocatable :: add_prefix_ !---------------------------------------------------------------------! add_prefix_ = 'Incorrect value encountered:  ' // trim ( name_ ) // ' = ' // & trim ( value_ ) call write_error ( add_prefix_ , unit_ ) !---------------------------------------------------------------------! end subroutine incorrect_value_ch !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine incorrect_value_int32 ( name_ , value_ , unit_ ) !! ``incorrect value encountered: !!   variable_name = variable_value`` !---------------------------------------------------------------------! character ( len = * ), intent ( in ) :: name_ !! name of the variable integer ( int32 ), intent ( in ) :: value_ !! value of the variable integer ( int32 ), optional , intent ( in ) :: unit_ !! optional, unit where the message will be written !---------------------------------------------------------------------! character ( len = 20 ) :: tmp_ character ( len = :), allocatable :: add_prefix_ !---------------------------------------------------------------------! write ( tmp_ , '(i5)' ) value_ add_prefix_ = 'Incorrect value encountered:  ' // trim ( name_ ) // ' = ' // & trim ( tmp_ ) call write_error ( add_prefix_ , unit_ ) !---------------------------------------------------------------------! end subroutine incorrect_value_int32 !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine incorrect_value_sp ( name_ , value_ , unit_ ) !! ``incorrect value encountered: !!   variable_name = variable_value`` !---------------------------------------------------------------------! character ( len = * ), intent ( in ) :: name_ !! name of the variable real ( sp ), intent ( in ) :: value_ !! value of the variable integer ( int32 ), optional , intent ( in ) :: unit_ !! optional, unit where the message will be written !---------------------------------------------------------------------! character ( len = 16 ), allocatable :: tmp_ character ( len = :), allocatable :: add_prefix_ !---------------------------------------------------------------------! write ( tmp_ , '(e16.8)' ) value_ add_prefix_ = 'Incorrect value encountered:  ' // trim ( name_ ) // ' = ' // & trim ( tmp_ ) call write_error ( add_prefix_ , unit_ ) !---------------------------------------------------------------------! end subroutine incorrect_value_sp !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine incorrect_value_dp ( name_ , value_ , unit_ ) !! ``incorrect value encountered: !!   variable_name = variable_value`` !---------------------------------------------------------------------! character ( len = * ), intent ( in ) :: name_ !! name of the variable real ( dp ), intent ( in ) :: value_ !! value of the variable integer ( int32 ), optional , intent ( in ) :: unit_ !! optional, unit where the message will be written !---------------------------------------------------------------------! character ( len = 16 ), allocatable :: tmp_ character ( len = :), allocatable :: add_prefix_ !---------------------------------------------------------------------! write ( tmp_ , '(e16.8)' ) value_ add_prefix_ = 'Incorrect value encountered:  ' // trim ( name_ ) // ' = ' // & trim ( tmp_ ) call write_error ( add_prefix_ , unit_ ) !---------------------------------------------------------------------! end subroutine incorrect_value_dp !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! function to_lowercase ( str ) result ( low_str ) !! forces lowercase on given string !---------------------------------------------------------------------! character ( len =* ), intent ( in ) :: str !! input string character ( len = len ( str )) :: low_str !! output (lowercase) string !---------------------------------------------------------------------! integer ( int32 ) :: i !---------------------------------------------------------------------! do i = 1 , len ( str ) low_str ( i : i ) = char_to_lowercase ( str ( i : i )) enddo !---------------------------------------------------------------------! end function to_lowercase !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! function char_to_lowercase ( s ) result ( l_s ) !! forces lowercase on a single character !---------------------------------------------------------------------! character ( len = 1 ), intent ( in ) :: s !! input character character ( len = 1 ) :: l_s !! output (lowercase) character !---------------------------------------------------------------------! integer ( int32 ) :: indx !---------------------------------------------------------------------! indx = index ( uppercase , s ) if ( indx > 0 ) then l_s = lowercase ( indx : indx ) else l_s = s endif !---------------------------------------------------------------------! end function char_to_lowercase !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! function integer_to_character ( i ) result ( res ) !! transfers integer to a character !---------------------------------------------------------------------! integer , intent ( in ) :: i !! input integer character ( len = 32 ) :: res !! output character !---------------------------------------------------------------------! write ( res , '(i0)' ) i res = adjustl ( res ) !---------------------------------------------------------------------! end function integer_to_character !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! function float_to_character ( f , format_string ) result ( res ) !! Converts a floating-point number to a character string. !---------------------------------------------------------------------! real ( dp ), intent ( in ) :: f !! input floating-point number character ( len =* ), intent ( in ), optional :: format_string !! Optional format string. character ( len = 64 ) :: res !! Output character string. !---------------------------------------------------------------------! character ( len = 32 ) :: default_format , user_format !---------------------------------------------------------------------! ! Default format: 6 decimal places !---------------------------------------------------------------------! default_format = '(F0.6)' !---------------------------------------------------------------------! if ( present ( format_string )) then user_format = trim ( format_string ) else user_format = default_format endif !---------------------------------------------------------------------! write ( res , user_format ) f res = adjustl ( res ) !---------------------------------------------------------------------! end function float_to_character !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! end module utility_functions_mod","tags":"","loc":"sourcefile/utility_functions_mod.f90.html"},{"title":"channels_mod.f90 – the SCATTERING code","text":"This file depends on sourcefile~~channels_mod.f90~~EfferentGraph sourcefile~channels_mod.f90 channels_mod.f90 sourcefile~input_reader_mod.f90 input_reader_mod.f90 sourcefile~channels_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~utility_functions_mod.f90 utility_functions_mod.f90 sourcefile~channels_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~array_operations_mod.f90 array_operations_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~array_operations_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~channels_mod.f90~~AfferentGraph sourcefile~channels_mod.f90 channels_mod.f90 sourcefile~scattering.f90 scattering.f90 sourcefile~scattering.f90->sourcefile~channels_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules channels_mod Source Code channels_mod.f90 Source Code module channels_mod !! This module provides subroutines that set the number of channels in the !! block, save quantum numbers for each channel (both in body- and space-fixed !! cases) and print quantum numbers on screen !---------------------------------------------------------------------------! use , intrinsic :: iso_fortran_env , only : int32 , sp => real32 , dp => real64 use io_mod use utility_functions_mod , only : write_error , write_message , write_warning , & integer_to_character , float_to_character !---------------------------------------------------------------------------! implicit none !---------------------------------------------------------------------------! private public :: set_number_of_channels , set_body_fixed_channels , & set_space_fixed_channels , count_open_channels_in_block , & calculate_largest_wavenumber , print_channels !---------------------------------------------------------------------------! contains !------------------------------------------------------------------------! subroutine set_number_of_channels ( total_angular_momentum_ , & number_of_channels_even_parity_block , number_of_channels_odd_parity_block ) !! determine the number of scattering channels in each parity block !! for given total angular momentum in both body-fixed and !! space-fixed frames !---------------------------------------------------------------------! !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: total_angular_momentum_ !! total angular momentum integer ( int32 ), intent ( out ) :: number_of_channels_even_parity_block !! number of channels in the p = 1 (even parity) block integer ( int32 ), intent ( out ) :: number_of_channels_odd_parity_block !! number of channels in the p = -1 (odd parity) block !---------------------------------------------------------------------! integer ( int32 ) :: number_of_channels_even_parity_block_sf , & number_of_channels_odd_parity_block_sf !---------------------------------------------------------------------! ! body-fixed frame !---------------------------------------------------------------------! call calculate_number_of_channels_body_fixed ( total_angular_momentum_ , & number_of_channels_even_parity_block , number_of_channels_odd_parity_block ) !---------------------------------------------------------------------! ! space-fixed frame !---------------------------------------------------------------------! call calculate_number_of_channels_space_fixed ( total_angular_momentum_ , & number_of_channels_even_parity_block_sf , number_of_channels_odd_parity_block_sf ) !---------------------------------------------------------------------! ! Check if the number of channels is the same !---------------------------------------------------------------------! call check_number_of_channels ( number_of_channels_even_parity_block , & number_of_channels_even_parity_block_sf , \"even\" ) call check_number_of_channels ( number_of_channels_odd_parity_block , & number_of_channels_odd_parity_block_sf , \"odd\" ) !---------------------------------------------------------------------! end subroutine set_number_of_channels !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine calculate_number_of_channels_body_fixed ( & total_angular_momentum_ , number_of_channels_even_parity_block , & number_of_channels_odd_parity_block ) !! calculate number of channels in even and odd parity !! blocks in the body-fixed frame; !! in principle, \\\\bar{\\Omega}\\in \\langle 0, \\mathrm{min}(j, J)), !! but number of channels additionally depends on the !! sign of \\ p (-1)&#94;{J} \\: channels with !! \\\\bar{\\Omega}=0\\ values enter blocks with !! \\ p (-1)&#94;{J} = + 1 \\ _only_; !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: total_angular_momentum_ !! total angular momentum integer ( int32 ), intent ( inout ) :: number_of_channels_even_parity_block !! number of channels in the p = 1 (even parity) block integer ( int32 ), intent ( inout ) :: number_of_channels_odd_parity_block !! number of channels in the p = -1 (odd parity) block !---------------------------------------------------------------------! integer ( int32 ) :: level_index_ , omega_max_ !---------------------------------------------------------------------! number_of_channels_even_parity_block = 0 number_of_channels_odd_parity_block = 0 do level_index_ = 1 , nlevel omega_max_ = min ( j1array ( level_index_ ), total_angular_momentum_ ) call update_channel_counts_body_fixed ( omega_max_ , total_angular_momentum_ , & number_of_channels_even_parity_block , number_of_channels_odd_parity_block ) end do !---------------------------------------------------------------------! end subroutine calculate_number_of_channels_body_fixed !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine update_channel_counts_body_fixed ( omega_max_ , & total_angular_momentum_ , number_of_channels_even_parity_block , & number_of_channels_odd_parity_block ) !! updates number_of_channels_even and number_of_channels_odd !! in the body-fixed frame for given \\J\\ and \\\\bar{Omega}_{max}\\ !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: omega_max_ !! largest value of \\\\bar{\\Omega}\\, for given !! rotational and total angular momenta integer ( int32 ), intent ( in ) :: total_angular_momentum_ !! total angular momentum integer ( int32 ), intent ( inout ) :: number_of_channels_even_parity_block !! number of channels for the p = 1 block integer ( int32 ), intent ( inout ) :: number_of_channels_odd_parity_block !! number of channels for the p = -1 block !---------------------------------------------------------------------! if ( mod ( total_angular_momentum_ , 2 ) == 0 ) then !------------------------------------------------------------------! ! Even J: channels with Omega = 0 only count in the even parity block !------------------------------------------------------------------! number_of_channels_even_parity_block = number_of_channels_even_parity_block + omega_max_ + 1 number_of_channels_odd_parity_block = number_of_channels_odd_parity_block + omega_max_ else !------------------------------------------------------------------! ! Odd J: channels with Omega = 0 only count in the odd parity block !------------------------------------------------------------------! number_of_channels_odd_parity_block = number_of_channels_odd_parity_block + omega_max_ + 1 number_of_channels_even_parity_block = number_of_channels_even_parity_block + omega_max_ endif !---------------------------------------------------------------------! end subroutine update_channel_counts_body_fixed !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine calculate_number_of_channels_space_fixed ( & total_angular_momentum_ , number_of_channels_even_parity_block , & number_of_channels_odd_parity_block ) !! calculate number of channels in even and odd parity !! blocks in the space-fixed frame based on available !! values of orbital angular momentum: !! \\ l \\in \\langle |j-J|, j+J \\rangle \\; !! parity is defined as \\p= (-1)&#94;{j+l}\\ !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: total_angular_momentum_ !! total angular momentum integer ( int32 ), intent ( inout ) :: number_of_channels_even_parity_block !! number of channels in the p = 1 (even parity) block integer ( int32 ), intent ( inout ) :: number_of_channels_odd_parity_block !! number of channels in the p = -1 (odd parity) block !---------------------------------------------------------------------! integer ( int32 ) :: level_index_ , l_min_ , l_max_ !---------------------------------------------------------------------! number_of_channels_even_parity_block = 0 number_of_channels_odd_parity_block = 0 do level_index_ = 1 , nlevel l_min_ = abs ( total_angular_momentum_ - j1array ( level_index_ )) l_max_ = total_angular_momentum_ + j1array ( level_index_ ) call update_channel_counts_space_fixed ( l_min_ , l_max_ , level_index_ , & number_of_channels_even_parity_block , number_of_channels_odd_parity_block ) end do !---------------------------------------------------------------------! end subroutine calculate_number_of_channels_space_fixed !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine update_channel_counts_space_fixed ( l_min_ , l_max_ , level_index_ , & number_of_channels_even_parity_block , number_of_channels_odd_parity_block ) !! updates number_of_channels_even and number_of_channels_odd !! in the space-fixed frame for given !! range of orbital angular momentum !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: l_min_ !! smallest value of \\ l = |j-J|\\ integer ( int32 ), intent ( in ) :: l_max_ !! largest value of \\ l = j+J\\ integer ( int32 ), intent ( in ) :: level_index_ !! index pointing to speceific \\j\\ value in j1array integer ( int32 ), intent ( inout ) :: number_of_channels_even_parity_block !! number of channels for the p = 1 block integer ( int32 ), intent ( inout ) :: number_of_channels_odd_parity_block !! number of channels for the p = -1 block !---------------------------------------------------------------------! integer ( int32 ) :: l_ !---------------------------------------------------------------------! do l_ = l_min_ , l_max_ if ( mod ( j1array ( level_index_ ) + l_ , 2 ) == 0 ) then number_of_channels_even_parity_block = & number_of_channels_even_parity_block + 1 else number_of_channels_odd_parity_block = & number_of_channels_odd_parity_block + 1 endif end do !---------------------------------------------------------------------! end subroutine update_channel_counts_space_fixed !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine check_number_of_channels ( number_of_channels_bf , & number_of_channels_sf , parity_block ) !! check if the number of channels is the same in body-fixed !! and space-fixed frames !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: number_of_channels_bf !! number of channels in the body-fixed frame integer ( int32 ), intent ( in ) :: number_of_channels_sf !! number of channels in the space-fixed frame character ( len =* ), intent ( in ) :: parity_block !! \"even\" or \"odd\", for printing purposes !---------------------------------------------------------------------! if ( number_of_channels_bf /= number_of_channels_sf ) then call write_error ( \"Different number of channels in \" // parity_block & // \" block (BF = \" // trim ( adjustl ( integer_to_character ( number_of_channels_bf ))) & // \", SF = \" // trim ( adjustl ( integer_to_character ( number_of_channels_sf ))) & // \"); check set_number_of_channels\" ) endif end subroutine check_number_of_channels !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine set_body_fixed_channels ( total_angular_momentum_ , & parity_exponent_ , channels_level_indices , channels_omega_values ) !! Prepares the channels_level_indices array which holds indices that refer to the !! basis arrays: v1level/j1level/elevel, and channels_omega_values which holds values !! of \\bar{\\Omega} !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: total_angular_momentum_ !! total angular momentum integer ( int32 ), intent ( in ) :: parity_exponent_ !! parity exponent of the block (0 if p = +1, 1 if p = -1) integer ( int32 ), intent ( inout ) :: channels_level_indices (:) !! holds the indices pointing to the basis arrays integer ( int32 ), intent ( inout ) :: channels_omega_values (:) !! holds all values of \\bar{\\Omega} !---------------------------------------------------------------------! integer ( int32 ) :: level_index_ , channel_index_ , omega_max_ , parity_term_exponent_ !---------------------------------------------------------------------! ! due to construction of body-fixed basis states: ! |v j \\bar{\\Omega} J p > = N (|v j \\bar{\\Omega} J > !                         + p (-1)&#94;{J} |v j -\\bar{\\Omega} J > ) ! we are interested in the exponent of the \"p (-1)&#94;{J}\" term !---------------------------------------------------------------------! parity_term_exponent_ = mod ( parity_exponent_ + total_angular_momentum_ , 2 ) !---------------------------------------------------------------------! channel_index_ = 0 !---------------------------------------------------------------------! do level_index_ = 1 , nlevel omega_max_ = min ( j1array ( level_index_ ), total_angular_momentum_ ) call update_body_fixed_channels_info ( omega_max_ , parity_term_exponent_ , & level_index_ , channel_index_ , channels_level_indices , channels_omega_values ) enddo !---------------------------------------------------------------------! end subroutine set_body_fixed_channels !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine update_body_fixed_channels_info ( omega_max_ , parity_term_exponent_ , & level_index_ , channel_index_ , channels_level_indices , channels_omega_values ) !! update channels_level_indices array which holds indices within the !! loop over level_index_ in set_body_fixed_channels !---------------------------------------------------------------------! integer ( int32 ) :: omega_max_ !! largest value of \\\\bar{\\Omega}\\, for given !! rotational and total angular momenta integer ( int32 ) :: parity_term_exponent_ !! exponent of the \\p (-1)&#94;{J}\\ term integer ( int32 ) :: level_index_ !! indices pointing to the basis arrays integer ( int32 ), intent ( inout ) :: channel_index_ !! index pointing to the current value in channels_level_indices !! and channels_omega_values; incremented in this subroutine integer ( int32 ), intent ( inout ) :: channels_level_indices (:) !! holds the indices pointing to the basis arrays integer ( int32 ), intent ( inout ) :: channels_omega_values (:) !! holds all values of \\bar{\\Omega} !---------------------------------------------------------------------! integer ( int32 ) :: omega_ , omega_start_ !---------------------------------------------------------------------! ! if p (-1)&#94;{J} = 1, \\bar{\\Omega} states enter the basis ! otherwise, \\bar{\\Omega} > 0; to avoid redundancy, we handle this ! with omega_start_ which is 0 if parity_term_exponent_ is 0, ! otherwise 1 !---------------------------------------------------------------------! omega_start_ = parity_term_exponent_ !---------------------------------------------------------------------! do omega_ = omega_start_ , omega_max_ channel_index_ = channel_index_ + 1 if ( channel_index_ > size ( channels_level_indices )) then call write_error ( \"channel_index_ out of bounds of \" // & \"channels_level_indices in set_body_fixed_channels.\" ) end if channels_omega_values ( channel_index_ ) = omega_ channels_level_indices ( channel_index_ ) = level_index_ enddo !---------------------------------------------------------------------! end subroutine update_body_fixed_channels_info !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine set_space_fixed_channels ( total_angular_momentum_ , & parity_exponent_ , channels_l_values ) !! Prepares the channels_l_values array which holds values of !! orbital angular momentum, \\l\\, a space-fixed-frame quantum number. !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: total_angular_momentum_ !! total angular momentum integer ( int32 ), intent ( in ) :: parity_exponent_ !! parity exponent of the block (0 if p = +1, 1 if p = -1) integer ( int32 ), intent ( inout ) :: channels_l_values (:) !! holds all values of l !---------------------------------------------------------------------! integer :: level_index_ , l_min_ , l_max_ , l_ , channel_index_ !---------------------------------------------------------------------! channel_index_ = 0 do level_index_ = 1 , nlevel l_min_ = abs ( total_angular_momentum_ - j1array ( level_index_ )) l_max_ = total_angular_momentum_ + j1array ( level_index_ ) do l_ = l_min_ , l_max_ if ( mod ( l_ + j1array ( level_index_ ), 2 ) == parity_exponent_ ) then channel_index_ = channel_index_ + 1 if ( channel_index_ > size ( channels_l_values )) then call write_error ( \"channel_index_ out of bounds of \" // & \"channels_l_values in set_space_fixed_channels.\" ) end if channels_l_values ( channel_index_ ) = l_ endif enddo enddo !---------------------------------------------------------------------! end subroutine set_space_fixed_channels !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! function count_open_channels_in_block ( channels_level_indices ) & result ( number_of_open_channels_ ) !! counts the energetically accessible channels in the given block !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: channels_level_indices (:) !! holds the indices pointing to the basis arrays integer ( int32 ) :: number_of_open_channels_ !! (output) number of open channels !---------------------------------------------------------------------! integer ( int32 ) :: channel_index_ !---------------------------------------------------------------------! number_of_open_channels_ = 0 do channel_index_ = 1 , size ( channels_level_indices ) if ( is_open ( elevel ( channels_level_indices ( channel_index_ )))) then number_of_open_channels_ = number_of_open_channels_ + 1 endif enddo !---------------------------------------------------------------------! end function count_open_channels_in_block !------------------------------------------------------------------------! !------------------------------------------------------------------------! function calculate_largest_wavenumber ( channels_level_indices ) result ( largest_wavenumber_ ) !! Calculates the largest wave number in the block; !! called only if there are any open channels !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: channels_level_indices (:) !! holds the indices pointing to the basis arrays real ( dp ) :: largest_wavenumber_ !! (output) the largest wave number (wavmax) in the block !---------------------------------------------------------------------! integer ( int32 ) :: channel_index_ real ( dp ) :: wavenumber_ !---------------------------------------------------------------------! wavenumber_ = 0.0_dp !---------------------------------------------------------------------! do channel_index_ = 1 , size ( channels_level_indices ) if ( is_open ( elevel ( channels_level_indices ( channel_index_ )))) then wavenumber_ = wavenumber_from_energy ( elevel ( channels_level_indices ( channel_index_ ))) largest_wavenumber_ = max ( largest_wavenumber_ , wavenumber_ ) endif enddo !---------------------------------------------------------------------! end function calculate_largest_wavenumber !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine print_channels ( parity_exponent_ , channels_level_indices , & channels_omega_values ) !! prints information about body-fixed channels on screen !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: parity_exponent_ !! parity exponent of the block (0 if p = +1, 1 if p = -1) integer ( int32 ), intent ( inout ) :: channels_level_indices (:) !! holds the indices pointing to the basis arrays integer ( int32 ), intent ( inout ) :: channels_omega_values (:) !! holds all values of \\bar{\\Omega} !---------------------------------------------------------------------! integer ( int32 ) :: channel_index_ , v_ , j_ , omega_ , parity_ real ( dp ) :: internal_energy_ , wavenumber_ !---------------------------------------------------------------------! call write_message ( \"  v1      j1     omega      p\" // repeat ( \" \" , 10 ) & // \"E_vj\" // repeat ( \" \" , 16 ) // \"wv\" ) !---------------------------------------------------------------------! do channel_index_ = 1 , size ( channels_level_indices ) v_ = v1array ( channels_level_indices ( channel_index_ )) j_ = j1array ( channels_level_indices ( channel_index_ )) omega_ = channels_omega_values ( channel_index_ ) parity_ = ( - 1 ) ** parity_exponent_ internal_energy_ = elevel ( channels_level_indices ( channel_index_ )) !------------------------------------------------------------------! ! format for open channels: !------------------------------------------------------------------! if ( is_open ( internal_energy_ )) then wavenumber_ = wavenumber_from_energy ( internal_energy_ ) call write_channel_line ( v_ , j_ , omega_ , parity_ , & internal_energy_ , wavenumber_ ) !------------------------------------------------------------------! ! format for closed channels: !------------------------------------------------------------------! else call write_channel_line ( v_ , j_ , omega_ , parity_ , internal_energy_ ) endif !------------------------------------------------------------------! enddo !---------------------------------------------------------------------! end subroutine print_channels !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine write_channel_line ( v_ , j_ , omega_ , parity_ , internal_energy_ , & wavenumber_ ) ! Subroutine arguments integer ( int32 ), intent ( in ) :: v_ !! vibrational quantum number integer ( int32 ), intent ( in ) :: j_ !! rotational quantum number integer ( int32 ), intent ( in ) :: omega_ !! \\\\bar{\\Omega}\\ integer ( int32 ), intent ( in ) :: parity_ !! parity of the block real ( dp ), intent ( in ) :: internal_energy_ !! \\E_{vj}\\ real ( dp ), intent ( in ), optional :: wavenumber_ !! (optional) if the channel is open, print information !! about the wavenumber !---------------------------------------------------------------------! character ( len = 200 ) :: line_ !---------------------------------------------------------------------! ! Check if wavenumber is provided !---------------------------------------------------------------------! if ( present ( wavenumber_ )) then write ( line_ , \"(I4,4X,I4,6X,I4,5X,I2,2X,F12.4,4X,F14.8)\" ) & v_ , j_ , omega_ , parity_ , internal_energy_ * hartreetocm , & wavenumber_ / bohrtoangstrom else write ( line_ , \"(I4,4X,I4,6X,I4,5X,I2,2X,F12.4,4X,'--------------')\" )& v_ , j_ , omega_ , parity_ , internal_energy_ * hartreetocm endif !---------------------------------------------------------------------! ! Print the formatted line !---------------------------------------------------------------------! call write_message ( line_ ) !---------------------------------------------------------------------! end subroutine write_channel_line !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! end module channels_mod","tags":"","loc":"sourcefile/channels_mod.f90.html"},{"title":"array_operations_allocate_submod.f90 – the SCATTERING code","text":"This file depends on sourcefile~~array_operations_allocate_submod.f90~~EfferentGraph sourcefile~array_operations_allocate_submod.f90 array_operations_allocate_submod.f90 sourcefile~array_operations_mod.f90 array_operations_mod.f90 sourcefile~array_operations_allocate_submod.f90->sourcefile~array_operations_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules array_operations_allocate_submod Source Code array_operations_allocate_submod.f90 Source Code submodule ( array_operations_mod ) array_operations_allocate_submod !! a submodule for allocate subroutines implicit none contains !------------------------------------------------------------------------! pure module subroutine allocate_1d_int32 ( array_ , size_ ) !! allocate a 1d array and fill it with 0s (intger version) integer ( int32 ), allocatable , intent ( inout ) :: array_ (:) integer ( int32 ), intent ( in ) :: size_ !---------------------------------------------------------------------! if ( allocated ( array_ )) deallocate ( array_ ) allocate ( array_ ( size_ )) array_ = 0 !---------------------------------------------------------------------! end subroutine allocate_1d_int32 !------------------------------------------------------------------------! pure module subroutine allocate_1d_sp ( array_ , size_ ) !! allocate a 1d array and fill it with 0s (single precision version) real ( sp ), allocatable , intent ( inout ) :: array_ (:) integer ( int32 ), intent ( in ) :: size_ !---------------------------------------------------------------------! if ( allocated ( array_ )) deallocate ( array_ ) allocate ( array_ ( size_ )) array_ = 0 !---------------------------------------------------------------------! end subroutine allocate_1d_sp !------------------------------------------------------------------------! pure module subroutine allocate_1d_dp ( array_ , size_ ) !! allocate a 1d array and fill it with 0s (double precision version) real ( dp ), allocatable , intent ( inout ) :: array_ (:) integer ( int32 ), intent ( in ) :: size_ !---------------------------------------------------------------------! if ( allocated ( array_ )) deallocate ( array_ ) allocate ( array_ ( size_ )) array_ = 0 !---------------------------------------------------------------------! end subroutine allocate_1d_dp !------------------------------------------------------------------------! !------------------------------------------------------------------------! pure module subroutine allocate_2d_int32 ( array_ , size1_ , size2_ ) !! allocate a 2d array and fill it with 0s (intger version) integer ( int32 ), allocatable , intent ( inout ) :: array_ (:,:) integer ( int32 ), intent ( in ) :: size1_ , size2_ !---------------------------------------------------------------------! if ( allocated ( array_ )) deallocate ( array_ ) allocate ( array_ ( size1_ , size2_ )) array_ = 0 !---------------------------------------------------------------------! end subroutine allocate_2d_int32 !------------------------------------------------------------------------! pure module subroutine allocate_2d_sp ( array_ , size1_ , size2_ ) !! allocate a 2d array and fill it with 0s (single precision version) real ( sp ), allocatable , intent ( inout ) :: array_ (:,:) integer ( int32 ), intent ( in ) :: size1_ , size2_ !---------------------------------------------------------------------! if ( allocated ( array_ )) deallocate ( array_ ) allocate ( array_ ( size1_ , size2_ )) array_ = 0 !---------------------------------------------------------------------! end subroutine allocate_2d_sp !------------------------------------------------------------------------! pure module subroutine allocate_2d_dp ( array_ , size1_ , size2_ ) !! allocate a 2d array and fill it with 0s (double precision version) real ( dp ), allocatable , intent ( inout ) :: array_ (:,:) integer ( int32 ), intent ( in ) :: size1_ , size2_ !---------------------------------------------------------------------! if ( allocated ( array_ )) deallocate ( array_ ) allocate ( array_ ( size1_ , size2_ )) array_ = 0 !---------------------------------------------------------------------! end subroutine allocate_2d_dp !------------------------------------------------------------------------! !------------------------------------------------------------------------! pure module subroutine allocate_3d_int32 ( array_ , size1_ , size2_ , size3_ ) !! allocate a 3d array and fill it with 0s (intger version) integer ( int32 ), allocatable , intent ( inout ) :: array_ (:,:,:) integer ( int32 ), intent ( in ) :: size1_ , size2_ , size3_ !---------------------------------------------------------------------! if ( allocated ( array_ )) deallocate ( array_ ) allocate ( array_ ( size1_ , size2_ , size3_ )) array_ = 0 !---------------------------------------------------------------------! end subroutine allocate_3d_int32 !------------------------------------------------------------------------! pure module subroutine allocate_3d_sp ( array_ , size1_ , size2_ , size3_ ) !! allocate a 3d array and fill it with 0s (single precision version) real ( sp ), allocatable , intent ( inout ) :: array_ (:,:,:) integer ( int32 ), intent ( in ) :: size1_ , size2_ , size3_ !---------------------------------------------------------------------! if ( allocated ( array_ )) deallocate ( array_ ) allocate ( array_ ( size1_ , size2_ , size3_ )) array_ = 0 !---------------------------------------------------------------------! end subroutine allocate_3d_sp !------------------------------------------------------------------------! pure module subroutine allocate_3d_dp ( array_ , size1_ , size2_ , size3_ ) !! allocate a 3d array and fill it with 0s (double precision version) real ( dp ), allocatable , intent ( inout ) :: array_ (:,:,:) integer ( int32 ), intent ( in ) :: size1_ , size2_ , size3_ !---------------------------------------------------------------------! if ( allocated ( array_ )) deallocate ( array_ ) allocate ( array_ ( size1_ , size2_ , size3_ )) array_ = 0 !---------------------------------------------------------------------! end subroutine allocate_3d_dp !------------------------------------------------------------------------! !------------------------------------------------------------------------! end submodule array_operations_allocate_submod","tags":"","loc":"sourcefile/array_operations_allocate_submod.f90.html"},{"title":"Program Description – the SCATTERING code","text":"The purpose of the SCATTERING code is to solve the coupled equations for a given scattering system, provide the\nscattering S-matrix elements, and calculate the state-to-state cross-sections. Contrary to other publically available codes, such as MOLSCAT ,\nor Hibridon , the SCATTERING code solves coupled equations in the body-fixed (BF) frame,\nwhere the coupling matrix exhibits a predominantly block-diagonal structure with blocks interconnected by centrifugal terms.\nThis significantly reduces computational time and memory requirements. The theory of non-reactive scattering in systems with arbitrary angular momenta in the BF frame was developed Launay ,\nand was recently recalled in the context of scattering calculations for He-perturbed shape of HD\nrovibrational resonances (see Stankiewicz et al ) and O 2 -perturbed resonances of HCl \n(see Olejnik et al ). We briefly summarize it in the Theoretical Background section. Structure of the code The user controls the code through the input file and by supplying properly-formatted radial coupling terms. \nThe input file is interpreted by io_mod module and the radial coupling terms are \nread and interpolated by subroutines kept in potential module. scattering is the central program. After reading the input file and radial coupling terms, \nit performs a loop over the total angular momentum and parity. For each iteration, the main program determines all expansion coefficients\n g_{\\boldsymbol{\\lambda},\\gamma,\\gamma'}&#94;{Jp}  (see Eq. (3) in the Coupling Matrix section).\nIn the next step, the propagation of the log-derivative matrix takes place through numerov that are kept in propagator_mod.f90 .\nThe resulting BF-log-derivative matrix is transformed to the SF-system using subroutines from boundary_conditions_mod module\nwhich also involves procedures that determine the scattering S-matrix (see Solution of the coupled equations section).\nThe main part of the code calls for the partial state-to-state cross sections calculated \nby subroutines kept in statetostateXS . The results are written to the S-matrix file (see S-matrix file ). The output file contains the information about each  J - and  p -labeled block and, if needed, provides the accumulated state-to-state cross sections .","tags":"","loc":"page/index.html"},{"title":"Theoretical background – the SCATTERING code","text":"The theory of non-reactive scattering in systems with arbitrary angular momenta in the BF frame was developed Launay ,\nand was recently recalled in the context of scattering calculations for He-perturbed shape of HD\nrovibrational resonances (see Stankiewicz et al ) and O 2 -perturbed resonances of HCl \n(see Olejnik et al ). We briefly summarize it in this section: What are coupled equations? Coupling Matrix Solutions of the coupled equations State-to-state cross-sections","tags":"","loc":"page/background/index.html"},{"title":"What are coupled equations? – the SCATTERING code","text":"In quantum scattering, coupled equations are sets of differential equations that describe \ndynamics of colliding molecules and/or atoms under the influence of the interaction potential. \nThese equations are \"coupled\" because the solution for one equation depends on the solutions of the others. \nIn the context of diatom-atom collisions, these equations account for rotational and vibrational states of the diatom and the relative motion of the colliding partners. Coupled equations are derived from time-independent Schrodinger equation, by expanding the scattering wave function\nin the chosen basis,  |\\gamma \\rangle  which leads to a set of coupled differential equations on the\nexpansion coefficients,  f_{\\gamma} (R) . The basis states  |\\gamma \\rangle  define the collision channels.\nIn the total angular momentum ( J ) representation, the coupled equations are block-diagonal with respect\nto total angular momentum and parity: Here,  W  is the coupling matrix which involves the contribution from the atom - molecule interaction energy,  {V}&#94;{Jp}_{\\gamma, \\gamma'}(R) ,\nrelative motion of atom with respect to the molecule, quantified by the square relative angular momentum operator,  \\mathbf{L}&#94;{2\\,Jp}_{\\gamma, \\gamma'}  , \nand relatvie kinetic energy of the colliding pair, expressed using wavevector,  k_{\\gamma} = \\sqrt{2\\mu(E - E_{\\mathrm{mol}})} .\n \\mu   is the reduced mass of the atom - molecule system,  E  is the total energy and  E_{\\mathrm{mol}}  is the internal (rovibrational)\nenergy of the molecule. For diatom ( &#94;{1}\\Sigma ) - atom ( &#94;{1}S ) scattering in the BF frame, collision channels are defined through \nvibrational and rotational quantum numbers of the molecule,  v  and  j , \nand the absolute value of the projection of the rotational angular momentum of the molecule (and the total angular momentum)\non the intermolecular axis,  \\bar{\\Omega} . Note In this section,  \\gamma  is a shorthand notation for a set of quantum numbers, \n \\gamma = v, j, \\bar{\\Omega}, J .","tags":"","loc":"page/background/coupled_equations.html"},{"title":"Coupling Matrix – the SCATTERING code","text":"Coupling matrix In order to construct the coupling matrix, we need the explicit form of matrix elements of  {W}&#94;{Jp}_{\\gamma, \\gamma'}(R) . Matrix elements of the interaction potential are given as Here,  v_{\\boldsymbol{\\lambda},\\gamma,\\gamma'} (R)  denotes the radial coupling terms of the potential energy surface: i.e. the 3D molecule - atom PES,  V(R, r, \\theta) , averaged over Legendre polynomials,  P_{\\lambda} (\\cos\\theta), \nand rovibrational wave functions of the isolated molecule,   \\chi_{\\eta}(r) , where  \\eta = v, j.\nNote that they are independent of  J  and  p . Note Radial coupling terms are calculated separately and provided to the SCATTERING code in a tabulated form: they are read\nin by the potential_read procedure and interpolated (see also Supplying radial coupling terms )\nby potential_interpolation . These subroutines are placed in the potential_mod module. Interpolated radial coupling terms at aritrary  R  are provided by the radtermvalue procedure from the propagators module.  g_{{\\lambda},\\gamma,\\gamma'}&#94;{Jp}  are the algebraic coefficients of the expansion which stem from matrix elements of Legendre polynomials, \n P_{\\lambda} (\\cos\\theta)  in the  \\gamma  basis. They are given as where quantities in brackets are the 3-j symbols. Note The SCATTERING code uses 3-j symbols calculated by the wigxjpf library H. T. Johansson and C. Forssén, Fast and Accurate Evaluation of Wigner 3j, 6j, and 9j Symbols Using Prime Factorization and Multiword Integer Arithmetic, SIAM J. Sci. Comput., 38(1) (2016), A376-A384. See eprint or Pre-print (2015) Algebraic coefficients are R-independent and are calculated only once per each block. \nNote that they are block-diagonal with respect to \\bar{\\Omega}. Note Calculation of  g_{{\\lambda},\\gamma,\\gamma'}&#94;{Jp}  algebraic coefficients is handled \nby the check_nonzero_coupling_matrix_elements and prepare_coupling_matrix_elements procedures from the algebraic_coefficients module. Procedure check_nonzero_coupling_matrix_elements first checks how many\nmatrix elements fulfill the  \\delta_{\\bar{\\Omega},\\bar{\\Omega}'}  condition - this is saved in the number_of_nonzero_coupling_matrix_elements variable.\nOn top of that, for each non-zero matrix element, the number of non-zero terms in the sum over \\lambda\nis checked and saved in number_of_nonzero_coupling_coefficients variable.\nThe coefficients are calculated with prepare_coupling_matrix_elements procedure and saved\nin the nonzero_coupling_coefficients variable.\nThe corresponding  \\lambda  indices are written indirectly in nonzero_legendre_indices array\nwhich holds indices to l1tab . Note The total contribution from the interaction potential, Eq. \\eqref{eq:pes_contribution}, is determined by pes_contribution procedure from propagators module. The centrifugal term,  \\mathbf{L}&#94;{2\\,Jp}_{\\gamma, \\gamma'} , is block-diagonal with respect to the rotational quantum number  j .\nTerms diagonal with respect to  \\bar{\\Omega}  are given as The centrifugal term additionally introduces couplings with  \\bar{\\Omega}  and  \\bar{\\Omega}' = \\bar{\\Omega} \\pm 1  blocks Note Matrix elements,  \\mathbf{L}&#94;{2\\,Jp}_{\\gamma, \\gamma'} , are calculated by the centrifugal_matrix subroutine from the propagators module.\nThese are called only once per block, at the begining of the numerov procedure.","tags":"","loc":"page/background/coupling_matrix.html"},{"title":"Solution of the coupled equations – the SCATTERING code","text":"Solution of the coupled equations Coupled equations are solved numerically. The SCATTERING code uses renormalized Numerov's algorithm (see Johnson )\nto propagate the log-derivative of  {f}&#94;{Jp}_{\\gamma} (R): Note Renormalized Numerov's algorithm is implemented in numerov procedure in propagators module. At the last point of propagation,  R_{max} , the log-derivative matrix is transformed to the space-fixed (SF) frame using the following transformation where the coefficients of the transformation are given as Note The transformation between arbitrary BF and SF matrices is implemented in boundary_conditions_mod : Eq. \\eqref{eq:BF-SF-transform} is implemented in calculate_sf_matrix_from_bf_matrix and calculate_single_sf_element subroutines, while Eq. \\eqref{eq:p-coeff} is handled by the p_coeff function. In the next step, the SF log-derivative matrix is then transformed to the reactance K-matrix through the following equation Here,   {J}  and  {N}  are diagonal matrices with elements depending on whether the corresponding \n \\gamma  level is energetically accessible ( E - E_{\\gamma} \\geq 0  ) or inaccessible (  E-E_{\\gamma} < 0 ).\nThese two cases are referred to as open and closed channels, respectively.\nFor the open channels, the  {J}  and  {N}  matrices take the following form: where  S_{l}(k_{\\gamma}R)  and  C_{l}(k_{\\gamma}R)  are Riccati-Bessel functions of the first and second kind, respectively. For the closed channels: with  I_{l+\\frac{1}{2}}(k_{\\gamma} R)  and  K_{l+\\frac{1}{2}}(k_{\\gamma} R)  being the modified Bessel functions of the first and second kind.\nPrimes in the formula for the reactance matrix denote derivatives of the Bessel functions. Note The SCATTERING code uses Riccati-Bessel and modified Bessel functions calculated by the special_functions library Shanjie Zhang, Jianming Jin, Computation of Special Functions, Wiley, 1996, ISBN: 0-471-11963-6, LC: QA351.C45. The  {K}&#94;{Jp}  matrix takes the block form: where  {K}_{oo} ,  {K}_{oc} ,  {K}_{co}  and  {K}_{cc}  are open-open, open-closed,\n closed-open and closed-closed submatrices of  {K}&#94;{Jp} . It can be shown (see Johnson ),\nthat the open-open part of the  reactance matrix is not changed upon the following replacement: This allows to avoid computational problems with modified Bessel functions. The same transformation is applied for the  {N}  and  {N}'  matrices. Note This part of calculations, starting from Eq. \\eqref{eq:log-der-to-K},\nis handled by the calculate_k_matrix subroutine in the boundary_conditions_mod module. Finally, the scattering S-matrix  {S}&#94;{Jp}  is obtained from the open-open portion of  {K}&#94;{Jp}  Note Eq. \\eqref{eq:K-to-S} is implemented in the calculate_s_matrix procedure in the boundary_conditions_mod module. The S-matrices are saved to external, binary file, in a manner similar to the one used by MOLSCAT (see S-matrix file ). Every time the S-matrix is determined, the code checks if the unitary condition is fulfilled If this condition is not fulfilled for several $J,p$ blocks, the code lists these blocks at the end of the output file\nand suggests to increase the steps parameter or to reduce the dr value. Note Eq. \\eqref{eq:sunitarity} is implemented in the unitarity_check procedure in the unitarity_check_mod module.","tags":"","loc":"page/background/solution.html"},{"title":"Cross-sections – the SCATTERING code","text":"Cross-sections Apart from S-matrices, the SCATTERING code calculates the state-to-state cross-sections: Note Cross-sections calculations take place within the statetostateXS module, in the calculate_sts_xs procedure.","tags":"","loc":"page/background/cross_sections.html"},{"title":"Input file – the SCATTERING code","text":"Input file Note The input file is read at the beginning of the calculations by subroutine read_input_file from the io_mod module. This subroutine uses namelist method of reading input files into the source code. Each input file should consist of three groups: INPUT, BASIS and POTENTIAL.\nNote that the names of the groups correspond to the ones used by MOLSCAT. The INPUT group defines the most important information about each run: label (character) - 80-character string describing the code run. reducedmass (double precision) - value of the reduced mass of the collisional system, in atomic mass units. ietoterel (integer) - can only take two values: ietoterel = 0 (default), energy is interpreted as the total energy of the colliding system; initial is ignored, ietoterel = 1, energy is interpreted as the relative kinetic energy, calculated with respect to the initial level in the basis. energy (double precision) - its interpretation depends on ietoterel . initial (integer) - see ietoterel . jtotmin , jtotmax , jtotstep (integers) - the calculations are performed from\n  J_{min} =  jtotmin to   J_{max} =  jtotmax with  \\Delta J =  jtotstep .\n  If jtotmax = -1, calculations are performed until ncac consecutive values of total angular momentum contribute less than dtol to the elastic state-to-state cross sections, and less than otol to the inelastic state-to-state cross sections. rmin , rmax (double precision) - the propagation is performed from  R_{min} =  rmin to\n R_{max} =  rmax . Note that there are no subroutines responsible for the extrapolation of the radial terms implemented in the code. dr (double precision) - if positive, it corresponds to the step of the propagator (in  a_{0}  ). steps (integer) - number of steps per half-wavelength of de Broglie's wavefunction of the system (see Sec.~\\ref{sec:Scattering-Details-Scattering}). vdepth (double precision, 0 by default) - the user is advised to specify the absolute value of the depth of the potential energy surface, \nwhich is included in the determination of the step size of the propagator (see Sec.~\\ref{sec:Scattering-Details-Scattering}). ncac (integer), dtol , otol (double precision), see ( jtotmin , jtotmax and jtotstep ). nlevel (integer) - number of levels in the basis set. nr (integer) - number of the grid points for the radial coupling terms in the potential expansion. nterms (integer) - number of  \\lambda  terms in the potential expansion, see Eq. (3) in Coupling Matrix section. totalcol (integer) - determines the total number of columns containing the radial coupling terms (see Supplying radial coupling terms ). n_skip_lines (integer) - number of lines at the beginning of the radial coupling terms file, which will be ignored while reading (see Supplying radial coupling terms ). iunits (integer) - if the  R  grid in the radial coupling terms file is given in atomic units (  a_{0}  ), choose iunits =0.\n If the radial distance is given in \\AA, put iunits = 1. potentialfile (character, RadialTerms.dat by default) - the name of the file with the radial coupling terms. smatrixfile (character, SmatrixFile.dat by default) - the name of the s-matrix file. ipart (integer) - if partial cross sections (for each parity block, within each $J$-block) are needed, put ipart = 1. Otherwise, put ipart = 0. partialfile (character, PartialFile.dat by default) - the name of the file with partial cross sections. prntlvl (integer, 2 by default): prntlvl = 0, basic information about a run, prntlvl = 1, information about each block is printed on screen, prntlvl = 2, information about the calculation time of some of the important parts of the code is printed, prntlvl = 3, accumulated state-to-state cross sections are printed on screen after each total angular momentum block, prntlvl  >  4, S-matrices are printed on screen. BASIS group specifies the vibrational and rotational quantum numbers of colliding molecules and the energy levels of rovibrational states v1array (integer array of nlevel size) - keeps values of the vibrational ( v ) quantum numbers that describe the levels of a diatomic molecule. j1array (integer array of nlevel size) - keeps values of the rotational ( j ) quantum numbers that describe the levels of a diatomic molecule. elevel (double precision array of nlevel size) - keeps energies of the rovibrational levels of a diatomic molecule, in cm &#94;{-1} . POTENTIAL group describes the quantum numbers of the radial coupling terms,  v_{\\boldsymbol{\\lambda},\\gamma,\\gamma'} (R) , see Eq. (3) in Coupling Matrix section.\nThis group of variables involves: l1tab (integer array of nterms size) - keeps values of  \\lambda  indices, describing the radial terms of the potential. v1pes , j1pes , v1ppes , j1ppes (integer arrays of totalcol size) keep values of  v, j, v', j'  indices of the radial coupling terms of the potential.","tags":"","loc":"page/inputfile.html"},{"title":"Installation – the SCATTERING code","text":"Prerequisites Make. A modern Fortran compiler, such as GNU Fortran Compiler (gfortran) or Intel Fortran Compiler (ifort) LAPACK and BLAS libraries Git (optional) wget the SCATTERING code uses the wigxjpf and special_functions libraries. These are downloaded and installed along with the rest of the code. Get the source code Using git git clone https://github.com/hjozwiak-umk/bigos_h2he.git ./bigos_dir This will create a directory ./bigos_dir on the local machine. Enter this directory. Without git Download the source code as a zip file: bigos.zip Extract the contents to ./bigos_dir and enter this directory. Build the code Ubuntu Windows 11","tags":"","loc":"page/installation/index.html"},{"title":"Ubuntu – the SCATTERING code","text":"Before building the code, make sure that we have all the necessary compilers, librariries and apps installed : sudo apt install make gfortran liblapack-dev libblas-dev wget git Enter ./bigos_dir Run make all . Note The script will download and extract the wigxjpf library in ./libs directory, and then build and compile the contents of ./src directory. The executable, scattering.x , is located in the main directory. You can now run make test to make sure that you recover reference outputs in the ref/ directory.","tags":"","loc":"page/installation/ubuntu.html"},{"title":"Windows 11 – the SCATTERING code","text":"Before building the code, make sure that we have all the necessary compilers, librariries and apps installed : Here, we provide a step-by-step instruction for installation of the necessary packages using Cygwin . Download the Cygwin installer from the official website Launch Cygwin setup. Choose \"Install from Internet\". Set up a Root directory. Set up a local package directory. Choose \"Use System Proxy Settings\". Choose A Download Site. After a while, a new \"Select Packages\" window appears. Navigate to \"Full\" list in the upper right corner: Locate necessery packages: make , gcc-fortran , liblapack-devel , libopenblas , git , wget and unzip . Choose the most recent version. Proceed with the installation and close the Setup window. Launch Cygwin Terminal Clone the repository from git git clone https://github.com/hjozwiak-umk/bigos_h2he.git ./bigos_dir Enter ./bigos_dir Run make all . Note The script will download and extract the wigxjpf library in ./libs directory, and then build and compile the contents of ./src directory. The executable, scattering.x , is located in the main directory. You can now run make test to make sure that you recover reference outputs in the ref/ directory.","tags":"","loc":"page/installation/windows11.html"},{"title":"Supplying radial terms – the SCATTERING code","text":"Supplying the radial coupling terms of the potential energy surface The code reads radial coupling terms from a separate file. The reading process is controlled by both the input file and pes_read_mod.f90 . The radial terms file starts with n_skip_lines lines which describe the file and are ignored by the code.\nThe reading procedure is continued using two loops: the first one over nterms (number of radial terms, which match the size of l1tab ),\n and the second one over nr (the number of points on the  R -grid).\nThe code assumes that each loop over nterms begins with a current value of}  \\lambda , and that the radial coupling terms are ordered in columns, where the first column corresponds to the  R -grid.\nAdditional loop over totalcol reads radial terms which couple different  v, j  and  v', j'  states.\nThe order of columns in the radial terms file must correspond to the values supplied in the v1pes , j1pes , v1ppes , j1ppes arrays in the input file. Modify the potential_read subroutine in pes_read_mod.f90 , if the radial terms file has a different format. The user can supply a larger set of terms that describe the coupling between different rovibrational states ( v, j  and   v', j'  ) than actually needed.\nThe POTENTIALREDUCTION subroutine from pes_read_mod.f90 will only pick and interpolate the necessary terms.\nNote that the procedure will be skipped if totalcol  <=  nlevel  \\cdot  (nlevel+1)/2.","tags":"","loc":"page/radialterms.html"},{"title":"S-matrix file – the SCATTERING code","text":"S-matrix file The following information is saved to the S-matrix binary file: label , \"2\" (a code name for diatom - atom scattering in the BIGOS package), nlevel , reducedmass (in atomic mass untis), (v1array(ilevel), j1array(ilevel), ilevel = 1, nlevel) (elevel(ilevel), ilevel = 1, nlevel) (in cm -1 ) initial, energy (in cm -1 ) jtot_, parity_index, number_of_open_channels (current value of  J ,  p  (if  p=1 , parity_index = 0, if  p = -1 , parity_index = 1) and number of open channels within the block) (channels_level_indices(iopen), channels_l_values(iopen), wv(iopen), iopen = 1, number_of_open_channels) (channels_level_indices is an integer array which keeps the values of pointers to the v1array and j1array, channels_l_values is an array containing all  l  values\ncorresponding to open channels, wv keeps values of  k_{\\gamma}  for each open channel (in 1/\\AA)). (srmatrix(iopen,iopen2), iopen2 = 1, iopen), iopen = 1, nopen) (real part of the S-matrix; only the lower triangle of the matrix is saved) (simatrix(iopen,iopen2), iopen2 = 1, iopen), iopen = 1, nopen) (imaginary part of the S-matrix; only the lower triangle of the matrix is saved) The last four steps are repeated for each block, looping over parity and total angular momentum.","tags":"","loc":"page/smatrixfile.html"}]}
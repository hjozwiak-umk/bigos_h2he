var tipuesearch = {"pages":[{"title":" the SCATTERING code ","text":"the SCATTERING code BIGOS – B inary I nelastic scattering and G eneralized O ptical cross S ection package is a set of FORTRAN 90 codes that\nallow the user to obtain various physical quantities related to the scattering problem involving diatomic molecules and\natoms. The package is being developed at the Nicolaus Copernicus University in Toruń. Here, we present the SCATTERINC code, the central part of the BIGOS package.\nThe purpose of the SCATTERING code is to solve the coupled equations for a given scattering system, provide the\nscattering S-matrix elements and calculate the state-to-state cross-sections. Please read the Program Description . Note This version of the code is adjusted for diatom - atom collision systems, in particular the H 2 - He system. Please, refer to this version of the code by citing the following paper H. Jozwiak, F. Thibault, A. Viel, P. Wcislo, F. Lique, Rovibrational (de-)excitation of H 2 by He revisited https://doi.org/10.48550/arXiv.2311.09890 Developer Info Hubert Jóźwiak","tags":"home","loc":"index.html"},{"title":"get_radial_coupling_term_value – the SCATTERING code","text":"public  subroutine get_radial_coupling_term_value(intermolecular_distance, lambda_, v_, j_, v_prime_, j_prime_, radial_term_value_) Returns the interpolated value of a specific radial coupling term\nat a given distance. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: intermolecular_distance Intermolecular distance, R integer(kind=int32), intent(in) :: lambda_ Legendre expansion index integer(kind=int32), intent(in) :: v_ pre-collisional vibrational quantum number integer(kind=int32), intent(in) :: j_ pre-collisional rotational quantum number integer(kind=int32), intent(in) :: v_prime_ post-collisional vibrational quantum number integer(kind=int32), intent(in) :: j_prime_ post-collisional rotational quantum number real(kind=dp), intent(out) :: radial_term_value_ Value of the radial coupling coefficient Calls proc~~get_radial_coupling_term_value~~CallsGraph proc~get_radial_coupling_term_value get_radial_coupling_term_value proc~ispline ispline proc~get_radial_coupling_term_value->proc~ispline proc~float_to_character float_to_character proc~ispline->proc~float_to_character proc~write_warning write_warning proc~ispline->proc~write_warning proc~write_message write_message proc~write_warning->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code get_radial_coupling_term_value Source Code subroutine get_radial_coupling_term_value ( intermolecular_distance , & lambda_ , v_ , j_ , v_prime_ , j_prime_ , radial_term_value_ ) !! Returns the interpolated value of a specific radial coupling term !! at a given distance. !---------------------------------------------------------------------! real ( dp ), intent ( in ) :: intermolecular_distance !! Intermolecular distance, \\R\\ integer ( int32 ), intent ( in ) :: lambda_ !! Legendre expansion index integer ( int32 ), intent ( in ) :: v_ !! pre-collisional vibrational quantum number integer ( int32 ), intent ( in ) :: j_ !! pre-collisional rotational quantum number integer ( int32 ), intent ( in ) :: v_prime_ !! post-collisional vibrational quantum number integer ( int32 ), intent ( in ) :: j_prime_ !! post-collisional rotational quantum number real ( dp ), intent ( out ) :: radial_term_value_ !! Value of the radial coupling coefficient !---------------------------------------------------------------------! integer ( int32 ) :: lambda_index , coupling_index !---------------------------------------------------------------------! lambda_index = find_lambda_index ( lambda_ ) !---------------------------------------------------------------------! if ( lambda_index == 0 ) then call handle_lambda_index_error ( lambda_ ) return endif !---------------------------------------------------------------------! coupling_index = find_coupling_index ( v_ , j_ , v_prime_ , j_prime_ ) !---------------------------------------------------------------------! if ( coupling_index == 0 ) then call handle_coupling_index_error ( v_ , j_ , v_prime_ , j_prime_ ) return endif !---------------------------------------------------------------------! radial_term_value_ = ISPLINE ( intermolecular_distance , nr , rmat , & vmat3D (:, lambda_index , coupling_index ), & bmat3D (:, lambda_index , coupling_index ), & cmat3D (:, lambda_index , coupling_index ), & dmat3D (:, lambda_index , coupling_index )) !---------------------------------------------------------------------! end subroutine get_radial_coupling_term_value","tags":"","loc":"proc/get_radial_coupling_term_value.html"},{"title":"interpolate_radial_coupling_terms – the SCATTERING code","text":"public  subroutine interpolate_radial_coupling_terms() Interpolates the radial coupling terms using cubic spline functions.\nThe resulting spline coefficients for each coupling term\nare stored in bmat3D, cmat3D, and dmat3D matrices. Arguments None Calls proc~~interpolate_radial_coupling_terms~~CallsGraph proc~interpolate_radial_coupling_terms interpolate_radial_coupling_terms proc~spline spline proc~interpolate_radial_coupling_terms->proc~spline proc~integer_to_character integer_to_character proc~spline->proc~integer_to_character proc~write_error write_error proc~spline->proc~write_error proc~write_message write_message proc~write_error->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~interpolate_radial_coupling_terms~~CalledByGraph proc~interpolate_radial_coupling_terms interpolate_radial_coupling_terms program~scattering SCATTERING program~scattering->proc~interpolate_radial_coupling_terms Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code interpolate_radial_coupling_terms Source Code subroutine interpolate_radial_coupling_terms !! Interpolates the radial coupling terms using cubic spline functions. !! The resulting spline coefficients for each coupling term !! are stored in bmat3D, cmat3D, and dmat3D matrices. !---------------------------------------------------------------------! integer ( int32 ) :: lambda_index_ , coupling_index_ real ( dp ) :: spline_coeff_b ( nr ), spline_coeff_c ( nr ), spline_coeff_d ( nr ) !---------------------------------------------------------------------! do lambda_index_ = 1 , nterms do coupling_index_ = 1 , minimal_number_of_coupling_terms !---------------------------------------------------------------! ! Compute spline coefficients for each coupling term !---------------------------------------------------------------! call SPLINE ( nr , rmat , vmat3D (:, lambda_index_ , coupling_index_ ), & spline_coeff_b , spline_coeff_c , spline_coeff_d ) !---------------------------------------------------------------! ! Store coefficients in the respective matrices !---------------------------------------------------------------! bmat3D (:, lambda_index_ , coupling_index_ ) = spline_coeff_b cmat3D (:, lambda_index_ , coupling_index_ ) = spline_coeff_c dmat3D (:, lambda_index_ , coupling_index_ ) = spline_coeff_d enddo enddo !---------------------------------------------------------------------! end subroutine interpolate_radial_coupling_terms","tags":"","loc":"proc/interpolate_radial_coupling_terms.html"},{"title":"read_radial_coupling_terms – the SCATTERING code","text":"public  subroutine read_radial_coupling_terms() Reads the radial coupling terms from the external file.\nThe file is assumed to be formatted as described in\n\"Supplying radial terms\" section.\nThe read radial coupling terms are kept in vmat/read_vmat3D Arguments None Calls proc~~read_radial_coupling_terms~~CallsGraph proc~read_radial_coupling_terms read_radial_coupling_terms proc~file_io_status file_io_status proc~read_radial_coupling_terms->proc~file_io_status proc~integer_to_character integer_to_character proc~file_io_status->proc~integer_to_character proc~write_error write_error proc~file_io_status->proc~write_error proc~write_message write_message proc~write_error->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~read_radial_coupling_terms~~CalledByGraph proc~read_radial_coupling_terms read_radial_coupling_terms program~scattering SCATTERING program~scattering->proc~read_radial_coupling_terms Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code read_radial_coupling_terms Source Code subroutine read_radial_coupling_terms !! Reads the radial coupling terms from the external file. !! The file is assumed to be formatted as described in !! \"Supplying radial terms\" section. !! The read radial coupling terms are kept in vmat/read_vmat3D !---------------------------------------------------------------------! character ( len = 200 ) :: err_message integer ( int32 ) :: nrtmp , l1 , iskip_ , lambda_index_ , ir , icol , io_status !---------------------------------------------------------------------! open ( pes_file_unit , file = trim ( potentialfile ), form = 'formatted' , & status = 'old' , iostat = io_status , iomsg = err_message ) call file_io_status ( io_status , err_message , pes_file_unit , 'o' ) !---------------------------------------------------------------------! ! Skip the informative lines at the beginning !---------------------------------------------------------------------! call skip_header_lines !---------------------------------------------------------------------! do lambda_index_ = 1 , nterms call read_and_validate_lambda ( lambda_index_ ) call read_potential_data ( lambda_index_ ) enddo !---------------------------------------------------------------------! close ( pes_file_unit , iostat = io_status , iomsg = err_message ) call file_io_status ( io_status , err_message , pes_file_unit , 'c' ) !---------------------------------------------------------------------! ! Check if supplied radial terms cover a sufficient range of R !---------------------------------------------------------------------! call validate_r_range !---------------------------------------------------------------------! end subroutine read_radial_coupling_terms","tags":"","loc":"proc/read_radial_coupling_terms.html"},{"title":"reduce_radial_coupling_terms – the SCATTERING code","text":"public  subroutine reduce_radial_coupling_terms() Reduces the read_vmat3D matrix to retain only the necessary coupling terms. Arguments None Calls proc~~reduce_radial_coupling_terms~~CallsGraph proc~reduce_radial_coupling_terms reduce_radial_coupling_terms proc~write_message write_message proc~reduce_radial_coupling_terms->proc~write_message proc~integer_to_character integer_to_character proc~reduce_radial_coupling_terms->proc~integer_to_character Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~reduce_radial_coupling_terms~~CalledByGraph proc~reduce_radial_coupling_terms reduce_radial_coupling_terms program~scattering SCATTERING program~scattering->proc~reduce_radial_coupling_terms Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code reduce_radial_coupling_terms Source Code subroutine reduce_radial_coupling_terms !! Reduces the read_vmat3D matrix to retain only the necessary coupling terms. !---------------------------------------------------------------------! integer ( int32 ) :: lambda_index_ , radial_index_ , coupling_index_ !---------------------------------------------------------------------! if ( total_number_of_coupling_terms /= minimal_number_of_coupling_terms ) then call write_message ( \"Reducing the number of the radial coupling terms...\" ) call print_pes_quantum_numbers ( \"Original\" , total_number_of_coupling_terms ) call reduce_coupling_terms () call print_pes_quantum_numbers ( \"Reduced\" , minimal_number_of_coupling_terms ) call write_message ( \"Reduced \" // & trim ( adjustl ( integer_to_character ( total_number_of_coupling_terms ))) // & \" radial terms to \" // trim ( adjustl ( integer_to_character ( minimal_number_of_coupling_terms )))) else !------------------------------------------------------------------! ! if there is nothing to be reduced, copy read_vmat3d to vmat3d !------------------------------------------------------------------! vmat3D = read_vmat3D endif !---------------------------------------------------------------------! deallocate ( read_vmat3D ) !---------------------------------------------------------------------! end subroutine reduce_radial_coupling_terms","tags":"","loc":"proc/reduce_radial_coupling_terms.html"},{"title":"calculate_pes_matrix – the SCATTERING code","text":"public  subroutine calculate_pes_matrix(total_angular_momentum_, intermolecular_distance_, channel_indices_, channels_omega_values_, nonzero_terms_per_element_, nonzero_legendre_indices_, nonzero_algebraic_coefficients_, vmatrix) calculates the contribution to the coupling matrix\nfrom the the interaction potential (PES);\nsee Eq. 1 in \"Coupling Matrix\" section;\ndiagonal contribution from wavevectors (see the last term in\nEq. 3 of \"What are coupled equations\" section) is added Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: total_angular_momentum_ total angular momentum real(kind=dp), intent(in) :: intermolecular_distance_ intermolecular distance integer(kind=int32), intent(in) :: channel_indices_ (:) holds the indices pointing to the basis arrays integer(kind=int32), intent(in) :: channels_omega_values_ (:) holds all values of \\bar{\\Omega} integer(kind=int32), intent(in) :: nonzero_terms_per_element_ (:) keeps the number of non-vanishing elements of the sum over \\lambda\nfor each non-zero element of the coupling matrix integer(kind=int32), intent(in) :: nonzero_legendre_indices_ (:) holds indices pointing to l1tab, which correspond to\nthe non-vanishing elements of the sum over \\lambda\nfor each non-zero element of the coupling matrix; real(kind=dp), intent(in) :: nonzero_algebraic_coefficients_ (:) holds the values of the non-zero algebraic coefficients real(kind=dp), intent(out) :: vmatrix (:,:) (output) - the interaction potential contribution to the coupling matrix Calls proc~~calculate_pes_matrix~~CallsGraph proc~calculate_pes_matrix calculate_pes_matrix interface~fill_symmetric_matrix fill_symmetric_matrix proc~calculate_pes_matrix->interface~fill_symmetric_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code calculate_pes_matrix Source Code subroutine calculate_pes_matrix ( total_angular_momentum_ , & intermolecular_distance_ , channel_indices_ , channels_omega_values_ , & nonzero_terms_per_element_ , nonzero_legendre_indices_ , & nonzero_algebraic_coefficients_ , vmatrix ) !! calculates the contribution to the coupling matrix !! from the the interaction potential (PES); !! see Eq. 1 in \"Coupling Matrix\" section; !! diagonal contribution from wavevectors (see the last term in !! Eq. 3 of \"What are coupled equations\" section) is added !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: total_angular_momentum_ !! total angular momentum real ( dp ), intent ( in ) :: intermolecular_distance_ !! intermolecular distance integer ( int32 ), intent ( in ) :: channel_indices_ (:) !! holds the indices pointing to the basis arrays integer ( int32 ), intent ( in ) :: channels_omega_values_ (:) !! holds all values of \\bar{\\Omega} integer ( int32 ), intent ( in ) :: nonzero_terms_per_element_ (:) !! keeps the number of non-vanishing elements of the sum over \\\\lambda\\ !! for each non-zero element of the coupling matrix integer ( int32 ), intent ( in ) :: nonzero_legendre_indices_ (:) !! holds indices pointing to l1tab, which correspond to !! the non-vanishing elements of the sum over \\\\lambda\\ !! for each non-zero element of the coupling matrix; real ( dp ), intent ( in ) :: nonzero_algebraic_coefficients_ (:) !! holds the values of the non-zero algebraic coefficients real ( dp ), intent ( out ) :: vmatrix (:,:) !! (output) - the interaction potential contribution to the coupling matrix !---------------------------------------------------------------------! integer ( int32 ) :: count_nonzero_algebraic_coefficients_ , & count_nonzero_coupling_matrix_elements , & count_nonzero_legendre_terms , channel_index_1_ , channel_index_2_ , & omega_ , omega_prime_ !---------------------------------------------------------------------! vmatrix = 0 count_nonzero_algebraic_coefficients_ = 0 count_nonzero_coupling_matrix_elements = 0 !---------------------------------------------------------------------! do channel_index_1_ = 1 , size ( channel_indices_ ) omega_ = channels_omega_values_ ( channel_index_1_ ) do channel_index_2_ = 1 , channel_index_1_ omega_prime_ = channels_omega_values_ ( channel_index_2_ ) !---------------------------------------------------------------! if ( omega_ /= omega_prime_ ) cycle !---------------------------------------------------------------! count_nonzero_coupling_matrix_elements & = count_nonzero_coupling_matrix_elements + 1 !---------------------------------------------------------------! ! process a single matrix element: ! get number of  non-zero terms in Legendre expansion for this ! matrix element !---------------------------------------------------------------! count_nonzero_legendre_terms & = nonzero_terms_per_element_ ( count_nonzero_coupling_matrix_elements ) !---------------------------------------------------------------! ! implementation of Eq. 1 in \"Coupling Matrix\" section !---------------------------------------------------------------! vmatrix ( channel_index_1_ , channel_index_2_ ) & = calculate_single_pes_matrix_element ( & intermolecular_distance_ , channel_index_1_ , & channel_index_2_ , channel_indices_ , & count_nonzero_legendre_terms , & count_nonzero_algebraic_coefficients_ , & nonzero_legendre_indices_ , nonzero_algebraic_coefficients_ ) !---------------------------------------------------------------! enddo enddo !---------------------------------------------------------------------! call fill_symmetric_matrix ( vmatrix , 'u' ) !---------------------------------------------------------------------! end subroutine calculate_pes_matrix","tags":"","loc":"proc/calculate_pes_matrix.html"},{"title":"check_nonzero_pes_matrix_elements – the SCATTERING code","text":"public  subroutine check_nonzero_pes_matrix_elements(channel_indices, channels_omega_values, number_of_nonzero_pes_matrix_elements, number_of_nonzero_algebraic_coefficients) checks the number of non-zero PES matrix elements due to\nthe \\bar{\\Omega} = \\bar{\\Omega}' condition,\n\"number_of_nonzero_pes_matrix_elements\",\nand the total number of non-zero algebraic coefficients,\n g_{{\\lambda},\\gamma,\\gamma'}&#94;{Jp} , in the whole matrix,\n\"number_of_nonzero_algebraic_coefficients\". Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: channel_indices (:) holds the indices pointing to the basis arrays integer(kind=int32), intent(in) :: channels_omega_values (:) holds all values of \\bar{\\Omega} integer(kind=int32), intent(out) :: number_of_nonzero_pes_matrix_elements number of non-zero terms in the sum () for each non-zero element of the PES matrix integer(kind=int32), intent(out) :: number_of_nonzero_algebraic_coefficients number of all non-zero algberaix coefficients in the whole PES matrix Calls proc~~check_nonzero_pes_matrix_elements~~CallsGraph proc~check_nonzero_pes_matrix_elements check_nonzero_pes_matrix_elements proc~zero_projections_3j_condition zero_projections_3j_condition proc~check_nonzero_pes_matrix_elements->proc~zero_projections_3j_condition proc~triangle_inequality_holds triangle_inequality_holds proc~zero_projections_3j_condition->proc~triangle_inequality_holds proc~is_sum_even is_sum_even proc~zero_projections_3j_condition->proc~is_sum_even Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~check_nonzero_pes_matrix_elements~~CalledByGraph proc~check_nonzero_pes_matrix_elements check_nonzero_pes_matrix_elements program~scattering SCATTERING program~scattering->proc~check_nonzero_pes_matrix_elements Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code check_nonzero_pes_matrix_elements Source Code subroutine check_nonzero_pes_matrix_elements ( channel_indices ,& channels_omega_values , number_of_nonzero_pes_matrix_elements , & number_of_nonzero_algebraic_coefficients ) !! checks the number of non-zero PES matrix elements due to !! the \\bar{\\Omega} = \\bar{\\Omega}' condition, !! \"number_of_nonzero_pes_matrix_elements\", !! and the total number of non-zero algebraic coefficients, !! \\ g\\_{{\\lambda},\\gamma,\\gamma'}&#94;{Jp} \\, in the whole matrix, !! \"number_of_nonzero_algebraic_coefficients\". !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: channel_indices (:) !! holds the indices pointing to the basis arrays integer ( int32 ), intent ( in ) :: channels_omega_values (:) !! holds all values of \\bar{\\Omega} integer ( int32 ), intent ( out ) :: number_of_nonzero_pes_matrix_elements !! number of non-zero terms in the sum () for each non-zero element of the PES matrix integer ( int32 ), intent ( out ) :: number_of_nonzero_algebraic_coefficients !! number of all non-zero algberaix coefficients in the whole PES matrix !---------------------------------------------------------------------! integer ( int32 ) :: count_nonzero_pes_matrix_elements , & count_nonzero_algebraic_coefficients , j_ , j_prime_ , omega_ , & omega_prime_ , lambda_ , channel_index_1_ , channel_index_2_ , legendre_term_index_ !---------------------------------------------------------------------! count_nonzero_algebraic_coefficients = 0 count_nonzero_pes_matrix_elements = 0 do channel_index_1_ = 1 , size ( channel_indices ) j_ = j1array ( channel_indices ( channel_index_1_ )) omega_ = channels_omega_values ( channel_index_1_ ) do channel_index_2_ = 1 , channel_index_1_ j_prime_ = j1array ( channel_indices ( channel_index_2_ )) omega_prime_ = channels_omega_values ( channel_index_2_ ) !---------------------------------------------------------------! if ( omega_ /= omega_prime_ ) cycle !---------------------------------------------------------------! count_nonzero_pes_matrix_elements = & count_nonzero_pes_matrix_elements + 1 do legendre_term_index_ = 1 , nterms lambda_ = l1tab ( legendre_term_index_ ) if (. not . zero_projections_3j_condition ( j_ , j_prime_ , lambda_ )) cycle count_nonzero_algebraic_coefficients = & count_nonzero_algebraic_coefficients + 1 enddo enddo enddo !---------------------------------------------------------------------! number_of_nonzero_algebraic_coefficients = count_nonzero_algebraic_coefficients number_of_nonzero_pes_matrix_elements = count_nonzero_pes_matrix_elements !---------------------------------------------------------------------! end subroutine check_nonzero_pes_matrix_elements","tags":"","loc":"proc/check_nonzero_pes_matrix_elements.html"},{"title":"prepare_pes_matrix_elements – the SCATTERING code","text":"public  subroutine prepare_pes_matrix_elements(channel_indices, channels_omega_values, nonzero_terms_per_element, nonzero_legendre_indices, nonzero_algebraic_coefficients) -- nonzero_terms_per_element - number of non-vanishing terms in\n   the sum over \\lambda in Eq. 1 in the \"Coupling Matrix\" section\n-- nonzero_legendre_indices - corresponding \\lambda value for\n   each non-vanishing coefficient is saved as an index to \"l1tab\"\n-- nonzero_algebraic_coefficients --  holds all non-vanishing\n    g_{{\\lambda},\\gamma,\\gamma'}&#94;{Jp}  coefficients Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: channel_indices (:) holds the indices pointing to the basis arrays integer(kind=int32), intent(in) :: channels_omega_values (:) holds all values of \\bar{\\Omega} integer(kind=int32), intent(inout) :: nonzero_terms_per_element (:) keeps the number of non-vanishing elements of the sum over \\lambda\nfor each non-zero element of the PES matrix integer(kind=int32), intent(inout) :: nonzero_legendre_indices (:) holds indices pointing to l1tab, which correspond to\nthe non-vanishing elements of the sum over \\lambda\nfor each non-zero element of the PES matrix; real(kind=dp), intent(inout) :: nonzero_algebraic_coefficients (:) holds the values of the non-zero algebraic coefficients Called by proc~~prepare_pes_matrix_elements~~CalledByGraph proc~prepare_pes_matrix_elements prepare_pes_matrix_elements program~scattering SCATTERING program~scattering->proc~prepare_pes_matrix_elements Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code prepare_pes_matrix_elements Source Code subroutine prepare_pes_matrix_elements ( channel_indices , & channels_omega_values , nonzero_terms_per_element , & nonzero_legendre_indices , nonzero_algebraic_coefficients ) !! prepares: !! -- nonzero_terms_per_element - number of non-vanishing terms in !!    the sum over \\\\lambda\\ in Eq. 1 in the \"Coupling Matrix\" section !! -- nonzero_legendre_indices - corresponding \\\\lambda\\ value for !!    each non-vanishing coefficient is saved as an index to \"l1tab\" !! -- nonzero_algebraic_coefficients --  holds _all_ non-vanishing !!    \\ g\\_{{\\lambda},\\gamma,\\gamma'}&#94;{Jp} \\ coefficients !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: channel_indices (:) !! holds the indices pointing to the basis arrays integer ( int32 ), intent ( in ) :: channels_omega_values (:) !! holds all values of \\bar{\\Omega} integer ( int32 ), intent ( inout ) :: nonzero_terms_per_element (:) !! keeps the number of non-vanishing elements of the sum over \\\\lambda\\ !! for each non-zero element of the PES matrix integer ( int32 ), intent ( inout ) :: nonzero_legendre_indices (:) !! holds indices pointing to l1tab, which correspond to !! the non-vanishing elements of the sum over \\\\lambda\\ !! for each non-zero element of the PES matrix; real ( dp ), intent ( inout ) :: nonzero_algebraic_coefficients (:) !! holds the values of the non-zero algebraic coefficients !---------------------------------------------------------------------! integer ( int32 ) :: count_nonzero_pes_matrix_elements , & count_nonzero_algebraic_coefficients , count_nonzero_legendre_terms , & j_ , j_prime_ , omega_ , omega_prime_ , lambda_ , channel_index_1_ , & channel_index_2_ , legendre_term_index_ real ( dp ) :: pscoeff !---------------------------------------------------------------------! nonzero_terms_per_element = 0 nonzero_legendre_indices = 0 nonzero_algebraic_coefficients = 0 count_nonzero_algebraic_coefficients = 0 count_nonzero_pes_matrix_elements = 0 !---------------------------------------------------------------------! do channel_index_1_ = 1 , size ( channel_indices ) j_ = j1array ( channel_indices ( channel_index_1_ )) omega_ = channels_omega_values ( channel_index_1_ ) do channel_index_2_ = 1 , channel_index_1_ j_prime_ = j1array ( channel_indices ( channel_index_2_ )) omega_prime_ = channels_omega_values ( channel_index_2_ ) if ( omega_ /= omega_prime_ ) cycle !---------------------------------------------------------------! ! passed \\bar{\\Omega} = \\bar{\\Omega}' condition !---------------------------------------------------------------! count_nonzero_pes_matrix_elements = & count_nonzero_pes_matrix_elements + 1 !---------------------------------------------------------------! ! process a single matrix element: ! determine non-zero terms in the sum over legendre polynomials ! for this element; these are saved to ... !---------------------------------------------------------------! call process_single_matrix_element ( j_ , j_prime_ , omega_ , & count_nonzero_algebraic_coefficients , & count_nonzero_legendre_terms , nonzero_legendre_indices , & nonzero_algebraic_coefficients ) nonzero_terms_per_element ( count_nonzero_pes_matrix_elements )& = count_nonzero_legendre_terms enddo enddo !---------------------------------------------------------------------! end subroutine prepare_pes_matrix_elements","tags":"","loc":"proc/prepare_pes_matrix_elements.html"},{"title":"print_pes_matrix_elements_summary – the SCATTERING code","text":"public  subroutine print_pes_matrix_elements_summary(number_of_channels, number_of_nonzero_pes_matrix_elements, number_of_nonzero_algebraic_coefficients) print a shor summary on the number of non-zero matrix elements\nof the PES matrix Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: number_of_channels size of the basis integer(kind=int32), intent(in) :: number_of_nonzero_pes_matrix_elements number of non-zero terms in the sum () for each non-zero element\nof the PES matrix integer(kind=int32), intent(in) :: number_of_nonzero_algebraic_coefficients number of all non-zero algberaix coefficients in the whole\nPES matrix Calls proc~~print_pes_matrix_elements_summary~~CallsGraph proc~print_pes_matrix_elements_summary print_pes_matrix_elements_summary proc~write_message write_message proc~print_pes_matrix_elements_summary->proc~write_message proc~integer_to_character integer_to_character proc~print_pes_matrix_elements_summary->proc~integer_to_character Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~print_pes_matrix_elements_summary~~CalledByGraph proc~print_pes_matrix_elements_summary print_pes_matrix_elements_summary program~scattering SCATTERING program~scattering->proc~print_pes_matrix_elements_summary Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code print_pes_matrix_elements_summary Source Code subroutine print_pes_matrix_elements_summary ( number_of_channels , & number_of_nonzero_pes_matrix_elements , & number_of_nonzero_algebraic_coefficients ) !! print a shor summary on the number of non-zero matrix elements !! of the PES matrix !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: number_of_channels !! size of the basis integer ( int32 ), intent ( in ) :: number_of_nonzero_pes_matrix_elements !! number of non-zero terms in the sum () for each non-zero element !! of the PES matrix integer ( int32 ), intent ( in ) :: number_of_nonzero_algebraic_coefficients !! number of all non-zero algberaix coefficients in the whole !! PES matrix !---------------------------------------------------------------------! call write_message ( repeat ( \"*\" , 90 )) call write_message ( repeat ( \" \" , 5 ) // \"Size of the PES matrix: \" // & integer_to_character ( number_of_channels )) call write_message ( repeat ( \" \" , 5 ) // \"Number of non-zero elements \" // & \"of the potential matrix: \" // integer_to_character ( & number_of_nonzero_pes_matrix_elements )) call write_message ( repeat ( \" \" , 5 ) // \"Number of non-zero elements \" // & \" of the PES matrix: \" // integer_to_character ( & number_of_nonzero_algebraic_coefficients )) call write_message ( repeat ( '*' , 90 )) !---------------------------------------------------------------------! end subroutine print_pes_matrix_elements_summary","tags":"","loc":"proc/print_pes_matrix_elements_summary.html"},{"title":"envj – the SCATTERING code","text":"public  function envj(n, x) utility function used by MSTA1 and MSTA2. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: x Return Value real(kind=8) Called by proc~~envj~~CalledByGraph proc~envj envj proc~msta1 msta1 proc~msta1->proc~envj proc~msta2 msta2 proc~msta2->proc~envj proc~rctj rctj proc~rctj->proc~msta1 proc~rctj->proc~msta2 proc~riccati_bessel_j riccati_bessel_j proc~riccati_bessel_j->proc~rctj proc~calculate_k_matrix calculate_k_matrix proc~calculate_k_matrix->proc~riccati_bessel_j program~scattering SCATTERING program~scattering->proc~calculate_k_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables logten n_r8 r8_gamma_log Variables Type Visibility Attributes Name Initial real(kind=8), public :: logten real(kind=8), public :: n_r8 real(kind=8), public :: r8_gamma_log","tags":"","loc":"proc/envj.html"},{"title":"msta1 – the SCATTERING code","text":"public  function msta1(x, mp) determines a backward recurrence starting point for Jn(x). Arguments Type Intent Optional Attributes Name real(kind=8) :: x integer(kind=4) :: mp Return Value integer(kind=4) Calls proc~~msta1~~CallsGraph proc~msta1 msta1 proc~envj envj proc~msta1->proc~envj Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~msta1~~CalledByGraph proc~msta1 msta1 proc~rctj rctj proc~rctj->proc~msta1 proc~riccati_bessel_j riccati_bessel_j proc~riccati_bessel_j->proc~rctj proc~calculate_k_matrix calculate_k_matrix proc~calculate_k_matrix->proc~riccati_bessel_j program~scattering SCATTERING program~scattering->proc~calculate_k_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables a0 f f0 f1 it n0 n1 nn Variables Type Visibility Attributes Name Initial real(kind=8), public :: a0 real(kind=8), public :: f real(kind=8), public :: f0 real(kind=8), public :: f1 integer(kind=4), public :: it integer(kind=4), public :: n0 integer(kind=4), public :: n1 integer(kind=4), public :: nn","tags":"","loc":"proc/msta1.html"},{"title":"msta2 – the SCATTERING code","text":"public  function msta2(x, n, mp) determines a backward recurrence starting point for Jn(x). Arguments Type Intent Optional Attributes Name real(kind=8) :: x integer(kind=4) :: n integer(kind=4) :: mp Return Value integer(kind=4) Calls proc~~msta2~~CallsGraph proc~msta2 msta2 proc~envj envj proc~msta2->proc~envj Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~msta2~~CalledByGraph proc~msta2 msta2 proc~rctj rctj proc~rctj->proc~msta2 proc~riccati_bessel_j riccati_bessel_j proc~riccati_bessel_j->proc~rctj proc~calculate_k_matrix calculate_k_matrix proc~calculate_k_matrix->proc~riccati_bessel_j program~scattering SCATTERING program~scattering->proc~calculate_k_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables a0 ejn f f0 f1 hmp it n0 n1 nn obj Variables Type Visibility Attributes Name Initial real(kind=8), public :: a0 real(kind=8), public :: ejn real(kind=8), public :: f real(kind=8), public :: f0 real(kind=8), public :: f1 real(kind=8), public :: hmp integer(kind=4), public :: it integer(kind=4), public :: n0 integer(kind=4), public :: n1 integer(kind=4), public :: nn real(kind=8), public :: obj","tags":"","loc":"proc/msta2.html"},{"title":"rctj – the SCATTERING code","text":"public  subroutine rctj(n, x, nm, rj, dj) computes Riccati-Bessel function of the first kind, and derivatives. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: x integer(kind=4) :: nm real(kind=8) :: rj (0:n) real(kind=8) :: dj (0:n) Calls proc~~rctj~~CallsGraph proc~rctj rctj proc~msta1 msta1 proc~rctj->proc~msta1 proc~msta2 msta2 proc~rctj->proc~msta2 proc~envj envj proc~msta1->proc~envj proc~msta2->proc~envj Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~rctj~~CalledByGraph proc~rctj rctj proc~riccati_bessel_j riccati_bessel_j proc~riccati_bessel_j->proc~rctj proc~calculate_k_matrix calculate_k_matrix proc~calculate_k_matrix->proc~riccati_bessel_j program~scattering SCATTERING program~scattering->proc~calculate_k_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables cs f f0 f1 k m rj0 rj1 Variables Type Visibility Attributes Name Initial real(kind=8), public :: cs real(kind=8), public :: f real(kind=8), public :: f0 real(kind=8), public :: f1 integer(kind=4), public :: k integer(kind=4), public :: m real(kind=8), public :: rj0 real(kind=8), public :: rj1","tags":"","loc":"proc/rctj.html"},{"title":"rcty – the SCATTERING code","text":"public  subroutine rcty(n, x, nm, ry, dy) computes Riccati-Bessel function of the second kind, and derivatives. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: x integer(kind=4) :: nm real(kind=8) :: ry (0:n) real(kind=8) :: dy (0:n) Called by proc~~rcty~~CalledByGraph proc~rcty rcty proc~riccati_bessel_y riccati_bessel_y proc~riccati_bessel_y->proc~rcty proc~calculate_k_matrix calculate_k_matrix proc~calculate_k_matrix->proc~riccati_bessel_y program~scattering SCATTERING program~scattering->proc~calculate_k_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables k rf0 rf1 rf2 Variables Type Visibility Attributes Name Initial integer(kind=4), public :: k real(kind=8), public :: rf0 real(kind=8), public :: rf1 real(kind=8), public :: rf2","tags":"","loc":"proc/rcty.html"},{"title":"ETOTAL – the SCATTERING code","text":"public  function ETOTAL() result(etot_) returns the total energy Arguments None Return Value real(kind=dp) Called by proc~~etotal~~CalledByGraph proc~etotal ETOTAL proc~is_open is_open proc~is_open->proc~etotal proc~input_summary input_summary proc~input_summary->proc~etotal proc~save_partial_xs_single_block save_partial_xs_single_block proc~save_partial_xs_single_block->proc~etotal program~scattering SCATTERING program~scattering->proc~etotal program~scattering->proc~save_partial_xs_single_block proc~save_open_basis_levels save_open_basis_levels program~scattering->proc~save_open_basis_levels proc~print_channels print_channels program~scattering->proc~print_channels proc~calculate_largest_wavenumber calculate_largest_wavenumber program~scattering->proc~calculate_largest_wavenumber proc~calculate_k_matrix calculate_k_matrix program~scattering->proc~calculate_k_matrix proc~read_input_file read_input_file program~scattering->proc~read_input_file proc~count_open_basis_levels count_open_basis_levels program~scattering->proc~count_open_basis_levels proc~count_open_channels_in_block count_open_channels_in_block program~scattering->proc~count_open_channels_in_block proc~wavenumber_squared_from_energy wavenumber_squared_from_energy proc~wavenumber_squared_from_energy->proc~etotal proc~save_open_basis_levels->proc~is_open proc~save_open_basis_levels->proc~wavenumber_squared_from_energy proc~print_channels->proc~is_open proc~print_channels->proc~wavenumber_squared_from_energy proc~calculate_largest_wavenumber->proc~is_open proc~calculate_largest_wavenumber->proc~wavenumber_squared_from_energy proc~calculate_k_matrix->proc~is_open proc~calculate_k_matrix->proc~wavenumber_squared_from_energy proc~read_input_file->proc~input_summary proc~count_open_basis_levels->proc~is_open proc~count_open_channels_in_block->proc~is_open Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/etotal.html"},{"title":"count_open_basis_levels – the SCATTERING code","text":"public  function count_open_basis_levels() result(open_) counts the energetically accessible levels in the basis Arguments None Return Value integer(kind=int32) Calls proc~~count_open_basis_levels~~CallsGraph proc~count_open_basis_levels count_open_basis_levels proc~is_open is_open proc~count_open_basis_levels->proc~is_open proc~etotal ETOTAL proc~is_open->proc~etotal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~count_open_basis_levels~~CalledByGraph proc~count_open_basis_levels count_open_basis_levels program~scattering SCATTERING program~scattering->proc~count_open_basis_levels Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables ilevel Source Code count_open_basis_levels Variables Type Visibility Attributes Name Initial integer(kind=int32), public :: ilevel Source Code function count_open_basis_levels () result ( open_ ) !! counts the energetically accessible levels in the basis !------------------------------------------------------------------------! integer ( int32 ) :: open_ , ilevel !------------------------------------------------------------------------! open_ = 0 do ilevel = 1 , nlevel if ( is_open ( elevel ( ilevel ))) open_ = open_ + 1 enddo !------------------------------------------------------------------------! end function count_open_basis_levels","tags":"","loc":"proc/count_open_basis_levels.html"},{"title":"is_open – the SCATTERING code","text":"public  function is_open(energy_) result(is_open_) checks if a channel/level is energetically accessible (open)\nby comparing energy with etotal() Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: energy_ level/channel energy Return Value logical Calls proc~~is_open~~CallsGraph proc~is_open is_open proc~etotal ETOTAL proc~is_open->proc~etotal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~is_open~~CalledByGraph proc~is_open is_open proc~save_open_basis_levels save_open_basis_levels proc~save_open_basis_levels->proc~is_open proc~print_channels print_channels proc~print_channels->proc~is_open proc~calculate_largest_wavenumber calculate_largest_wavenumber proc~calculate_largest_wavenumber->proc~is_open proc~calculate_k_matrix calculate_k_matrix proc~calculate_k_matrix->proc~is_open proc~count_open_basis_levels count_open_basis_levels proc~count_open_basis_levels->proc~is_open proc~count_open_channels_in_block count_open_channels_in_block proc~count_open_channels_in_block->proc~is_open program~scattering SCATTERING program~scattering->proc~save_open_basis_levels program~scattering->proc~print_channels program~scattering->proc~calculate_largest_wavenumber program~scattering->proc~calculate_k_matrix program~scattering->proc~count_open_basis_levels program~scattering->proc~count_open_channels_in_block Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code is_open Source Code function is_open ( energy_ ) result ( is_open_ ) !! checks if a channel/level is energetically accessible (open) !! by comparing energy with etotal() !------------------------------------------------------------------------! real ( dp ), intent ( in ) :: energy_ !! level/channel energy logical :: is_open_ !------------------------------------------------------------------------! is_open_ = ( energy_ <= ETOTAL () ) !------------------------------------------------------------------------! end function is_open","tags":"","loc":"proc/is_open.html"},{"title":"wavenumber_squared_from_energy – the SCATTERING code","text":"public  function wavenumber_squared_from_energy(energy_) result(k_) returns the squared wavenumber, k_{a}&#94;{2},\ngiven the energy of a given state, E_{a};\ncalls etot() function; atomic units in the whole function\n k_{a} = \\sqrt(2 \\mu (E_{tot} - E_{a}) \nsince it uses reduced_mass and etotal(), the function checks\nif units are already converted Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: energy_ energy of a given state,  E_{a} , in a.u. Return Value real(kind=dp) wavenumber, k_{a}, in a.u. Calls proc~~wavenumber_squared_from_energy~~CallsGraph proc~wavenumber_squared_from_energy wavenumber_squared_from_energy proc~etotal ETOTAL proc~wavenumber_squared_from_energy->proc~etotal proc~write_error write_error proc~wavenumber_squared_from_energy->proc~write_error proc~write_message write_message proc~write_error->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~wavenumber_squared_from_energy~~CalledByGraph proc~wavenumber_squared_from_energy wavenumber_squared_from_energy proc~save_open_basis_levels save_open_basis_levels proc~save_open_basis_levels->proc~wavenumber_squared_from_energy proc~print_channels print_channels proc~print_channels->proc~wavenumber_squared_from_energy proc~calculate_largest_wavenumber calculate_largest_wavenumber proc~calculate_largest_wavenumber->proc~wavenumber_squared_from_energy proc~calculate_k_matrix calculate_k_matrix proc~calculate_k_matrix->proc~wavenumber_squared_from_energy program~scattering SCATTERING program~scattering->proc~save_open_basis_levels program~scattering->proc~print_channels program~scattering->proc~calculate_largest_wavenumber program~scattering->proc~calculate_k_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code wavenumber_squared_from_energy Source Code function wavenumber_squared_from_energy ( energy_ ) result ( k_ ) !! returns the squared wavenumber, \\k_{a}&#94;{2}\\, !! given the energy of a given state, \\E_{a}\\; !! calls etot() function; atomic units in the whole function !! \\ k_{a} = \\sqrt(2 \\mu (E_{tot} - E_{a}) \\ !! since it uses reduced_mass and etotal(), the function checks !! if units are already converted !------------------------------------------------------------------------! real ( dp ), intent ( in ) :: energy_ !! energy of a given state, \\ E_{a} \\, in a.u. real ( dp ) :: k_ !! wavenumber, \\k_{a}\\, in a.u. !------------------------------------------------------------------------! if ( units_converted ) then !---------------------------------------------------------------------! ! abs() is for closed channels, see... !---------------------------------------------------------------------! k_ = 2 * reduced_mass * ( ETOTAL () - energy_ ) else call write_error ( \"wavenumber_squared_from_energy called but units are not \" // & \"converted yet\" ) endif !------------------------------------------------------------------------! end function wavenumber_squared_from_energy","tags":"","loc":"proc/wavenumber_squared_from_energy.html"},{"title":"input_summary – the SCATTERING code","text":"public  subroutine input_summary() summarize the input parameters for the current run Arguments None Calls proc~~input_summary~~CallsGraph proc~input_summary input_summary proc~write_message write_message proc~input_summary->proc~write_message proc~float_to_character float_to_character proc~input_summary->proc~float_to_character proc~etotal ETOTAL proc~input_summary->proc~etotal proc~integer_to_character integer_to_character proc~input_summary->proc~integer_to_character Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~input_summary~~CalledByGraph proc~input_summary input_summary proc~read_input_file read_input_file proc~read_input_file->proc~input_summary program~scattering SCATTERING program~scattering->proc~read_input_file Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables ilevel Source Code input_summary Variables Type Visibility Attributes Name Initial integer(kind=int32), public :: ilevel Source Code subroutine input_summary !! summarize the input parameters for the current run !------------------------------------------------------------------------! integer ( int32 ) :: ilevel !------------------------------------------------------------------------! call write_message ( \"User-supplied label: \" // label ) call write_message ( \"Reduced mass: \" // & trim ( adjustl ( float_to_character ( reduced_mass , \"(F10.4)\" ))) // \" a.m.u.\" ) call write_message ( \"*** Energy levels in the basis set: ***\" ) call write_message ( \"   v       j            Energy (cm&#94;{-1})\" ) do ilevel = 1 , nlevel write ( * , \"(I4,4X,I4,16X,F12.4)\" ) v1array ( ilevel ), j1array ( ilevel ), elevel ( ilevel ) enddo write ( * , \"(44X,A3)\" ) \"***\" if ( jtotmax . ne . 999999 ) then call write_message ( \"The equations will be solved \" // & \"for total angular momentum J from \" // & trim ( adjustl ( integer_to_character ( jtotmin ))) // \" to \" & // trim ( adjustl ( integer_to_character ( jtotmax ))) // \" with step \" // & trim ( adjustl ( integer_to_character ( jtotstep )))) else call write_message ( \"The loop over JTOT will be performed from \" // & trim ( adjustl ( integer_to_character ( jtotmin ))) // \" with step \" // & trim ( adjustl ( integer_to_character ( jtotstep ))) // \" until \" // & trim ( adjustl ( integer_to_character ( consecutive_blocks_threshold ))) // & \" consecutive JTOT-blocks contribute less than \" // & trim ( adjustl ( float_to_character ( elastic_xs_threshold , \"(E10.4)\" ))) // & \" A&#94;2 to the elastic XS and less than \" // & trim ( adjustl ( float_to_character ( inelastic_xs_threshold , \"(E10.4)\" ))) // & \" A&#94;2 to the inelastic XS\" ) endif if ( relative_energy_flag . eq . 0 ) then call write_message ( \"The calculations will be performed for the total energy equal to \" & // trim ( adjustl ( float_to_character ( ETOTAL (), \"(F10.4)\" ))) // \" cm-1\" ) else if ( relative_energy_flag . eq . 1 ) then call write_message ( \"Relative kinetic energy of the colliding system: \" // & trim ( adjustl ( float_to_character ( energy , \"(F10.4)\" ))) // \" cm-1\" ) call write_message ( \"The kinetic energy is calculated with respect to the\" // & \" v = \" // trim ( adjustl ( integer_to_character ( v1array ( initial )))) // & \" j = \" // trim ( adjustl ( integer_to_character ( j1array ( initial )))) // & \" level in the basis set with the rotational energy \" // & trim ( adjustl ( float_to_character ( elevel ( initial ), \"(F10.4)\" ))) & // \" cm-1.\" ) call write_message ( \"This gives the total energy equal to \" // & trim ( adjustl ( float_to_character ( ETOTAL (), \"(F10.4)\" ))) // \" cm-1\" ) endif if ( print_partial_cross_sections ) then call write_message ( \"Partial cross sections will be saved into \" // partialfile ) endif call write_message ( \"S-matrix elements will be saved into \" // smatrixfile ) !------------------------------------------------------------------------! end subroutine input_summary","tags":"","loc":"proc/input_summary.html"},{"title":"read_input_file – the SCATTERING code","text":"public  subroutine read_input_file() reads the input file prepared by the user using NAMELIST feature\nthe code uses 3 namelists: input, basis and potential Arguments None Calls proc~~read_input_file~~CallsGraph proc~read_input_file read_input_file proc~check_namelist_basis check_namelist_basis proc~read_input_file->proc~check_namelist_basis proc~input_summary input_summary proc~read_input_file->proc~input_summary interface~allocate_1d allocate_1d proc~read_input_file->interface~allocate_1d proc~check_namelist_potential check_namelist_potential proc~read_input_file->proc~check_namelist_potential proc~file_io_status file_io_status proc~read_input_file->proc~file_io_status proc~check_namelist_input check_namelist_input proc~read_input_file->proc~check_namelist_input interface~allocate_3d allocate_3d proc~read_input_file->interface~allocate_3d proc~integer_to_character integer_to_character proc~check_namelist_basis->proc~integer_to_character interface~incorrect_value incorrect_value proc~check_namelist_basis->interface~incorrect_value proc~float_to_character float_to_character proc~input_summary->proc~float_to_character proc~write_message write_message proc~input_summary->proc~write_message proc~input_summary->proc~integer_to_character proc~etotal ETOTAL proc~input_summary->proc~etotal proc~check_namelist_potential->proc~integer_to_character proc~check_namelist_potential->interface~incorrect_value proc~write_error write_error proc~file_io_status->proc~write_error proc~file_io_status->proc~integer_to_character proc~check_namelist_input->proc~write_message proc~check_namelist_input->proc~write_error proc~check_namelist_input->proc~integer_to_character proc~check_namelist_input->interface~incorrect_value proc~write_error->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~read_input_file~~CalledByGraph proc~read_input_file read_input_file program~scattering SCATTERING program~scattering->proc~read_input_file Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables err_message icol icoupl iilevel il ilevel io_status Source Code read_input_file Variables Type Visibility Attributes Name Initial character(len=200), public :: err_message integer(kind=int32), public :: icol integer(kind=int32), public :: icoupl integer(kind=int32), public :: iilevel integer(kind=int32), public :: il integer(kind=int32), public :: ilevel integer(kind=int32), public :: io_status Source Code subroutine read_input_file !! reads the input file prepared by the user using NAMELIST feature !! the code uses 3 namelists: input, basis and potential !------------------------------------------------------------------------! character ( len = 200 ) :: err_message integer ( int32 ) :: ilevel , iilevel , icoupl , icol , il , io_status !------------------------------------------------------------------------! namelist / INPUT / label , reduced_mass , relative_energy_flag , energy , & jtotmin , jtotmax , jtotstep , rmin , rmax , dr , steps , vdepth , & consecutive_blocks_threshold , elastic_xs_threshold , & inelastic_xs_threshold , nlevel , initial , nr , nterms , & total_number_of_coupling_terms , n_skip_lines , iunits , & potentialfile , smatrixfile , print_partial_cross_sections , & partialfile , prntlvl namelist / BASIS / v1array , j1array , elevel namelist / POTENTIAL / l1tab , v1pes , j1pes , v1ppes , j1ppes !------------------------------------------------------------------------------! open ( unit = 5 , action = 'read' , form = 'formatted' , access = 'sequential' , & status = 'old' , iostat = io_status , iomsg = err_message ) call file_io_status ( io_status , err_message , 5 , 'o' ) !------------------------------------------------------------------------------! ! Read the input namelist:                                                     ! !------------------------------------------------------------------------------! read ( unit = 5 , nml = INPUT , iostat = io_status , iomsg = err_message ) call file_io_status ( io_status , err_message , 5 , 'r' ) !------------------------------------------------------------------------------! ! Check if the variables from input namelist are supplied correctly:           ! !------------------------------------------------------------------------------! call check_namelist_input if ( jtotmax . eq . - 1 ) jtotmax = 999999 call allocate_1d ( v1array , nlevel ) call allocate_1d ( j1array , nlevel ) call allocate_1d ( elevel , nlevel ) call allocate_1d ( l1tab , nterms ) call allocate_1d ( v1pes , total_number_of_coupling_terms ) call allocate_1d ( v1ppes , total_number_of_coupling_terms ) call allocate_1d ( j1pes , total_number_of_coupling_terms ) call allocate_1d ( j1ppes , total_number_of_coupling_terms ) select case ( iunits ) case ( 0 ) radial_term_distance_converter = 1.0_dp case ( 1 ) radial_term_distance_converter = bohrtoangstrom end select radial_term_energy_converter = 1.0_dp / hartreetocm !------------------------------------------------------------------------------! ! Read the basis namelist & check if the values were supplied correctly:       ! !------------------------------------------------------------------------------! read ( unit = 5 , nml = BASIS , iostat = io_status , iomsg = err_message ) call file_io_status ( io_status , err_message , 5 , 'r' ) call check_namelist_basis !------------------------------------------------------------------------------! ! If itype = 2/4 the code reads all the total_number_of_coupling_terms coupling terms, but some of   ! ! them will not be used in the calculations. Here, the code prepares           ! ! the arrays of minimal_number_of_coupling_terms size, that will hold only the necessary terms           ! !------------------------------------------------------------------------------! minimal_number_of_coupling_terms = nlevel * ( nlevel + 1 ) / 2 call allocate_1d ( reduced_j1pes , minimal_number_of_coupling_terms ) call allocate_1d ( reduced_j1ppes , minimal_number_of_coupling_terms ) call allocate_1d ( reduced_v1pes , minimal_number_of_coupling_terms ) call allocate_1d ( reduced_v1ppes , minimal_number_of_coupling_terms ) icoupl = 0 do ilevel = 1 , nlevel do iilevel = ilevel , nlevel icoupl = icoupl + 1 reduced_v1pes ( icoupl ) = v1array ( ilevel ) reduced_j1pes ( icoupl ) = j1array ( ilevel ) reduced_v1ppes ( icoupl ) = v1array ( iilevel ) reduced_j1ppes ( icoupl ) = j1array ( iilevel ) enddo enddo !------------------------------------------------------------------------------! ! Read the potential namelist & check if the values were supplied correctly:   ! !------------------------------------------------------------------------------! read ( unit = 5 , nml = POTENTIAL , iostat = io_status , iomsg = err_message ) call file_io_status ( io_status , err_message , 5 , 'r' ) call check_namelist_potential close ( 5 ) !------------------------------------------------------------------------------! ! Prepare the arrays that are needed for interpolation of the coupling terms:  ! !------------------------------------------------------------------------------! call allocate_1d ( rmat , nr ) call allocate_3d ( read_vmat3D , nr , nterms , total_number_of_coupling_terms ) call allocate_3d ( vmat3D , nr , nterms , minimal_number_of_coupling_terms ) call allocate_3d ( bmat3D , nr , nterms , minimal_number_of_coupling_terms ) call allocate_3d ( cmat3D , nr , nterms , minimal_number_of_coupling_terms ) call allocate_3d ( dmat3D , nr , nterms , minimal_number_of_coupling_terms ) !------------------------------------------------------------------------------! ! Summarize the input parameters:                                              ! !------------------------------------------------------------------------------! call input_summary end subroutine read_input_file","tags":"","loc":"proc/read_input_file.html"},{"title":"save_open_basis_levels – the SCATTERING code","text":"public  subroutine save_open_basis_levels(number_of_open_basis_levels, open_basis_levels, open_basis_wavevectors) saves indices to open levels in the basis and corresponding\nwavenumbers (in A&#94;2) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: number_of_open_basis_levels number of energetically accessible levels in the basis integer(kind=int32), intent(inout), allocatable :: open_basis_levels (:) array holding indices to energetically accessible levels in the basis real(kind=dp), intent(inout), allocatable :: open_basis_wavevectors (:) array holding wavevectors calculated w.r.t energetically accessible levels in the basis Calls proc~~save_open_basis_levels~~CallsGraph proc~save_open_basis_levels save_open_basis_levels interface~allocate_1d allocate_1d proc~save_open_basis_levels->interface~allocate_1d proc~is_open is_open proc~save_open_basis_levels->proc~is_open proc~wavenumber_squared_from_energy wavenumber_squared_from_energy proc~save_open_basis_levels->proc~wavenumber_squared_from_energy proc~etotal ETOTAL proc~is_open->proc~etotal proc~wavenumber_squared_from_energy->proc~etotal proc~write_error write_error proc~wavenumber_squared_from_energy->proc~write_error proc~write_message write_message proc~write_error->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~save_open_basis_levels~~CalledByGraph proc~save_open_basis_levels save_open_basis_levels program~scattering SCATTERING program~scattering->proc~save_open_basis_levels Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables count_ ilevel Source Code save_open_basis_levels Variables Type Visibility Attributes Name Initial integer(kind=int32), public :: count_ integer(kind=int32), public :: ilevel Source Code subroutine save_open_basis_levels ( number_of_open_basis_levels , & open_basis_levels , open_basis_wavevectors ) !! saves indices to open levels in the basis and corresponding !! wavenumbers (in A&#94;2) !------------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: number_of_open_basis_levels !! number of energetically accessible levels in the basis integer ( int32 ), intent ( inout ), allocatable :: open_basis_levels (:) !! array holding indices to energetically accessible levels in the basis real ( dp ), intent ( inout ), allocatable :: open_basis_wavevectors (:) !! array holding wavevectors calculated w.r.t energetically accessible levels in the basis !------------------------------------------------------------------------! integer ( int32 ) :: count_ , ilevel !------------------------------------------------------------------------! call allocate_1d ( open_basis_levels , number_of_open_basis_levels ) call allocate_1d ( open_basis_wavevectors , number_of_open_basis_levels ) !------------------------------------------------------------------------! count_ = 0 do ilevel = 1 , nlevel if ( is_open ( elevel ( ilevel ))) then count_ = count_ + 1 open_basis_levels ( count_ ) = ilevel open_basis_wavevectors ( count_ ) = & sqrt ( wavenumber_squared_from_energy ( elevel ( ilevel )) ) / bohrtoangstrom endif enddo !------------------------------------------------------------------------! end subroutine save_open_basis_levels","tags":"","loc":"proc/save_open_basis_levels.html"},{"title":"units_conversion – the SCATTERING code","text":"public  subroutine units_conversion() converts all physical quantities to atomic units Arguments None Called by proc~~units_conversion~~CalledByGraph proc~units_conversion units_conversion program~scattering SCATTERING program~scattering->proc~units_conversion Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables ilevel Source Code units_conversion Variables Type Visibility Attributes Name Initial integer(kind=int32), public :: ilevel Source Code subroutine units_conversion !! converts all physical quantities to atomic units !------------------------------------------------------------------------! integer ( int32 ) :: ilevel !------------------------------------------------------------------------! reduced_mass = reduced_mass * amutoau energy = energy / hartreetocm vdepth = vdepth / hartreetocm !------------------------------------------------------------------------! do ilevel = 1 , nlevel elevel ( ilevel ) = elevel ( ilevel ) / hartreetocm enddo !------------------------------------------------------------------------! units_converted = . true . !------------------------------------------------------------------------! end subroutine units_conversion","tags":"","loc":"proc/units_conversion.html"},{"title":"is_sum_even – the SCATTERING code","text":"public  function is_sum_even(x, y, z) result(sum_even) checks if the sum of 3 integers is an even integer Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x variables to check if the sum is even integer(kind=int32), intent(in) :: y variables to check if the sum is even integer(kind=int32), intent(in) :: z variables to check if the sum is even Return Value logical (out) result: true/false Called by proc~~is_sum_even~~CalledByGraph proc~is_sum_even is_sum_even proc~zero_projections_3j_condition zero_projections_3j_condition proc~zero_projections_3j_condition->proc~is_sum_even proc~check_nonzero_pes_matrix_elements check_nonzero_pes_matrix_elements proc~check_nonzero_pes_matrix_elements->proc~zero_projections_3j_condition program~scattering SCATTERING program~scattering->proc~check_nonzero_pes_matrix_elements Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code is_sum_even Source Code function is_sum_even ( x , y , z ) result ( sum_even ) !! checks if the sum of 3 integers is an even integer !------------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: x , y , z !! variables to check if the sum is even logical :: sum_even !! (out) result: true/false !------------------------------------------------------------------------! sum_even = ( modulo ( x + y + z , 2 ) == 0 ) !------------------------------------------------------------------------! end function is_sum_even","tags":"","loc":"proc/is_sum_even.html"},{"title":"ispline – the SCATTERING code","text":"public  function ispline(u_, N_, x_, y_, b_, c_, d_) result(spl_result) returns interpolated value at guven u_ point\nnumber of points and ascending order of x is not checked since\nispline is called after \"spline\" where these checks are done Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: u_ point at which the tabulated value is interpolated integer(kind=int32), intent(in) :: N_ number of grid points real(kind=dp), intent(in) :: x_ (N_) grid points real(kind=dp), intent(in) :: y_ (N_) tabulated values real(kind=dp), intent(in) :: b_ (N_) arrays with coefficients of the spline function real(kind=dp), intent(in) :: c_ (N_) arrays with coefficients of the spline function real(kind=dp), intent(in) :: d_ (N_) arrays with coefficients of the spline function Return Value real(kind=dp) interpolated value at u_ Calls proc~~ispline~~CallsGraph proc~ispline ispline proc~float_to_character float_to_character proc~ispline->proc~float_to_character proc~write_warning write_warning proc~ispline->proc~write_warning proc~write_message write_message proc~write_warning->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~ispline~~CalledByGraph proc~ispline ispline proc~get_radial_coupling_term_value get_radial_coupling_term_value proc~get_radial_coupling_term_value->proc~ispline Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables dx_ k_ l_ mid_ Source Code ispline Variables Type Visibility Attributes Name Initial real(kind=dp), public :: dx_ integer(kind=int32), public :: k_ integer(kind=int32), public :: l_ integer(kind=int32), public :: mid_ Source Code function ispline ( u_ , N_ , x_ , y_ , b_ , c_ , d_ ) result ( spl_result ) !! returns interpolated value at guven u_ point !! number of points and ascending order of x is not checked since !! ispline is called after \"spline\" where these checks are done !------------------------------------------------------------------------! real ( dp ), intent ( in ) :: u_ !! point at which the tabulated value is interpolated integer ( int32 ), intent ( in ) :: N_ !! number of grid points real ( dp ), intent ( in ) :: x_ ( N_ ) !! grid points real ( dp ), intent ( in ) :: y_ ( N_ ) !! tabulated values real ( dp ), intent ( in ) :: b_ ( N_ ), c_ ( N_ ), d_ ( N_ ) !! arrays with coefficients of the spline function real ( dp ) :: spl_result !! interpolated value at u_ !------------------------------------------------------------------------! integer ( int32 ) :: k_ , l_ , mid_ real ( dp ) :: dx_ !------------------------------------------------------------------------! if ( u_ > x_ ( N_ )) then call write_warning ( \"ispline: point u_ = \" // & trim ( adjustl ( float_to_character ( u_ ))) // \" exceeds the original \" & // \"grid: x(N) = \" // trim ( adjustl ( float_to_character ( x_ ( N_ ))))) spl_result = y_ ( N_ ) else if ( u_ < x_ ( 1 ) ) then call write_warning ( \"ispline: point u_ = \" // & trim ( adjustl ( float_to_character ( u_ ))) // \" exceeds the original \" & // \"grid: x(1) = \" // trim ( adjustl ( float_to_character ( x_ ( 1 ))))) spl_result = y_ ( 1 ) else !---------------------------------------------------------------------! l_ = 1 k_ = N_ + 1 do while ( k_ > l_ + 1 ) mid_ = nint ( ( l_ + k_ ) / 2.0_dp ) if ( x_ ( mid_ ) > u_ ) then k_ = mid_ else l_ = mid_ endif end do dx_ = u_ - x_ ( l_ ) spl_result = y_ ( l_ ) + dx_ * ( b_ ( l_ ) + dx_ * ( c_ ( l_ ) + d_ ( l_ ) * dx_ )) !---------------------------------------------------------------------! endif !------------------------------------------------------------------------! end function ispline","tags":"","loc":"proc/ispline.html"},{"title":"percival_seaton_coefficient – the SCATTERING code","text":"public  function percival_seaton_coefficient(j_, j_prime_, lambda_, omega_) result(percival_seaton_coefficient_) Uses fwigxjpf proc~~percival_seaton_coefficient~~UsesGraph proc~percival_seaton_coefficient percival_seaton_coefficient fwigxjpf fwigxjpf proc~percival_seaton_coefficient->fwigxjpf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. calculates Percival-Seaton coefficients (body-fixed variant) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: j_ pre-collisional rotational angular momentum integer(kind=int32), intent(in) :: j_prime_ post-collisional rotational angular momentum integer(kind=int32), intent(in) :: lambda_ Legendre expansion coefficient  \\lambda integer(kind=int32), intent(in) :: omega_ \\bar{\\Omega} Return Value real(kind=dp) (out) result: percival seaton coefficient in the body-fixed frame Calls proc~~percival_seaton_coefficient~~CallsGraph proc~percival_seaton_coefficient percival_seaton_coefficient fwig3jj fwig3jj proc~percival_seaton_coefficient->fwig3jj Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code percival_seaton_coefficient Source Code function percival_seaton_coefficient ( j_ , j_prime_ , lambda_ , omega_ ) & result ( percival_seaton_coefficient_ ) !! calculates Percival-Seaton coefficients (body-fixed variant) !! \\begin{equation} !! \\label{eq:algebraic_coeffs} !! g_{{\\lambda},\\gamma,\\gamma'}&#94;{Jp} = \\delta_{\\bar{\\Omega},\\bar{\\Omega}'} (-1)&#94;{\\bar{\\Omega}} \\sqrt{(2j+1)(2j'+1)} !! \\begin{pmatrix} !!   j & j' & \\lambda \\\\ 0 & 0 & 0 !! \\end{pmatrix} !! \\begin{pmatrix} !! j & j' & \\lambda \\\\ \\bar{\\Omega} & -\\bar{\\Omega} & 0 \\end{pmatrix}. !! \\end{equation} !------------------------------------------------------------------------! use fwigxjpf , only : fwig3jj !------------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: j_ !! pre-collisional rotational angular momentum integer ( int32 ), intent ( in ) :: j_prime_ !! post-collisional rotational angular momentum integer ( int32 ), intent ( in ) :: omega_ !! \\\\bar{\\Omega}\\ integer ( int32 ), intent ( in ) :: lambda_ !! Legendre expansion coefficient \\ \\lambda\\ real ( dp ) :: percival_seaton_coefficient_ !! (out) result: percival seaton coefficient in the body-fixed frame !------------------------------------------------------------------------! percival_seaton_coefficient_ = ( - 1.0_dp ) ** ( omega_ ) * sqrt ( & real (( 2 * j_ + 1 ) * ( 2 * j_prime_ + 1 ), dp )) & * fwig3jj ( 2 * j_ , 2 * j_prime_ , 2 * lambda_ , 0 , 0 , 0 ) & * fwig3jj ( 2 * j_ , 2 * j_prime_ , 2 * lambda_ , & 2 * omega_ , - 2 * omega_ , 0 ) !------------------------------------------------------------------------! end function percival_seaton_coefficient","tags":"","loc":"proc/percival_seaton_coefficient.html"},{"title":"rgamma – the SCATTERING code","text":"public  function rgamma(x, odd, even) result(rgamma_val) Calculates 1/Gamma(1-X); modernized version of Molscat's\n rgamma function; see:\n https://github.com/molscat/molscat/blob/36fa8f93a92f851e9d84245dd6a972e2910541c5/source_code/rbesjy.f\n-----------------------------------------------------------------------! Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x real(kind=dp), intent(out) :: odd real(kind=dp), intent(out) :: even Return Value real(kind=dp) Called by proc~~rgamma~~CalledByGraph proc~rgamma rgamma proc~modified_bessel_temme_algorithm modified_bessel_temme_algorithm proc~modified_bessel_temme_algorithm->proc~rgamma proc~modified_bessel_k_ratio modified_bessel_k_ratio proc~modified_bessel_k_ratio->proc~modified_bessel_temme_algorithm proc~calculate_k_matrix calculate_k_matrix proc~calculate_k_matrix->proc~modified_bessel_k_ratio program~scattering SCATTERING program~scattering->proc~calculate_k_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables alfa b beta i x2 Source Code rgamma Variables Type Visibility Attributes Name Initial real(kind=dp), public :: alfa real(kind=dp), public, dimension(12), save :: b = [-0.283876542276024_dp, -0.076852840844786_dp, 0.001706305071096_dp, 0.001271927136655_dp, 0.000076309597586_dp, -0.000004971736704_dp, -0.000000865920800_dp, -0.000000033126120_dp, 0.000000001745136_dp, 0.000000000242310_dp, 0.000000000009161_dp, -0.000000000000170_dp] real(kind=dp), public :: beta integer, public :: i real(kind=dp), public :: x2 Source Code function rgamma ( x , odd , even ) result ( rgamma_val ) !! Calculates 1/Gamma(1-X); modernized version of Molscat's !! rgamma function; see: !! https://github.com/molscat/molscat/blob/36fa8f93a92f851e9d84245dd6a972e2910541c5/source_code/rbesjy.f !!-----------------------------------------------------------------------! real ( dp ), intent ( in ) :: x real ( dp ), intent ( out ) :: odd , even real ( dp ) :: rgamma_val , x2 , alfa , beta integer :: i real ( dp ), dimension ( 12 ), save :: b = [ & - 0.283876542276024_dp , - 0.076852840844786_dp , & 0.001706305071096_dp , 0.001271927136655_dp , & 0.000076309597586_dp , - 0.000004971736704_dp , & - 0.000000865920800_dp , - 0.000000033126120_dp , & 0.000000001745136_dp , 0.000000000242310_dp , & 0.000000000009161_dp , - 0.000000000000170_dp ] x2 = x * x * 8.0_dp alfa = - 0.000000000000001_dp beta = 0.0_dp do i = 12 , 2 , - 2 beta = - ( 2 * alfa + beta ) alfa = - beta * x2 - alfa + b ( i ) end do even = ( beta / 2.0_dp + alfa ) * x2 - alfa + 0.921870293650453_dp alfa = - 0.000000000000034_dp beta = 0.0_dp do i = 11 , 1 , - 2 beta = - ( 2 * alfa + beta ) alfa = - beta * x2 - alfa + b ( i ) end do odd = 2 * ( alfa + beta ) rgamma_val = odd * x + even end function rgamma","tags":"","loc":"proc/rgamma.html"},{"title":"triangle_inequality_holds – the SCATTERING code","text":"public  function triangle_inequality_holds(x, y, z) result(holds) check if the triangle inequality for 3 variables hols Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x variables to check the triangle inequality integer(kind=int32), intent(in) :: y variables to check the triangle inequality integer(kind=int32), intent(in) :: z variables to check the triangle inequality Return Value logical (out) result: true/false Called by proc~~triangle_inequality_holds~~CalledByGraph proc~triangle_inequality_holds triangle_inequality_holds proc~zero_projections_3j_condition zero_projections_3j_condition proc~zero_projections_3j_condition->proc~triangle_inequality_holds proc~check_nonzero_pes_matrix_elements check_nonzero_pes_matrix_elements proc~check_nonzero_pes_matrix_elements->proc~zero_projections_3j_condition program~scattering SCATTERING program~scattering->proc~check_nonzero_pes_matrix_elements Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code triangle_inequality_holds Source Code function triangle_inequality_holds ( x , y , z ) result ( holds ) !! check if the triangle inequality for 3 variables hols !------------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: x , y , z !! variables to check the triangle inequality logical :: holds !! (out) result: true/false !------------------------------------------------------------------------! holds = ( ( x + y >= z ) . and . ( x + z >= y ) . and . ( y + z >= x ) ) !------------------------------------------------------------------------! end function triangle_inequality_holds","tags":"","loc":"proc/triangle_inequality_holds.html"},{"title":"zero_projections_3j_condition – the SCATTERING code","text":"public  function zero_projections_3j_condition(x, y, z) result(is_valid) checks the condition for nonvanishing 3-j symbol with zero projections:\ntriangle inequality on x,y,z and if the sum x+y+z is an even integer Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x variables to check for 3-j symbol conditions integer(kind=int32), intent(in) :: y variables to check for 3-j symbol conditions integer(kind=int32), intent(in) :: z variables to check for 3-j symbol conditions Return Value logical (out) result: true/false if conditions are met Calls proc~~zero_projections_3j_condition~~CallsGraph proc~zero_projections_3j_condition zero_projections_3j_condition proc~triangle_inequality_holds triangle_inequality_holds proc~zero_projections_3j_condition->proc~triangle_inequality_holds proc~is_sum_even is_sum_even proc~zero_projections_3j_condition->proc~is_sum_even Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~zero_projections_3j_condition~~CalledByGraph proc~zero_projections_3j_condition zero_projections_3j_condition proc~check_nonzero_pes_matrix_elements check_nonzero_pes_matrix_elements proc~check_nonzero_pes_matrix_elements->proc~zero_projections_3j_condition program~scattering SCATTERING program~scattering->proc~check_nonzero_pes_matrix_elements Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code zero_projections_3j_condition Source Code function zero_projections_3j_condition ( x , y , z ) result ( is_valid ) !! checks the condition for nonvanishing 3-j symbol with zero projections: !! triangle inequality on x,y,z and if the sum x+y+z is an even integer !------------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: x , y , z !! variables to check for 3-j symbol conditions logical :: is_valid !! (out) result: true/false if conditions are met !------------------------------------------------------------------------! is_valid = ( triangle_inequality_holds ( x , y , z ) . and . is_sum_even ( x , y , z )) !------------------------------------------------------------------------! end function zero_projections_3j_condition","tags":"","loc":"proc/zero_projections_3j_condition.html"},{"title":"modified_bessel_k_ratio – the SCATTERING code","text":"public  subroutine modified_bessel_k_ratio(l_, x_, ratio_) calculates the ratio of the modified Bessel function of the second\nkind K_{l_ + 1/2}(x) and its first derivative (Eq. 8 in the\n\"Solution of the coupled equations\" section)\nUses Temme's algorithm [N. M. Temme, J. Comput. Phys. 19 (1975) 324],\nimplemented in \"modified_bessel_temme_algorithm\" subroutine;\nUnfortunately, the \"ikv\" function from special_functions\nlibrary failed at large x_ values. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: l_ l - order of the function (without the 1/2 factor!) real(kind=dp), intent(in) :: x_ x - argument of the function real(kind=dp), intent(inout) :: ratio_ ratio of the modified Bessel function of the second kind to its derivative Calls proc~~modified_bessel_k_ratio~~CallsGraph proc~modified_bessel_k_ratio modified_bessel_k_ratio proc~modified_bessel_temme_algorithm modified_bessel_temme_algorithm proc~modified_bessel_k_ratio->proc~modified_bessel_temme_algorithm proc~write_error write_error proc~modified_bessel_temme_algorithm->proc~write_error proc~rgamma rgamma proc~modified_bessel_temme_algorithm->proc~rgamma proc~write_message write_message proc~write_error->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~modified_bessel_k_ratio~~CalledByGraph proc~modified_bessel_k_ratio modified_bessel_k_ratio proc~calculate_k_matrix calculate_k_matrix proc~calculate_k_matrix->proc~modified_bessel_k_ratio program~scattering SCATTERING program~scattering->proc~calculate_k_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables ck_ dk_ ek_ order_ Source Code modified_bessel_k_ratio Variables Type Visibility Attributes Name Initial real(kind=dp), public :: ck_ real(kind=dp), public :: dk_ real(kind=dp), public :: ek_ real(kind=dp), public :: order_ Source Code subroutine modified_bessel_k_ratio ( l_ , x_ , ratio_ ) !! calculates the ratio of the modified Bessel function of the second !! kind K_{l_ + 1/2}(x) and its first derivative (Eq. 8 in the !! \"Solution of the coupled equations\" section) !! Uses Temme's algorithm [N. M. Temme, J. Comput. Phys. 19 (1975) 324], !! implemented in \"modified_bessel_temme_algorithm\" subroutine; !! Unfortunately, the \"ikv\" function from special_functions !! library failed at large x_ values. !------------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: l_ !! l - order of the function (without the 1/2 factor!) real ( dp ), intent ( in ) :: x_ !! x - argument of the function real ( dp ), intent ( inout ) :: ratio_ !! ratio of the modified Bessel function of the second kind to its derivative !------------------------------------------------------------------------! real ( dp ) :: order_ , ck_ , dk_ , ek_ !------------------------------------------------------------------------! order_ = real ( l_ , dp ) + 0.5_dp call modified_bessel_temme_algorithm ( order_ , x_ , ck_ , dk_ , ek_ ) ratio_ = dk_ / ck_ !------------------------------------------------------------------------! end subroutine modified_bessel_k_ratio","tags":"","loc":"proc/modified_bessel_k_ratio.html"},{"title":"modified_bessel_temme_algorithm – the SCATTERING code","text":"public  subroutine modified_bessel_temme_algorithm(v, x, ck, dk, ek) Implementation of the Temme's algorithm\n[N. M. Temme, J. Comput. Phys. 19 (1975) 324] to calculating\nmodified Bessel functions of the second kind.\nThis is a direct modernization of the \"mbessk\" subroutine\nin MOLSCAT:\nhttps://github.com/molscat/molscat/blob/master/source_code/rbessk.f Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: v real(kind=dp), intent(in) :: x real(kind=dp), intent(out) :: ck real(kind=dp), intent(out) :: dk real(kind=dp), intent(out) :: ek Calls proc~~modified_bessel_temme_algorithm~~CallsGraph proc~modified_bessel_temme_algorithm modified_bessel_temme_algorithm proc~write_error write_error proc~modified_bessel_temme_algorithm->proc~write_error proc~rgamma rgamma proc~modified_bessel_temme_algorithm->proc~rgamma proc~write_message write_message proc~write_error->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~modified_bessel_temme_algorithm~~CalledByGraph proc~modified_bessel_temme_algorithm modified_bessel_temme_algorithm proc~modified_bessel_k_ratio modified_bessel_k_ratio proc~modified_bessel_k_ratio->proc~modified_bessel_temme_algorithm proc~calculate_k_matrix calculate_k_matrix proc~calculate_k_matrix->proc~modified_bessel_k_ratio program~scattering SCATTERING program~scattering->proc~calculate_k_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables a ak ak1 b c d e eps ex f g h m maxit n na p pi q s sk xmin y Source Code modified_bessel_temme_algorithm Variables Type Visibility Attributes Name Initial real(kind=dp), public :: a real(kind=dp), public :: ak real(kind=dp), public :: ak1 real(kind=dp), public :: b real(kind=dp), public :: c real(kind=dp), public :: d real(kind=dp), public :: e real(kind=dp), public, parameter :: eps = 1.0e-15_dp real(kind=dp), public :: ex real(kind=dp), public :: f real(kind=dp), public :: g real(kind=dp), public :: h integer, public :: m integer, public :: maxit integer, public :: n integer, public :: na real(kind=dp), public :: p real(kind=dp), public :: pi real(kind=dp), public :: q real(kind=dp), public :: s real(kind=dp), public :: sk real(kind=dp), public, parameter :: xmin = 1.0_dp real(kind=dp), public :: y Source Code subroutine modified_bessel_temme_algorithm ( v , x , ck , dk , ek ) !! Implementation of the Temme's algorithm !! [N. M. Temme, J. Comput. Phys. 19 (1975) 324] to calculating !! modified Bessel functions of the second kind. !! This is a direct modernization of the \"mbessk\" subroutine !! in MOLSCAT: !! https://github.com/molscat/molscat/blob/master/source_code/rbessk.f !------------------------------------------------------------------------! real ( dp ), intent ( in ) :: v , x real ( dp ), intent ( out ) :: ck , dk , ek real ( dp ) :: a , b , c , d , e , f , g , h , p , q , s , sk , y , ak , ak1 , ex , pi integer :: n , m , na , maxit real ( dp ), parameter :: eps = 1.0e-15_dp , xmin = 1.0_dp !------------------------------------------------------------------------! pi = acos ( - 1.0_dp ) if ( v < 0.0_dp . or . x <= 0.0_dp ) then call write_error ( \"modified_bessel_temme_algorithm: Invalid input values for v or x\" ) endif na = int ( v + 0.5_dp ) a = v - na if ( x < xmin ) then ! Small x: Temme's series for small x b = x / 2.0_dp d = - log ( b ) e = a * d c = a * pi if ( abs ( c ) < eps ) then c = 1.0_dp else c = c / sin ( c ) endif if ( abs ( e ) < eps ) then s = 1.0_dp else s = sinh ( e ) / e endif e = exp ( e ) ! Compute the gamma function and its derivatives P and Q ! Replace RGAMMA(A,P,Q) with a modern equivalent if necessary g = e * rgamma ( a , p , q ) e = ( e + 1.0_dp / e ) / 2.0_dp f = c * ( p * e + q * s * d ) e = a * a p = 0.5_dp * g * c q = 0.5_dp / g c = 1.0_dp d = b * b ak = f ak1 = p do n = 1 , maxit f = ( f * n + p + q ) / ( n * n - e ) c = c * d / n p = p / ( n - a ) q = q / ( n + a ) g = c * ( p - n * f ) h = c * f ak = ak + h ak1 = ak1 + g if ( abs ( h / ak ) + abs ( g / ak1 ) < eps ) exit end do f = ak g = ak1 / b ex = 0.0_dp else ! Large x: Temme's PQ method for large x c = 0.25_dp - a * a g = 1.0_dp f = 0.0_dp e = x * cos ( a * pi ) / pi / eps do n = 1 , maxit h = ( 2 * ( n + x ) * g - ( n - 1 + c / n ) * f ) / ( n + 1 ) f = g g = h if ( h * n > e ) exit end do p = f / g q = p b = x + x e = b - 2.0_dp do m = n , 1 , - 1 p = ( m - 1 + c / m ) / ( e + ( m + 1 ) * ( 2.0_dp - p )) q = p * ( q + 1.0_dp ) end do f = sqrt ( pi / b ) / ( 1.0_dp + q ) g = f * ( a + x + 0.5_dp - p ) / x ex = x endif ! Upward recursion p = 0.0_dp if ( na > 0 ) then y = 2.0_dp / x do n = 1 , na h = y * ( a + n ) * g + f f = g g = h if ( abs ( f ) > 4.0_dp ) then p = p + 1.0_dp f = 0.0625_dp * f g = 0.0625_dp * g endif end do endif ck = f dk = ( v / x ) * f - g sk = sqrt ( ck * ck + dk * dk ) ck = ck / sk dk = dk / sk ek = log ( sk ) + p * log ( 1 6.0_dp ) - ex end subroutine modified_bessel_temme_algorithm","tags":"","loc":"proc/modified_bessel_temme_algorithm.html"},{"title":"riccati_bessel_j – the SCATTERING code","text":"public  subroutine riccati_bessel_j(l_, x_, j_, jp_) calculates the Riccati-Bessel function of the first kind and its\nfirst derivative. Calls the rctj function from special_functions.f90 Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: l_ l - order of the Riccati-Bessel function of the first kind real(kind=dp), intent(in) :: x_ x - argument of the Riccati-Bessel function of the first kind real(kind=dp), intent(inout) :: j_ j_{l} (x) - Riccati-Bessel funciton of the first kind real(kind=dp), intent(inout) :: jp_ j_{l}' (x) - derivative of the Riccati-Bessel funciton of the first kind Calls proc~~riccati_bessel_j~~CallsGraph proc~riccati_bessel_j riccati_bessel_j proc~rctj rctj proc~riccati_bessel_j->proc~rctj proc~integer_to_character integer_to_character proc~riccati_bessel_j->proc~integer_to_character proc~write_warning write_warning proc~riccati_bessel_j->proc~write_warning proc~msta1 msta1 proc~rctj->proc~msta1 proc~msta2 msta2 proc~rctj->proc~msta2 proc~write_message write_message proc~write_warning->proc~write_message proc~envj envj proc~msta1->proc~envj proc~msta2->proc~envj Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~riccati_bessel_j~~CalledByGraph proc~riccati_bessel_j riccati_bessel_j proc~calculate_k_matrix calculate_k_matrix proc~calculate_k_matrix->proc~riccati_bessel_j program~scattering SCATTERING program~scattering->proc~calculate_k_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables dj_ highest_order_ rj_ Source Code riccati_bessel_j Variables Type Visibility Attributes Name Initial real(kind=dp), public, dimension(l_+1) :: dj_ integer(kind=int32), public :: highest_order_ real(kind=dp), public, dimension(l_+1) :: rj_ Source Code subroutine riccati_bessel_j ( l_ , x_ , j_ , jp_ ) !! calculates the Riccati-Bessel function of the first kind and its !! first derivative. Calls the rctj function from special_functions.f90 !------------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: l_ !! l - order of the Riccati-Bessel function of the first kind real ( dp ), intent ( in ) :: x_ !! x - argument of the Riccati-Bessel function of the first kind real ( dp ), intent ( inout ) :: j_ !! j_{l} (x) - Riccati-Bessel funciton of the first kind real ( dp ), intent ( inout ) :: jp_ !! j_{l}' (x) - derivative of the Riccati-Bessel funciton of the first kind !------------------------------------------------------------------------! integer ( int32 ) :: highest_order_ real ( dp ), dimension ( l_ + 1 ) :: rj_ , dj_ !------------------------------------------------------------------------! if ( l_ == 0 ) then call rctj ( l_ + 1 , x_ , highest_order_ , rj_ , dj_ ) else call rctj ( l_ , x_ , highest_order_ , rj_ , dj_ ) endif if ( highest_order_ < l_ ) then !---------------------------------------------------------------------! call write_warning ( \"riccati_bessel_j: maximum order of Riccati-Bessel function:\" & // trim ( adjustl ( integer_to_character ( highest_order_ ))) // \"is smaller than \" // & \"requested order l = \" // trim ( adjustl ( integer_to_character ( l_ ))) ) !---------------------------------------------------------------------! j_ = rj_ ( highest_order_ ) jp_ = dj_ ( highest_order_ ) else j_ = rj_ ( l_ + 1 ) jp_ = dj_ ( l_ + 1 ) endif !------------------------------------------------------------------------! end subroutine riccati_bessel_j","tags":"","loc":"proc/riccati_bessel_j.html"},{"title":"riccati_bessel_y – the SCATTERING code","text":"public  subroutine riccati_bessel_y(l_, x_, y_, yp_) calculates the Riccati-Bessel function of the second kind and its\nfirst derivative. Calls the rcty function from special_functions.f90 Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: l_ l - order of the Riccati-Bessel function of the second kind real(kind=dp), intent(in) :: x_ x - argument of the Riccati-Bessel function of the second kind real(kind=dp), intent(inout) :: y_ y_{l} (x) - Riccati-Bessel funciton of the second kind real(kind=dp), intent(inout) :: yp_ y_{l}' (x) - derivative of the Riccati-Bessel funciton of the second kind Calls proc~~riccati_bessel_y~~CallsGraph proc~riccati_bessel_y riccati_bessel_y proc~rcty rcty proc~riccati_bessel_y->proc~rcty proc~integer_to_character integer_to_character proc~riccati_bessel_y->proc~integer_to_character proc~write_warning write_warning proc~riccati_bessel_y->proc~write_warning proc~write_message write_message proc~write_warning->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~riccati_bessel_y~~CalledByGraph proc~riccati_bessel_y riccati_bessel_y proc~calculate_k_matrix calculate_k_matrix proc~calculate_k_matrix->proc~riccati_bessel_y program~scattering SCATTERING program~scattering->proc~calculate_k_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables dy_ highest_order_ ry_ Source Code riccati_bessel_y Variables Type Visibility Attributes Name Initial real(kind=dp), public, dimension(l_+1) :: dy_ integer(kind=int32), public :: highest_order_ real(kind=dp), public, dimension(l_+1) :: ry_ Source Code subroutine riccati_bessel_y ( l_ , x_ , y_ , yp_ ) !! calculates the Riccati-Bessel function of the second kind and its !! first derivative. Calls the rcty function from special_functions.f90 !------------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: l_ !! l - order of the Riccati-Bessel function of the second kind real ( dp ), intent ( in ) :: x_ !! x - argument of the Riccati-Bessel function of the second kind real ( dp ), intent ( inout ) :: y_ !! y_{l} (x) - Riccati-Bessel funciton of the second kind real ( dp ), intent ( inout ) :: yp_ !! y_{l}' (x) - derivative of the Riccati-Bessel funciton of the second kind !------------------------------------------------------------------------! integer ( int32 ) :: highest_order_ real ( dp ), dimension ( l_ + 1 ) :: ry_ , dy_ !------------------------------------------------------------------------! if ( l_ == 0 ) then call rcty ( l_ + 1 , x_ , highest_order_ , ry_ , dy_ ) else call rcty ( l_ , x_ , highest_order_ , ry_ , dy_ ) endif y_ = ry_ ( l_ + 1 ) yp_ = dy_ ( l_ + 1 ) !------------------------------------------------------------------------! if ( highest_order_ < l_ ) then !---------------------------------------------------------------------! call write_warning ( \"riccati_bessel_j: maximum order of Riccati-Bessel function:\" & // trim ( adjustl ( integer_to_character ( highest_order_ ))) // \"is smaller than \" // & \"requested order l = \" // trim ( adjustl ( integer_to_character ( l_ ))) ) !---------------------------------------------------------------------! y_ = ry_ ( highest_order_ ) yp_ = dy_ ( highest_order_ ) else y_ = ry_ ( l_ + 1 ) yp_ = dy_ ( l_ + 1 ) endif !------------------------------------------------------------------------! end subroutine riccati_bessel_y","tags":"","loc":"proc/riccati_bessel_y.html"},{"title":"spline – the SCATTERING code","text":"public  subroutine spline(N_, x_, y_, b_, c_, d_) determines b, c and d coefficients of the cubic spline function\ny(x) = y_i + b_i * dx + c_i * dx&#94;2 + d_i * dx&#94;3,\nwhere dx = x - x_i, and x_i <= x < x_i+1.\nThe algorithm is based on\nGerald, C., and Wheatley, P., \"Applied Numerical Analysis\", Addison-Wesley, 1994. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: N_ number of grid points real(kind=dp), intent(in) :: x_ (N_) grid points (ascending order) real(kind=dp), intent(in) :: y_ (N_) tabulated values real(kind=dp), intent(out) :: b_ (N_) arrays with coefficients of the spline function real(kind=dp), intent(out) :: c_ (N_) arrays with coefficients of the spline function real(kind=dp), intent(out) :: d_ (N_) arrays with coefficients of the spline function Calls proc~~spline~~CallsGraph proc~spline spline proc~integer_to_character integer_to_character proc~spline->proc~integer_to_character proc~write_error write_error proc~spline->proc~write_error proc~write_message write_message proc~write_error->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~spline~~CalledByGraph proc~spline spline proc~interpolate_radial_coupling_terms interpolate_radial_coupling_terms proc~interpolate_radial_coupling_terms->proc~spline program~scattering SCATTERING program~scattering->proc~interpolate_radial_coupling_terms Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables diff_x_ i_ j_ w_ Source Code spline Variables Type Visibility Attributes Name Initial real(kind=dp), public :: diff_x_ (N_-1) integer(kind=int32), public :: i_ integer(kind=int32), public :: j_ real(kind=dp), public :: w_ Source Code subroutine spline ( N_ , x_ , y_ , b_ , c_ , d_ ) !! determines b, c and d coefficients of the cubic spline function !! y(x) = y_i + b_i * dx + c_i * dx&#94;2 + d_i * dx&#94;3, !! where dx = x - x_i, and x_i <= x < x_i+1. !! The algorithm is based on !! Gerald, C., and Wheatley, P., \"Applied Numerical Analysis\", Addison-Wesley, 1994. !------------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: N_ !! number of grid points real ( dp ), intent ( in ) :: x_ ( N_ ) !! grid points (ascending order) real ( dp ), intent ( in ) :: y_ ( N_ ) !! tabulated values real ( dp ), intent ( out ) :: b_ ( N_ ), c_ ( N_ ), d_ ( N_ ) !! arrays with coefficients of the spline function !------------------------------------------------------------------------! integer ( int32 ) :: i_ , j_ real ( dp ) :: w_ real ( dp ) :: diff_x_ ( N_ - 1 ) !------------------------------------------------------------------------! ! check if the number of points is larger than 4 !------------------------------------------------------------------------! if ( N_ < 4 ) then call write_error ( \"spline function called with \" // & trim ( adjustl ( integer_to_character ( N_ ))) // \" points\" ) endif !------------------------------------------------------------------------! ! check if x is sorted in ascending order !------------------------------------------------------------------------! do i_ = 2 , N_ if ( x_ ( i_ ) <= x_ ( i_ - 1 )) then call write_error ( \"spline: x values are not in ascending order \" // & \" at index \" // trim ( adjustl ( integer_to_character ( i_ )))) endif end do !------------------------------------------------------------------------! diff_x_ = x_ ( 2 : N_ ) - x_ ( 1 : N_ - 1 ) !------------------------------------------------------------------------! b_ ( 2 : N_ - 1 ) = 2.0_dp * ( diff_x_ ( 1 : N_ - 2 ) + diff_x_ ( 2 : N_ - 1 )) b_ ( 1 ) = - diff_x_ ( 1 ) b_ ( N_ ) = - diff_x_ ( N_ - 1 ) c_ ( 2 : N_ - 1 ) = ( y_ ( 3 : N_ ) - y_ ( 2 : N_ - 1 ) ) / diff_x_ ( 2 : N_ - 1 ) & - ( y_ ( 2 : N_ - 1 ) - y_ ( 1 : N_ - 2 ) ) / diff_x_ ( 1 : N_ - 2 ) c_ ( 1 ) = c_ ( 3 ) / ( x_ ( 4 ) - x_ ( 2 )) - c_ ( 2 ) / ( x_ ( 3 ) - x_ ( 1 )) c_ ( N_ ) = c_ ( N_ - 1 ) / ( x_ ( N_ ) - x_ ( N_ - 2 )) - c_ ( N_ - 2 ) / ( x_ ( N_ - 1 ) - x_ ( N_ - 3 )) c_ ( 1 ) = c_ ( 1 ) / ( x_ ( 4 ) - x_ ( 1 )) * diff_x_ ( 1 ) ** 2 c_ ( N_ ) = - c_ ( N_ ) / ( x_ ( N_ ) - x_ ( N_ - 3 )) * diff_x_ ( N_ - 1 ) ** 2 do i_ = 2 , N_ w_ = diff_x_ ( i_ - 1 ) / b_ ( i_ - 1 ) b_ ( i_ ) = b_ ( i_ ) - w_ * diff_x_ ( i_ - 1 ) c_ ( i_ ) = c_ ( i_ ) - w_ * c_ ( i_ - 1 ) end do c_ ( N_ ) = c_ ( N_ ) / b_ ( N_ ) do j_ = 1 , N_ - 1 i_ = N_ - j_ c_ ( i_ ) = ( c_ ( i_ ) - diff_x_ ( i_ ) * c_ ( i_ + 1 )) / b_ ( i_ ) end do b_ ( 1 : N_ - 1 ) = ( y_ ( 2 : N_ ) - y_ ( 1 : N_ - 1 ) ) / diff_x_ ( 1 : N_ - 1 ) & - ( 2.0_dp * c_ ( 1 : N_ - 1 ) + c_ ( 2 : N_ ) ) * diff_x_ ( 1 : N_ - 1 ) d_ ( 1 : N_ - 1 ) = ( c_ ( 2 : N_ ) - c_ ( 1 : N_ - 1 ) ) / diff_x_ ( 1 : N_ - 1 ) c_ = c_ * 3.0_dp end subroutine spline","tags":"","loc":"proc/spline.html"},{"title":"check_unitarity_for_each_channel – the SCATTERING code","text":"public  function check_unitarity_for_each_channel(sum_of_squares) result(is_unitary_) checks if the calculated sum of squares equals 1 for each channel Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: sum_of_squares (:)  \\sum_{\\gamma'} \\Bigl|{S}&#94;{Jp}_{\\gamma, \\gamma'}\\Bigr|&#94;{2}  Return Value logical (output) if .true. unitarity is fulfilled, .false. otherwise Called by proc~~check_unitarity_for_each_channel~~CalledByGraph proc~check_unitarity_for_each_channel check_unitarity_for_each_channel proc~unitarity_check unitarity_check proc~unitarity_check->proc~check_unitarity_for_each_channel program~scattering SCATTERING program~scattering->proc~unitarity_check Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables channel_index Source Code check_unitarity_for_each_channel Variables Type Visibility Attributes Name Initial integer, public :: channel_index Source Code function check_unitarity_for_each_channel ( sum_of_squares ) & result ( is_unitary_ ) !! checks if the calculated sum of squares equals 1 for each channel !---------------------------------------------------------------------! real ( dp ), intent ( in ) :: sum_of_squares (:) !! \\ \\sum\\_{\\gamma'} \\Bigl|{S}&#94;{Jp}\\_{\\gamma, \\gamma'}\\Bigr|&#94;{2} \\ logical :: is_unitary_ !! (output) if .true. unitarity is fulfilled, .false. otherwise !---------------------------------------------------------------------! integer :: channel_index !---------------------------------------------------------------------! is_unitary_ = . true . do channel_index = 1 , size ( sum_of_squares ) if ( abs ( sum_of_squares ( channel_index ) - 1.0_dp ) > unitary_tolerance ) then is_unitary_ = . false . exit endif end do !---------------------------------------------------------------------! end function check_unitarity_for_each_channel","tags":"","loc":"proc/check_unitarity_for_each_channel.html"},{"title":"calculate_sum_of_squares_for_each_channel – the SCATTERING code","text":"public  subroutine calculate_sum_of_squares_for_each_channel(s_matrix_real, s_matrix_imag, sum_of_squares_) calculates the sum\n \\sum_{\\gamma'} \\Bigl|{S}&#94;{Jp}_{\\gamma, \\gamma'}\\Bigr|&#94;{2} \nfor all \\gamma channels Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: s_matrix_real (:,:) real part of the S-matrix real(kind=dp), intent(in) :: s_matrix_imag (:,:) imaginary part of the S-matrix real(kind=dp), intent(out) :: sum_of_squares_ (:) (output)  \\sum_{\\gamma'} \\Bigl|{S}&#94;{Jp}_{\\gamma, \\gamma'}\\Bigr|&#94;{2}  Called by proc~~calculate_sum_of_squares_for_each_channel~~CalledByGraph proc~calculate_sum_of_squares_for_each_channel calculate_sum_of_squares_for_each_channel proc~unitarity_check unitarity_check proc~unitarity_check->proc~calculate_sum_of_squares_for_each_channel program~scattering SCATTERING program~scattering->proc~unitarity_check Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables channel_index_ Source Code calculate_sum_of_squares_for_each_channel Variables Type Visibility Attributes Name Initial integer(kind=int32), public :: channel_index_ Source Code subroutine calculate_sum_of_squares_for_each_channel ( s_matrix_real , & s_matrix_imag , sum_of_squares_ ) !! calculates the sum !! \\ \\sum\\_{\\gamma'} \\Bigl|{S}&#94;{Jp}\\_{\\gamma, \\gamma'}\\Bigr|&#94;{2} \\ !! for all \\\\gamma\\ channels !---------------------------------------------------------------------! real ( dp ), intent ( in ) :: s_matrix_real (:,:) !! real part of the S-matrix real ( dp ), intent ( in ) :: s_matrix_imag (:,:) !! imaginary part of the S-matrix real ( dp ), intent ( out ) :: sum_of_squares_ (:) !! (output) \\ \\sum\\_{\\gamma'} \\Bigl|{S}&#94;{Jp}\\_{\\gamma, \\gamma'}\\Bigr|&#94;{2} \\ !---------------------------------------------------------------------! integer ( int32 ) :: channel_index_ !---------------------------------------------------------------------! do channel_index_ = 1 , size ( s_matrix_real , 1 ) sum_of_squares_ ( channel_index_ ) = & sum ( s_matrix_real ( channel_index_ , :) ** 2 & + s_matrix_imag ( channel_index_ , :) ** 2 ) enddo !---------------------------------------------------------------------! end subroutine calculate_sum_of_squares_for_each_channel","tags":"","loc":"proc/calculate_sum_of_squares_for_each_channel.html"},{"title":"handle_unitarity_output_message – the SCATTERING code","text":"public  subroutine handle_unitarity_output_message(is_unitary) handle printing messages depending on the outcome of unitarity check Arguments Type Intent Optional Attributes Name logical, intent(in) :: is_unitary if .true. unitarity is fulfilled, .false. otherwise Calls proc~~handle_unitarity_output_message~~CallsGraph proc~handle_unitarity_output_message handle_unitarity_output_message proc~write_message write_message proc~handle_unitarity_output_message->proc~write_message proc~write_warning write_warning proc~handle_unitarity_output_message->proc~write_warning proc~write_warning->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~handle_unitarity_output_message~~CalledByGraph proc~handle_unitarity_output_message handle_unitarity_output_message proc~unitarity_check unitarity_check proc~unitarity_check->proc~handle_unitarity_output_message program~scattering SCATTERING program~scattering->proc~unitarity_check Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code handle_unitarity_output_message Source Code subroutine handle_unitarity_output_message ( is_unitary ) !! handle printing messages depending on the outcome of unitarity check !---------------------------------------------------------------------! logical , intent ( in ) :: is_unitary !! if .true. unitarity is fulfilled, .false. otherwise !---------------------------------------------------------------------! if ( is_unitary ) then call write_message ( \"S-matrix unitary condition fulfilled\" ) else call write_warning ( \"Unitary condition is not fulfilled for one or more channels\" ) call write_message ( \"Consider increasing the STEPS parameter\" ) endif !---------------------------------------------------------------------! end subroutine handle_unitarity_output_message","tags":"","loc":"proc/handle_unitarity_output_message.html"},{"title":"unitarity_check – the SCATTERING code","text":"public  subroutine unitarity_check(number_of_open_channels, s_matrix_real, s_matrix_imag, is_unitary) checks the unitarity of the S-matrix\n(Eq. (13) in \"Solution of coupled equations\") Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: number_of_open_channels number of open channels real(kind=dp), intent(in) :: s_matrix_real (number_of_open_channels,number_of_open_channels) real part of the S-matrix real(kind=dp), intent(in) :: s_matrix_imag (number_of_open_channels,number_of_open_channels) imaginary part of the S-matrix logical, intent(inout) :: is_unitary (output) if .true. unitarity is fulfilled, .false. otherwise Calls proc~~unitarity_check~~CallsGraph proc~unitarity_check unitarity_check proc~write_header write_header proc~unitarity_check->proc~write_header proc~handle_unitarity_output_message handle_unitarity_output_message proc~unitarity_check->proc~handle_unitarity_output_message proc~check_unitarity_for_each_channel check_unitarity_for_each_channel proc~unitarity_check->proc~check_unitarity_for_each_channel proc~calculate_sum_of_squares_for_each_channel calculate_sum_of_squares_for_each_channel proc~unitarity_check->proc~calculate_sum_of_squares_for_each_channel proc~write_message write_message proc~write_header->proc~write_message proc~write_error write_error proc~write_header->proc~write_error interface~incorrect_value incorrect_value proc~write_header->interface~incorrect_value proc~handle_unitarity_output_message->proc~write_message proc~write_warning write_warning proc~handle_unitarity_output_message->proc~write_warning proc~write_error->proc~write_message proc~write_warning->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~unitarity_check~~CalledByGraph proc~unitarity_check unitarity_check program~scattering SCATTERING program~scattering->proc~unitarity_check Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables channel_index sum_of_squares Source Code unitarity_check Variables Type Visibility Attributes Name Initial integer(kind=int32), public :: channel_index real(kind=dp), public :: sum_of_squares (number_of_open_channels) Source Code subroutine unitarity_check ( number_of_open_channels , s_matrix_real , & s_matrix_imag , is_unitary ) !! checks the unitarity of the S-matrix !! (Eq. (13) in \"Solution of coupled equations\") !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: number_of_open_channels !! number of open channels real ( dp ), intent ( in ) :: s_matrix_real ( number_of_open_channels , number_of_open_channels ) !! real part of the S-matrix real ( dp ), intent ( in ) :: s_matrix_imag ( number_of_open_channels , number_of_open_channels ) !! imaginary part of the S-matrix logical , intent ( inout ) :: is_unitary !! (output) if .true. unitarity is fulfilled, .false. otherwise !---------------------------------------------------------------------! integer ( int32 ) :: channel_index real ( dp ) :: sum_of_squares ( number_of_open_channels ) !---------------------------------------------------------------------! is_unitary = . true . !---------------------------------------------------------------------! call write_header ( \"unitarity\" ) !---------------------------------------------------------------------! ! Calculating sum of squares for each channel !---------------------------------------------------------------------! call calculate_sum_of_squares_for_each_channel ( s_matrix_real , & s_matrix_imag , sum_of_squares ) !---------------------------------------------------------------------! ! Checking unitarity for each channel !---------------------------------------------------------------------! is_unitary = check_unitarity_for_each_channel ( sum_of_squares ) !---------------------------------------------------------------------! ! Handling the output message based on unitarity check !---------------------------------------------------------------------! call handle_unitarity_output_message ( is_unitary ) !---------------------------------------------------------------------! end subroutine unitarity_check","tags":"","loc":"proc/unitarity_check.html"},{"title":"add_scalar_to_diagonal – the SCATTERING code","text":"public interface add_scalar_to_diagonal Contents Subroutines add_scalar_to_diagonal_dp add_scalar_to_diagonal_int32 add_scalar_to_diagonal_sp Subroutines public module subroutine add_scalar_to_diagonal_dp(matrix_, scalar_) ! add a scalar value to the matrix diagonal (double precision version) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: matrix_ (:,:) real(kind=dp), intent(in) :: scalar_ public module subroutine add_scalar_to_diagonal_int32(matrix_, scalar_) add a scalar value to the matrix diagonal (integer version) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: matrix_ (:,:) integer(kind=int32), intent(in) :: scalar_ public module subroutine add_scalar_to_diagonal_sp(matrix_, scalar_) add a scalar value to the matrix diagonal (single precision version) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: matrix_ (:,:) real(kind=sp), intent(in) :: scalar_","tags":"","loc":"interface/add_scalar_to_diagonal.html"},{"title":"allocate_1d – the SCATTERING code","text":"public interface allocate_1d Called by interface~~allocate_1d~~CalledByGraph interface~allocate_1d allocate_1d proc~read_input_file read_input_file proc~read_input_file->interface~allocate_1d proc~save_open_basis_levels save_open_basis_levels proc~save_open_basis_levels->interface~allocate_1d program~scattering SCATTERING program~scattering->interface~allocate_1d program~scattering->proc~read_input_file program~scattering->proc~save_open_basis_levels Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines allocate_1d_dp allocate_1d_int32 allocate_1d_sp Subroutines public pure module subroutine allocate_1d_dp(array_, size_) allocate a 1d array and fill it with 0s (double precision version) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), allocatable :: array_ (:) integer(kind=int32), intent(in) :: size_ public pure module subroutine allocate_1d_int32(array_, size_) allocate a 1d array and fill it with 0s (integer version) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), allocatable :: array_ (:) integer(kind=int32), intent(in) :: size_ public pure module subroutine allocate_1d_sp(array_, size_) allocate a 1d array and fill it with 0s (single precision version) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout), allocatable :: array_ (:) integer(kind=int32), intent(in) :: size_","tags":"","loc":"interface/allocate_1d.html"},{"title":"allocate_2d – the SCATTERING code","text":"public interface allocate_2d Called by interface~~allocate_2d~~CalledByGraph interface~allocate_2d allocate_2d program~scattering SCATTERING program~scattering->interface~allocate_2d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines allocate_2d_dp allocate_2d_int32 allocate_2d_sp Subroutines public pure module subroutine allocate_2d_dp(array_, size1_, size2_) allocate a 2d array and fill it with 0s (double precision version) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), allocatable :: array_ (:,:) integer(kind=int32), intent(in) :: size1_ integer(kind=int32), intent(in) :: size2_ public pure module subroutine allocate_2d_int32(array_, size1_, size2_) allocate a 2d array and fill it with 0s (integer version) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), allocatable :: array_ (:,:) integer(kind=int32), intent(in) :: size1_ integer(kind=int32), intent(in) :: size2_ public pure module subroutine allocate_2d_sp(array_, size1_, size2_) allocate a 2d array and fill it with 0s (single precision version) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout), allocatable :: array_ (:,:) integer(kind=int32), intent(in) :: size1_ integer(kind=int32), intent(in) :: size2_","tags":"","loc":"interface/allocate_2d.html"},{"title":"allocate_3d – the SCATTERING code","text":"public interface allocate_3d Called by interface~~allocate_3d~~CalledByGraph interface~allocate_3d allocate_3d proc~read_input_file read_input_file proc~read_input_file->interface~allocate_3d program~scattering SCATTERING program~scattering->proc~read_input_file Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines allocate_3d_dp allocate_3d_int32 allocate_3d_sp Subroutines public pure module subroutine allocate_3d_dp(array_, size1_, size2_, size3_) allocate a 3d array and fill it with 0s (double precision version) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), allocatable :: array_ (:,:,:) integer(kind=int32), intent(in) :: size1_ integer(kind=int32), intent(in) :: size2_ integer(kind=int32), intent(in) :: size3_ public pure module subroutine allocate_3d_int32(array_, size1_, size2_, size3_) allocate a 3d array and fill it with 0s (integer version) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), allocatable :: array_ (:,:,:) integer(kind=int32), intent(in) :: size1_ integer(kind=int32), intent(in) :: size2_ integer(kind=int32), intent(in) :: size3_ public pure module subroutine allocate_3d_sp(array_, size1_, size2_, size3_) allocate a 3d array and fill it with 0s (single precision version) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout), allocatable :: array_ (:,:,:) integer(kind=int32), intent(in) :: size1_ integer(kind=int32), intent(in) :: size2_ integer(kind=int32), intent(in) :: size3_","tags":"","loc":"interface/allocate_3d.html"},{"title":"append – the SCATTERING code","text":"public interface append Called by interface~~append~~CalledByGraph interface~append append program~scattering SCATTERING program~scattering->interface~append Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines append_dp append_int32 append_sp Subroutines public pure module subroutine append_dp(array_, element_) append element to an array (double precision version) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), allocatable :: array_ (:) real(kind=dp), intent(in) :: element_ public pure module subroutine append_int32(array_, element_) append element to an array (integer version) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), allocatable :: array_ (:) integer(kind=int32), intent(in) :: element_ public pure module subroutine append_sp(array_, element_) append element to an array (single precision version) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout), allocatable :: array_ (:) real(kind=sp), intent(in) :: element_","tags":"","loc":"interface/append.html"},{"title":"fill_symmetric_matrix – the SCATTERING code","text":"public interface fill_symmetric_matrix Called by interface~~fill_symmetric_matrix~~CalledByGraph interface~fill_symmetric_matrix fill_symmetric_matrix proc~calculate_pes_matrix calculate_pes_matrix proc~calculate_pes_matrix->interface~fill_symmetric_matrix proc~calculate_s_matrix calculate_s_matrix proc~calculate_s_matrix->interface~fill_symmetric_matrix proc~calculate_centrifugal_matrix calculate_centrifugal_matrix proc~calculate_centrifugal_matrix->interface~fill_symmetric_matrix program~scattering SCATTERING program~scattering->proc~calculate_s_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines fill_symmetric_matrix_dp fill_symmetric_matrix_int32 fill_symmetric_matrix_sp Subroutines public module subroutine fill_symmetric_matrix_dp(matrix_, upper_lower_) fill the upper/lower triangle of a symmetric matrix (double precision version) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: matrix_ (:,:) character(len=1), intent(in) :: upper_lower_ public module subroutine fill_symmetric_matrix_int32(matrix_, upper_lower_) fill the upper/lower triangle of a symmetric matrix (integer version) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: matrix_ (:,:) character(len=1), intent(in) :: upper_lower_ public module subroutine fill_symmetric_matrix_sp(matrix_, upper_lower_) fill the upper/lower triangle of a symmetric matrix (single precision version) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: matrix_ (:,:) character(len=1), intent(in) :: upper_lower_","tags":"","loc":"interface/fill_symmetric_matrix.html"},{"title":"invert_symmetric_matrix – the SCATTERING code","text":"public interface invert_symmetric_matrix Called by interface~~invert_symmetric_matrix~~CalledByGraph interface~invert_symmetric_matrix invert_symmetric_matrix proc~calculate_s_matrix calculate_s_matrix proc~calculate_s_matrix->interface~invert_symmetric_matrix program~scattering SCATTERING program~scattering->proc~calculate_s_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines invert_symmetric_matrix_dp invert_symmetric_matrix_int32 invert_symmetric_matrix_sp Subroutines public module subroutine invert_symmetric_matrix_dp(matrix_) invert a symmetric matrix using DSYTRI method (double precision version) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: matrix_ (:,:) public module subroutine invert_symmetric_matrix_int32(matrix_) invert a symmetric matrix using DSYTRI method (integer version) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: matrix_ (:,:) public module subroutine invert_symmetric_matrix_sp(matrix_) invert a symmetric matrix using DSYTRI method (single precision version) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: matrix_ (:,:)","tags":"","loc":"interface/invert_symmetric_matrix.html"},{"title":"calculate_centrifugal_matrix – the SCATTERING code","text":"public  subroutine calculate_centrifugal_matrix(total_angular_momentum_, channel_indices_, channels_omega_values_, centrifugal_matrix_) calculates the (R* 2) centrifugal matrix from the second term\nof Eq. 3 in \"What are coupled equations?\" section;\nMatrix elements are given in Eq. 4 and 6 of \"Coupling Matrix\" secion Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: total_angular_momentum_ total angular momentum integer(kind=int32), intent(in) :: channel_indices_ (:) holds the indices pointing to the basis arrays integer(kind=int32), intent(in) :: channels_omega_values_ (:) holds all values of \\bar{\\Omega} real(kind=dp), intent(out) :: centrifugal_matrix_ (:,:) (output) - (R* 2) centrifugal matrix Calls proc~~calculate_centrifugal_matrix~~CallsGraph proc~calculate_centrifugal_matrix calculate_centrifugal_matrix interface~fill_symmetric_matrix fill_symmetric_matrix proc~calculate_centrifugal_matrix->interface~fill_symmetric_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code calculate_centrifugal_matrix Source Code subroutine calculate_centrifugal_matrix ( total_angular_momentum_ , & channel_indices_ , channels_omega_values_ , centrifugal_matrix_ ) !! calculates the (R**2)*centrifugal matrix from the second term !! of Eq. 3 in \"What are coupled equations?\" section; !! Matrix elements are given in Eq. 4 and 6 of \"Coupling Matrix\" secion !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: total_angular_momentum_ !! total angular momentum integer ( int32 ), intent ( in ) :: channel_indices_ (:) !! holds the indices pointing to the basis arrays integer ( int32 ), intent ( in ) :: channels_omega_values_ (:) !! holds all values of \\bar{\\Omega} real ( dp ), intent ( out ) :: centrifugal_matrix_ (:,:) !! (output) - (R**2)*centrifugal matrix !---------------------------------------------------------------------! integer ( int32 ) :: omega_ , omega_prime_ , v_ , j_ , v_prime_ , j_prime_ , & channel_index_1_ , channel_index_2_ real ( dp ) :: centtmp , delta_1_ , delta_2_ !---------------------------------------------------------------------! centrifugal_matrix_ = 0 do channel_index_1_ = 1 , size ( channel_indices_ ) v_ = v1array ( channel_indices_ ( channel_index_1_ )) j_ = j1array ( channel_indices_ ( channel_index_1_ )) omega_ = channels_omega_values_ ( channel_index_1_ ) delta_1_ = delta_for_zero_omega ( omega_ ) do channel_index_2_ = 1 , channel_index_1_ v_prime_ = v1array ( channel_indices_ ( channel_index_2_ )) j_prime_ = j1array ( channel_indices_ ( channel_index_2_ )) omega_prime_ = channels_omega_values_ ( channel_index_2_ ) delta_2_ = delta_for_zero_omega ( omega_prime_ ) !---------------------------------------------------------------! if ( v_ /= v_prime_ . or . j_ /= j_prime_ . or . & abs ( omega_ - omega_prime_ ) > 1 ) then cycle endif !---------------------------------------------------------------! if ( omega_ == omega_prime_ ) then !------------------------------------------------------------! ! Eq. 4 in \"Coupling Matrix\" section !------------------------------------------------------------! centrifugal_matrix_ ( channel_index_1_ , channel_index_2_ ) & = calculate_diagonal_centrifugal_element ( & total_angular_momentum_ , j_ , omega_ ) else !------------------------------------------------------------! ! Eq. 5 in \"Coupling Matrix\" section !------------------------------------------------------------! centrifugal_matrix_ ( channel_index_1_ , channel_index_2_ ) & = calculate_offdiagonal_centrifugal_element ( & total_angular_momentum_ , j_ , omega_ , omega_prime_ , & delta_1_ , delta_2_ ) endif !---------------------------------------------------------------! enddo enddo !---------------------------------------------------------------------! call fill_symmetric_matrix ( centrifugal_matrix_ , 'u' ) !---------------------------------------------------------------------! end subroutine calculate_centrifugal_matrix","tags":"","loc":"proc/calculate_centrifugal_matrix.html"},{"title":"calculate_k_matrix – the SCATTERING code","text":"public  subroutine calculate_k_matrix(number_of_channels, log_der_matrix, number_of_open_channels, channel_indices, channel_l_values, r_, k_matrix) calculates the K-matrix from log-derivative matrix using Eq. (4) in\n\"Solution of coupled equations\" Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: number_of_channels y-matrix is of number_of_channels x number_of_channels size real(kind=dp), intent(in) :: log_der_matrix (number_of_channels,number_of_channels) asymptotic log-derivative matrix integer(kind=int32), intent(in) :: number_of_open_channels number of open channels integer(kind=int32), intent(in) :: channel_indices (number_of_channels) holds the indices pointing to the basis arrays integer(kind=int32), intent(in) :: channel_l_values (number_of_channels) holds all values of l real(kind=dp), intent(in) :: r_ Rmax real(kind=dp), intent(inout) :: k_matrix (number_of_open_channels,number_of_open_channels) K-matrix Calls proc~~calculate_k_matrix~~CallsGraph proc~calculate_k_matrix calculate_k_matrix proc~is_open is_open proc~calculate_k_matrix->proc~is_open proc~riccati_bessel_j riccati_bessel_j proc~calculate_k_matrix->proc~riccati_bessel_j dgemm dgemm proc~calculate_k_matrix->dgemm dgesv dgesv proc~calculate_k_matrix->dgesv proc~modified_bessel_k_ratio modified_bessel_k_ratio proc~calculate_k_matrix->proc~modified_bessel_k_ratio proc~wavenumber_squared_from_energy wavenumber_squared_from_energy proc~calculate_k_matrix->proc~wavenumber_squared_from_energy proc~riccati_bessel_y riccati_bessel_y proc~calculate_k_matrix->proc~riccati_bessel_y proc~etotal ETOTAL proc~is_open->proc~etotal proc~rctj rctj proc~riccati_bessel_j->proc~rctj proc~write_warning write_warning proc~riccati_bessel_j->proc~write_warning proc~integer_to_character integer_to_character proc~riccati_bessel_j->proc~integer_to_character proc~modified_bessel_temme_algorithm modified_bessel_temme_algorithm proc~modified_bessel_k_ratio->proc~modified_bessel_temme_algorithm proc~write_error write_error proc~wavenumber_squared_from_energy->proc~write_error proc~wavenumber_squared_from_energy->proc~etotal proc~riccati_bessel_y->proc~write_warning proc~riccati_bessel_y->proc~integer_to_character proc~rcty rcty proc~riccati_bessel_y->proc~rcty proc~modified_bessel_temme_algorithm->proc~write_error proc~rgamma rgamma proc~modified_bessel_temme_algorithm->proc~rgamma proc~msta2 msta2 proc~rctj->proc~msta2 proc~msta1 msta1 proc~rctj->proc~msta1 proc~write_message write_message proc~write_warning->proc~write_message proc~write_error->proc~write_message proc~envj envj proc~msta2->proc~envj proc~msta1->proc~envj Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~calculate_k_matrix~~CalledByGraph proc~calculate_k_matrix calculate_k_matrix program~scattering SCATTERING program~scattering->proc~calculate_k_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code calculate_k_matrix Source Code subroutine calculate_k_matrix ( number_of_channels , log_der_matrix , & number_of_open_channels , channel_indices , channel_l_values , & r_ , k_matrix ) !! calculates the K-matrix from log-derivative matrix using Eq. (4) in !! \"Solution of coupled equations\" !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: number_of_channels !! y-matrix is of number_of_channels x number_of_channels size real ( dp ), intent ( in ) :: log_der_matrix ( number_of_channels , number_of_channels ) !! asymptotic log-derivative matrix integer ( int32 ), intent ( in ) :: number_of_open_channels !! number of open channels integer ( int32 ), intent ( in ) :: channel_indices ( number_of_channels ) !! holds the indices pointing to the basis arrays integer ( int32 ), intent ( in ) :: channel_l_values ( number_of_channels ) !! holds all values of l real ( dp ), intent ( in ) :: r_ !! Rmax real ( dp ), intent ( inout ) :: k_matrix ( number_of_open_channels , number_of_open_channels ) !! K-matrix !---------------------------------------------------------------------! integer ( int32 ) :: open_channel_index_ , closed_channel_index_ , & channel_index_ , status_ , l_ real ( dp ) :: wavenumber , x , j_element_ , jp_element_ , n_element_ , & np_element_ , ratio integer ( int32 ) :: open_channels_indices ( number_of_open_channels ) integer ( int32 ) :: closed_channels_indices ( number_of_channels - number_of_open_channels ) real ( dp ) :: diag_n_matrix ( number_of_channels , number_of_channels ), & diag_np_matrix ( number_of_channels , number_of_channels ), & diag_j_matrix ( number_of_channels , number_of_open_channels ), & diag_jp_matrix ( number_of_channels , number_of_open_channels ) !---------------------------------------------------------------------! ! diag_j_matrix   -  diagonal J matrix (Eqs. 5, 7) ! diag_jp_matrix  -  diagonal J`matrix (derivative of J) ! diag_n_matrix   -  diagonal N matrix (Eqs. 6, 8) ! diag_np_matrix  -  diagonal N`matrix (derivative of N) !---------------------------------------------------------------------! diag_j_matrix = 0 diag_jp_matrix = 0 diag_n_matrix = 0 diag_np_matrix = 0 !---------------------------------------------------------------------! open_channel_index_ = 0 closed_channel_index_ = 0 !---------------------------------------------------------------------! ! save indices to open and closed channels ! this is because channels might not be sorted eneregetically !---------------------------------------------------------------------! do channel_index_ = 1 , number_of_channels if ( is_open ( elevel ( channel_indices ( channel_index_ )))) then open_channel_index_ = open_channel_index_ + 1 open_channels_indices ( open_channel_index_ ) = channel_index_ else closed_channel_index_ = closed_channel_index_ + 1 closed_channels_indices ( closed_channel_index_ ) = channel_index_ endif enddo !---------------------------------------------------------------------! ! Prepare J, J', N and N' matrices (Eqs. 5-6) ! open channels: !---------------------------------------------------------------------! do open_channel_index_ = 1 , number_of_open_channels wavenumber = sqrt ( wavenumber_squared_from_energy ( & elevel ( channel_indices ( open_channels_indices ( open_channel_index_ ))))) x = wavenumber * r_ l_ = channel_l_values ( open_channels_indices ( open_channel_index_ )) call riccati_bessel_j ( & l_ , x , j_element_ , jp_element_ ) diag_j_matrix ( open_channel_index_ , open_channel_index_ ) & = ( wavenumber ) ** ( - 0.5d0 ) * j_element_ diag_jp_matrix ( open_channel_index_ , open_channel_index_ ) & = ( wavenumber ) ** ( 0.5d0 ) * jp_element_ call riccati_bessel_y ( l_ , x , n_element_ , np_element_ ) diag_n_matrix ( open_channel_index_ , open_channel_index_ ) & = ( wavenumber ) ** ( - 0.5d0 ) * n_element_ diag_np_matrix ( open_channel_index_ , open_channel_index_ ) & = ( wavenumber ) ** ( 0.5d0 ) * np_element_ enddo !---------------------------------------------------------------------! ! Prepare J, J', N and N' matrices (Eqs. 7-8) ! closed channels: !---------------------------------------------------------------------! do closed_channel_index_ = 1 , number_of_channels - number_of_open_channels wavenumber = sqrt ( abs ( wavenumber_squared_from_energy ( & elevel ( channel_indices ( closed_channels_indices ( closed_channel_index_ )))))) x = wavenumber * r_ l_ = channel_l_values ( closed_channels_indices ( closed_channel_index_ )) call modified_bessel_k_ratio ( l_ , x , ratio ) !------------------------------------------------------------------! ! substitution for closed channels, (Eqs. 10 - 11) !------------------------------------------------------------------! diag_n_matrix ( number_of_open_channels + closed_channel_index_ , & number_of_open_channels + closed_channel_index_ ) = 1.d0 diag_np_matrix ( number_of_open_channels + closed_channel_index_ , & number_of_open_channels + closed_channel_index_ ) = wavenumber * ratio enddo !---------------------------------------------------------------------! -----------------------> consider a separate function call DGEMM ( 'N' , 'N' , number_of_channels , number_of_channels , & number_of_channels , 1.0d0 , log_der_matrix , number_of_channels , diag_n_matrix , & number_of_channels , - 1.d0 , diag_np_matrix , number_of_channels ) call DGEMM ( 'N' , 'N' , number_of_channels , number_of_open_channels , & number_of_channels , - 1.0d0 , log_der_matrix , number_of_channels , diag_j_matrix , & number_of_channels , 1.d0 , diag_jp_matrix , number_of_channels ) !---------------------------------------------------------------------! call DGESV ( number_of_channels , number_of_open_channels , diag_np_matrix , & number_of_channels , diag_j_matrix , diag_jp_matrix , number_of_channels , status_ ) !---------------------------------------------------------------------! k_matrix = diag_jp_matrix ( 1 : number_of_open_channels , 1 : number_of_open_channels ) !---------------------------------------------------------------------! end subroutine calculate_k_matrix","tags":"","loc":"proc/calculate_k_matrix.html"},{"title":"calculate_s_matrix – the SCATTERING code","text":"public  subroutine calculate_s_matrix(number_of_open_channels, k_matrix, s_matrix_real, s_matrix_imag) calculates S-matrix from open-open portion of the K-matrix using\nEq. (12) in \"Solution of coupled equations\" Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: number_of_open_channels number of open channels real(kind=dp), intent(in) :: k_matrix (number_of_open_channels,number_of_open_channels) K-matrix real(kind=dp), intent(inout) :: s_matrix_real (number_of_open_channels,number_of_open_channels) (output) real part of the S-matrix real(kind=dp), intent(inout) :: s_matrix_imag (number_of_open_channels,number_of_open_channels) (output) imaginary part of the S-matrix Calls proc~~calculate_s_matrix~~CallsGraph proc~calculate_s_matrix calculate_s_matrix dgemm dgemm proc~calculate_s_matrix->dgemm interface~fill_symmetric_matrix fill_symmetric_matrix proc~calculate_s_matrix->interface~fill_symmetric_matrix interface~invert_symmetric_matrix invert_symmetric_matrix proc~calculate_s_matrix->interface~invert_symmetric_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~calculate_s_matrix~~CalledByGraph proc~calculate_s_matrix calculate_s_matrix program~scattering SCATTERING program~scattering->proc~calculate_s_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code calculate_s_matrix Source Code subroutine calculate_s_matrix ( number_of_open_channels , k_matrix , & s_matrix_real , s_matrix_imag ) !! calculates S-matrix from open-open portion of the K-matrix using !! Eq. (12) in \"Solution of coupled equations\" !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: number_of_open_channels !! number of open channels real ( dp ), intent ( in ) :: k_matrix ( number_of_open_channels , number_of_open_channels ) !! K-matrix real ( dp ), intent ( inout ) :: s_matrix_real ( number_of_open_channels , number_of_open_channels ) !! (output) real part of the S-matrix real ( dp ), intent ( inout ) :: s_matrix_imag ( number_of_open_channels , number_of_open_channels ) !! (output) imaginary part of the S-matrix !---------------------------------------------------------------------! integer ( int32 ) :: open_channel_index_1_ , open_channel_index_2_ real ( dp ) :: s_tmp_matrix ( number_of_open_channels , number_of_open_channels ) !---------------------------------------------------------------------! s_matrix_real = 0 s_matrix_imag = 0 !---------------------------------------------------------------------! !---------------------------------------------------------------------! call DGEMM ( 'N' , 'N' , number_of_open_channels , number_of_open_channels , & number_of_open_channels , 0.5d0 , k_matrix , number_of_open_channels , & k_matrix , number_of_open_channels , 0.d0 , s_tmp_matrix , number_of_open_channels ) !---------------------------------------------------------------------! do open_channel_index_1_ = 1 , number_of_open_channels s_tmp_matrix ( open_channel_index_1_ , open_channel_index_1_ ) = & s_tmp_matrix ( open_channel_index_1_ , open_channel_index_1_ ) + 0.5d0 enddo !---------------------------------------------------------------------! call invert_symmetric_matrix ( s_tmp_matrix ) call fill_symmetric_matrix ( s_tmp_matrix , 'u' ) !---------------------------------------------------------------------! call DGEMM ( 'N' , 'N' , number_of_open_channels , number_of_open_channels , & number_of_open_channels , - 1.0d0 , s_tmp_matrix , number_of_open_channels ,& k_matrix , number_of_open_channels , 0.d0 , s_matrix_imag , number_of_open_channels ) !---------------------------------------------------------------------! do open_channel_index_1_ = 1 , number_of_open_channels do open_channel_index_2_ = 1 , number_of_open_channels s_matrix_real ( open_channel_index_1_ , open_channel_index_2_ ) = & s_tmp_matrix ( open_channel_index_1_ , open_channel_index_2_ ) enddo s_matrix_real ( open_channel_index_1_ , open_channel_index_1_ ) = & s_matrix_real ( open_channel_index_1_ , open_channel_index_1_ ) - 1.d0 enddo !---------------------------------------------------------------------! end subroutine calculate_s_matrix","tags":"","loc":"proc/calculate_s_matrix.html"},{"title":"calculate_sf_matrix_from_bf_matrix – the SCATTERING code","text":"public  subroutine calculate_sf_matrix_from_bf_matrix(number_of_channels, total_angular_momentum_, channel_indices, channels_omega_values, channel_l_values, bf_matrix, sf_matrix) takes as an input matrix in the body-fixed frame and transforms it \nto the spec-fixed frame; iterates over all matrix elements\nand calls calculate_single_SF_element Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: number_of_channels size of the basis integer(kind=int32), intent(in) :: total_angular_momentum_ total angular momentum integer(kind=int32), intent(in) :: channel_indices (number_of_channels) holds the indices pointing to the basis arrays integer(kind=int32), intent(in) :: channels_omega_values (number_of_channels) holds all values of \\bar{\\Omega} integer(kind=int32), intent(in) :: channel_l_values (number_of_channels) holds all values of l real(kind=dp), intent(in) :: bf_matrix (number_of_channels,number_of_channels) matrix in the BF frame real(kind=dp), intent(inout) :: sf_matrix (number_of_channels,number_of_channels) (output) matrix in the SF frame Called by proc~~calculate_sf_matrix_from_bf_matrix~~CalledByGraph proc~calculate_sf_matrix_from_bf_matrix calculate_sf_matrix_from_bf_matrix program~scattering SCATTERING program~scattering->proc~calculate_sf_matrix_from_bf_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code calculate_sf_matrix_from_bf_matrix Source Code subroutine calculate_sf_matrix_from_bf_matrix ( number_of_channels , & total_angular_momentum_ , channel_indices , & channels_omega_values , channel_l_values , bf_matrix , sf_matrix ) !! takes as an input matrix in the body-fixed frame and transforms it !! to the spec-fixed frame; iterates over all matrix elements !! and calls calculate_single_SF_element !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: number_of_channels !! size of the basis integer ( int32 ), intent ( in ) :: total_angular_momentum_ !! total angular momentum integer ( int32 ), intent ( in ) :: channel_indices ( number_of_channels ) !! holds the indices pointing to the basis arrays integer ( int32 ), intent ( in ) :: channels_omega_values ( number_of_channels ) !! holds all values of \\bar{\\Omega} integer ( int32 ), intent ( in ) :: channel_l_values ( number_of_channels ) !! holds all values of l real ( dp ), intent ( in ) :: bf_matrix ( number_of_channels , number_of_channels ) !! matrix in the BF frame real ( dp ), intent ( inout ) :: sf_matrix ( number_of_channels , number_of_channels ) !! (output) matrix in the SF frame !---------------------------------------------------------------------! integer ( int32 ) :: l_ , lp_ , omega_ , omegap_ , v1_ , j1_ , v1p_ , j1p_ , channel_index_1_ , channel_index_2_ real ( dp ) :: single_sf_element !---------------------------------------------------------------------! do channel_index_1_ = 1 , number_of_channels v1_ = v1array ( channel_indices ( channel_index_1_ )) j1_ = j1array ( channel_indices ( channel_index_1_ )) l_ = channel_l_values ( channel_index_1_ ) do channel_index_2_ = 1 , number_of_channels v1p_ = v1array ( channel_indices ( channel_index_2_ )) j1p_ = j1array ( channel_indices ( channel_index_2_ )) lp_ = channel_l_values ( channel_index_2_ ) call calculate_single_SF_element ( number_of_channels , & total_angular_momentum_ , v1_ , j1_ , v1p_ , j1p_ , l_ , lp_ , & channel_indices , channels_omega_values , bf_matrix , & single_sf_element ) sf_matrix ( channel_index_1_ , channel_index_2_ ) = single_sf_element enddo enddo !---------------------------------------------------------------------! end subroutine calculate_sf_matrix_from_bf_matrix","tags":"","loc":"proc/calculate_sf_matrix_from_bf_matrix.html"},{"title":"check_namelist_basis – the SCATTERING code","text":"public  subroutine check_namelist_basis() Check variables read from namelist \"basis\" Arguments None Calls proc~~check_namelist_basis~~CallsGraph proc~check_namelist_basis check_namelist_basis proc~integer_to_character integer_to_character proc~check_namelist_basis->proc~integer_to_character interface~incorrect_value incorrect_value proc~check_namelist_basis->interface~incorrect_value Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~check_namelist_basis~~CalledByGraph proc~check_namelist_basis check_namelist_basis proc~read_input_file read_input_file proc~read_input_file->proc~check_namelist_basis program~scattering SCATTERING program~scattering->proc~read_input_file Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables level_index_ Source Code check_namelist_basis Variables Type Visibility Attributes Name Initial integer(kind=int32), public :: level_index_ Source Code subroutine check_namelist_basis !! Check variables read from namelist \"basis\" !---------------------------------------------------------------------! integer ( int32 ) :: level_index_ !---------------------------------------------------------------------! do level_index_ = 1 , nlevel if ( v1array ( level_index_ ). lt . 0 ) then call incorrect_value ( \"v1array(\" // & integer_to_character ( level_index_ ) // \")\" , v1array ( level_index_ ), 5 ) endif if ( j1array ( level_index_ ). lt . 0 ) then call incorrect_value ( \"j1array(\" // & integer_to_character ( level_index_ ) // \")\" , j1array ( level_index_ ), 5 ) endif if ( elevel ( level_index_ ). lt . 0.0_dp ) then call incorrect_value ( \"elevel(\" // & integer_to_character ( level_index_ ) // \")\" , elevel ( level_index_ ), 5 ) endif enddo end subroutine check_namelist_basis","tags":"","loc":"proc/check_namelist_basis.html"},{"title":"check_namelist_input – the SCATTERING code","text":"public  subroutine check_namelist_input() Check variables read from namelist \"input\" Arguments None Calls proc~~check_namelist_input~~CallsGraph proc~check_namelist_input check_namelist_input interface~incorrect_value incorrect_value proc~check_namelist_input->interface~incorrect_value proc~write_error write_error proc~check_namelist_input->proc~write_error proc~write_message write_message proc~check_namelist_input->proc~write_message proc~integer_to_character integer_to_character proc~check_namelist_input->proc~integer_to_character proc~write_error->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~check_namelist_input~~CalledByGraph proc~check_namelist_input check_namelist_input proc~read_input_file read_input_file proc~read_input_file->proc~check_namelist_input program~scattering SCATTERING program~scattering->proc~read_input_file Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code check_namelist_input Source Code subroutine check_namelist_input !! Check variables read from namelist \"input\" !---------------------------------------------------------------------! if ( reduced_mass . lt . 0 ) then call incorrect_value ( \"reduced_mass\" , reduced_mass , 5 ) endif if (( relative_energy_flag . ne . 0 ). and .( relative_energy_flag . ne . 1 )) then call incorrect_value ( \"relative_energy_flag\" , relative_energy_flag , 5 ) endif if ( energy . lt . 0 ) then call incorrect_value ( \"energy\" , energy , 5 ) endif if ( rmin . le . 0 ) then call incorrect_value ( \"rmin\" , rmin , 5 ) endif if ( rmax . le . 0 ) then call incorrect_value ( \"rmax\" , rmax , 5 ) endif if ( rmax . lt . rmin ) then call incorrect_value ( \"rmax/rmin\" , rmax / rmin , 5 ) endif if ( steps . le . 0.d0 ) then call incorrect_value ( \"steps\" , steps , 5 ) endif if ( vdepth . lt . 0.d0 ) then call incorrect_value ( \"vdepth\" , vdepth , 5 ) endif if ( jtotmin . lt . 0 ) then call incorrect_value ( \"jtotmin\" , jtotmin , 5 ) endif if ( jtotmax . lt . 0 ) then if ( consecutive_blocks_threshold . lt . 0 ) then call write_message ( \"JTOTMAX < 0:\" ) call incorrect_value ( \"consecutive_blocks_threshold\" , consecutive_blocks_threshold , 5 ) endif if ( elastic_xs_threshold . lt . 0 ) then call write_message ( \"JTOTMAX < 0:\" ) call incorrect_value ( \"elastic_xs_threshold\" , elastic_xs_threshold , 5 ) endif if ( inelastic_xs_threshold . lt . 0 ) then call write_message ( \"JTOTMAX < 0:\" ) call incorrect_value ( \"inelastic_xs_threshold\" , inelastic_xs_threshold , 5 ) endif else if ( jtotmax . lt . jtotmin ) then call write_message ( \"jtotmax is smaller than jtotmin\" ) call incorrect_value ( \"jtotmax/jtotmin\" , & real ( jtotmax / jtotmin , dp ), 5 ) endif endif if ( nlevel . le . 0 ) then call incorrect_value ( \"nlevel\" , nlevel , 5 ) endif if ( relative_energy_flag . eq . 1 ) then if ( initial . le . 0 ) then call write_message ( \"relative_energy_flag = 1:\" ) call incorrect_value ( \"initial\" , initial , 5 ) endif if ( initial . gt . nlevel ) then call write_message ( \"relative_energy_flag = 1:\" ) call write_message ( \"nlevel = \" // & trim ( adjustl ( integer_to_character ( nlevel )))) call incorrect_value ( \"initial > nlevel\" , initial , 5 ) endif endif if ( nr . le . 0 ) then call incorrect_value ( \"nr\" , nr , 5 ) endif if ( nterms . le . 0 ) then call incorrect_value ( \"nterms\" , nterms , 5 ) endif if ( total_number_of_coupling_terms . le . 0 ) then call incorrect_value ( \"total_number_of_coupling_terms\" , total_number_of_coupling_terms , 5 ) endif if ( n_skip_lines . lt . 0 ) then call incorrect_value ( \"n_skip_lines\" , n_skip_lines , 5 ) endif if (( iunits . ne . 0 ). and .( iunits . ne . 1 )) then call incorrect_value ( \"iunits\" , iunits , 5 ) endif inquire ( file = potentialfile , exist = pes_file_exists ) if ( pes_file_exists . eqv .. false .) then call write_error ( trim ( adjustl ( potentialfile )) // \" does not exist\" ) endif if ( prntlvl . lt . 0 ) then call incorrect_value ( \"prntlvl\" , prntlvl , 5 ) endif !---------------------------------------------------------------------! end subroutine check_namelist_input","tags":"","loc":"proc/check_namelist_input.html"},{"title":"check_namelist_potential – the SCATTERING code","text":"public  subroutine check_namelist_potential() Check variables read from namelist \"potential\" Arguments None Calls proc~~check_namelist_potential~~CallsGraph proc~check_namelist_potential check_namelist_potential proc~integer_to_character integer_to_character proc~check_namelist_potential->proc~integer_to_character interface~incorrect_value incorrect_value proc~check_namelist_potential->interface~incorrect_value Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~check_namelist_potential~~CalledByGraph proc~check_namelist_potential check_namelist_potential proc~read_input_file read_input_file proc~read_input_file->proc~check_namelist_potential program~scattering SCATTERING program~scattering->proc~read_input_file Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables column_index_ legendre_index_ Source Code check_namelist_potential Variables Type Visibility Attributes Name Initial integer(kind=int32), public :: column_index_ integer(kind=int32), public :: legendre_index_ Source Code subroutine check_namelist_potential !! Check variables read from namelist \"potential\" !---------------------------------------------------------------------! integer ( int32 ) :: legendre_index_ , column_index_ !---------------------------------------------------------------------! do legendre_index_ = 1 , nterms if ( l1tab ( legendre_index_ ). lt . 0 ) then call incorrect_value ( \"l1tab(\" // & integer_to_character ( legendre_index_ ) // \")\" , & l1tab ( legendre_index_ ), 5 ) endif enddo do column_index_ = 1 , total_number_of_coupling_terms if ( v1pes ( column_index_ ). lt . 0 ) then call incorrect_value ( \"v1pes(\" // & integer_to_character ( column_index_ ) // \")\" , & v1pes ( column_index_ ), 5 ) endif if ( j1pes ( column_index_ ). lt . 0 ) then call incorrect_value ( \"j1pes(\" // & integer_to_character ( column_index_ ) // \")\" , & j1pes ( column_index_ ), 5 ) endif if ( v1ppes ( column_index_ ). lt . 0 ) then call incorrect_value ( \"vp1pes(\" // & integer_to_character ( column_index_ ) // \")\" , & v1ppes ( column_index_ ), 5 ) endif if ( j1ppes ( column_index_ ). lt . 0 ) then call incorrect_value ( \"j1ppes(\" // & integer_to_character ( column_index_ ) // \")\" , & j1ppes ( column_index_ ), 5 ) endif enddo end subroutine check_namelist_potential","tags":"","loc":"proc/check_namelist_potential.html"},{"title":"numerov – the SCATTERING code","text":"public  subroutine numerov(number_of_channels_, channel_indices_, channels_omega_values_, nonzero_terms_per_element_, nonzero_legendre_indices_, nonzero_algebraic_coefficients_, number_of_steps_, total_angular_momentum_, log_der_matrix_) renormalized Numerov propagator\n... Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: number_of_channels_ size of the basis integer(kind=int32), intent(in) :: channel_indices_ (number_of_channels_) holds the indices pointing to the basis arrays integer(kind=int32), intent(in) :: channels_omega_values_ (number_of_channels_) holds all values of \\bar{\\Omega} integer(kind=int32), intent(in) :: nonzero_terms_per_element_ (:) keeps the number of non-zero terms in the sum (Eq. (6.21)) for\neach non-zero element of W/V integer(kind=int32), intent(in) :: nonzero_legendre_indices_ (:) holds the proper indices pointing to l1/l2/lltabs, which\ncorrespond to the non-vanishing elements of the sum  (Eq. (6.21))\nfor each non-zero element of W/V real(kind=dp), intent(in) :: nonzero_algebraic_coefficients_ (:) holds the values of the non-zero algebraic coefficients integer(kind=int32), intent(in) :: number_of_steps_ number of steps from rmin to rmax integer(kind=int32), intent(in) :: total_angular_momentum_ total angular momentum real(kind=dp), intent(inout) :: log_der_matrix_ (number_of_channels_,number_of_channels_) resulting log-derivative matrix at RMAX Calls proc~~numerov~~CallsGraph proc~numerov numerov proc~time_count_summary time_count_summary proc~numerov->proc~time_count_summary proc~write_message write_message proc~time_count_summary->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~numerov~~CalledByGraph proc~numerov numerov program~scattering SCATTERING program~scattering->proc~numerov Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code numerov Source Code subroutine numerov ( number_of_channels_ , channel_indices_ , & channels_omega_values_ , nonzero_terms_per_element_ , & nonzero_legendre_indices_ , nonzero_algebraic_coefficients_ , & number_of_steps_ , total_angular_momentum_ , log_der_matrix_ ) !! renormalized Numerov propagator !! ... !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: number_of_channels_ !! size of the basis integer ( int32 ), intent ( in ) :: channel_indices_ ( number_of_channels_ ) !! holds the indices pointing to the basis arrays integer ( int32 ), intent ( in ) :: channels_omega_values_ ( number_of_channels_ ) !! holds all values of \\bar{\\Omega} integer ( int32 ), intent ( in ) :: nonzero_terms_per_element_ (:) !! keeps the number of non-zero terms in the sum (Eq. (6.21)) for !! each non-zero element of W/V integer ( int32 ), intent ( in ) :: nonzero_legendre_indices_ (:) !! holds the proper indices pointing to l1/l2/lltabs, which !! correspond to the non-vanishing elements of the sum  (Eq. (6.21)) !! for each non-zero element of W/V real ( dp ), intent ( in ) :: nonzero_algebraic_coefficients_ (:) !! holds the values of the non-zero algebraic coefficients integer ( int32 ), intent ( in ) :: number_of_steps_ !! number of steps from rmin to rmax integer ( int32 ), intent ( in ) :: total_angular_momentum_ !! total angular momentum real ( dp ), intent ( inout ) :: log_der_matrix_ ( number_of_channels_ , number_of_channels_ ) !! resulting log-derivative matrix at RMAX !---------------------------------------------------------------------! integer ( int32 ) :: i , channel_index_1_ , channel_index_2_ real ( dp ) :: start , finish , intermolecular_distance_ , step_numerov_ , calculation_time_ real ( dp ), dimension ( number_of_channels_ , number_of_channels_ ) :: & centrifugal_matrix_ , & t_matrix_minus_ , t_matrix_ , t_matrix_plus_ , r_matrix_ , & r_matrix_rmax_ , r_matrix_plus_ !---------------------------------------------------------------------! CALL CPU_TIME ( start ) step_numerov_ = ( rmax - rmin ) / dble ( number_of_steps_ - 1 ) intermolecular_distance_ = rmin !---------------------------------------------------------------------! ! Initial setup: calculate centrifugal matrix and R_matrix at Rmin + 1 !---------------------------------------------------------------------! call initial_setup ( number_of_channels_ , step_numerov_ , total_angular_momentum_ , & intermolecular_distance_ , channel_indices_ , channels_omega_values_ ,& nonzero_terms_per_element_ , nonzero_legendre_indices_ , & nonzero_algebraic_coefficients_ , centrifugal_matrix_ , r_matrix_ ) !---------------------------------------------------------------------! ! Propagation loop !---------------------------------------------------------------------! do i = 2 , number_of_steps_ - 2 !------------------------------------------------------------------! intermolecular_distance_ = rmin + ( i - 1 ) * step_numerov_ !------------------------------------------------------------------! call general_propagation_step ( number_of_channels_ , step_numerov_ , & total_angular_momentum_ , intermolecular_distance_ , channel_indices_ , & channels_omega_values_ , nonzero_terms_per_element_ , nonzero_legendre_indices_ , & nonzero_algebraic_coefficients_ , centrifugal_matrix_ , r_matrix_ ) !------------------------------------------------------------------! end do !---------------------------------------------------------------------! call handle_final_propagation_steps ( number_of_channels_ , step_numerov_ , & total_angular_momentum_ , channel_indices_ , & channels_omega_values_ , nonzero_terms_per_element_ , nonzero_legendre_indices_ , & nonzero_algebraic_coefficients_ , centrifugal_matrix_ , r_matrix_ , & t_matrix_minus_ , t_matrix_ , t_matrix_plus_ , r_matrix_rmax_ , r_matrix_plus_ ) !---------------------------------------------------------------------! CALL CPU_TIME ( finish ) !---------------------------------------------------------------------! ! Eq. (6.29) !---------------------------------------------------------------------! call calculate_log_der_matrix ( step_numerov_ , number_of_channels_ , & t_matrix_minus_ , t_matrix_ , t_matrix_plus_ , r_matrix_rmax_ , r_matrix_plus_ , log_der_matrix_ ) !---------------------------------------------------------------------! if ( prntlvl . ge . 2 ) then call time_count_summary ( start , finish , calculation_time_ , & \"Propagation completed in \" ) endif !---------------------------------------------------------------------! end subroutine numerov","tags":"","loc":"proc/numerov.html"},{"title":"float_to_character – the SCATTERING code","text":"public  function float_to_character(f, format_string) result(res) Converts a floating-point number to a character string. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: f input floating-point number character(len=*), intent(in), optional :: format_string Optional format string. Return Value character(len=64) Output character string. Called by proc~~float_to_character~~CalledByGraph proc~float_to_character float_to_character proc~ispline ispline proc~ispline->proc~float_to_character proc~input_summary input_summary proc~input_summary->proc~float_to_character program~scattering SCATTERING program~scattering->proc~float_to_character proc~read_input_file read_input_file program~scattering->proc~read_input_file proc~get_radial_coupling_term_value get_radial_coupling_term_value proc~get_radial_coupling_term_value->proc~ispline proc~read_input_file->proc~input_summary Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code float_to_character Source Code function float_to_character ( f , format_string ) result ( res ) !! Converts a floating-point number to a character string. !---------------------------------------------------------------------! real ( dp ), intent ( in ) :: f !! input floating-point number character ( len =* ), intent ( in ), optional :: format_string !! Optional format string. character ( len = 64 ) :: res !! Output character string. !---------------------------------------------------------------------! character ( len = 32 ) :: default_format , user_format !---------------------------------------------------------------------! ! Default format: 6 decimal places !---------------------------------------------------------------------! default_format = '(F0.6)' !---------------------------------------------------------------------! if ( present ( format_string )) then user_format = trim ( format_string ) else user_format = default_format endif !---------------------------------------------------------------------! write ( res , user_format ) f res = adjustl ( res ) !---------------------------------------------------------------------! end function float_to_character","tags":"","loc":"proc/float_to_character.html"},{"title":"integer_to_character – the SCATTERING code","text":"public  function integer_to_character(i) result(res) transfers integer to a character Arguments Type Intent Optional Attributes Name integer, intent(in) :: i input integer Return Value character(len=32) output character Called by proc~~integer_to_character~~CalledByGraph proc~integer_to_character integer_to_character proc~spline spline proc~spline->proc~integer_to_character proc~input_summary input_summary proc~input_summary->proc~integer_to_character proc~check_namelist_basis check_namelist_basis proc~check_namelist_basis->proc~integer_to_character proc~reduce_radial_coupling_terms reduce_radial_coupling_terms proc~reduce_radial_coupling_terms->proc~integer_to_character proc~riccati_bessel_j riccati_bessel_j proc~riccati_bessel_j->proc~integer_to_character program~scattering SCATTERING program~scattering->proc~integer_to_character program~scattering->proc~reduce_radial_coupling_terms proc~print_pes_matrix_elements_summary print_pes_matrix_elements_summary program~scattering->proc~print_pes_matrix_elements_summary proc~interpolate_radial_coupling_terms interpolate_radial_coupling_terms program~scattering->proc~interpolate_radial_coupling_terms proc~read_input_file read_input_file program~scattering->proc~read_input_file proc~read_radial_coupling_terms read_radial_coupling_terms program~scattering->proc~read_radial_coupling_terms proc~calculate_k_matrix calculate_k_matrix program~scattering->proc~calculate_k_matrix proc~save_s_matrix_file_header save_s_matrix_file_header program~scattering->proc~save_s_matrix_file_header proc~save_partial_xs_file_header save_partial_xs_file_header program~scattering->proc~save_partial_xs_file_header proc~file_io_status file_io_status proc~file_io_status->proc~integer_to_character proc~print_pes_matrix_elements_summary->proc~integer_to_character proc~check_namelist_input check_namelist_input proc~check_namelist_input->proc~integer_to_character proc~check_namelist_potential check_namelist_potential proc~check_namelist_potential->proc~integer_to_character proc~riccati_bessel_y riccati_bessel_y proc~riccati_bessel_y->proc~integer_to_character proc~interpolate_radial_coupling_terms->proc~spline proc~read_input_file->proc~input_summary proc~read_input_file->proc~check_namelist_basis proc~read_input_file->proc~file_io_status proc~read_input_file->proc~check_namelist_input proc~read_input_file->proc~check_namelist_potential proc~read_radial_coupling_terms->proc~file_io_status proc~calculate_k_matrix->proc~riccati_bessel_j proc~calculate_k_matrix->proc~riccati_bessel_y proc~save_s_matrix_file_header->proc~file_io_status proc~save_partial_xs_file_header->proc~file_io_status Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code integer_to_character Source Code function integer_to_character ( i ) result ( res ) !! transfers integer to a character !---------------------------------------------------------------------! integer , intent ( in ) :: i !! input integer character ( len = 32 ) :: res !! output character !---------------------------------------------------------------------! write ( res , '(i0)' ) i res = adjustl ( res ) !---------------------------------------------------------------------! end function integer_to_character","tags":"","loc":"proc/integer_to_character.html"},{"title":"to_lowercase – the SCATTERING code","text":"public  function to_lowercase(str) result(low_str) forces lowercase on given string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str input string Return Value character(len=len) output (lowercase) string Contents Source Code to_lowercase Source Code function to_lowercase ( str ) result ( low_str ) !! forces lowercase on given string !---------------------------------------------------------------------! character ( len =* ), intent ( in ) :: str !! input string character ( len = len ( str )) :: low_str !! output (lowercase) string !---------------------------------------------------------------------! integer ( int32 ) :: i !---------------------------------------------------------------------! do i = 1 , len ( str ) low_str ( i : i ) = char_to_lowercase ( str ( i : i )) enddo !---------------------------------------------------------------------! end function to_lowercase","tags":"","loc":"proc/to_lowercase.html"},{"title":"alloc_status – the SCATTERING code","text":"public  subroutine alloc_status(istat_, message_, op_, unit_) check the status after allocation Arguments Type Intent Optional Attributes Name integer(kind=int32) :: istat_ result of stat=istat in (de)allocate character(len=*), intent(in) :: message_ a message to be written character(len=1), intent(in) :: op_ 'a' for allocation, 'd' for deallocation integer(kind=int32), intent(in), optional :: unit_ optional, unit where the message will be written Calls proc~~alloc_status~~CallsGraph proc~alloc_status alloc_status proc~write_error write_error proc~alloc_status->proc~write_error proc~write_message write_message proc~write_error->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code alloc_status Source Code subroutine alloc_status ( istat_ , message_ , op_ , unit_ ) !! check the status after allocation !---------------------------------------------------------------------! integer ( int32 ) :: istat_ !! result of stat=istat in (de)allocate character ( len = * ), intent ( in ) :: message_ !! a message to be written character ( len = 1 ), intent ( in ) :: op_ !! 'a' for allocation, 'd' for deallocation integer ( int32 ), optional , intent ( in ) :: unit_ !! optional, unit where the message will be written !---------------------------------------------------------------------! character ( len = :), allocatable :: add_prefix_ !---------------------------------------------------------------------! add_prefix_ = '' if ( istat_ /= 0 ) then select case ( op_ ) case ( 'a' ) add_prefix_ = 'memory allocation: ' // trim ( message_ ) case ( 'd' ) add_prefix_ = 'memory deallocation: ' // trim ( message_ ) case default call write_error & ( 'Incorrect op_ argument in alloc_status subroutine (' & // trim ( op_ ) // ')' ) end select call write_error ( add_prefix_ , unit_ ) endif !---------------------------------------------------------------------! end subroutine alloc_status","tags":"","loc":"proc/alloc_status.html"},{"title":"file_io_status – the SCATTERING code","text":"public  subroutine file_io_status(istat_, iomsg_, channel_, op_, unit_) check the status during various io operations on files Arguments Type Intent Optional Attributes Name integer(kind=int32) :: istat_ result of iostat in open/read/write/close character(len=*), intent(in) :: iomsg_ result of iomsg in open/read/write/close integer(kind=int32), intent(in) :: channel_ name of the file character(len=1), intent(in) :: op_ 'o' for opening of the file, 'r' for reading, 'w' for writing,\n'c' for closing integer(kind=int32), intent(in), optional :: unit_ optional, unit where the message will be written Calls proc~~file_io_status~~CallsGraph proc~file_io_status file_io_status proc~integer_to_character integer_to_character proc~file_io_status->proc~integer_to_character proc~write_error write_error proc~file_io_status->proc~write_error proc~write_message write_message proc~write_error->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~file_io_status~~CalledByGraph proc~file_io_status file_io_status proc~read_radial_coupling_terms read_radial_coupling_terms proc~read_radial_coupling_terms->proc~file_io_status proc~save_s_matrix_file_header save_s_matrix_file_header proc~save_s_matrix_file_header->proc~file_io_status proc~read_input_file read_input_file proc~read_input_file->proc~file_io_status proc~save_partial_xs_file_header save_partial_xs_file_header proc~save_partial_xs_file_header->proc~file_io_status program~scattering SCATTERING program~scattering->proc~read_radial_coupling_terms program~scattering->proc~save_s_matrix_file_header program~scattering->proc~read_input_file program~scattering->proc~save_partial_xs_file_header Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code file_io_status Source Code subroutine file_io_status ( istat_ , iomsg_ , channel_ , op_ , unit_ ) !! check the status during various io operations on files !---------------------------------------------------------------------! integer ( int32 ) :: istat_ !! result of iostat in open/read/write/close character ( len = * ), intent ( in ) :: iomsg_ !! result of iomsg in open/read/write/close integer ( int32 ), intent ( in ) :: channel_ !! name of the file character ( len = 1 ), intent ( in ) :: op_ !! 'o' for opening of the file, 'r' for reading, 'w' for writing, !! 'c' for closing integer ( int32 ), optional , intent ( in ) :: unit_ !! optional, unit where the message will be written !---------------------------------------------------------------------! character ( len = :), allocatable :: add_prefix_ !---------------------------------------------------------------------! add_prefix_ = '' if ( istat_ /= 0 ) then select case ( op_ ) case ( 'o' ) add_prefix_ = 'opening file on channel: ' // & integer_to_character ( channel_ ) case ( 'r' ) add_prefix_ = 'reading file on channel: ' // & integer_to_character ( channel_ ) case ( 'w' ) add_prefix_ = 'writing to file on channel: ' // & integer_to_character ( channel_ ) case ( 'c' ) add_prefix_ = 'closing file on channel: ' // & integer_to_character ( channel_ ) case default call write_error & ( 'Incorrect op_ argument in file_io_status subroutine (' & // trim ( op_ ) // ')' ) end select call write_error ( trim ( add_prefix_ ) // \" with message: \" // iomsg_ , unit_ ) endif !---------------------------------------------------------------------! end subroutine file_io_status","tags":"","loc":"proc/file_io_status.html"},{"title":"time_count_summary – the SCATTERING code","text":"public  subroutine time_count_summary(start_, stop_, time_, message_) print the message about the time it took to complete a single task Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: start_ initial time real(kind=dp), intent(in) :: stop_ final time real(kind=dp), intent(out) :: time_ stop_ - start_ character(len=*), intent(in), optional :: message_ (optional) a message to print instead of a default\n\"Completed in ... s\" Calls proc~~time_count_summary~~CallsGraph proc~time_count_summary time_count_summary proc~write_message write_message proc~time_count_summary->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~time_count_summary~~CalledByGraph proc~time_count_summary time_count_summary proc~numerov numerov proc~numerov->proc~time_count_summary program~scattering SCATTERING program~scattering->proc~time_count_summary program~scattering->proc~numerov proc~calculate_state_to_state_cross_section calculate_state_to_state_cross_section program~scattering->proc~calculate_state_to_state_cross_section proc~calculate_state_to_state_cross_section->proc~time_count_summary Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code time_count_summary Source Code subroutine time_count_summary ( start_ , stop_ , time_ , message_ ) !! print the message about the time it took to complete a single task !---------------------------------------------------------------------! real ( dp ), intent ( in ) :: start_ !! initial time real ( dp ), intent ( in ) :: stop_ !! final time real ( dp ), intent ( out ) :: time_ !! stop_ - start_ character ( len = * ), optional , intent ( in ) :: message_ !! (optional) a message to print instead of a default !! \"Completed in ... s\" !---------------------------------------------------------------------! character ( len = 12 ) :: default_message = 'Completed in' character ( len = 100 ) :: time_msg !---------------------------------------------------------------------! time_ = stop_ - start_ if ( present ( message_ )) then write ( time_msg , fmt = '(a,x,a,es11.4,x,a)' ) & '--' , trim ( message_ ), time_ , 's' else write ( time_msg , fmt = '(a,x,a,es11.4,x,a)' ) & '--' , default_message , time_ , 's' endif call write_message ( time_msg ) !---------------------------------------------------------------------! end subroutine time_count_summary","tags":"","loc":"proc/time_count_summary.html"},{"title":"write_error – the SCATTERING code","text":"public  subroutine write_error(message_, unit_) writes an error message on a chosen unit Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message_ a message to be written integer(kind=int32), intent(in), optional :: unit_ optional, unit where the message will be written Calls proc~~write_error~~CallsGraph proc~write_error write_error proc~write_message write_message proc~write_error->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~write_error~~CalledByGraph proc~write_error write_error proc~spline spline proc~spline->proc~write_error proc~modified_bessel_temme_algorithm modified_bessel_temme_algorithm proc~modified_bessel_temme_algorithm->proc~write_error proc~wavenumber_squared_from_energy wavenumber_squared_from_energy proc~wavenumber_squared_from_energy->proc~write_error proc~file_io_status file_io_status proc~file_io_status->proc~write_error proc~check_namelist_input check_namelist_input proc~check_namelist_input->proc~write_error proc~write_header write_header proc~write_header->proc~write_error proc~alloc_status alloc_status proc~alloc_status->proc~write_error proc~set_space_fixed_channels set_space_fixed_channels proc~set_space_fixed_channels->proc~write_error proc~interpolate_radial_coupling_terms interpolate_radial_coupling_terms proc~interpolate_radial_coupling_terms->proc~spline proc~modified_bessel_k_ratio modified_bessel_k_ratio proc~modified_bessel_k_ratio->proc~modified_bessel_temme_algorithm proc~save_open_basis_levels save_open_basis_levels proc~save_open_basis_levels->proc~wavenumber_squared_from_energy proc~print_channels print_channels proc~print_channels->proc~wavenumber_squared_from_energy proc~calculate_largest_wavenumber calculate_largest_wavenumber proc~calculate_largest_wavenumber->proc~wavenumber_squared_from_energy proc~calculate_k_matrix calculate_k_matrix proc~calculate_k_matrix->proc~wavenumber_squared_from_energy proc~calculate_k_matrix->proc~modified_bessel_k_ratio proc~read_radial_coupling_terms read_radial_coupling_terms proc~read_radial_coupling_terms->proc~file_io_status proc~read_input_file read_input_file proc~read_input_file->proc~file_io_status proc~read_input_file->proc~check_namelist_input proc~unitarity_check unitarity_check proc~unitarity_check->proc~write_header program~scattering SCATTERING program~scattering->proc~write_header program~scattering->proc~set_space_fixed_channels program~scattering->proc~interpolate_radial_coupling_terms program~scattering->proc~save_open_basis_levels program~scattering->proc~print_channels program~scattering->proc~calculate_largest_wavenumber program~scattering->proc~calculate_k_matrix program~scattering->proc~read_radial_coupling_terms program~scattering->proc~read_input_file program~scattering->proc~unitarity_check proc~save_s_matrix_file_header save_s_matrix_file_header program~scattering->proc~save_s_matrix_file_header proc~save_partial_xs_file_header save_partial_xs_file_header program~scattering->proc~save_partial_xs_file_header proc~save_s_matrix_file_header->proc~file_io_status proc~save_partial_xs_file_header->proc~file_io_status Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_error Source Code subroutine write_error ( message_ , unit_ ) !! writes an error message on a chosen unit !---------------------------------------------------------------------! character ( len = * ), intent ( in ) :: message_ !! a message to be written integer ( int32 ), optional , intent ( in ) :: unit_ !! optional, unit where the message will be written !---------------------------------------------------------------------! call write_message ( 'Error: ' // trim ( message_ ), unit_ ) stop !---------------------------------------------------------------------! end subroutine write_error","tags":"","loc":"proc/write_error.html"},{"title":"write_header – the SCATTERING code","text":"public  subroutine write_header(header_type, opt_integer_) writes headers on screen Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: header_type specifies the type of the header: 'main', 'input_read',\n'input_check', 'input_summary', 'initialization', 'check_norm',\n'save_basis', 'save_pes', 'radial_terms', 'save_radial_terms',\n'reconstruction' integer(kind=int32), intent(in), optional :: opt_integer_ optional integer used in case \"block\" to pass jtot value Calls proc~~write_header~~CallsGraph proc~write_header write_header proc~write_message write_message proc~write_header->proc~write_message proc~write_error write_error proc~write_header->proc~write_error interface~incorrect_value incorrect_value proc~write_header->interface~incorrect_value proc~write_error->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~write_header~~CalledByGraph proc~write_header write_header proc~unitarity_check unitarity_check proc~unitarity_check->proc~write_header program~scattering SCATTERING program~scattering->proc~write_header program~scattering->proc~unitarity_check Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_header Source Code subroutine write_header ( header_type , opt_integer_ ) !! writes headers on screen character ( len = * ), intent ( in ) :: header_type !! specifies the type of the header: 'main', 'input_read', !! 'input_check', 'input_summary', 'initialization', 'check_norm', !! 'save_basis', 'save_pes', 'radial_terms', 'save_radial_terms', !! 'reconstruction' integer ( int32 ), optional , intent ( in ) :: opt_integer_ !! optional integer used in case \"block\" to pass jtot value !---------------------------------------------------------------------! character ( len = 100 ) :: header_star , header_str character ( len = 10 ) :: tmp_str_ integer ( int32 ) :: len_str_ !---------------------------------------------------------------------! select case ( trim ( header_type )) case ( 'main' ) write ( header_star , fmt = \"(a90)\" ) repeat ( \"*\" , 90 ) call write_message ( header_star ) call write_message ( header_star ) write ( header_str , fmt = '(a,25x,a43,20x,a)' ) & '*' , 'BIGOS quantum scattering package, vs. 0.00.' , '*' call write_message ( header_str ) write ( header_str , fmt = '(a,36x,a19,33x,a)' ) & '*' , 'the SCATTERING code' , '*' call write_message ( header_str ) write ( header_str , fmt = '(a,29x,a31,28x,a)' ) & '*' , 'adjusted for H2-He calculations' , '*' call write_message ( header_str ) write ( header_str , fmt = '(a,37x,a17,34x,a)' ) & '*' , 'by Hubert Jozwiak' , '*' call write_message ( header_str ) write ( header_str , fmt = '(a,40x,a11,37x,a)' ) & '*' , '20/12/2023 ' , '*' call write_message ( header_str ) call write_message ( header_star ) case ( 'block' ) call write_message ( repeat ( '*' , 90 )) if ( present ( opt_integer_ )) then write ( tmp_str_ , \"(i10)\" ) opt_integer_ len_str_ = len_trim ( tmp_str_ ) write ( * , '(\"*\", A, \"JTOT = \", A, A, \"*\")' ) & repeat ( ' ' , 40 - len_str_ ), tmp_str_ , repeat ( ' ' , 41 ) call write_message ( repeat ( '*' , 90 )) else call write_error ( \"**** JTOT value not provided in \" // & \"write_header_block ****\" ) endif case ( 'unitarity' ) call write_message ( repeat ( \" \" , 43 ) // \"***\" ) call write_message ( \"Check of the unitarity of the S-matrix:\" ) call write_message ( repeat ( \" \" , 34 ) // \"*** S-matrix elements: ***\" ) call write_message ( \"   ROW   COL\" // repeat ( \" \" , 15 ) // \"S**2\" // & repeat ( \" \" , 17 ) // \"RE (S)\" // repeat ( \" \" , 17 ) // \"IM (S)\" ) case default call incorrect_value ( 'header_type (write_header)' , header_type ) end select !---------------------------------------------------------------------! end subroutine write_header","tags":"","loc":"proc/write_header.html"},{"title":"write_message – the SCATTERING code","text":"public  subroutine write_message(message_, unit_) writes a message on a chosen unit Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message_ a message to be written integer(kind=int32), intent(in), optional :: unit_ optional, unit where the message will be written Called by proc~~write_message~~CalledByGraph proc~write_message write_message proc~write_warning write_warning proc~write_warning->proc~write_message proc~write_error write_error proc~write_error->proc~write_message proc~print_channels print_channels proc~print_channels->proc~write_message proc~wavenumber_squared_from_energy wavenumber_squared_from_energy proc~print_channels->proc~wavenumber_squared_from_energy proc~input_summary input_summary proc~input_summary->proc~write_message proc~reduce_radial_coupling_terms reduce_radial_coupling_terms proc~reduce_radial_coupling_terms->proc~write_message proc~print_largest_partial_cross_sections print_largest_partial_cross_sections proc~print_largest_partial_cross_sections->proc~write_message proc~save_partial_xs_single_block save_partial_xs_single_block proc~save_partial_xs_single_block->proc~write_message program~scattering SCATTERING program~scattering->proc~write_message program~scattering->proc~print_channels program~scattering->proc~reduce_radial_coupling_terms program~scattering->proc~print_largest_partial_cross_sections program~scattering->proc~save_partial_xs_single_block proc~print_pes_matrix_elements_summary print_pes_matrix_elements_summary program~scattering->proc~print_pes_matrix_elements_summary proc~write_header write_header program~scattering->proc~write_header proc~time_count_summary time_count_summary program~scattering->proc~time_count_summary proc~save_partial_xs_file_header save_partial_xs_file_header program~scattering->proc~save_partial_xs_file_header proc~read_input_file read_input_file program~scattering->proc~read_input_file proc~unitarity_check unitarity_check program~scattering->proc~unitarity_check proc~set_space_fixed_channels set_space_fixed_channels program~scattering->proc~set_space_fixed_channels proc~numerov numerov program~scattering->proc~numerov proc~calculate_state_to_state_cross_section calculate_state_to_state_cross_section program~scattering->proc~calculate_state_to_state_cross_section proc~interpolate_radial_coupling_terms interpolate_radial_coupling_terms program~scattering->proc~interpolate_radial_coupling_terms proc~save_open_basis_levels save_open_basis_levels program~scattering->proc~save_open_basis_levels proc~calculate_k_matrix calculate_k_matrix program~scattering->proc~calculate_k_matrix proc~calculate_largest_wavenumber calculate_largest_wavenumber program~scattering->proc~calculate_largest_wavenumber proc~read_radial_coupling_terms read_radial_coupling_terms program~scattering->proc~read_radial_coupling_terms proc~save_s_matrix_file_header save_s_matrix_file_header program~scattering->proc~save_s_matrix_file_header proc~print_pes_matrix_elements_summary->proc~write_message proc~check_namelist_input check_namelist_input proc~check_namelist_input->proc~write_message proc~check_namelist_input->proc~write_error proc~handle_unitarity_output_message handle_unitarity_output_message proc~handle_unitarity_output_message->proc~write_message proc~handle_unitarity_output_message->proc~write_warning proc~write_header->proc~write_message proc~write_header->proc~write_error proc~time_count_summary->proc~write_message proc~save_partial_xs_file_header->proc~write_message proc~file_io_status file_io_status proc~save_partial_xs_file_header->proc~file_io_status proc~ispline ispline proc~ispline->proc~write_warning proc~riccati_bessel_j riccati_bessel_j proc~riccati_bessel_j->proc~write_warning proc~spline spline proc~spline->proc~write_error proc~modified_bessel_temme_algorithm modified_bessel_temme_algorithm proc~modified_bessel_temme_algorithm->proc~write_error proc~read_input_file->proc~input_summary proc~read_input_file->proc~check_namelist_input proc~read_input_file->proc~file_io_status proc~unitarity_check->proc~handle_unitarity_output_message proc~unitarity_check->proc~write_header proc~riccati_bessel_y riccati_bessel_y proc~riccati_bessel_y->proc~write_warning proc~wavenumber_squared_from_energy->proc~write_error proc~file_io_status->proc~write_error proc~alloc_status alloc_status proc~alloc_status->proc~write_error proc~set_space_fixed_channels->proc~write_error proc~numerov->proc~time_count_summary proc~calculate_state_to_state_cross_section->proc~time_count_summary proc~interpolate_radial_coupling_terms->proc~spline proc~save_open_basis_levels->proc~wavenumber_squared_from_energy proc~calculate_k_matrix->proc~riccati_bessel_j proc~calculate_k_matrix->proc~riccati_bessel_y proc~calculate_k_matrix->proc~wavenumber_squared_from_energy proc~modified_bessel_k_ratio modified_bessel_k_ratio proc~calculate_k_matrix->proc~modified_bessel_k_ratio proc~modified_bessel_k_ratio->proc~modified_bessel_temme_algorithm proc~calculate_largest_wavenumber->proc~wavenumber_squared_from_energy proc~read_radial_coupling_terms->proc~file_io_status proc~get_radial_coupling_term_value get_radial_coupling_term_value proc~get_radial_coupling_term_value->proc~ispline proc~save_s_matrix_file_header->proc~file_io_status Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_message Source Code subroutine write_message ( message_ , unit_ ) !! writes a message on a chosen unit !---------------------------------------------------------------------! character ( len = * ), intent ( in ) :: message_ !! a message to be written integer ( int32 ), optional , intent ( in ) :: unit_ !! optional, unit where the message will be written !---------------------------------------------------------------------! if ( present ( unit_ )) then write ( unit_ , '(a)' ) trim ( message_ ) else write ( output_unit , '(a)' ) trim ( message_ ) endif !---------------------------------------------------------------------! end subroutine write_message","tags":"","loc":"proc/write_message.html"},{"title":"write_warning – the SCATTERING code","text":"public  subroutine write_warning(message_, unit_) writes a warning message on a chosen unit Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message_ a message to be written integer(kind=int32), intent(in), optional :: unit_ optional, unit where the message will be written Calls proc~~write_warning~~CallsGraph proc~write_warning write_warning proc~write_message write_message proc~write_warning->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~write_warning~~CalledByGraph proc~write_warning write_warning proc~ispline ispline proc~ispline->proc~write_warning proc~riccati_bessel_j riccati_bessel_j proc~riccati_bessel_j->proc~write_warning proc~handle_unitarity_output_message handle_unitarity_output_message proc~handle_unitarity_output_message->proc~write_warning proc~riccati_bessel_y riccati_bessel_y proc~riccati_bessel_y->proc~write_warning proc~get_radial_coupling_term_value get_radial_coupling_term_value proc~get_radial_coupling_term_value->proc~ispline proc~unitarity_check unitarity_check proc~unitarity_check->proc~handle_unitarity_output_message proc~calculate_k_matrix calculate_k_matrix proc~calculate_k_matrix->proc~riccati_bessel_j proc~calculate_k_matrix->proc~riccati_bessel_y program~scattering SCATTERING program~scattering->proc~unitarity_check program~scattering->proc~calculate_k_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_warning Source Code subroutine write_warning ( message_ , unit_ ) !! writes a warning message on a chosen unit !---------------------------------------------------------------------! character ( len = * ), intent ( in ) :: message_ !! a message to be written integer ( int32 ), optional , intent ( in ) :: unit_ !! optional, unit where the message will be written !---------------------------------------------------------------------! call write_message ( 'Warning: ' // trim ( message_ ), unit_ ) !---------------------------------------------------------------------! end subroutine write_warning","tags":"","loc":"proc/write_warning.html"},{"title":"incorrect_value – the SCATTERING code","text":"public interface incorrect_value interface for the following message: incorrect value encountered:\n  variable_name = variable_value Called by interface~~incorrect_value~~CalledByGraph interface~incorrect_value incorrect_value proc~check_namelist_input check_namelist_input proc~check_namelist_input->interface~incorrect_value proc~check_namelist_potential check_namelist_potential proc~check_namelist_potential->interface~incorrect_value proc~check_namelist_basis check_namelist_basis proc~check_namelist_basis->interface~incorrect_value proc~write_header write_header proc~write_header->interface~incorrect_value proc~read_input_file read_input_file proc~read_input_file->proc~check_namelist_input proc~read_input_file->proc~check_namelist_potential proc~read_input_file->proc~check_namelist_basis proc~unitarity_check unitarity_check proc~unitarity_check->proc~write_header program~scattering SCATTERING program~scattering->proc~write_header program~scattering->proc~read_input_file program~scattering->proc~unitarity_check Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures incorrect_value_ch incorrect_value_int32 incorrect_value_sp incorrect_value_dp Module Procedures private  subroutine incorrect_value_ch(name_, value_, unit_) incorrect value encountered:\n  variable_name = variable_value Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name_ name of the variable character(len=*), intent(in) :: value_ value of the variable integer(kind=int32), intent(in), optional :: unit_ optional, unit where the message will be written private  subroutine incorrect_value_int32(name_, value_, unit_) incorrect value encountered:\n  variable_name = variable_value Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name_ name of the variable integer(kind=int32), intent(in) :: value_ value of the variable integer(kind=int32), intent(in), optional :: unit_ optional, unit where the message will be written private  subroutine incorrect_value_sp(name_, value_, unit_) incorrect value encountered:\n  variable_name = variable_value Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name_ name of the variable real(kind=sp), intent(in) :: value_ value of the variable integer(kind=int32), intent(in), optional :: unit_ optional, unit where the message will be written private  subroutine incorrect_value_dp(name_, value_, unit_) incorrect value encountered:\n  variable_name = variable_value Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name_ name of the variable real(kind=dp), intent(in) :: value_ value of the variable integer(kind=int32), intent(in), optional :: unit_ optional, unit where the message will be written","tags":"","loc":"interface/incorrect_value.html"},{"title":"save_s_matrix_block_info – the SCATTERING code","text":"public  subroutine save_s_matrix_block_info(total_angular_momentum, parity_exponent, number_of_open_channels, channel_indices, channel_l_values, wv, s_matrix_real, s_matrix_imag) save information about current block\n-- total angular momentum, parity exponent, number of open channels\n   in the current block\n-- array of indices pointing to the basis arrays, array holding\n   l values, wavenumbers\n-- real part of the S-matrix\n-- imaginary part of the S-matrix Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: total_angular_momentum integer(kind=int32), intent(in) :: parity_exponent integer(kind=int32), intent(in) :: number_of_open_channels integer(kind=int32), intent(in) :: channel_indices (number_of_open_channels) integer(kind=int32), intent(in) :: channel_l_values (number_of_open_channels) real(kind=dp), intent(in) :: wv (number_of_open_channels) real(kind=dp), intent(in) :: s_matrix_real (number_of_open_channels,number_of_open_channels) real(kind=dp), intent(in) :: s_matrix_imag (number_of_open_channels,number_of_open_channels) Called by proc~~save_s_matrix_block_info~~CalledByGraph proc~save_s_matrix_block_info save_s_matrix_block_info program~scattering SCATTERING program~scattering->proc~save_s_matrix_block_info Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code save_s_matrix_block_info Source Code subroutine save_s_matrix_block_info ( total_angular_momentum , parity_exponent , & number_of_open_channels , channel_indices , channel_l_values , wv , & s_matrix_real , s_matrix_imag ) !! save information about current block !! -- total angular momentum, parity exponent, number of open channels !!    in the current block !! -- array of indices pointing to the basis arrays, array holding !!    \\l\\ values, wavenumbers !! -- real part of the S-matrix !! -- imaginary part of the S-matrix !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: total_angular_momentum integer ( int32 ), intent ( in ) :: parity_exponent integer ( int32 ), intent ( in ) :: number_of_open_channels integer ( int32 ), intent ( in ) :: channel_indices ( number_of_open_channels ) integer ( int32 ), intent ( in ) :: channel_l_values ( number_of_open_channels ) real ( dp ), intent ( in ) :: wv ( number_of_open_channels ) real ( dp ), intent ( in ) :: s_matrix_real ( number_of_open_channels , number_of_open_channels ) real ( dp ), intent ( in ) :: s_matrix_imag ( number_of_open_channels , number_of_open_channels ) !---------------------------------------------------------------------! integer ( int32 ) :: channel_index_ , channel_index_2_ !---------------------------------------------------------------------! write ( s_matrix_unit ) total_angular_momentum , parity_exponent , number_of_open_channels write ( s_matrix_unit ) ( channel_indices ( channel_index_ ), & channel_l_values ( channel_index_ ), wv ( channel_index_ ), & channel_index_ = 1 , number_of_open_channels ) write ( s_matrix_unit )(( s_matrix_real ( channel_index_ , channel_index_2_ ),& channel_index_2_ = 1 , channel_index_ ), channel_index_ = 1 , number_of_open_channels ) write ( s_matrix_unit ) (( s_matrix_imag ( channel_index_ , channel_index_2_ ),& channel_index_2_ = 1 , channel_index_ ), channel_index_ = 1 , number_of_open_channels ) !---------------------------------------------------------------------! end subroutine save_s_matrix_block_info","tags":"","loc":"proc/save_s_matrix_block_info.html"},{"title":"save_s_matrix_file_header – the SCATTERING code","text":"public  subroutine save_s_matrix_file_header() save \"header\" of the S-matrix file:\n-- label, \"itype\", number of levels in the basis, reduced mass of the system\n-- vibrational and rotational quantum numbers\n-- rovibrational energies\n-- index pointing to the initial level and the kinetic/total energy Arguments None Calls proc~~save_s_matrix_file_header~~CallsGraph proc~save_s_matrix_file_header save_s_matrix_file_header proc~file_io_status file_io_status proc~save_s_matrix_file_header->proc~file_io_status proc~integer_to_character integer_to_character proc~file_io_status->proc~integer_to_character proc~write_error write_error proc~file_io_status->proc~write_error proc~write_message write_message proc~write_error->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~save_s_matrix_file_header~~CalledByGraph proc~save_s_matrix_file_header save_s_matrix_file_header program~scattering SCATTERING program~scattering->proc~save_s_matrix_file_header Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code save_s_matrix_file_header Source Code subroutine save_s_matrix_file_header !! save \"header\" of the S-matrix file: !! -- label, \"itype\", number of levels in the basis, reduced mass of the system !! -- vibrational and rotational quantum numbers !! -- rovibrational energies !! -- index pointing to the initial level and the kinetic/total energy !---------------------------------------------------------------------! character ( len = 200 ) :: err_message integer ( int32 ) :: io_status , ilevel !---------------------------------------------------------------------! open ( s_matrix_unit , file = trim ( smatrixfile ), form = 'unformatted' , & iostat = io_status , iomsg = err_message ) call file_io_status ( io_status , err_message , s_matrix_unit , \"o\" ) !---------------------------------------------------------------------! write ( s_matrix_unit ) label , 2 , nlevel , reduced_mass write ( s_matrix_unit ) ( v1array ( ilevel ), j1array ( ilevel ), ilevel = 1 , nlevel ) write ( s_matrix_unit ) ( elevel ( ilevel ), ilevel = 1 , nlevel ) write ( s_matrix_unit ) initial , energy !---------------------------------------------------------------------! end subroutine save_s_matrix_file_header","tags":"","loc":"proc/save_s_matrix_file_header.html"},{"title":"calculate_largest_wavenumber – the SCATTERING code","text":"public  function calculate_largest_wavenumber(channel_indices) result(largest_wavenumber_) Calculates the largest wave number in the block;\ncalled only if there are any open channels Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: channel_indices (:) holds the indices pointing to the basis arrays Return Value real(kind=dp) (output) the largest wave number (wavmax) in the block Calls proc~~calculate_largest_wavenumber~~CallsGraph proc~calculate_largest_wavenumber calculate_largest_wavenumber proc~is_open is_open proc~calculate_largest_wavenumber->proc~is_open proc~wavenumber_squared_from_energy wavenumber_squared_from_energy proc~calculate_largest_wavenumber->proc~wavenumber_squared_from_energy proc~etotal ETOTAL proc~is_open->proc~etotal proc~wavenumber_squared_from_energy->proc~etotal proc~write_error write_error proc~wavenumber_squared_from_energy->proc~write_error proc~write_message write_message proc~write_error->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~calculate_largest_wavenumber~~CalledByGraph proc~calculate_largest_wavenumber calculate_largest_wavenumber program~scattering SCATTERING program~scattering->proc~calculate_largest_wavenumber Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code calculate_largest_wavenumber Source Code function calculate_largest_wavenumber ( channel_indices ) result ( largest_wavenumber_ ) !! Calculates the largest wave number in the block; !! called only if there are any open channels !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: channel_indices (:) !! holds the indices pointing to the basis arrays real ( dp ) :: largest_wavenumber_ !! (output) the largest wave number (wavmax) in the block !---------------------------------------------------------------------! integer ( int32 ) :: channel_index_ real ( dp ) :: wavenumber_ !---------------------------------------------------------------------! wavenumber_ = 0.0_dp !---------------------------------------------------------------------! do channel_index_ = 1 , size ( channel_indices ) if ( is_open ( elevel ( channel_indices ( channel_index_ )))) then wavenumber_ = sqrt ( wavenumber_squared_from_energy ( elevel ( channel_indices ( channel_index_ ))) ) largest_wavenumber_ = max ( largest_wavenumber_ , wavenumber_ ) endif enddo !---------------------------------------------------------------------! end function calculate_largest_wavenumber","tags":"","loc":"proc/calculate_largest_wavenumber.html"},{"title":"count_open_channels_in_block – the SCATTERING code","text":"public  function count_open_channels_in_block(channel_indices) result(number_of_open_channels_) counts the energetically accessible channels in the given block Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: channel_indices (:) holds the indices pointing to the basis arrays Return Value integer(kind=int32) (output) number of open channels Calls proc~~count_open_channels_in_block~~CallsGraph proc~count_open_channels_in_block count_open_channels_in_block proc~is_open is_open proc~count_open_channels_in_block->proc~is_open proc~etotal ETOTAL proc~is_open->proc~etotal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~count_open_channels_in_block~~CalledByGraph proc~count_open_channels_in_block count_open_channels_in_block program~scattering SCATTERING program~scattering->proc~count_open_channels_in_block Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code count_open_channels_in_block Source Code function count_open_channels_in_block ( channel_indices ) & result ( number_of_open_channels_ ) !! counts the energetically accessible channels in the given block !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: channel_indices (:) !! holds the indices pointing to the basis arrays integer ( int32 ) :: number_of_open_channels_ !! (output) number of open channels !---------------------------------------------------------------------! integer ( int32 ) :: channel_index_ !---------------------------------------------------------------------! number_of_open_channels_ = 0 do channel_index_ = 1 , size ( channel_indices ) if ( is_open ( elevel ( channel_indices ( channel_index_ )))) then number_of_open_channels_ = number_of_open_channels_ + 1 endif enddo !---------------------------------------------------------------------! end function count_open_channels_in_block","tags":"","loc":"proc/count_open_channels_in_block.html"},{"title":"print_channels – the SCATTERING code","text":"public  subroutine print_channels(parity_exponent_, channel_indices, channels_omega_values) prints information about body-fixed channels on screen Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: parity_exponent_ parity exponent of the block (0 if p = +1, 1 if p = -1) integer(kind=int32), intent(inout) :: channel_indices (:) holds the indices pointing to the basis arrays integer(kind=int32), intent(inout) :: channels_omega_values (:) holds all values of \\bar{\\Omega} Calls proc~~print_channels~~CallsGraph proc~print_channels print_channels proc~write_message write_message proc~print_channels->proc~write_message proc~is_open is_open proc~print_channels->proc~is_open proc~wavenumber_squared_from_energy wavenumber_squared_from_energy proc~print_channels->proc~wavenumber_squared_from_energy proc~etotal ETOTAL proc~is_open->proc~etotal proc~wavenumber_squared_from_energy->proc~etotal proc~write_error write_error proc~wavenumber_squared_from_energy->proc~write_error proc~write_error->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~print_channels~~CalledByGraph proc~print_channels print_channels program~scattering SCATTERING program~scattering->proc~print_channels Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code print_channels Source Code subroutine print_channels ( parity_exponent_ , channel_indices , & channels_omega_values ) !! prints information about body-fixed channels on screen !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: parity_exponent_ !! parity exponent of the block (0 if p = +1, 1 if p = -1) integer ( int32 ), intent ( inout ) :: channel_indices (:) !! holds the indices pointing to the basis arrays integer ( int32 ), intent ( inout ) :: channels_omega_values (:) !! holds all values of \\bar{\\Omega} !---------------------------------------------------------------------! integer ( int32 ) :: channel_index_ , v_ , j_ , omega_ , parity_ real ( dp ) :: internal_energy_ , wavenumber_ !---------------------------------------------------------------------! call write_message ( \"  v1      j1     omega      p\" // repeat ( \" \" , 10 ) & // \"E_vj\" // repeat ( \" \" , 16 ) // \"wv\" ) !---------------------------------------------------------------------! do channel_index_ = 1 , size ( channel_indices ) v_ = v1array ( channel_indices ( channel_index_ )) j_ = j1array ( channel_indices ( channel_index_ )) omega_ = channels_omega_values ( channel_index_ ) parity_ = ( - 1 ) ** parity_exponent_ internal_energy_ = elevel ( channel_indices ( channel_index_ )) !------------------------------------------------------------------! ! format for open channels: !------------------------------------------------------------------! if ( is_open ( internal_energy_ )) then wavenumber_ = sqrt ( wavenumber_squared_from_energy ( internal_energy_ ) ) call write_channel_line ( v_ , j_ , omega_ , parity_ , & internal_energy_ , wavenumber_ ) !------------------------------------------------------------------! ! format for closed channels: !------------------------------------------------------------------! else call write_channel_line ( v_ , j_ , omega_ , parity_ , internal_energy_ ) endif !------------------------------------------------------------------! enddo !---------------------------------------------------------------------! end subroutine print_channels","tags":"","loc":"proc/print_channels.html"},{"title":"set_body_fixed_channels – the SCATTERING code","text":"public  subroutine set_body_fixed_channels(total_angular_momentum_, parity_exponent_, channel_indices, channels_omega_values) Prepares the channel_indices array which holds indices that refer to the\nbasis arrays: v1level/j1level/elevel, and channels_omega_values which holds values\nof \\bar{\\Omega} Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: total_angular_momentum_ total angular momentum integer(kind=int32), intent(in) :: parity_exponent_ parity exponent of the block (0 if p = +1, 1 if p = -1) integer(kind=int32), intent(inout) :: channel_indices (:) holds the indices pointing to the basis arrays integer(kind=int32), intent(inout) :: channels_omega_values (:) holds all values of \\bar{\\Omega} Called by proc~~set_body_fixed_channels~~CalledByGraph proc~set_body_fixed_channels set_body_fixed_channels program~scattering SCATTERING program~scattering->proc~set_body_fixed_channels Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code set_body_fixed_channels Source Code subroutine set_body_fixed_channels ( total_angular_momentum_ , & parity_exponent_ , channel_indices , channels_omega_values ) !! Prepares the channel_indices array which holds indices that refer to the !! basis arrays: v1level/j1level/elevel, and channels_omega_values which holds values !! of \\bar{\\Omega} !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: total_angular_momentum_ !! total angular momentum integer ( int32 ), intent ( in ) :: parity_exponent_ !! parity exponent of the block (0 if p = +1, 1 if p = -1) integer ( int32 ), intent ( inout ) :: channel_indices (:) !! holds the indices pointing to the basis arrays integer ( int32 ), intent ( inout ) :: channels_omega_values (:) !! holds all values of \\bar{\\Omega} !---------------------------------------------------------------------! integer ( int32 ) :: level_index_ , channel_index_ , omega_max_ , parity_term_exponent_ !---------------------------------------------------------------------! ! due to construction of body-fixed basis states: ! |v j \\bar{\\Omega} J p > = N (|v j \\bar{\\Omega} J > !                         + p (-1)&#94;{J} |v j -\\bar{\\Omega} J > ) ! we are interested in the exponent of the \"p (-1)&#94;{J}\" term !---------------------------------------------------------------------! parity_term_exponent_ = mod ( parity_exponent_ + total_angular_momentum_ , 2 ) !---------------------------------------------------------------------! channel_index_ = 0 !---------------------------------------------------------------------! do level_index_ = 1 , nlevel omega_max_ = min ( j1array ( level_index_ ), total_angular_momentum_ ) call update_body_fixed_channels_info ( omega_max_ , parity_term_exponent_ , & level_index_ , channel_index_ , channel_indices , channels_omega_values ) enddo !---------------------------------------------------------------------! end subroutine set_body_fixed_channels","tags":"","loc":"proc/set_body_fixed_channels.html"},{"title":"set_number_of_channels – the SCATTERING code","text":"public  subroutine set_number_of_channels(total_angular_momentum_, number_of_channels_even_parity_block, number_of_channels_odd_parity_block) determine the number of scattering channels in each parity block \nfor given total angular momentum in both body-fixed and\nspace-fixed frames Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: total_angular_momentum_ total angular momentum integer(kind=int32), intent(out) :: number_of_channels_even_parity_block number of channels in the p = 1 (even parity) block integer(kind=int32), intent(out) :: number_of_channels_odd_parity_block number of channels in the p = -1 (odd parity) block Called by proc~~set_number_of_channels~~CalledByGraph proc~set_number_of_channels set_number_of_channels program~scattering SCATTERING program~scattering->proc~set_number_of_channels Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code set_number_of_channels Source Code subroutine set_number_of_channels ( total_angular_momentum_ , & number_of_channels_even_parity_block , number_of_channels_odd_parity_block ) !! determine the number of scattering channels in each parity block !! for given total angular momentum in both body-fixed and !! space-fixed frames !---------------------------------------------------------------------! !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: total_angular_momentum_ !! total angular momentum integer ( int32 ), intent ( out ) :: number_of_channels_even_parity_block !! number of channels in the p = 1 (even parity) block integer ( int32 ), intent ( out ) :: number_of_channels_odd_parity_block !! number of channels in the p = -1 (odd parity) block !---------------------------------------------------------------------! integer ( int32 ) :: number_of_channels_even_parity_block_sf , & number_of_channels_odd_parity_block_sf !---------------------------------------------------------------------! ! body-fixed frame !---------------------------------------------------------------------! call calculate_number_of_channels_body_fixed ( total_angular_momentum_ , & number_of_channels_even_parity_block , number_of_channels_odd_parity_block ) !---------------------------------------------------------------------! ! space-fixed frame !---------------------------------------------------------------------! call calculate_number_of_channels_space_fixed ( total_angular_momentum_ , & number_of_channels_even_parity_block_sf , number_of_channels_odd_parity_block_sf ) !---------------------------------------------------------------------! ! Check if the number of channels is the same !---------------------------------------------------------------------! call check_number_of_channels ( number_of_channels_even_parity_block , & number_of_channels_even_parity_block_sf , \"even\" ) call check_number_of_channels ( number_of_channels_odd_parity_block , & number_of_channels_odd_parity_block_sf , \"odd\" ) !---------------------------------------------------------------------! end subroutine set_number_of_channels","tags":"","loc":"proc/set_number_of_channels.html"},{"title":"set_space_fixed_channels – the SCATTERING code","text":"public  subroutine set_space_fixed_channels(total_angular_momentum_, parity_exponent_, channel_l_values) Prepares the channel_l_values array which holds values of\norbital angular momentum, l, a space-fixed-frame quantum number. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: total_angular_momentum_ total angular momentum integer(kind=int32), intent(in) :: parity_exponent_ parity exponent of the block (0 if p = +1, 1 if p = -1) integer(kind=int32), intent(inout) :: channel_l_values (:) holds all values of l Calls proc~~set_space_fixed_channels~~CallsGraph proc~set_space_fixed_channels set_space_fixed_channels proc~write_error write_error proc~set_space_fixed_channels->proc~write_error proc~write_message write_message proc~write_error->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~set_space_fixed_channels~~CalledByGraph proc~set_space_fixed_channels set_space_fixed_channels program~scattering SCATTERING program~scattering->proc~set_space_fixed_channels Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code set_space_fixed_channels Source Code subroutine set_space_fixed_channels ( total_angular_momentum_ , & parity_exponent_ , channel_l_values ) !! Prepares the channel_l_values array which holds values of !! orbital angular momentum, \\l\\, a space-fixed-frame quantum number. !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: total_angular_momentum_ !! total angular momentum integer ( int32 ), intent ( in ) :: parity_exponent_ !! parity exponent of the block (0 if p = +1, 1 if p = -1) integer ( int32 ), intent ( inout ) :: channel_l_values (:) !! holds all values of l !---------------------------------------------------------------------! integer :: level_index_ , l_min_ , l_max_ , l_ , channel_index_ !---------------------------------------------------------------------! channel_index_ = 0 do level_index_ = 1 , nlevel l_min_ = abs ( total_angular_momentum_ - j1array ( level_index_ )) l_max_ = total_angular_momentum_ + j1array ( level_index_ ) do l_ = l_min_ , l_max_ if ( mod ( l_ + j1array ( level_index_ ), 2 ) == parity_exponent_ ) then channel_index_ = channel_index_ + 1 if ( channel_index_ > size ( channel_l_values )) then call write_error ( \"channel_index_ out of bounds of \" // & \"channel_l_values in set_space_fixed_channels.\" ) end if channel_l_values ( channel_index_ ) = l_ endif enddo enddo !---------------------------------------------------------------------! end subroutine set_space_fixed_channels","tags":"","loc":"proc/set_space_fixed_channels.html"},{"title":"calculate_state_to_state_cross_section – the SCATTERING code","text":"public  subroutine calculate_state_to_state_cross_section(total_angular_momentum_, open_basis_levels_, open_basis_wavevectors_, s_matrix_real_, s_matrix_imag_, channel_indices_, channel_l_values_, cross_section_array_) Calculates all state-to-state cross-sections. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: total_angular_momentum_ total angular momentum integer(kind=int32), intent(in) :: open_basis_levels_ (:) holds indices to the basis arrays which correspond to open channels real(kind=dp), intent(in) :: open_basis_wavevectors_ (:) holds wavenumbers k_{i} real(kind=dp), intent(in) :: s_matrix_real_ (:,:) real and imaginary parts of the S-matrix real(kind=dp), intent(in) :: s_matrix_imag_ (:,:) real and imaginary parts of the S-matrix integer(kind=int32), intent(in) :: channel_indices_ (:) holds the indices pointing to the basis arrays integer(kind=int32), intent(in) :: channel_l_values_ (:) holds all values of l real(kind=dp), intent(inout) :: cross_section_array_ (:) array holding all XSs Calls proc~~calculate_state_to_state_cross_section~~CallsGraph proc~calculate_state_to_state_cross_section calculate_state_to_state_cross_section proc~time_count_summary time_count_summary proc~calculate_state_to_state_cross_section->proc~time_count_summary proc~write_message write_message proc~time_count_summary->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~calculate_state_to_state_cross_section~~CalledByGraph proc~calculate_state_to_state_cross_section calculate_state_to_state_cross_section program~scattering SCATTERING program~scattering->proc~calculate_state_to_state_cross_section Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents","tags":"","loc":"proc/calculate_state_to_state_cross_section.html"},{"title":"check_cross_section_thresholds – the SCATTERING code","text":"public  subroutine check_cross_section_thresholds(largest_elastic_xs_, largest_inelastic_xs_, consecutive_elastic_, consecutive_inelastic_, terminate_) Checks if the elastic_xs_threshold (threshold for elastic XS) and inelastic_xs_threshold\n(threshold for inelastic XS) conditions are already fulfilled. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: largest_elastic_xs_ largest elastic XS in the block real(kind=dp), intent(in) :: largest_inelastic_xs_ largest inelastic XS in the block integer(kind=int32), intent(inout) :: consecutive_elastic_ number of consecutive blocks meeting condition on elastic XS integer(kind=int32), intent(inout) :: consecutive_inelastic_ number of consecutive blocks meeting condition on inelastic XS logical, intent(inout) :: terminate_ flag to indicate termination of loop based on thresholds Called by proc~~check_cross_section_thresholds~~CalledByGraph proc~check_cross_section_thresholds check_cross_section_thresholds program~scattering SCATTERING program~scattering->proc~check_cross_section_thresholds Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code check_cross_section_thresholds Source Code subroutine check_cross_section_thresholds ( largest_elastic_xs_ , & largest_inelastic_xs_ , consecutive_elastic_ , consecutive_inelastic_ , & terminate_ ) !! Checks if the elastic_xs_threshold (threshold for elastic XS) and inelastic_xs_threshold !! (threshold for inelastic XS) conditions are already fulfilled. !---------------------------------------------------------------------! real ( dp ), intent ( in ) :: largest_elastic_xs_ !! largest elastic XS in the block real ( dp ), intent ( in ) :: largest_inelastic_xs_ !! largest inelastic XS in the block integer ( int32 ), intent ( inout ) :: consecutive_elastic_ !! number of consecutive blocks meeting condition on elastic XS integer ( int32 ), intent ( inout ) :: consecutive_inelastic_ !! number of consecutive blocks meeting condition on inelastic XS logical , intent ( inout ) :: terminate_ !! flag to indicate termination of loop based on thresholds !---------------------------------------------------------------------! logical :: is_elastic_xs_within_threshold , is_inelastic_xs_within_threshold !---------------------------------------------------------------------! terminate_ = . false . is_elastic_xs_within_threshold = ( largest_elastic_xs_ <= elastic_xs_threshold ) is_inelastic_xs_within_threshold = ( largest_inelastic_xs_ <= inelastic_xs_threshold ) if ( is_elastic_xs_within_threshold ) then consecutive_elastic_ = consecutive_elastic_ + 1 else consecutive_elastic_ = 0 endif if ( is_inelastic_xs_within_threshold ) then consecutive_inelastic_ = consecutive_inelastic_ + 1 else consecutive_inelastic_ = 0 endif if (( consecutive_elastic_ >= consecutive_blocks_threshold ). and . & ( consecutive_inelastic_ >= consecutive_blocks_threshold )) then terminate_ = . true . endif !---------------------------------------------------------------------! end subroutine check_cross_section_thresholds","tags":"","loc":"proc/check_cross_section_thresholds.html"},{"title":"print_largest_partial_cross_sections – the SCATTERING code","text":"public  subroutine print_largest_partial_cross_sections(total_angular_momentum_, largest_elastic_xs_, largest_inelastic_xs_, elastic_index_, inelastic_index_1_, inelastic_index_2_, open_basis_levels_) Print the largest partial elastic and inelastic state-to-state\ncross-sections in a given block. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: total_angular_momentum_ total angular momentum real(kind=dp), intent(in) :: largest_elastic_xs_ the largest partial elastic state-to-state XS in the block real(kind=dp), intent(in) :: largest_inelastic_xs_ the largest partial inelastic state-to-state XS in the block integer(kind=int32), intent(in) :: elastic_index_ index pointing indirectly to quantum numbers associated with\nthe largest partial elastic state-to-state XS in the block integer(kind=int32), intent(in) :: inelastic_index_1_ indices pointing indirectly to quantum numbers associated with\nthe largest partial inelastic state-to-state XS in the block integer(kind=int32), intent(in) :: inelastic_index_2_ indices pointing indirectly to quantum numbers associated with\nthe largest partial inelastic state-to-state XS in the block integer(kind=int32), intent(in) :: open_basis_levels_ (:) holds indices to the basis arrays that correspond to open channels Calls proc~~print_largest_partial_cross_sections~~CallsGraph proc~print_largest_partial_cross_sections print_largest_partial_cross_sections proc~write_message write_message proc~print_largest_partial_cross_sections->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~print_largest_partial_cross_sections~~CalledByGraph proc~print_largest_partial_cross_sections print_largest_partial_cross_sections program~scattering SCATTERING program~scattering->proc~print_largest_partial_cross_sections Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code print_largest_partial_cross_sections Source Code subroutine print_largest_partial_cross_sections ( total_angular_momentum_ , & largest_elastic_xs_ , largest_inelastic_xs_ , elastic_index_ , & inelastic_index_1_ , inelastic_index_2_ , open_basis_levels_ ) !! Print the largest partial elastic and inelastic state-to-state !! cross-sections in a given block. !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: total_angular_momentum_ !! total angular momentum real ( dp ), intent ( in ) :: largest_elastic_xs_ !! the largest partial elastic state-to-state XS in the block real ( dp ), intent ( in ) :: largest_inelastic_xs_ !! the largest partial inelastic state-to-state XS in the block integer ( int32 ), intent ( in ) :: elastic_index_ !! index pointing indirectly to quantum numbers associated with !! the largest partial elastic state-to-state XS in the block integer ( int32 ), intent ( in ) :: inelastic_index_1_ , inelastic_index_2_ !! indices pointing indirectly to quantum numbers associated with !! the largest partial inelastic state-to-state XS in the block integer ( int32 ), intent ( in ) :: open_basis_levels_ (:) !! holds indices to the basis arrays that correspond to open channels !---------------------------------------------------------------------! if ( prntlvl <= 2 ) then call print_basic_cross_section_info ( total_angular_momentum_ , & largest_elastic_xs_ , \"elastic\" ) call print_basic_cross_section_info ( total_angular_momentum_ , & largest_inelastic_xs_ , \"inelastic\" ) else if ( prntlvl >= 3 ) then call print_detailed_cross_section_info ( total_angular_momentum_ , & largest_elastic_xs_ , elastic_index_ , elastic_index_ , & open_basis_levels_ , \"elastic\" ) call print_detailed_cross_section_info ( total_angular_momentum_ , & largest_inelastic_xs_ , inelastic_index_1_ , inelastic_index_2_ , & open_basis_levels_ , \"inelastic\" ) endif !---------------------------------------------------------------------! call write_message ( repeat ( \" \" , 43 ) // \"***\" ) !---------------------------------------------------------------------! end subroutine print_largest_partial_cross_sections","tags":"","loc":"proc/print_largest_partial_cross_sections.html"},{"title":"save_partial_xs_file_header – the SCATTERING code","text":"public  subroutine save_partial_xs_file_header() save \"header\" of the partial cross-sections file:\n-- label, \"itype\", number of levels in the basis, reduced mass of the system\n-- vibrational and rotational quantum numbers\n-- rovibrational energies\n-- index pointing to the initial level and the kinetic/total energy Arguments None Calls proc~~save_partial_xs_file_header~~CallsGraph proc~save_partial_xs_file_header save_partial_xs_file_header proc~file_io_status file_io_status proc~save_partial_xs_file_header->proc~file_io_status proc~write_message write_message proc~save_partial_xs_file_header->proc~write_message proc~integer_to_character integer_to_character proc~file_io_status->proc~integer_to_character proc~write_error write_error proc~file_io_status->proc~write_error proc~write_error->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~save_partial_xs_file_header~~CalledByGraph proc~save_partial_xs_file_header save_partial_xs_file_header program~scattering SCATTERING program~scattering->proc~save_partial_xs_file_header Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code save_partial_xs_file_header Source Code subroutine save_partial_xs_file_header !! save \"header\" of the partial cross-sections file: !! -- label, \"itype\", number of levels in the basis, reduced mass of the system !! -- vibrational and rotational quantum numbers !! -- rovibrational energies !! -- index pointing to the initial level and the kinetic/total energy !---------------------------------------------------------------------! character ( len = 200 ) :: err_message integer ( int32 ) :: io_status , ilevel !---------------------------------------------------------------------! open ( partial_file_unit , file = trim ( partialfile ), form = 'formatted' , & status = 'unknown' , iostat = io_status , iomsg = err_message ) call file_io_status ( io_status , err_message , partial_file_unit , \"o\" ) !---------------------------------------------------------------------! call write_message ( \"  jtot  iblock  v1_f  j1_f  <-  v1_i  j1_i'\" // & repeat ( \" \" , 13 ) // \"K.E.\" // repeat ( \" \" , 16 ) // \"XS\" , & unit_ = partial_file_unit ) !---------------------------------------------------------------------! end subroutine save_partial_xs_file_header","tags":"","loc":"proc/save_partial_xs_file_header.html"},{"title":"save_partial_xs_single_block – the SCATTERING code","text":"public  subroutine save_partial_xs_single_block(jtot_, block_number_, number_of_open_basis_levels, open_basis_levels, xs_block) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: jtot_ integer(kind=int32), intent(in) :: block_number_ integer(kind=int32), intent(in) :: number_of_open_basis_levels integer(kind=int32), intent(in) :: open_basis_levels (number_of_open_basis_levels) real(kind=dp), intent(in) :: xs_block (number_of_open_basis_levels*number_of_open_basis_levels) Calls proc~~save_partial_xs_single_block~~CallsGraph proc~save_partial_xs_single_block save_partial_xs_single_block proc~etotal ETOTAL proc~save_partial_xs_single_block->proc~etotal proc~write_message write_message proc~save_partial_xs_single_block->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~save_partial_xs_single_block~~CalledByGraph proc~save_partial_xs_single_block save_partial_xs_single_block program~scattering SCATTERING program~scattering->proc~save_partial_xs_single_block Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code save_partial_xs_single_block Source Code subroutine save_partial_xs_single_block ( jtot_ , block_number_ , & number_of_open_basis_levels , open_basis_levels , xs_block ) !! ... !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: jtot_ integer ( int32 ), intent ( in ) :: block_number_ integer ( int32 ), intent ( in ) :: number_of_open_basis_levels integer ( int32 ), intent ( in ) :: open_basis_levels ( number_of_open_basis_levels ) real ( dp ), intent ( in ) :: xs_block ( number_of_open_basis_levels * number_of_open_basis_levels ) !---------------------------------------------------------------------! character ( len = 200 ) :: partial_line integer ( int32 ) :: level_index_ , level_index_2_ !---------------------------------------------------------------------! do level_index_ = 1 , number_of_open_basis_levels do level_index_2_ = 1 , number_of_open_basis_levels write ( partial_line , & \"(I6,2X,I6,2X,I4,2X,I4,6X,I4,2X,I4,2X,E16.8,2X,E16.8)\" ) & jtot_ , block_number_ , v1array ( open_basis_levels ( level_index_ )), & j1array ( open_basis_levels ( level_index_ )), & v1array ( open_basis_levels ( level_index_ )), & j1array ( open_basis_levels ( level_index_ )), & ( etotal () - elevel ( open_basis_levels ( level_index_ ))) * hartreetocm , & xs_block (( level_index_ - 1 ) * number_of_open_basis_levels + level_index_2_ ) call write_message ( partial_line , unit_ = 12 ) enddo enddo !---------------------------------------------------------------------! end subroutine save_partial_xs_single_block","tags":"","loc":"proc/save_partial_xs_single_block.html"},{"title":"radial_coupling_terms_mod – the SCATTERING code","text":"This module provides all functions that handle radial coupling terms\n of the PES. It covers:\n 1. reading radial coupling terms from external file (\"read_radial_coupling_terms\",\n    \"skip_header_lines\", \"read_and_validate_lambda\", \"read_potential_data\",\n    \"validate_r_range\")\n 2. reducing the number of read coupling terms to retain only necessary\n    couplings (\"reduce_radial_coupling_terms\", \"print_pes_quantum_numbers\",\n    \"reduce_coupling_terms\", \"find_reduced_term\")\n 3. interpolation of radial coupling terms (\"interpolate_radial_coupling_terms\")\n 4. providing value of the interpolated radial coupling term (\"get_radial_coupling_term_value\")\n--------------------------------------------------------------------------! Uses io_mod data_mod utility_functions_mod iso_fortran_env math_functions_mod module~~radial_coupling_terms_mod~~UsesGraph module~radial_coupling_terms_mod radial_coupling_terms_mod module~math_functions_mod math_functions_mod module~radial_coupling_terms_mod->module~math_functions_mod module~utility_functions_mod utility_functions_mod module~radial_coupling_terms_mod->module~utility_functions_mod module~data_mod data_mod module~radial_coupling_terms_mod->module~data_mod iso_fortran_env iso_fortran_env module~radial_coupling_terms_mod->iso_fortran_env module~io_mod io_mod module~radial_coupling_terms_mod->module~io_mod module~math_functions_mod->module~utility_functions_mod module~math_functions_mod->iso_fortran_env module~special_functions_mod special_functions_mod module~math_functions_mod->module~special_functions_mod module~utility_functions_mod->iso_fortran_env module~data_mod->iso_fortran_env module~io_mod->module~utility_functions_mod module~io_mod->module~data_mod module~io_mod->iso_fortran_env module~array_operations_mod array_operations_mod module~io_mod->module~array_operations_mod module~input_validation input_validation module~io_mod->module~input_validation module~array_operations_mod->iso_fortran_env module~input_validation->module~utility_functions_mod module~input_validation->module~data_mod module~input_validation->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~radial_coupling_terms_mod~~UsedByGraph module~radial_coupling_terms_mod radial_coupling_terms_mod module~pes_matrix_mod pes_matrix_mod module~pes_matrix_mod->module~radial_coupling_terms_mod program~scattering SCATTERING program~scattering->module~radial_coupling_terms_mod program~scattering->module~pes_matrix_mod module~propagator_mod propagator_mod program~scattering->module~propagator_mod module~propagator_mod->module~pes_matrix_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines get_radial_coupling_term_value interpolate_radial_coupling_terms read_radial_coupling_terms reduce_radial_coupling_terms Subroutines public  subroutine get_radial_coupling_term_value (intermolecular_distance, lambda_, v_, j_, v_prime_, j_prime_, radial_term_value_) Returns the interpolated value of a specific radial coupling term\nat a given distance. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: intermolecular_distance Intermolecular distance, R integer(kind=int32), intent(in) :: lambda_ Legendre expansion index integer(kind=int32), intent(in) :: v_ pre-collisional vibrational quantum number integer(kind=int32), intent(in) :: j_ pre-collisional rotational quantum number integer(kind=int32), intent(in) :: v_prime_ post-collisional vibrational quantum number integer(kind=int32), intent(in) :: j_prime_ post-collisional rotational quantum number real(kind=dp), intent(out) :: radial_term_value_ Value of the radial coupling coefficient public  subroutine interpolate_radial_coupling_terms () Interpolates the radial coupling terms using cubic spline functions.\nThe resulting spline coefficients for each coupling term\nare stored in bmat3D, cmat3D, and dmat3D matrices. Arguments None public  subroutine read_radial_coupling_terms () Reads the radial coupling terms from the external file.\nThe file is assumed to be formatted as described in\n\"Supplying radial terms\" section.\nThe read radial coupling terms are kept in vmat/read_vmat3D Arguments None public  subroutine reduce_radial_coupling_terms () Reduces the read_vmat3D matrix to retain only the necessary coupling terms. Arguments None","tags":"","loc":"module/radial_coupling_terms_mod.html"},{"title":"pes_matrix_mod – the SCATTERING code","text":"This module provides functions calculating the algebraic coefficients\n g_{{\\lambda},\\gamma,\\gamma'}&#94;{Jp}  entering the PES matrix,\nand the full PES matrix (see Eq. 1 in the \"Coupling Matrix\" section). Subroutines preparing algebraic coefficients and determining the number\nof non-zero terms of the PES matrix are called only once,\nbefore Numerov propagator is initialized Subroutines calculating the full PES matrix at desired R are called\nwithin the propagator loop The data is organized as follows:\n- number of non-zero terms of the PES matrix due to\n  \\bar{\\Omega} = \\bar{\\Omega}' condition is saved as\n  \"number_of_nonzero_pes_matrix_elements\"\n- number of non-vanishing terms in the sum over \\lambda\n  in Eq. 1 in the \"Coupling Matrix\" section is saved in a\n  \"nonzero_terms_per_element\" array which is of\n  \"number_of_nonzero_pes_matrix_elements\" size\n- a total number of non-vanishing   g_{{\\lambda},\\gamma,\\gamma'}&#94;{Jp} \n  coefficients is saved in \"number_of_nonzero_algebraic_coefficients\"\n- all non-vanishing   g_{{\\lambda},\\gamma,\\gamma'}&#94;{Jp} \n  coefficients are saved in \"nonzero_algebraic_coefficients\" array,\n  which is of \"number_of_nonzero_algebraic_coefficients\" size\n- corresponding \\lambda value for each non-vanishing coefficient\n  is saved as an index to \"l1tab\" in the \"nonzero_legendre_indices\"\n  array (which is of \"number_of_nonzero_algebraic_coefficients\" size) Uses radial_coupling_terms_mod io_mod data_mod array_operations_mod utility_functions_mod iso_fortran_env math_functions_mod module~~pes_matrix_mod~~UsesGraph module~pes_matrix_mod pes_matrix_mod module~radial_coupling_terms_mod radial_coupling_terms_mod module~pes_matrix_mod->module~radial_coupling_terms_mod module~math_functions_mod math_functions_mod module~pes_matrix_mod->module~math_functions_mod module~utility_functions_mod utility_functions_mod module~pes_matrix_mod->module~utility_functions_mod module~array_operations_mod array_operations_mod module~pes_matrix_mod->module~array_operations_mod module~data_mod data_mod module~pes_matrix_mod->module~data_mod module~io_mod io_mod module~pes_matrix_mod->module~io_mod iso_fortran_env iso_fortran_env module~pes_matrix_mod->iso_fortran_env module~radial_coupling_terms_mod->module~math_functions_mod module~radial_coupling_terms_mod->module~utility_functions_mod module~radial_coupling_terms_mod->module~data_mod module~radial_coupling_terms_mod->module~io_mod module~radial_coupling_terms_mod->iso_fortran_env module~math_functions_mod->module~utility_functions_mod module~math_functions_mod->iso_fortran_env module~special_functions_mod special_functions_mod module~math_functions_mod->module~special_functions_mod module~utility_functions_mod->iso_fortran_env module~array_operations_mod->iso_fortran_env module~data_mod->iso_fortran_env module~io_mod->module~utility_functions_mod module~io_mod->module~array_operations_mod module~io_mod->module~data_mod module~io_mod->iso_fortran_env module~input_validation input_validation module~io_mod->module~input_validation module~input_validation->module~utility_functions_mod module~input_validation->module~data_mod module~input_validation->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~pes_matrix_mod~~UsedByGraph module~pes_matrix_mod pes_matrix_mod module~propagator_mod propagator_mod module~propagator_mod->module~pes_matrix_mod program~scattering SCATTERING program~scattering->module~pes_matrix_mod program~scattering->module~propagator_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines calculate_pes_matrix check_nonzero_pes_matrix_elements prepare_pes_matrix_elements print_pes_matrix_elements_summary Subroutines public  subroutine calculate_pes_matrix (total_angular_momentum_, intermolecular_distance_, channel_indices_, channels_omega_values_, nonzero_terms_per_element_, nonzero_legendre_indices_, nonzero_algebraic_coefficients_, vmatrix) calculates the contribution to the coupling matrix\nfrom the the interaction potential (PES);\nsee Eq. 1 in \"Coupling Matrix\" section;\ndiagonal contribution from wavevectors (see the last term in\nEq. 3 of \"What are coupled equations\" section) is added Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: total_angular_momentum_ total angular momentum real(kind=dp), intent(in) :: intermolecular_distance_ intermolecular distance integer(kind=int32), intent(in) :: channel_indices_ (:) holds the indices pointing to the basis arrays integer(kind=int32), intent(in) :: channels_omega_values_ (:) holds all values of \\bar{\\Omega} integer(kind=int32), intent(in) :: nonzero_terms_per_element_ (:) keeps the number of non-vanishing elements of the sum over \\lambda\nfor each non-zero element of the coupling matrix integer(kind=int32), intent(in) :: nonzero_legendre_indices_ (:) holds indices pointing to l1tab, which correspond to\nthe non-vanishing elements of the sum over \\lambda\nfor each non-zero element of the coupling matrix; real(kind=dp), intent(in) :: nonzero_algebraic_coefficients_ (:) holds the values of the non-zero algebraic coefficients real(kind=dp), intent(out) :: vmatrix (:,:) (output) - the interaction potential contribution to the coupling matrix public  subroutine check_nonzero_pes_matrix_elements (channel_indices, channels_omega_values, number_of_nonzero_pes_matrix_elements, number_of_nonzero_algebraic_coefficients) checks the number of non-zero PES matrix elements due to\nthe \\bar{\\Omega} = \\bar{\\Omega}' condition,\n\"number_of_nonzero_pes_matrix_elements\",\nand the total number of non-zero algebraic coefficients,\n g_{{\\lambda},\\gamma,\\gamma'}&#94;{Jp} , in the whole matrix,\n\"number_of_nonzero_algebraic_coefficients\". Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: channel_indices (:) holds the indices pointing to the basis arrays integer(kind=int32), intent(in) :: channels_omega_values (:) holds all values of \\bar{\\Omega} integer(kind=int32), intent(out) :: number_of_nonzero_pes_matrix_elements number of non-zero terms in the sum () for each non-zero element of the PES matrix integer(kind=int32), intent(out) :: number_of_nonzero_algebraic_coefficients number of all non-zero algberaix coefficients in the whole PES matrix public  subroutine prepare_pes_matrix_elements (channel_indices, channels_omega_values, nonzero_terms_per_element, nonzero_legendre_indices, nonzero_algebraic_coefficients) -- nonzero_terms_per_element - number of non-vanishing terms in\n   the sum over \\lambda in Eq. 1 in the \"Coupling Matrix\" section\n-- nonzero_legendre_indices - corresponding \\lambda value for\n   each non-vanishing coefficient is saved as an index to \"l1tab\"\n-- nonzero_algebraic_coefficients --  holds all non-vanishing\n    g_{{\\lambda},\\gamma,\\gamma'}&#94;{Jp}  coefficients Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: channel_indices (:) holds the indices pointing to the basis arrays integer(kind=int32), intent(in) :: channels_omega_values (:) holds all values of \\bar{\\Omega} integer(kind=int32), intent(inout) :: nonzero_terms_per_element (:) keeps the number of non-vanishing elements of the sum over \\lambda\nfor each non-zero element of the PES matrix integer(kind=int32), intent(inout) :: nonzero_legendre_indices (:) holds indices pointing to l1tab, which correspond to\nthe non-vanishing elements of the sum over \\lambda\nfor each non-zero element of the PES matrix; real(kind=dp), intent(inout) :: nonzero_algebraic_coefficients (:) holds the values of the non-zero algebraic coefficients public  subroutine print_pes_matrix_elements_summary (number_of_channels, number_of_nonzero_pes_matrix_elements, number_of_nonzero_algebraic_coefficients) print a shor summary on the number of non-zero matrix elements\nof the PES matrix Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: number_of_channels size of the basis integer(kind=int32), intent(in) :: number_of_nonzero_pes_matrix_elements number of non-zero terms in the sum () for each non-zero element\nof the PES matrix integer(kind=int32), intent(in) :: number_of_nonzero_algebraic_coefficients number of all non-zero algberaix coefficients in the whole\nPES matrix","tags":"","loc":"module/pes_matrix_mod.html"},{"title":"special_functions_mod – the SCATTERING code","text":"This module holds rctj, rcty, envj, msta1, msta2, ikv, gamma from\n special_functions library, donwloaded from:\n https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html\n  Author: Original FORTRAN77 version by Shanjie Zhang, Jianming Jin.\nFORTRAN90 version by John Burkardt. Reference: Shanjie Zhang, Jianming Jin,\nComputation of Special Functions,\nWiley, 1996,\nISBN: 0-471-11963-6,\nLC: QA351.C45. --------------------------------------------------------------------------! Used by module~~special_functions_mod~~UsedByGraph module~special_functions_mod special_functions_mod module~math_functions_mod math_functions_mod module~math_functions_mod->module~special_functions_mod module~radial_coupling_terms_mod radial_coupling_terms_mod module~radial_coupling_terms_mod->module~math_functions_mod module~pes_matrix_mod pes_matrix_mod module~pes_matrix_mod->module~math_functions_mod module~pes_matrix_mod->module~radial_coupling_terms_mod module~boundary_conditions_mod boundary_conditions_mod module~boundary_conditions_mod->module~math_functions_mod program~scattering SCATTERING program~scattering->module~radial_coupling_terms_mod program~scattering->module~pes_matrix_mod program~scattering->module~boundary_conditions_mod module~propagator_mod propagator_mod program~scattering->module~propagator_mod module~propagator_mod->module~pes_matrix_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Functions envj msta1 msta2 Subroutines rctj rcty Functions public  function envj (n, x) utility function used by MSTA1 and MSTA2. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: x Return Value real(kind=8) public  function msta1 (x, mp) determines a backward recurrence starting point for Jn(x). Arguments Type Intent Optional Attributes Name real(kind=8) :: x integer(kind=4) :: mp Return Value integer(kind=4) public  function msta2 (x, n, mp) determines a backward recurrence starting point for Jn(x). Arguments Type Intent Optional Attributes Name real(kind=8) :: x integer(kind=4) :: n integer(kind=4) :: mp Return Value integer(kind=4) Subroutines public  subroutine rctj (n, x, nm, rj, dj) computes Riccati-Bessel function of the first kind, and derivatives. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: x integer(kind=4) :: nm real(kind=8) :: rj (0:n) real(kind=8) :: dj (0:n) public  subroutine rcty (n, x, nm, ry, dy) computes Riccati-Bessel function of the second kind, and derivatives. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: x integer(kind=4) :: nm real(kind=8) :: ry (0:n) real(kind=8) :: dy (0:n)","tags":"","loc":"module/special_functions_mod.html"},{"title":"io_mod – the SCATTERING code","text":"this module provides following functions and subroutines:\n1. input_file - reads the input file prepared by the user\n2. input_check - checks the variables supplied in the input file\n3. input_summary - summary of the input variables\n5. etotal (function) - returns the total energy of the system\n6. wavenumber_squared_from_energy (function) - returns the wavenumber\n7. units_conversion - converts all physical quantities to atomic units\n8. count_available_xs (function) - counts energetically accessible\n   levels in the basis\n9. jaccess (function) - returns jopen and waveopen - arrays needed for\n   calculations of the state-to-state XS Uses input_validation data_mod array_operations_mod utility_functions_mod iso_fortran_env module~~io_mod~~UsesGraph module~io_mod io_mod module~input_validation input_validation module~io_mod->module~input_validation module~utility_functions_mod utility_functions_mod module~io_mod->module~utility_functions_mod module~array_operations_mod array_operations_mod module~io_mod->module~array_operations_mod iso_fortran_env iso_fortran_env module~io_mod->iso_fortran_env module~data_mod data_mod module~io_mod->module~data_mod module~input_validation->module~utility_functions_mod module~input_validation->iso_fortran_env module~input_validation->module~data_mod module~utility_functions_mod->iso_fortran_env module~array_operations_mod->iso_fortran_env module~data_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~io_mod~~UsedByGraph module~io_mod io_mod module~radial_coupling_terms_mod radial_coupling_terms_mod module~radial_coupling_terms_mod->module~io_mod module~channels_mod channels_mod module~channels_mod->module~io_mod module~pes_matrix_mod pes_matrix_mod module~pes_matrix_mod->module~io_mod module~pes_matrix_mod->module~radial_coupling_terms_mod program~scattering SCATTERING program~scattering->module~io_mod program~scattering->module~radial_coupling_terms_mod program~scattering->module~channels_mod program~scattering->module~pes_matrix_mod module~propagator_mod propagator_mod program~scattering->module~propagator_mod module~boundary_conditions_mod boundary_conditions_mod program~scattering->module~boundary_conditions_mod module~state_to_state_cross_sections_mod state_to_state_cross_sections_mod program~scattering->module~state_to_state_cross_sections_mod module~centrifugal_matrix_mod centrifugal_matrix_mod module~centrifugal_matrix_mod->module~io_mod module~propagator_mod->module~io_mod module~propagator_mod->module~pes_matrix_mod module~propagator_mod->module~centrifugal_matrix_mod module~boundary_conditions_mod->module~io_mod module~state_to_state_cross_sections_mod->module~io_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Functions ETOTAL count_open_basis_levels is_open wavenumber_squared_from_energy Subroutines input_summary read_input_file save_open_basis_levels units_conversion Functions public  function ETOTAL () result(etot_) returns the total energy Arguments None Return Value real(kind=dp) public  function count_open_basis_levels () result(open_) counts the energetically accessible levels in the basis Arguments None Return Value integer(kind=int32) public  function is_open (energy_) result(is_open_) checks if a channel/level is energetically accessible (open)\nby comparing energy with etotal() Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: energy_ level/channel energy Return Value logical public  function wavenumber_squared_from_energy (energy_) result(k_) returns the squared wavenumber, k_{a}&#94;{2},\ngiven the energy of a given state, E_{a};\ncalls etot() function; atomic units in the whole function\n k_{a} = \\sqrt(2 \\mu (E_{tot} - E_{a}) \nsince it uses reduced_mass and etotal(), the function checks\nif units are already converted Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: energy_ energy of a given state,  E_{a} , in a.u. Return Value real(kind=dp) wavenumber, k_{a}, in a.u. Subroutines public  subroutine input_summary () summarize the input parameters for the current run Arguments None public  subroutine read_input_file () reads the input file prepared by the user using NAMELIST feature\nthe code uses 3 namelists: input, basis and potential Arguments None public  subroutine save_open_basis_levels (number_of_open_basis_levels, open_basis_levels, open_basis_wavevectors) saves indices to open levels in the basis and corresponding\nwavenumbers (in A&#94;2) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: number_of_open_basis_levels number of energetically accessible levels in the basis integer(kind=int32), intent(inout), allocatable :: open_basis_levels (:) array holding indices to energetically accessible levels in the basis real(kind=dp), intent(inout), allocatable :: open_basis_wavevectors (:) array holding wavevectors calculated w.r.t energetically accessible levels in the basis public  subroutine units_conversion () converts all physical quantities to atomic units Arguments None","tags":"","loc":"module/io_mod.html"},{"title":"math_functions_mod – the SCATTERING code","text":"this module holds 4 types of functions:\n-- algebraic functions: percival_seaton_coefficient\n-- geometric functions: triangle_inequality_holds, is_sum_even, zero_projections_3j_condition\n-- bessel functions: groups functions: riccati_bessel_j, bessely and modified_bessel_k_ratio\n   that call special functions from special_functions.f90 library\n-- interpolation procedures: spline and ispline functions for interpolating data\n-- additional functions: rctj, rcty, envj, msta1, msta2, ikv, gamma from\n   special_functions library Uses utility_functions_mod iso_fortran_env special_functions_mod module~~math_functions_mod~~UsesGraph module~math_functions_mod math_functions_mod module~utility_functions_mod utility_functions_mod module~math_functions_mod->module~utility_functions_mod iso_fortran_env iso_fortran_env module~math_functions_mod->iso_fortran_env module~special_functions_mod special_functions_mod module~math_functions_mod->module~special_functions_mod module~utility_functions_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~math_functions_mod~~UsedByGraph module~math_functions_mod math_functions_mod module~radial_coupling_terms_mod radial_coupling_terms_mod module~radial_coupling_terms_mod->module~math_functions_mod module~pes_matrix_mod pes_matrix_mod module~pes_matrix_mod->module~math_functions_mod module~pes_matrix_mod->module~radial_coupling_terms_mod module~boundary_conditions_mod boundary_conditions_mod module~boundary_conditions_mod->module~math_functions_mod program~scattering SCATTERING program~scattering->module~radial_coupling_terms_mod program~scattering->module~pes_matrix_mod program~scattering->module~boundary_conditions_mod module~propagator_mod propagator_mod program~scattering->module~propagator_mod module~propagator_mod->module~pes_matrix_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Functions is_sum_even ispline percival_seaton_coefficient rgamma triangle_inequality_holds zero_projections_3j_condition Subroutines modified_bessel_k_ratio modified_bessel_temme_algorithm riccati_bessel_j riccati_bessel_y spline Functions public  function is_sum_even (x, y, z) result(sum_even) checks if the sum of 3 integers is an even integer Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x variables to check if the sum is even integer(kind=int32), intent(in) :: y variables to check if the sum is even integer(kind=int32), intent(in) :: z variables to check if the sum is even Return Value logical (out) result: true/false public  function ispline (u_, N_, x_, y_, b_, c_, d_) result(spl_result) returns interpolated value at guven u_ point\nnumber of points and ascending order of x is not checked since\nispline is called after \"spline\" where these checks are done Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: u_ point at which the tabulated value is interpolated integer(kind=int32), intent(in) :: N_ number of grid points real(kind=dp), intent(in) :: x_ (N_) grid points real(kind=dp), intent(in) :: y_ (N_) tabulated values real(kind=dp), intent(in) :: b_ (N_) arrays with coefficients of the spline function real(kind=dp), intent(in) :: c_ (N_) arrays with coefficients of the spline function real(kind=dp), intent(in) :: d_ (N_) arrays with coefficients of the spline function Return Value real(kind=dp) interpolated value at u_ public  function percival_seaton_coefficient (j_, j_prime_, lambda_, omega_) result(percival_seaton_coefficient_) calculates Percival-Seaton coefficients (body-fixed variant) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: j_ pre-collisional rotational angular momentum integer(kind=int32), intent(in) :: j_prime_ post-collisional rotational angular momentum integer(kind=int32), intent(in) :: lambda_ Legendre expansion coefficient  \\lambda integer(kind=int32), intent(in) :: omega_ \\bar{\\Omega} Return Value real(kind=dp) (out) result: percival seaton coefficient in the body-fixed frame public  function rgamma (x, odd, even) result(rgamma_val) Calculates 1/Gamma(1-X); modernized version of Molscat's\n rgamma function; see:\n https://github.com/molscat/molscat/blob/36fa8f93a92f851e9d84245dd6a972e2910541c5/source_code/rbesjy.f\n-----------------------------------------------------------------------! Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x real(kind=dp), intent(out) :: odd real(kind=dp), intent(out) :: even Return Value real(kind=dp) public  function triangle_inequality_holds (x, y, z) result(holds) check if the triangle inequality for 3 variables hols Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x variables to check the triangle inequality integer(kind=int32), intent(in) :: y variables to check the triangle inequality integer(kind=int32), intent(in) :: z variables to check the triangle inequality Return Value logical (out) result: true/false public  function zero_projections_3j_condition (x, y, z) result(is_valid) checks the condition for nonvanishing 3-j symbol with zero projections:\ntriangle inequality on x,y,z and if the sum x+y+z is an even integer Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x variables to check for 3-j symbol conditions integer(kind=int32), intent(in) :: y variables to check for 3-j symbol conditions integer(kind=int32), intent(in) :: z variables to check for 3-j symbol conditions Return Value logical (out) result: true/false if conditions are met Subroutines public  subroutine modified_bessel_k_ratio (l_, x_, ratio_) calculates the ratio of the modified Bessel function of the second\nkind K_{l_ + 1/2}(x) and its first derivative (Eq. 8 in the\n\"Solution of the coupled equations\" section)\nUses Temme's algorithm [N. M. Temme, J. Comput. Phys. 19 (1975) 324],\nimplemented in \"modified_bessel_temme_algorithm\" subroutine;\nUnfortunately, the \"ikv\" function from special_functions\nlibrary failed at large x_ values. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: l_ l - order of the function (without the 1/2 factor!) real(kind=dp), intent(in) :: x_ x - argument of the function real(kind=dp), intent(inout) :: ratio_ ratio of the modified Bessel function of the second kind to its derivative public  subroutine modified_bessel_temme_algorithm (v, x, ck, dk, ek) Implementation of the Temme's algorithm\n[N. M. Temme, J. Comput. Phys. 19 (1975) 324] to calculating\nmodified Bessel functions of the second kind.\nThis is a direct modernization of the \"mbessk\" subroutine\nin MOLSCAT:\nhttps://github.com/molscat/molscat/blob/master/source_code/rbessk.f Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: v real(kind=dp), intent(in) :: x real(kind=dp), intent(out) :: ck real(kind=dp), intent(out) :: dk real(kind=dp), intent(out) :: ek public  subroutine riccati_bessel_j (l_, x_, j_, jp_) calculates the Riccati-Bessel function of the first kind and its\nfirst derivative. Calls the rctj function from special_functions.f90 Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: l_ l - order of the Riccati-Bessel function of the first kind real(kind=dp), intent(in) :: x_ x - argument of the Riccati-Bessel function of the first kind real(kind=dp), intent(inout) :: j_ j_{l} (x) - Riccati-Bessel funciton of the first kind real(kind=dp), intent(inout) :: jp_ j_{l}' (x) - derivative of the Riccati-Bessel funciton of the first kind public  subroutine riccati_bessel_y (l_, x_, y_, yp_) calculates the Riccati-Bessel function of the second kind and its\nfirst derivative. Calls the rcty function from special_functions.f90 Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: l_ l - order of the Riccati-Bessel function of the second kind real(kind=dp), intent(in) :: x_ x - argument of the Riccati-Bessel function of the second kind real(kind=dp), intent(inout) :: y_ y_{l} (x) - Riccati-Bessel funciton of the second kind real(kind=dp), intent(inout) :: yp_ y_{l}' (x) - derivative of the Riccati-Bessel funciton of the second kind public  subroutine spline (N_, x_, y_, b_, c_, d_) determines b, c and d coefficients of the cubic spline function\ny(x) = y_i + b_i * dx + c_i * dx&#94;2 + d_i * dx&#94;3,\nwhere dx = x - x_i, and x_i <= x < x_i+1.\nThe algorithm is based on\nGerald, C., and Wheatley, P., \"Applied Numerical Analysis\", Addison-Wesley, 1994. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: N_ number of grid points real(kind=dp), intent(in) :: x_ (N_) grid points (ascending order) real(kind=dp), intent(in) :: y_ (N_) tabulated values real(kind=dp), intent(out) :: b_ (N_) arrays with coefficients of the spline function real(kind=dp), intent(out) :: c_ (N_) arrays with coefficients of the spline function real(kind=dp), intent(out) :: d_ (N_) arrays with coefficients of the spline function","tags":"","loc":"module/math_functions_mod.html"},{"title":"unitarity_check_mod – the SCATTERING code","text":"This module contains subroutines that check the unitarity condition\nof the S-matrix (see Eq. (13) in \"Solution of coupled equations\") Uses data_mod iso_fortran_env utility_functions_mod module~~unitarity_check_mod~~UsesGraph module~unitarity_check_mod unitarity_check_mod module~data_mod data_mod module~unitarity_check_mod->module~data_mod iso_fortran_env iso_fortran_env module~unitarity_check_mod->iso_fortran_env module~utility_functions_mod utility_functions_mod module~unitarity_check_mod->module~utility_functions_mod module~data_mod->iso_fortran_env module~utility_functions_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~unitarity_check_mod~~UsedByGraph module~unitarity_check_mod unitarity_check_mod program~scattering SCATTERING program~scattering->module~unitarity_check_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Functions check_unitarity_for_each_channel Subroutines calculate_sum_of_squares_for_each_channel handle_unitarity_output_message unitarity_check Functions public  function check_unitarity_for_each_channel (sum_of_squares) result(is_unitary_) checks if the calculated sum of squares equals 1 for each channel Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: sum_of_squares (:)  \\sum_{\\gamma'} \\Bigl|{S}&#94;{Jp}_{\\gamma, \\gamma'}\\Bigr|&#94;{2}  Return Value logical (output) if .true. unitarity is fulfilled, .false. otherwise Subroutines public  subroutine calculate_sum_of_squares_for_each_channel (s_matrix_real, s_matrix_imag, sum_of_squares_) calculates the sum\n \\sum_{\\gamma'} \\Bigl|{S}&#94;{Jp}_{\\gamma, \\gamma'}\\Bigr|&#94;{2} \nfor all \\gamma channels Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: s_matrix_real (:,:) real part of the S-matrix real(kind=dp), intent(in) :: s_matrix_imag (:,:) imaginary part of the S-matrix real(kind=dp), intent(out) :: sum_of_squares_ (:) (output)  \\sum_{\\gamma'} \\Bigl|{S}&#94;{Jp}_{\\gamma, \\gamma'}\\Bigr|&#94;{2}  public  subroutine handle_unitarity_output_message (is_unitary) handle printing messages depending on the outcome of unitarity check Arguments Type Intent Optional Attributes Name logical, intent(in) :: is_unitary if .true. unitarity is fulfilled, .false. otherwise public  subroutine unitarity_check (number_of_open_channels, s_matrix_real, s_matrix_imag, is_unitary) checks the unitarity of the S-matrix\n(Eq. (13) in \"Solution of coupled equations\") Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: number_of_open_channels number of open channels real(kind=dp), intent(in) :: s_matrix_real (number_of_open_channels,number_of_open_channels) real part of the S-matrix real(kind=dp), intent(in) :: s_matrix_imag (number_of_open_channels,number_of_open_channels) imaginary part of the S-matrix logical, intent(inout) :: is_unitary (output) if .true. unitarity is fulfilled, .false. otherwise","tags":"","loc":"module/unitarity_check_mod.html"},{"title":"array_operations_mod – the SCATTERING code","text":"this module provides supplementary functions and subroutines to handle\nmatrix allocation, invertion, appending etc. Uses iso_fortran_env module~~array_operations_mod~~UsesGraph module~array_operations_mod array_operations_mod iso_fortran_env iso_fortran_env module~array_operations_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: array_operations_add_scalar_to_diagonal_submod array_operations_allocate_submod array_operations_append_submod array_operations_fill_symmetric_matrix_submod array_operations_invert_symmetric_matrix_submod module~~array_operations_mod~~UsedByGraph module~array_operations_mod array_operations_mod module~pes_matrix_mod pes_matrix_mod module~pes_matrix_mod->module~array_operations_mod module~io_mod io_mod module~pes_matrix_mod->module~io_mod module~radial_coupling_terms_mod radial_coupling_terms_mod module~pes_matrix_mod->module~radial_coupling_terms_mod program~scattering SCATTERING program~scattering->module~array_operations_mod program~scattering->module~pes_matrix_mod module~propagator_mod propagator_mod program~scattering->module~propagator_mod program~scattering->module~io_mod module~boundary_conditions_mod boundary_conditions_mod program~scattering->module~boundary_conditions_mod program~scattering->module~radial_coupling_terms_mod module~state_to_state_cross_sections_mod state_to_state_cross_sections_mod program~scattering->module~state_to_state_cross_sections_mod module~channels_mod channels_mod program~scattering->module~channels_mod module~array_operations_append_submod array_operations_append_submod module~array_operations_append_submod->module~array_operations_mod module~array_operations_allocate_submod array_operations_allocate_submod module~array_operations_allocate_submod->module~array_operations_mod module~propagator_mod->module~array_operations_mod module~propagator_mod->module~pes_matrix_mod module~centrifugal_matrix_mod centrifugal_matrix_mod module~propagator_mod->module~centrifugal_matrix_mod module~propagator_mod->module~io_mod module~centrifugal_matrix_mod->module~array_operations_mod module~centrifugal_matrix_mod->module~io_mod module~io_mod->module~array_operations_mod module~boundary_conditions_mod->module~array_operations_mod module~boundary_conditions_mod->module~io_mod module~array_operations_invert_symmetric_matrix_submod array_operations_invert_symmetric_matrix_submod module~array_operations_invert_symmetric_matrix_submod->module~array_operations_mod module~array_operations_fill_symmetric_matrix_submod array_operations_fill_symmetric_matrix_submod module~array_operations_fill_symmetric_matrix_submod->module~array_operations_mod module~array_operations_add_scalar_to_diagonal_submod array_operations_add_scalar_to_diagonal_submod module~array_operations_add_scalar_to_diagonal_submod->module~array_operations_mod module~radial_coupling_terms_mod->module~io_mod module~state_to_state_cross_sections_mod->module~io_mod module~channels_mod->module~io_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces add_scalar_to_diagonal allocate_1d allocate_2d allocate_3d append fill_symmetric_matrix invert_symmetric_matrix Interfaces public        interface add_scalar_to_diagonal public module subroutine add_scalar_to_diagonal_dp(matrix_, scalar_) ! add a scalar value to the matrix diagonal (double precision version) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: matrix_ (:,:) real(kind=dp), intent(in) :: scalar_ public module subroutine add_scalar_to_diagonal_int32(matrix_, scalar_) add a scalar value to the matrix diagonal (integer version) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: matrix_ (:,:) integer(kind=int32), intent(in) :: scalar_ public module subroutine add_scalar_to_diagonal_sp(matrix_, scalar_) add a scalar value to the matrix diagonal (single precision version) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: matrix_ (:,:) real(kind=sp), intent(in) :: scalar_ public        interface allocate_1d public pure module subroutine allocate_1d_dp(array_, size_) allocate a 1d array and fill it with 0s (double precision version) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), allocatable :: array_ (:) integer(kind=int32), intent(in) :: size_ public pure module subroutine allocate_1d_int32(array_, size_) allocate a 1d array and fill it with 0s (integer version) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), allocatable :: array_ (:) integer(kind=int32), intent(in) :: size_ public pure module subroutine allocate_1d_sp(array_, size_) allocate a 1d array and fill it with 0s (single precision version) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout), allocatable :: array_ (:) integer(kind=int32), intent(in) :: size_ public        interface allocate_2d public pure module subroutine allocate_2d_dp(array_, size1_, size2_) allocate a 2d array and fill it with 0s (double precision version) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), allocatable :: array_ (:,:) integer(kind=int32), intent(in) :: size1_ integer(kind=int32), intent(in) :: size2_ public pure module subroutine allocate_2d_int32(array_, size1_, size2_) allocate a 2d array and fill it with 0s (integer version) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), allocatable :: array_ (:,:) integer(kind=int32), intent(in) :: size1_ integer(kind=int32), intent(in) :: size2_ public pure module subroutine allocate_2d_sp(array_, size1_, size2_) allocate a 2d array and fill it with 0s (single precision version) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout), allocatable :: array_ (:,:) integer(kind=int32), intent(in) :: size1_ integer(kind=int32), intent(in) :: size2_ public        interface allocate_3d public pure module subroutine allocate_3d_dp(array_, size1_, size2_, size3_) allocate a 3d array and fill it with 0s (double precision version) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), allocatable :: array_ (:,:,:) integer(kind=int32), intent(in) :: size1_ integer(kind=int32), intent(in) :: size2_ integer(kind=int32), intent(in) :: size3_ public pure module subroutine allocate_3d_int32(array_, size1_, size2_, size3_) allocate a 3d array and fill it with 0s (integer version) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), allocatable :: array_ (:,:,:) integer(kind=int32), intent(in) :: size1_ integer(kind=int32), intent(in) :: size2_ integer(kind=int32), intent(in) :: size3_ public pure module subroutine allocate_3d_sp(array_, size1_, size2_, size3_) allocate a 3d array and fill it with 0s (single precision version) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout), allocatable :: array_ (:,:,:) integer(kind=int32), intent(in) :: size1_ integer(kind=int32), intent(in) :: size2_ integer(kind=int32), intent(in) :: size3_ public        interface append public pure module subroutine append_dp(array_, element_) append element to an array (double precision version) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), allocatable :: array_ (:) real(kind=dp), intent(in) :: element_ public pure module subroutine append_int32(array_, element_) append element to an array (integer version) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), allocatable :: array_ (:) integer(kind=int32), intent(in) :: element_ public pure module subroutine append_sp(array_, element_) append element to an array (single precision version) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout), allocatable :: array_ (:) real(kind=sp), intent(in) :: element_ public        interface fill_symmetric_matrix public module subroutine fill_symmetric_matrix_dp(matrix_, upper_lower_) fill the upper/lower triangle of a symmetric matrix (double precision version) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: matrix_ (:,:) character(len=1), intent(in) :: upper_lower_ public module subroutine fill_symmetric_matrix_int32(matrix_, upper_lower_) fill the upper/lower triangle of a symmetric matrix (integer version) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: matrix_ (:,:) character(len=1), intent(in) :: upper_lower_ public module subroutine fill_symmetric_matrix_sp(matrix_, upper_lower_) fill the upper/lower triangle of a symmetric matrix (single precision version) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: matrix_ (:,:) character(len=1), intent(in) :: upper_lower_ public        interface invert_symmetric_matrix public module subroutine invert_symmetric_matrix_dp(matrix_) invert a symmetric matrix using DSYTRI method (double precision version) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: matrix_ (:,:) public module subroutine invert_symmetric_matrix_int32(matrix_) invert a symmetric matrix using DSYTRI method (integer version) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: matrix_ (:,:) public module subroutine invert_symmetric_matrix_sp(matrix_) invert a symmetric matrix using DSYTRI method (single precision version) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: matrix_ (:,:)","tags":"","loc":"module/array_operations_mod.html"},{"title":"centrifugal_matrix_mod – the SCATTERING code","text":"This module calculates the centrifugal matrix - see the second term\nin Eq. 3 in \"What are coupled equations?\" section. Uses data_mod io_mod iso_fortran_env array_operations_mod module~~centrifugal_matrix_mod~~UsesGraph module~centrifugal_matrix_mod centrifugal_matrix_mod module~data_mod data_mod module~centrifugal_matrix_mod->module~data_mod module~array_operations_mod array_operations_mod module~centrifugal_matrix_mod->module~array_operations_mod iso_fortran_env iso_fortran_env module~centrifugal_matrix_mod->iso_fortran_env module~io_mod io_mod module~centrifugal_matrix_mod->module~io_mod module~data_mod->iso_fortran_env module~array_operations_mod->iso_fortran_env module~io_mod->module~data_mod module~io_mod->module~array_operations_mod module~io_mod->iso_fortran_env module~input_validation input_validation module~io_mod->module~input_validation module~utility_functions_mod utility_functions_mod module~io_mod->module~utility_functions_mod module~input_validation->module~data_mod module~input_validation->iso_fortran_env module~input_validation->module~utility_functions_mod module~utility_functions_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~centrifugal_matrix_mod~~UsedByGraph module~centrifugal_matrix_mod centrifugal_matrix_mod module~propagator_mod propagator_mod module~propagator_mod->module~centrifugal_matrix_mod program~scattering SCATTERING program~scattering->module~propagator_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines calculate_centrifugal_matrix Subroutines public  subroutine calculate_centrifugal_matrix (total_angular_momentum_, channel_indices_, channels_omega_values_, centrifugal_matrix_) calculates the (R* 2) centrifugal matrix from the second term\nof Eq. 3 in \"What are coupled equations?\" section;\nMatrix elements are given in Eq. 4 and 6 of \"Coupling Matrix\" secion Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: total_angular_momentum_ total angular momentum integer(kind=int32), intent(in) :: channel_indices_ (:) holds the indices pointing to the basis arrays integer(kind=int32), intent(in) :: channels_omega_values_ (:) holds all values of \\bar{\\Omega} real(kind=dp), intent(out) :: centrifugal_matrix_ (:,:) (output) - (R* 2) centrifugal matrix","tags":"","loc":"module/centrifugal_matrix_mod.html"},{"title":"data_mod – the SCATTERING code","text":"Uses iso_fortran_env module~~data_mod~~UsesGraph module~data_mod data_mod iso_fortran_env iso_fortran_env module~data_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~data_mod~~UsedByGraph module~data_mod data_mod module~input_validation input_validation module~input_validation->module~data_mod module~radial_coupling_terms_mod radial_coupling_terms_mod module~radial_coupling_terms_mod->module~data_mod module~io_mod io_mod module~radial_coupling_terms_mod->module~io_mod module~channels_mod channels_mod module~channels_mod->module~data_mod module~channels_mod->module~io_mod module~pes_matrix_mod pes_matrix_mod module~pes_matrix_mod->module~data_mod module~pes_matrix_mod->module~radial_coupling_terms_mod module~pes_matrix_mod->module~io_mod module~unitarity_check_mod unitarity_check_mod module~unitarity_check_mod->module~data_mod program~scattering SCATTERING program~scattering->module~data_mod program~scattering->module~radial_coupling_terms_mod program~scattering->module~channels_mod program~scattering->module~pes_matrix_mod program~scattering->module~unitarity_check_mod program~scattering->module~io_mod module~boundary_conditions_mod boundary_conditions_mod program~scattering->module~boundary_conditions_mod module~propagator_mod propagator_mod program~scattering->module~propagator_mod module~save_s_matrix_mod save_s_matrix_mod program~scattering->module~save_s_matrix_mod module~state_to_state_cross_sections_mod state_to_state_cross_sections_mod program~scattering->module~state_to_state_cross_sections_mod module~io_mod->module~data_mod module~io_mod->module~input_validation module~centrifugal_matrix_mod centrifugal_matrix_mod module~centrifugal_matrix_mod->module~data_mod module~centrifugal_matrix_mod->module~io_mod module~boundary_conditions_mod->module~data_mod module~boundary_conditions_mod->module~io_mod module~propagator_mod->module~data_mod module~propagator_mod->module~pes_matrix_mod module~propagator_mod->module~io_mod module~propagator_mod->module~centrifugal_matrix_mod module~save_s_matrix_mod->module~data_mod module~state_to_state_cross_sections_mod->module~data_mod module~state_to_state_cross_sections_mod->module~io_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables amutoau bmat3D bohrtoangstrom cmat3D consecutive_blocks_threshold dmat3D dr elastic_xs_threshold elevel energy hartreetocm inelastic_xs_threshold initial input_unit iunits j1array j1pes j1ppes jtotmax jtotmin jtotstep l1tab label minimal_number_of_coupling_terms n_skip_lines nlevel nr nterms partial_file_unit partialfile pes_file_exists pes_file_unit pi potentialfile print_partial_cross_sections prntlvl radial_term_distance_converter radial_term_energy_converter read_vmat3D reduced_j1pes reduced_j1ppes reduced_mass reduced_v1pes reduced_v1ppes relative_energy_flag rmat rmax rmin s_matrix_unit smatrixfile steps total_number_of_coupling_terms unitary_tolerance units_converted v1array v1pes v1ppes vdepth vmat3D Variables Type Visibility Attributes Name Initial real(kind=dp), public, parameter :: amutoau = 1822.8884862d0 real(kind=dp), public, allocatable :: bmat3D (:,:,:) arrays holding spline coefficients interpolating vmat3D real(kind=dp), public, parameter :: bohrtoangstrom = 0.5291772109d0 real(kind=dp), public, allocatable :: cmat3D (:,:,:) arrays holding spline coefficients interpolating vmat3D integer(kind=int32), public :: consecutive_blocks_threshold = 1 number of consecutive blocks for which the threshold condition\non cross-sections needs to be fulfilled to terminate calculations\nif \"jtotmax\" = -1 real(kind=dp), public, allocatable :: dmat3D (:,:,:) arrays holding spline coefficients interpolating vmat3D real(kind=dp), public :: dr = -1.0_dp if >=0, dr is used to determine number of steps on the R grid;\notherwise, grid is determined from \"steps\" real(kind=dp), public :: elastic_xs_threshold = 0.1_dp threshold condition on elastic cross-sections used in \"jtotmax\"=-1 real(kind=dp), public, allocatable :: elevel (:) array holding energies of rovibrational levels of the molecule, corresponding to\nv1array and j1array elements; of nlevel size real(kind=dp), public :: energy = -1.0_dp if \"relative_energy_flag\" = 0, \"energy\" is the total energy (kinetic+internal)\nif \"relative_energy_flag\" = 1, \"energy\" is the kinetic energy real(kind=dp), public, parameter :: hartreetocm = 219474.631363d0 real(kind=dp), public :: inelastic_xs_threshold = 0.1_dp threshold condition on elastic cross-sections used in \"jtotmax\"=-1 integer(kind=int32), public :: initial = -1 if \"relative_energy_flag\" = 1, \"initial\" points to a specific level\nin the basis indicating the initial molecular level integer(kind=int32), public, parameter :: input_unit = 5 integer(kind=int32), public :: iunits = 0 TO BE CORRECTED integer(kind=int32), public, allocatable :: j1array (:) array holding rotational quantum numbers, of nlevel size, integer(kind=int32), public, allocatable :: j1pes (:) arrays holding quantum numbers of radial coupling terms:\n\\eta = v, j, and \\eta' = v', j', of \"total_number_of_coupling_terms\"size;\nsee Eq. 2 in the \"Coupling Matrix\" section integer(kind=int32), public, allocatable :: j1ppes (:) arrays holding quantum numbers of radial coupling terms:\n\\eta = v, j, and \\eta' = v', j', of \"total_number_of_coupling_terms\"size;\nsee Eq. 2 in the \"Coupling Matrix\" section integer(kind=int32), public :: jtotmax = -1 range of total angular momenta, for which coupled equations are solved integer(kind=int32), public :: jtotmin = 0 range of total angular momenta, for which coupled equations are solved integer(kind=int32), public :: jtotstep = 1 range of total angular momenta, for which coupled equations are solved integer(kind=int32), public, allocatable :: l1tab (:) array holding legendre indices of the PES expansion, \\lambda)),\nof nterms size; see Eq. 2 in the \"Coupling Matrix\" section character(len=80), public :: label = \"Test scattering calculations\" user-defined label integer(kind=int32), public :: minimal_number_of_coupling_terms minimal number of coupling terms based on levels provided in the basis integer(kind=int32), public :: n_skip_lines = 0 number of lines that at the beginning of \"potentialfile\" that are to be skipped integer(kind=int32), public :: nlevel = -1 number of rovibrational levels in the basis integer(kind=int32), public :: nr = -1 number of grid points for the radial coupling terms in the potential expansion integer(kind=int32), public :: nterms = -1 number of the radial coupling terms in the potential expansion integer(kind=int32), public, parameter :: partial_file_unit = 12 character(len=80), public :: partialfile = \"PartialFile.dat\" name of the file holding partial state-to-state cross-sections logical, public :: pes_file_exists = .false. a flag for checking existence of \"potentialfile\" -> MOVE integer(kind=int32), public, parameter :: pes_file_unit = 8 real(kind=dp), public, parameter :: pi = dacos(-1.d0) character(len=80), public :: potentialfile = \"RadialTerms.dat\" name of the file with tabulated radial coupling terms of the PES logical, public :: print_partial_cross_sections = .false. if .true. partial cross-sections will be saved to \"partialfile\" integer(kind=int32), public :: prntlvl = 2 print level control; should be >= 0 real(kind=dp), public :: radial_term_distance_converter real(kind=dp), public :: radial_term_energy_converter real(kind=dp), public, allocatable :: read_vmat3D (:,:,:) array holding read radial coupling terms of the PES;\nthe 3 dimensions correspond to R, \\lambda, \\eta \\eta' grids\nand are of (nr, nterms, total_number_of_coupling_terms) size integer(kind=int32), public, allocatable :: reduced_j1pes (:) arrays holding quantum numbers of the necessary radial coupling terms\n(based on levels provided in the basis):\n\\eta = v, j, and \\eta' = v', j', of \"minimal_number_of_coupling_terms\" size;\nsee Eq. 2 in the \"Coupling Matrix\" section integer(kind=int32), public, allocatable :: reduced_j1ppes (:) arrays holding quantum numbers of the necessary radial coupling terms\n(based on levels provided in the basis):\n\\eta = v, j, and \\eta' = v', j', of \"minimal_number_of_coupling_terms\" size;\nsee Eq. 2 in the \"Coupling Matrix\" section real(kind=dp), public :: reduced_mass = -1.0_dp reduced mass of the scattering system integer(kind=int32), public, allocatable :: reduced_v1pes (:) arrays holding quantum numbers of the necessary radial coupling terms\n(based on levels provided in the basis):\n\\eta = v, j, and \\eta' = v', j', of \"minimal_number_of_coupling_terms\" size;\nsee Eq. 2 in the \"Coupling Matrix\" section integer(kind=int32), public, allocatable :: reduced_v1ppes (:) arrays holding quantum numbers of the necessary radial coupling terms\n(based on levels provided in the basis):\n\\eta = v, j, and \\eta' = v', j', of \"minimal_number_of_coupling_terms\" size;\nsee Eq. 2 in the \"Coupling Matrix\" section integer(kind=int32), public :: relative_energy_flag = 0 if set to 0, \"energy\" is interpreted as the total energy,\nif set to 1, \"energy\" is interpreted as kinetic energy calculated with\nrespect to selected \"initial\" level real(kind=dp), public, allocatable :: rmat (:) array holding R grid points, filled while reading radial coupling\nterms from the \"potentialfile\"; of \"nr\" size real(kind=dp), public :: rmax = -1.0_dp range of the propagation real(kind=dp), public :: rmin = -1.0_dp range of the propagation integer(kind=int32), public, parameter :: s_matrix_unit = 11 character(len=80), public :: smatrixfile = \"SmatrixFile.dat\" name of the S-matrix file integer(kind=int32), public :: steps = 10 number of steps per half-de Broglie wavelength of the scattering system;\nif provided on input, the number of R-grid points is determined\nas N = \\frac{R_{max}-R_{min}}{\\pi(k_{max}+k_{vdepth})}\\mathrm{steps},\nwhere k_{max} is the largest wavevector in a given block,\nand k_{vdepth} is the correction due to the depth of the potential,\nsee \"vdepth\" integer(kind=int32), public :: total_number_of_coupling_terms = 1 total number of coupling terms provided in \"potentialfile\" real(kind=dp), public, parameter :: unitary_tolerance = 1e-6_dp logical, public :: units_converted = .false. if .true. mass and energy units are converted integer(kind=int32), public, allocatable :: v1array (:) array holding vibrational quantum numbers, of nlevel size integer(kind=int32), public, allocatable :: v1pes (:) arrays holding quantum numbers of radial coupling terms:\n\\eta = v, j, and \\eta' = v', j', of \"total_number_of_coupling_terms\"size;\nsee Eq. 2 in the \"Coupling Matrix\" section integer(kind=int32), public, allocatable :: v1ppes (:) arrays holding quantum numbers of radial coupling terms:\n\\eta = v, j, and \\eta' = v', j', of \"total_number_of_coupling_terms\"size;\nsee Eq. 2 in the \"Coupling Matrix\" section real(kind=dp), public :: vdepth = 0.0_dp the absolute value of the depth of the potential, included\nin the determination of the step size of the propagator through\nk_{vdepth} = \\sqrt{2\\mu(\\mathrm{vdepth})} real(kind=dp), public, allocatable :: vmat3D (:,:,:) array holding necessary radial coupling terms of the PES\n(based on levels provided in the basis);\nthe 3 dimensions correspond to R, \\lambda, \\eta \\eta' grids\nand are of (nr, nterms, minimal_number_of_coupling_terms) size","tags":"","loc":"module/data_mod.html"},{"title":"boundary_conditions_mod – the SCATTERING code","text":"This module contains subroutines that transform the asymptotic\nlog-derivative matrix into the scattering S-matrix\n(see \"Solution of coupled equations\" section) Uses io_mod data_mod array_operations_mod fwigxjpf utility_functions_mod iso_fortran_env math_functions_mod module~~boundary_conditions_mod~~UsesGraph module~boundary_conditions_mod boundary_conditions_mod module~utility_functions_mod utility_functions_mod module~boundary_conditions_mod->module~utility_functions_mod module~math_functions_mod math_functions_mod module~boundary_conditions_mod->module~math_functions_mod module~array_operations_mod array_operations_mod module~boundary_conditions_mod->module~array_operations_mod module~data_mod data_mod module~boundary_conditions_mod->module~data_mod module~io_mod io_mod module~boundary_conditions_mod->module~io_mod fwigxjpf fwigxjpf module~boundary_conditions_mod->fwigxjpf iso_fortran_env iso_fortran_env module~boundary_conditions_mod->iso_fortran_env module~utility_functions_mod->iso_fortran_env module~math_functions_mod->module~utility_functions_mod module~math_functions_mod->iso_fortran_env module~special_functions_mod special_functions_mod module~math_functions_mod->module~special_functions_mod module~array_operations_mod->iso_fortran_env module~data_mod->iso_fortran_env module~io_mod->module~utility_functions_mod module~io_mod->module~array_operations_mod module~io_mod->module~data_mod module~io_mod->iso_fortran_env module~input_validation input_validation module~io_mod->module~input_validation module~input_validation->module~utility_functions_mod module~input_validation->module~data_mod module~input_validation->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~boundary_conditions_mod~~UsedByGraph module~boundary_conditions_mod boundary_conditions_mod program~scattering SCATTERING program~scattering->module~boundary_conditions_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines calculate_k_matrix calculate_s_matrix calculate_sf_matrix_from_bf_matrix Subroutines public  subroutine calculate_k_matrix (number_of_channels, log_der_matrix, number_of_open_channels, channel_indices, channel_l_values, r_, k_matrix) calculates the K-matrix from log-derivative matrix using Eq. (4) in\n\"Solution of coupled equations\" Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: number_of_channels y-matrix is of number_of_channels x number_of_channels size real(kind=dp), intent(in) :: log_der_matrix (number_of_channels,number_of_channels) asymptotic log-derivative matrix integer(kind=int32), intent(in) :: number_of_open_channels number of open channels integer(kind=int32), intent(in) :: channel_indices (number_of_channels) holds the indices pointing to the basis arrays integer(kind=int32), intent(in) :: channel_l_values (number_of_channels) holds all values of l real(kind=dp), intent(in) :: r_ Rmax real(kind=dp), intent(inout) :: k_matrix (number_of_open_channels,number_of_open_channels) K-matrix public  subroutine calculate_s_matrix (number_of_open_channels, k_matrix, s_matrix_real, s_matrix_imag) calculates S-matrix from open-open portion of the K-matrix using\nEq. (12) in \"Solution of coupled equations\" Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: number_of_open_channels number of open channels real(kind=dp), intent(in) :: k_matrix (number_of_open_channels,number_of_open_channels) K-matrix real(kind=dp), intent(inout) :: s_matrix_real (number_of_open_channels,number_of_open_channels) (output) real part of the S-matrix real(kind=dp), intent(inout) :: s_matrix_imag (number_of_open_channels,number_of_open_channels) (output) imaginary part of the S-matrix public  subroutine calculate_sf_matrix_from_bf_matrix (number_of_channels, total_angular_momentum_, channel_indices, channels_omega_values, channel_l_values, bf_matrix, sf_matrix) takes as an input matrix in the body-fixed frame and transforms it \nto the spec-fixed frame; iterates over all matrix elements\nand calls calculate_single_SF_element Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: number_of_channels size of the basis integer(kind=int32), intent(in) :: total_angular_momentum_ total angular momentum integer(kind=int32), intent(in) :: channel_indices (number_of_channels) holds the indices pointing to the basis arrays integer(kind=int32), intent(in) :: channels_omega_values (number_of_channels) holds all values of \\bar{\\Omega} integer(kind=int32), intent(in) :: channel_l_values (number_of_channels) holds all values of l real(kind=dp), intent(in) :: bf_matrix (number_of_channels,number_of_channels) matrix in the BF frame real(kind=dp), intent(inout) :: sf_matrix (number_of_channels,number_of_channels) (output) matrix in the SF frame","tags":"","loc":"module/boundary_conditions_mod.html"},{"title":"input_validation – the SCATTERING code","text":"This module provides subroutines validating read values Uses data_mod utility_functions_mod iso_fortran_env module~~input_validation~~UsesGraph module~input_validation input_validation module~data_mod data_mod module~input_validation->module~data_mod iso_fortran_env iso_fortran_env module~input_validation->iso_fortran_env module~utility_functions_mod utility_functions_mod module~input_validation->module~utility_functions_mod module~data_mod->iso_fortran_env module~utility_functions_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~input_validation~~UsedByGraph module~input_validation input_validation module~io_mod io_mod module~io_mod->module~input_validation module~radial_coupling_terms_mod radial_coupling_terms_mod module~radial_coupling_terms_mod->module~io_mod module~channels_mod channels_mod module~channels_mod->module~io_mod module~pes_matrix_mod pes_matrix_mod module~pes_matrix_mod->module~io_mod module~pes_matrix_mod->module~radial_coupling_terms_mod program~scattering SCATTERING program~scattering->module~io_mod program~scattering->module~radial_coupling_terms_mod program~scattering->module~channels_mod program~scattering->module~pes_matrix_mod module~propagator_mod propagator_mod program~scattering->module~propagator_mod module~boundary_conditions_mod boundary_conditions_mod program~scattering->module~boundary_conditions_mod module~state_to_state_cross_sections_mod state_to_state_cross_sections_mod program~scattering->module~state_to_state_cross_sections_mod module~centrifugal_matrix_mod centrifugal_matrix_mod module~centrifugal_matrix_mod->module~io_mod module~propagator_mod->module~io_mod module~propagator_mod->module~pes_matrix_mod module~propagator_mod->module~centrifugal_matrix_mod module~boundary_conditions_mod->module~io_mod module~state_to_state_cross_sections_mod->module~io_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines check_namelist_basis check_namelist_input check_namelist_potential Subroutines public  subroutine check_namelist_basis () Check variables read from namelist \"basis\" Arguments None public  subroutine check_namelist_input () Check variables read from namelist \"input\" Arguments None public  subroutine check_namelist_potential () Check variables read from namelist \"potential\" Arguments None","tags":"","loc":"module/input_validation.html"},{"title":"propagator_mod – the SCATTERING code","text":"This modules contains the subroutines used by the renormalized\nNumerov propagator. Uses pes_matrix_mod io_mod centrifugal_matrix_mod data_mod array_operations_mod utility_functions_mod iso_fortran_env module~~propagator_mod~~UsesGraph module~propagator_mod propagator_mod module~pes_matrix_mod pes_matrix_mod module~propagator_mod->module~pes_matrix_mod module~utility_functions_mod utility_functions_mod module~propagator_mod->module~utility_functions_mod module~array_operations_mod array_operations_mod module~propagator_mod->module~array_operations_mod module~data_mod data_mod module~propagator_mod->module~data_mod module~centrifugal_matrix_mod centrifugal_matrix_mod module~propagator_mod->module~centrifugal_matrix_mod module~io_mod io_mod module~propagator_mod->module~io_mod iso_fortran_env iso_fortran_env module~propagator_mod->iso_fortran_env module~pes_matrix_mod->module~utility_functions_mod module~pes_matrix_mod->module~array_operations_mod module~pes_matrix_mod->module~data_mod module~pes_matrix_mod->module~io_mod module~pes_matrix_mod->iso_fortran_env module~radial_coupling_terms_mod radial_coupling_terms_mod module~pes_matrix_mod->module~radial_coupling_terms_mod module~math_functions_mod math_functions_mod module~pes_matrix_mod->module~math_functions_mod module~utility_functions_mod->iso_fortran_env module~array_operations_mod->iso_fortran_env module~data_mod->iso_fortran_env module~centrifugal_matrix_mod->module~array_operations_mod module~centrifugal_matrix_mod->module~data_mod module~centrifugal_matrix_mod->module~io_mod module~centrifugal_matrix_mod->iso_fortran_env module~io_mod->module~utility_functions_mod module~io_mod->module~array_operations_mod module~io_mod->module~data_mod module~io_mod->iso_fortran_env module~input_validation input_validation module~io_mod->module~input_validation module~radial_coupling_terms_mod->module~utility_functions_mod module~radial_coupling_terms_mod->module~data_mod module~radial_coupling_terms_mod->module~io_mod module~radial_coupling_terms_mod->iso_fortran_env module~radial_coupling_terms_mod->module~math_functions_mod module~math_functions_mod->module~utility_functions_mod module~math_functions_mod->iso_fortran_env module~special_functions_mod special_functions_mod module~math_functions_mod->module~special_functions_mod module~input_validation->module~utility_functions_mod module~input_validation->module~data_mod module~input_validation->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~propagator_mod~~UsedByGraph module~propagator_mod propagator_mod program~scattering SCATTERING program~scattering->module~propagator_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines numerov Subroutines public  subroutine numerov (number_of_channels_, channel_indices_, channels_omega_values_, nonzero_terms_per_element_, nonzero_legendre_indices_, nonzero_algebraic_coefficients_, number_of_steps_, total_angular_momentum_, log_der_matrix_) renormalized Numerov propagator\n... Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: number_of_channels_ size of the basis integer(kind=int32), intent(in) :: channel_indices_ (number_of_channels_) holds the indices pointing to the basis arrays integer(kind=int32), intent(in) :: channels_omega_values_ (number_of_channels_) holds all values of \\bar{\\Omega} integer(kind=int32), intent(in) :: nonzero_terms_per_element_ (:) keeps the number of non-zero terms in the sum (Eq. (6.21)) for\neach non-zero element of W/V integer(kind=int32), intent(in) :: nonzero_legendre_indices_ (:) holds the proper indices pointing to l1/l2/lltabs, which\ncorrespond to the non-vanishing elements of the sum  (Eq. (6.21))\nfor each non-zero element of W/V real(kind=dp), intent(in) :: nonzero_algebraic_coefficients_ (:) holds the values of the non-zero algebraic coefficients integer(kind=int32), intent(in) :: number_of_steps_ number of steps from rmin to rmax integer(kind=int32), intent(in) :: total_angular_momentum_ total angular momentum real(kind=dp), intent(inout) :: log_der_matrix_ (number_of_channels_,number_of_channels_) resulting log-derivative matrix at RMAX","tags":"","loc":"module/propagator_mod.html"},{"title":"utility_functions_mod – the SCATTERING code","text":"utility_functions_mod contains functions which handle writing \nmessages/errors/warnings on screen, formatting headers, summary of the \ncalculations and a few other supporting functions. Uses iso_fortran_env module~~utility_functions_mod~~UsesGraph module~utility_functions_mod utility_functions_mod iso_fortran_env iso_fortran_env module~utility_functions_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~utility_functions_mod~~UsedByGraph module~utility_functions_mod utility_functions_mod module~input_validation input_validation module~input_validation->module~utility_functions_mod module~math_functions_mod math_functions_mod module~math_functions_mod->module~utility_functions_mod module~radial_coupling_terms_mod radial_coupling_terms_mod module~radial_coupling_terms_mod->module~utility_functions_mod module~radial_coupling_terms_mod->module~math_functions_mod module~io_mod io_mod module~radial_coupling_terms_mod->module~io_mod module~pes_matrix_mod pes_matrix_mod module~pes_matrix_mod->module~utility_functions_mod module~pes_matrix_mod->module~math_functions_mod module~pes_matrix_mod->module~radial_coupling_terms_mod module~pes_matrix_mod->module~io_mod module~unitarity_check_mod unitarity_check_mod module~unitarity_check_mod->module~utility_functions_mod module~channels_mod channels_mod module~channels_mod->module~utility_functions_mod module~channels_mod->module~io_mod program~scattering SCATTERING program~scattering->module~utility_functions_mod program~scattering->module~radial_coupling_terms_mod program~scattering->module~pes_matrix_mod program~scattering->module~unitarity_check_mod program~scattering->module~channels_mod program~scattering->module~io_mod module~boundary_conditions_mod boundary_conditions_mod program~scattering->module~boundary_conditions_mod module~propagator_mod propagator_mod program~scattering->module~propagator_mod module~save_s_matrix_mod save_s_matrix_mod program~scattering->module~save_s_matrix_mod module~state_to_state_cross_sections_mod state_to_state_cross_sections_mod program~scattering->module~state_to_state_cross_sections_mod module~io_mod->module~utility_functions_mod module~io_mod->module~input_validation module~boundary_conditions_mod->module~utility_functions_mod module~boundary_conditions_mod->module~math_functions_mod module~boundary_conditions_mod->module~io_mod module~propagator_mod->module~utility_functions_mod module~propagator_mod->module~pes_matrix_mod module~propagator_mod->module~io_mod module~centrifugal_matrix_mod centrifugal_matrix_mod module~propagator_mod->module~centrifugal_matrix_mod module~save_s_matrix_mod->module~utility_functions_mod module~state_to_state_cross_sections_mod->module~utility_functions_mod module~state_to_state_cross_sections_mod->module~io_mod module~array_operations_fill_symmetric_matrix_submod array_operations_fill_symmetric_matrix_submod module~array_operations_fill_symmetric_matrix_submod->module~utility_functions_mod module~array_operations_add_scalar_to_diagonal_submod array_operations_add_scalar_to_diagonal_submod module~array_operations_add_scalar_to_diagonal_submod->module~utility_functions_mod module~centrifugal_matrix_mod->module~io_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces incorrect_value Functions float_to_character integer_to_character to_lowercase Subroutines alloc_status file_io_status time_count_summary write_error write_header write_message write_warning Interfaces public        interface incorrect_value interface for the following message: incorrect value encountered:\n  variable_name = variable_value private  subroutine incorrect_value_ch(name_, value_, unit_) incorrect value encountered:\n  variable_name = variable_value Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name_ name of the variable character(len=*), intent(in) :: value_ value of the variable integer(kind=int32), intent(in), optional :: unit_ optional, unit where the message will be written private  subroutine incorrect_value_int32(name_, value_, unit_) incorrect value encountered:\n  variable_name = variable_value Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name_ name of the variable integer(kind=int32), intent(in) :: value_ value of the variable integer(kind=int32), intent(in), optional :: unit_ optional, unit where the message will be written private  subroutine incorrect_value_sp(name_, value_, unit_) incorrect value encountered:\n  variable_name = variable_value Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name_ name of the variable real(kind=sp), intent(in) :: value_ value of the variable integer(kind=int32), intent(in), optional :: unit_ optional, unit where the message will be written private  subroutine incorrect_value_dp(name_, value_, unit_) incorrect value encountered:\n  variable_name = variable_value Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name_ name of the variable real(kind=dp), intent(in) :: value_ value of the variable integer(kind=int32), intent(in), optional :: unit_ optional, unit where the message will be written Functions public  function float_to_character (f, format_string) result(res) Converts a floating-point number to a character string. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: f input floating-point number character(len=*), intent(in), optional :: format_string Optional format string. Return Value character(len=64) Output character string. public  function integer_to_character (i) result(res) transfers integer to a character Arguments Type Intent Optional Attributes Name integer, intent(in) :: i input integer Return Value character(len=32) output character public  function to_lowercase (str) result(low_str) forces lowercase on given string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str input string Return Value character(len=len) output (lowercase) string Subroutines public  subroutine alloc_status (istat_, message_, op_, unit_) check the status after allocation Arguments Type Intent Optional Attributes Name integer(kind=int32) :: istat_ result of stat=istat in (de)allocate character(len=*), intent(in) :: message_ a message to be written character(len=1), intent(in) :: op_ 'a' for allocation, 'd' for deallocation integer(kind=int32), intent(in), optional :: unit_ optional, unit where the message will be written public  subroutine file_io_status (istat_, iomsg_, channel_, op_, unit_) check the status during various io operations on files Arguments Type Intent Optional Attributes Name integer(kind=int32) :: istat_ result of iostat in open/read/write/close character(len=*), intent(in) :: iomsg_ result of iomsg in open/read/write/close integer(kind=int32), intent(in) :: channel_ name of the file character(len=1), intent(in) :: op_ 'o' for opening of the file, 'r' for reading, 'w' for writing,\n'c' for closing integer(kind=int32), intent(in), optional :: unit_ optional, unit where the message will be written public  subroutine time_count_summary (start_, stop_, time_, message_) print the message about the time it took to complete a single task Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: start_ initial time real(kind=dp), intent(in) :: stop_ final time real(kind=dp), intent(out) :: time_ stop_ - start_ character(len=*), intent(in), optional :: message_ (optional) a message to print instead of a default\n\"Completed in ... s\" public  subroutine write_error (message_, unit_) writes an error message on a chosen unit Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message_ a message to be written integer(kind=int32), intent(in), optional :: unit_ optional, unit where the message will be written public  subroutine write_header (header_type, opt_integer_) writes headers on screen Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: header_type specifies the type of the header: 'main', 'input_read',\n'input_check', 'input_summary', 'initialization', 'check_norm',\n'save_basis', 'save_pes', 'radial_terms', 'save_radial_terms',\n'reconstruction' integer(kind=int32), intent(in), optional :: opt_integer_ optional integer used in case \"block\" to pass jtot value public  subroutine write_message (message_, unit_) writes a message on a chosen unit Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message_ a message to be written integer(kind=int32), intent(in), optional :: unit_ optional, unit where the message will be written public  subroutine write_warning (message_, unit_) writes a warning message on a chosen unit Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message_ a message to be written integer(kind=int32), intent(in), optional :: unit_ optional, unit where the message will be written","tags":"","loc":"module/utility_functions_mod.html"},{"title":"save_s_matrix_mod – the SCATTERING code","text":"This module provides procedures that save selective information\nto the S-matrix file Uses data_mod iso_fortran_env utility_functions_mod module~~save_s_matrix_mod~~UsesGraph module~save_s_matrix_mod save_s_matrix_mod module~data_mod data_mod module~save_s_matrix_mod->module~data_mod iso_fortran_env iso_fortran_env module~save_s_matrix_mod->iso_fortran_env module~utility_functions_mod utility_functions_mod module~save_s_matrix_mod->module~utility_functions_mod module~data_mod->iso_fortran_env module~utility_functions_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~save_s_matrix_mod~~UsedByGraph module~save_s_matrix_mod save_s_matrix_mod program~scattering SCATTERING program~scattering->module~save_s_matrix_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines save_s_matrix_block_info save_s_matrix_file_header Subroutines public  subroutine save_s_matrix_block_info (total_angular_momentum, parity_exponent, number_of_open_channels, channel_indices, channel_l_values, wv, s_matrix_real, s_matrix_imag) save information about current block\n-- total angular momentum, parity exponent, number of open channels\n   in the current block\n-- array of indices pointing to the basis arrays, array holding\n   l values, wavenumbers\n-- real part of the S-matrix\n-- imaginary part of the S-matrix Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: total_angular_momentum integer(kind=int32), intent(in) :: parity_exponent integer(kind=int32), intent(in) :: number_of_open_channels integer(kind=int32), intent(in) :: channel_indices (number_of_open_channels) integer(kind=int32), intent(in) :: channel_l_values (number_of_open_channels) real(kind=dp), intent(in) :: wv (number_of_open_channels) real(kind=dp), intent(in) :: s_matrix_real (number_of_open_channels,number_of_open_channels) real(kind=dp), intent(in) :: s_matrix_imag (number_of_open_channels,number_of_open_channels) public  subroutine save_s_matrix_file_header () save \"header\" of the S-matrix file:\n-- label, \"itype\", number of levels in the basis, reduced mass of the system\n-- vibrational and rotational quantum numbers\n-- rovibrational energies\n-- index pointing to the initial level and the kinetic/total energy Arguments None","tags":"","loc":"module/save_s_matrix_mod.html"},{"title":"channels_mod – the SCATTERING code","text":"This module provides subroutines that set the number of channels in the\nblock, save quantum numbers for each channel (both in body- and space-fixed\ncases) and print quantum numbers on screen Uses data_mod io_mod iso_fortran_env utility_functions_mod module~~channels_mod~~UsesGraph module~channels_mod channels_mod module~data_mod data_mod module~channels_mod->module~data_mod iso_fortran_env iso_fortran_env module~channels_mod->iso_fortran_env module~utility_functions_mod utility_functions_mod module~channels_mod->module~utility_functions_mod module~io_mod io_mod module~channels_mod->module~io_mod module~data_mod->iso_fortran_env module~utility_functions_mod->iso_fortran_env module~io_mod->module~data_mod module~io_mod->iso_fortran_env module~io_mod->module~utility_functions_mod module~input_validation input_validation module~io_mod->module~input_validation module~array_operations_mod array_operations_mod module~io_mod->module~array_operations_mod module~input_validation->module~data_mod module~input_validation->iso_fortran_env module~input_validation->module~utility_functions_mod module~array_operations_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~channels_mod~~UsedByGraph module~channels_mod channels_mod program~scattering SCATTERING program~scattering->module~channels_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Functions calculate_largest_wavenumber count_open_channels_in_block Subroutines print_channels set_body_fixed_channels set_number_of_channels set_space_fixed_channels Functions public  function calculate_largest_wavenumber (channel_indices) result(largest_wavenumber_) Calculates the largest wave number in the block;\ncalled only if there are any open channels Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: channel_indices (:) holds the indices pointing to the basis arrays Return Value real(kind=dp) (output) the largest wave number (wavmax) in the block public  function count_open_channels_in_block (channel_indices) result(number_of_open_channels_) counts the energetically accessible channels in the given block Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: channel_indices (:) holds the indices pointing to the basis arrays Return Value integer(kind=int32) (output) number of open channels Subroutines public  subroutine print_channels (parity_exponent_, channel_indices, channels_omega_values) prints information about body-fixed channels on screen Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: parity_exponent_ parity exponent of the block (0 if p = +1, 1 if p = -1) integer(kind=int32), intent(inout) :: channel_indices (:) holds the indices pointing to the basis arrays integer(kind=int32), intent(inout) :: channels_omega_values (:) holds all values of \\bar{\\Omega} public  subroutine set_body_fixed_channels (total_angular_momentum_, parity_exponent_, channel_indices, channels_omega_values) Prepares the channel_indices array which holds indices that refer to the\nbasis arrays: v1level/j1level/elevel, and channels_omega_values which holds values\nof \\bar{\\Omega} Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: total_angular_momentum_ total angular momentum integer(kind=int32), intent(in) :: parity_exponent_ parity exponent of the block (0 if p = +1, 1 if p = -1) integer(kind=int32), intent(inout) :: channel_indices (:) holds the indices pointing to the basis arrays integer(kind=int32), intent(inout) :: channels_omega_values (:) holds all values of \\bar{\\Omega} public  subroutine set_number_of_channels (total_angular_momentum_, number_of_channels_even_parity_block, number_of_channels_odd_parity_block) determine the number of scattering channels in each parity block \nfor given total angular momentum in both body-fixed and\nspace-fixed frames Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: total_angular_momentum_ total angular momentum integer(kind=int32), intent(out) :: number_of_channels_even_parity_block number of channels in the p = 1 (even parity) block integer(kind=int32), intent(out) :: number_of_channels_odd_parity_block number of channels in the p = -1 (odd parity) block public  subroutine set_space_fixed_channels (total_angular_momentum_, parity_exponent_, channel_l_values) Prepares the channel_l_values array which holds values of\norbital angular momentum, l, a space-fixed-frame quantum number. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: total_angular_momentum_ total angular momentum integer(kind=int32), intent(in) :: parity_exponent_ parity exponent of the block (0 if p = +1, 1 if p = -1) integer(kind=int32), intent(inout) :: channel_l_values (:) holds all values of l","tags":"","loc":"module/channels_mod.html"},{"title":"state_to_state_cross_sections_mod – the SCATTERING code","text":"This module provides functions and subroutines for calculating and analyzing\nstate-to-state cross-sections. It is divided into three main parts:\n1. Calculating cross-sections: Functions for computing state-to-state\n   cross-sections based on quantum states, S-matrix, and scattering parameters.\n   (\"calculate_state_to_state_cross_section\", \"compute_individual_cross_section\",\n   \"get_block_indices\", \"sum_cross_section_contributions\",\n   \"compute_real_component\", \"compute_imag_component\")\n2. Printing cross-sections: Subroutines to output the largest partial\n   cross-sections, providing both basic and detailed information.\n   (\"print_largest_partial_cross_sections\", \"print_basic_cross_section_info\",\n   \"print_detailed_cross_section_info\")\n3. Threshold checking: Subroutine to check if the computed cross-sections\n   meet specified convergence conditions\n   (\"check_cross_section_thresholds\") Uses data_mod io_mod iso_fortran_env utility_functions_mod module~~state_to_state_cross_sections_mod~~UsesGraph module~state_to_state_cross_sections_mod state_to_state_cross_sections_mod module~data_mod data_mod module~state_to_state_cross_sections_mod->module~data_mod iso_fortran_env iso_fortran_env module~state_to_state_cross_sections_mod->iso_fortran_env module~utility_functions_mod utility_functions_mod module~state_to_state_cross_sections_mod->module~utility_functions_mod module~io_mod io_mod module~state_to_state_cross_sections_mod->module~io_mod module~data_mod->iso_fortran_env module~utility_functions_mod->iso_fortran_env module~io_mod->module~data_mod module~io_mod->iso_fortran_env module~io_mod->module~utility_functions_mod module~input_validation input_validation module~io_mod->module~input_validation module~array_operations_mod array_operations_mod module~io_mod->module~array_operations_mod module~input_validation->module~data_mod module~input_validation->iso_fortran_env module~input_validation->module~utility_functions_mod module~array_operations_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~state_to_state_cross_sections_mod~~UsedByGraph module~state_to_state_cross_sections_mod state_to_state_cross_sections_mod program~scattering SCATTERING program~scattering->module~state_to_state_cross_sections_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines calculate_state_to_state_cross_section check_cross_section_thresholds print_largest_partial_cross_sections save_partial_xs_file_header save_partial_xs_single_block Subroutines public  subroutine calculate_state_to_state_cross_section (total_angular_momentum_, open_basis_levels_, open_basis_wavevectors_, s_matrix_real_, s_matrix_imag_, channel_indices_, channel_l_values_, cross_section_array_) Calculates all state-to-state cross-sections. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: total_angular_momentum_ total angular momentum integer(kind=int32), intent(in) :: open_basis_levels_ (:) holds indices to the basis arrays which correspond to open channels real(kind=dp), intent(in) :: open_basis_wavevectors_ (:) holds wavenumbers k_{i} real(kind=dp), intent(in) :: s_matrix_real_ (:,:) real and imaginary parts of the S-matrix real(kind=dp), intent(in) :: s_matrix_imag_ (:,:) real and imaginary parts of the S-matrix integer(kind=int32), intent(in) :: channel_indices_ (:) holds the indices pointing to the basis arrays integer(kind=int32), intent(in) :: channel_l_values_ (:) holds all values of l real(kind=dp), intent(inout) :: cross_section_array_ (:) array holding all XSs public  subroutine check_cross_section_thresholds (largest_elastic_xs_, largest_inelastic_xs_, consecutive_elastic_, consecutive_inelastic_, terminate_) Checks if the elastic_xs_threshold (threshold for elastic XS) and inelastic_xs_threshold\n(threshold for inelastic XS) conditions are already fulfilled. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: largest_elastic_xs_ largest elastic XS in the block real(kind=dp), intent(in) :: largest_inelastic_xs_ largest inelastic XS in the block integer(kind=int32), intent(inout) :: consecutive_elastic_ number of consecutive blocks meeting condition on elastic XS integer(kind=int32), intent(inout) :: consecutive_inelastic_ number of consecutive blocks meeting condition on inelastic XS logical, intent(inout) :: terminate_ flag to indicate termination of loop based on thresholds public  subroutine print_largest_partial_cross_sections (total_angular_momentum_, largest_elastic_xs_, largest_inelastic_xs_, elastic_index_, inelastic_index_1_, inelastic_index_2_, open_basis_levels_) Print the largest partial elastic and inelastic state-to-state\ncross-sections in a given block. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: total_angular_momentum_ total angular momentum real(kind=dp), intent(in) :: largest_elastic_xs_ the largest partial elastic state-to-state XS in the block real(kind=dp), intent(in) :: largest_inelastic_xs_ the largest partial inelastic state-to-state XS in the block integer(kind=int32), intent(in) :: elastic_index_ index pointing indirectly to quantum numbers associated with\nthe largest partial elastic state-to-state XS in the block integer(kind=int32), intent(in) :: inelastic_index_1_ indices pointing indirectly to quantum numbers associated with\nthe largest partial inelastic state-to-state XS in the block integer(kind=int32), intent(in) :: inelastic_index_2_ indices pointing indirectly to quantum numbers associated with\nthe largest partial inelastic state-to-state XS in the block integer(kind=int32), intent(in) :: open_basis_levels_ (:) holds indices to the basis arrays that correspond to open channels public  subroutine save_partial_xs_file_header () save \"header\" of the partial cross-sections file:\n-- label, \"itype\", number of levels in the basis, reduced mass of the system\n-- vibrational and rotational quantum numbers\n-- rovibrational energies\n-- index pointing to the initial level and the kinetic/total energy Arguments None public  subroutine save_partial_xs_single_block (jtot_, block_number_, number_of_open_basis_levels, open_basis_levels, xs_block) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: jtot_ integer(kind=int32), intent(in) :: block_number_ integer(kind=int32), intent(in) :: number_of_open_basis_levels integer(kind=int32), intent(in) :: open_basis_levels (number_of_open_basis_levels) real(kind=dp), intent(in) :: xs_block (number_of_open_basis_levels*number_of_open_basis_levels)","tags":"","loc":"module/state_to_state_cross_sections_mod.html"},{"title":"array_operations_invert_symmetric_matrix_submod – the SCATTERING code","text":"a submodule for append subroutines Uses Ancestors: array_operations_mod module~~array_operations_invert_symmetric_matrix_submod~~UsesGraph module~array_operations_invert_symmetric_matrix_submod array_operations_invert_symmetric_matrix_submod module~array_operations_mod array_operations_mod module~array_operations_invert_symmetric_matrix_submod->module~array_operations_mod iso_fortran_env iso_fortran_env module~array_operations_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"module/array_operations_invert_symmetric_matrix_submod.html"},{"title":"array_operations_append_submod – the SCATTERING code","text":"a submodule for append subroutines Uses Ancestors: array_operations_mod module~~array_operations_append_submod~~UsesGraph module~array_operations_append_submod array_operations_append_submod module~array_operations_mod array_operations_mod module~array_operations_append_submod->module~array_operations_mod iso_fortran_env iso_fortran_env module~array_operations_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"module/array_operations_append_submod.html"},{"title":"array_operations_fill_symmetric_matrix_submod – the SCATTERING code","text":"a submodule for append subroutines Uses utility_functions_mod Ancestors: array_operations_mod module~~array_operations_fill_symmetric_matrix_submod~~UsesGraph module~array_operations_fill_symmetric_matrix_submod array_operations_fill_symmetric_matrix_submod module~utility_functions_mod utility_functions_mod module~array_operations_fill_symmetric_matrix_submod->module~utility_functions_mod module~array_operations_mod array_operations_mod module~array_operations_fill_symmetric_matrix_submod->module~array_operations_mod iso_fortran_env iso_fortran_env module~utility_functions_mod->iso_fortran_env module~array_operations_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"module/array_operations_fill_symmetric_matrix_submod.html"},{"title":"array_operations_add_scalar_to_diagonal_submod – the SCATTERING code","text":"a submodule for add_scalar_to_diagonal subroutines Uses utility_functions_mod Ancestors: array_operations_mod module~~array_operations_add_scalar_to_diagonal_submod~~UsesGraph module~array_operations_add_scalar_to_diagonal_submod array_operations_add_scalar_to_diagonal_submod module~utility_functions_mod utility_functions_mod module~array_operations_add_scalar_to_diagonal_submod->module~utility_functions_mod module~array_operations_mod array_operations_mod module~array_operations_add_scalar_to_diagonal_submod->module~array_operations_mod iso_fortran_env iso_fortran_env module~utility_functions_mod->iso_fortran_env module~array_operations_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"module/array_operations_add_scalar_to_diagonal_submod.html"},{"title":"array_operations_allocate_submod – the SCATTERING code","text":"a submodule for allocate subroutines Uses Ancestors: array_operations_mod module~~array_operations_allocate_submod~~UsesGraph module~array_operations_allocate_submod array_operations_allocate_submod module~array_operations_mod array_operations_mod module~array_operations_allocate_submod->module~array_operations_mod iso_fortran_env iso_fortran_env module~array_operations_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"module/array_operations_allocate_submod.html"},{"title":"SCATTERING – the SCATTERING code","text":"Uses radial_coupling_terms_mod state_to_state_cross_sections_mod unitarity_check_mod channels_mod pes_matrix_mod io_mod data_mod save_s_matrix_mod array_operations_mod boundary_conditions_mod utility_functions_mod iso_fortran_env propagator_mod program~~scattering~~UsesGraph program~scattering SCATTERING module~radial_coupling_terms_mod radial_coupling_terms_mod program~scattering->module~radial_coupling_terms_mod module~channels_mod channels_mod program~scattering->module~channels_mod module~utility_functions_mod utility_functions_mod program~scattering->module~utility_functions_mod module~pes_matrix_mod pes_matrix_mod program~scattering->module~pes_matrix_mod module~unitarity_check_mod unitarity_check_mod program~scattering->module~unitarity_check_mod module~state_to_state_cross_sections_mod state_to_state_cross_sections_mod program~scattering->module~state_to_state_cross_sections_mod module~io_mod io_mod program~scattering->module~io_mod module~data_mod data_mod program~scattering->module~data_mod module~save_s_matrix_mod save_s_matrix_mod program~scattering->module~save_s_matrix_mod module~array_operations_mod array_operations_mod program~scattering->module~array_operations_mod module~boundary_conditions_mod boundary_conditions_mod program~scattering->module~boundary_conditions_mod iso_fortran_env iso_fortran_env program~scattering->iso_fortran_env module~propagator_mod propagator_mod program~scattering->module~propagator_mod module~radial_coupling_terms_mod->module~utility_functions_mod module~radial_coupling_terms_mod->module~io_mod module~radial_coupling_terms_mod->module~data_mod module~radial_coupling_terms_mod->iso_fortran_env module~math_functions_mod math_functions_mod module~radial_coupling_terms_mod->module~math_functions_mod module~channels_mod->module~utility_functions_mod module~channels_mod->module~io_mod module~channels_mod->module~data_mod module~channels_mod->iso_fortran_env module~utility_functions_mod->iso_fortran_env module~pes_matrix_mod->module~radial_coupling_terms_mod module~pes_matrix_mod->module~utility_functions_mod module~pes_matrix_mod->module~io_mod module~pes_matrix_mod->module~data_mod module~pes_matrix_mod->module~array_operations_mod module~pes_matrix_mod->iso_fortran_env module~pes_matrix_mod->module~math_functions_mod module~unitarity_check_mod->module~utility_functions_mod module~unitarity_check_mod->module~data_mod module~unitarity_check_mod->iso_fortran_env module~state_to_state_cross_sections_mod->module~utility_functions_mod module~state_to_state_cross_sections_mod->module~io_mod module~state_to_state_cross_sections_mod->module~data_mod module~state_to_state_cross_sections_mod->iso_fortran_env module~io_mod->module~utility_functions_mod module~io_mod->module~data_mod module~io_mod->module~array_operations_mod module~io_mod->iso_fortran_env module~input_validation input_validation module~io_mod->module~input_validation module~data_mod->iso_fortran_env module~save_s_matrix_mod->module~utility_functions_mod module~save_s_matrix_mod->module~data_mod module~save_s_matrix_mod->iso_fortran_env module~array_operations_mod->iso_fortran_env module~boundary_conditions_mod->module~utility_functions_mod module~boundary_conditions_mod->module~io_mod module~boundary_conditions_mod->module~data_mod module~boundary_conditions_mod->module~array_operations_mod module~boundary_conditions_mod->iso_fortran_env module~boundary_conditions_mod->module~math_functions_mod fwigxjpf fwigxjpf module~boundary_conditions_mod->fwigxjpf module~propagator_mod->module~utility_functions_mod module~propagator_mod->module~pes_matrix_mod module~propagator_mod->module~io_mod module~propagator_mod->module~data_mod module~propagator_mod->module~array_operations_mod module~propagator_mod->iso_fortran_env module~centrifugal_matrix_mod centrifugal_matrix_mod module~propagator_mod->module~centrifugal_matrix_mod module~math_functions_mod->module~utility_functions_mod module~math_functions_mod->iso_fortran_env module~special_functions_mod special_functions_mod module~math_functions_mod->module~special_functions_mod module~centrifugal_matrix_mod->module~io_mod module~centrifugal_matrix_mod->module~data_mod module~centrifugal_matrix_mod->module~array_operations_mod module~centrifugal_matrix_mod->iso_fortran_env module~input_validation->module~utility_functions_mod module~input_validation->module~data_mod module~input_validation->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Calls program~~scattering~~CallsGraph program~scattering SCATTERING fwig_table_init fwig_table_init program~scattering->fwig_table_init fwig_temp_init fwig_temp_init program~scattering->fwig_temp_init proc~calculate_k_matrix calculate_k_matrix program~scattering->proc~calculate_k_matrix proc~float_to_character float_to_character program~scattering->proc~float_to_character proc~print_largest_partial_cross_sections print_largest_partial_cross_sections program~scattering->proc~print_largest_partial_cross_sections proc~save_s_matrix_file_header save_s_matrix_file_header program~scattering->proc~save_s_matrix_file_header proc~integer_to_character integer_to_character program~scattering->proc~integer_to_character proc~count_open_channels_in_block count_open_channels_in_block program~scattering->proc~count_open_channels_in_block proc~read_input_file read_input_file program~scattering->proc~read_input_file proc~save_open_basis_levels save_open_basis_levels program~scattering->proc~save_open_basis_levels proc~print_channels print_channels program~scattering->proc~print_channels proc~calculate_largest_wavenumber calculate_largest_wavenumber program~scattering->proc~calculate_largest_wavenumber interface~allocate_2d allocate_2d program~scattering->interface~allocate_2d proc~save_partial_xs_single_block save_partial_xs_single_block program~scattering->proc~save_partial_xs_single_block proc~save_s_matrix_block_info save_s_matrix_block_info program~scattering->proc~save_s_matrix_block_info interface~append append program~scattering->interface~append proc~count_open_basis_levels count_open_basis_levels program~scattering->proc~count_open_basis_levels proc~set_body_fixed_channels set_body_fixed_channels program~scattering->proc~set_body_fixed_channels proc~print_pes_matrix_elements_summary print_pes_matrix_elements_summary program~scattering->proc~print_pes_matrix_elements_summary fwig_temp_free fwig_temp_free program~scattering->fwig_temp_free proc~set_number_of_channels set_number_of_channels program~scattering->proc~set_number_of_channels proc~check_nonzero_pes_matrix_elements check_nonzero_pes_matrix_elements program~scattering->proc~check_nonzero_pes_matrix_elements proc~save_partial_xs_file_header save_partial_xs_file_header program~scattering->proc~save_partial_xs_file_header proc~units_conversion units_conversion program~scattering->proc~units_conversion interface~allocate_1d allocate_1d program~scattering->interface~allocate_1d proc~set_space_fixed_channels set_space_fixed_channels program~scattering->proc~set_space_fixed_channels proc~prepare_pes_matrix_elements prepare_pes_matrix_elements program~scattering->proc~prepare_pes_matrix_elements proc~calculate_s_matrix calculate_s_matrix program~scattering->proc~calculate_s_matrix proc~etotal ETOTAL program~scattering->proc~etotal proc~calculate_state_to_state_cross_section calculate_state_to_state_cross_section program~scattering->proc~calculate_state_to_state_cross_section proc~read_radial_coupling_terms read_radial_coupling_terms program~scattering->proc~read_radial_coupling_terms proc~reduce_radial_coupling_terms reduce_radial_coupling_terms program~scattering->proc~reduce_radial_coupling_terms proc~interpolate_radial_coupling_terms interpolate_radial_coupling_terms program~scattering->proc~interpolate_radial_coupling_terms proc~write_message write_message program~scattering->proc~write_message proc~calculate_sf_matrix_from_bf_matrix calculate_sf_matrix_from_bf_matrix program~scattering->proc~calculate_sf_matrix_from_bf_matrix proc~unitarity_check unitarity_check program~scattering->proc~unitarity_check proc~check_cross_section_thresholds check_cross_section_thresholds program~scattering->proc~check_cross_section_thresholds proc~write_header write_header program~scattering->proc~write_header proc~time_count_summary time_count_summary program~scattering->proc~time_count_summary proc~numerov numerov program~scattering->proc~numerov fwig_table_free fwig_table_free program~scattering->fwig_table_free proc~riccati_bessel_j riccati_bessel_j proc~calculate_k_matrix->proc~riccati_bessel_j proc~modified_bessel_k_ratio modified_bessel_k_ratio proc~calculate_k_matrix->proc~modified_bessel_k_ratio proc~riccati_bessel_y riccati_bessel_y proc~calculate_k_matrix->proc~riccati_bessel_y proc~is_open is_open proc~calculate_k_matrix->proc~is_open dgemm dgemm proc~calculate_k_matrix->dgemm proc~wavenumber_squared_from_energy wavenumber_squared_from_energy proc~calculate_k_matrix->proc~wavenumber_squared_from_energy dgesv dgesv proc~calculate_k_matrix->dgesv proc~print_largest_partial_cross_sections->proc~write_message proc~file_io_status file_io_status proc~save_s_matrix_file_header->proc~file_io_status proc~count_open_channels_in_block->proc~is_open proc~read_input_file->interface~allocate_1d proc~input_summary input_summary proc~read_input_file->proc~input_summary proc~read_input_file->proc~file_io_status proc~check_namelist_basis check_namelist_basis proc~read_input_file->proc~check_namelist_basis interface~allocate_3d allocate_3d proc~read_input_file->interface~allocate_3d proc~check_namelist_potential check_namelist_potential proc~read_input_file->proc~check_namelist_potential proc~check_namelist_input check_namelist_input proc~read_input_file->proc~check_namelist_input proc~save_open_basis_levels->interface~allocate_1d proc~save_open_basis_levels->proc~is_open proc~save_open_basis_levels->proc~wavenumber_squared_from_energy proc~print_channels->proc~write_message proc~print_channels->proc~is_open proc~print_channels->proc~wavenumber_squared_from_energy proc~calculate_largest_wavenumber->proc~is_open proc~calculate_largest_wavenumber->proc~wavenumber_squared_from_energy proc~save_partial_xs_single_block->proc~etotal proc~save_partial_xs_single_block->proc~write_message proc~count_open_basis_levels->proc~is_open proc~print_pes_matrix_elements_summary->proc~integer_to_character proc~print_pes_matrix_elements_summary->proc~write_message proc~zero_projections_3j_condition zero_projections_3j_condition proc~check_nonzero_pes_matrix_elements->proc~zero_projections_3j_condition proc~save_partial_xs_file_header->proc~write_message proc~save_partial_xs_file_header->proc~file_io_status proc~write_error write_error proc~set_space_fixed_channels->proc~write_error interface~invert_symmetric_matrix invert_symmetric_matrix proc~calculate_s_matrix->interface~invert_symmetric_matrix proc~calculate_s_matrix->dgemm interface~fill_symmetric_matrix fill_symmetric_matrix proc~calculate_s_matrix->interface~fill_symmetric_matrix proc~calculate_state_to_state_cross_section->proc~time_count_summary proc~read_radial_coupling_terms->proc~file_io_status proc~reduce_radial_coupling_terms->proc~integer_to_character proc~reduce_radial_coupling_terms->proc~write_message proc~spline spline proc~interpolate_radial_coupling_terms->proc~spline proc~unitarity_check->proc~write_header proc~handle_unitarity_output_message handle_unitarity_output_message proc~unitarity_check->proc~handle_unitarity_output_message proc~calculate_sum_of_squares_for_each_channel calculate_sum_of_squares_for_each_channel proc~unitarity_check->proc~calculate_sum_of_squares_for_each_channel proc~check_unitarity_for_each_channel check_unitarity_for_each_channel proc~unitarity_check->proc~check_unitarity_for_each_channel proc~write_header->proc~write_message proc~write_header->proc~write_error interface~incorrect_value incorrect_value proc~write_header->interface~incorrect_value proc~time_count_summary->proc~write_message proc~numerov->proc~time_count_summary proc~riccati_bessel_j->proc~integer_to_character proc~rctj rctj proc~riccati_bessel_j->proc~rctj proc~write_warning write_warning proc~riccati_bessel_j->proc~write_warning proc~modified_bessel_temme_algorithm modified_bessel_temme_algorithm proc~modified_bessel_k_ratio->proc~modified_bessel_temme_algorithm proc~input_summary->proc~float_to_character proc~input_summary->proc~integer_to_character proc~input_summary->proc~etotal proc~input_summary->proc~write_message proc~write_error->proc~write_message proc~riccati_bessel_y->proc~integer_to_character proc~riccati_bessel_y->proc~write_warning proc~rcty rcty proc~riccati_bessel_y->proc~rcty proc~file_io_status->proc~integer_to_character proc~file_io_status->proc~write_error proc~is_open->proc~etotal proc~triangle_inequality_holds triangle_inequality_holds proc~zero_projections_3j_condition->proc~triangle_inequality_holds proc~is_sum_even is_sum_even proc~zero_projections_3j_condition->proc~is_sum_even proc~handle_unitarity_output_message->proc~write_message proc~handle_unitarity_output_message->proc~write_warning proc~check_namelist_basis->proc~integer_to_character proc~check_namelist_basis->interface~incorrect_value proc~spline->proc~integer_to_character proc~spline->proc~write_error proc~wavenumber_squared_from_energy->proc~etotal proc~wavenumber_squared_from_energy->proc~write_error proc~check_namelist_potential->proc~integer_to_character proc~check_namelist_potential->interface~incorrect_value proc~check_namelist_input->proc~integer_to_character proc~check_namelist_input->proc~write_message proc~check_namelist_input->proc~write_error proc~check_namelist_input->interface~incorrect_value proc~msta1 msta1 proc~rctj->proc~msta1 proc~msta2 msta2 proc~rctj->proc~msta2 proc~modified_bessel_temme_algorithm->proc~write_error proc~rgamma rgamma proc~modified_bessel_temme_algorithm->proc~rgamma proc~write_warning->proc~write_message proc~envj envj proc~msta1->proc~envj proc~msta2->proc~envj Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables BF_log_der_matrix SF_log_der_matrix channel_indices channel_l_values channels_omega_values consecutive_blocks_thresholddiag consecutive_blocks_thresholdoff err_message iblock icheck icount icount2 ij ilevel io_status iomega iopen iopen2 isize_ isize_2 jinddiag jindoff1 jindoff2 jtot_ k_matrix largest_wavevector len_even len_odd lmat_len lmax lmin ltmp maxXSdiag maxXSoff nonzero_algebraic_coefficients nonzero_legendre_indices nonzero_terms_per_element nsteps number_of_channels number_of_nonzero_algebraic_coefficients number_of_nonzero_pes_matrix_elements number_of_open_basis_levels number_of_open_channels omegamax open_basis_levels open_basis_wavevectors parity_exponent parity_exponenttmp partial_line s_matrix_imag s_matrix_real size_even size_odd smatcheckarr terminate time_coupling time_coupling_start time_coupling_stop time_init time_init_stop time_jtot time_jtot_start time_jtot_stop time_parity time_parity_start time_parity_stop time_total time_total_start time_total_stop unitarity_block_check wavvdepth wv xs_block xs_jtot xs_line xs_total Source Code SCATTERING Variables Type Attributes Name Initial real(kind=dp), allocatable :: BF_log_der_matrix (:,:) real(kind=dp), allocatable :: SF_log_der_matrix (:,:) integer, allocatable :: channel_indices (:) integer, allocatable :: channel_l_values (:) integer, allocatable :: channels_omega_values (:) integer(kind=int32) :: consecutive_blocks_thresholddiag integer(kind=int32) :: consecutive_blocks_thresholdoff character(len=200) :: err_message integer(kind=int32) :: iblock integer(kind=int32) :: icheck integer(kind=int32) :: icount integer(kind=int32) :: icount2 integer(kind=int32) :: ij integer(kind=int32) :: ilevel integer(kind=int32) :: io_status integer(kind=int32) :: iomega integer(kind=int32) :: iopen integer(kind=int32) :: iopen2 integer(kind=int32) :: isize_ integer(kind=int32) :: isize_2 integer(kind=int32) :: jinddiag integer(kind=int32) :: jindoff1 integer(kind=int32) :: jindoff2 integer(kind=int32) :: jtot_ real(kind=dp), allocatable :: k_matrix (:,:) real(kind=dp) :: largest_wavevector integer(kind=int32) :: len_even integer(kind=int32) :: len_odd integer(kind=int32) :: lmat_len integer(kind=int32) :: lmax integer(kind=int32) :: lmin integer(kind=int32) :: ltmp real(kind=dp) :: maxXSdiag real(kind=dp) :: maxXSoff real(kind=dp), allocatable :: nonzero_algebraic_coefficients (:) integer, allocatable :: nonzero_legendre_indices (:) integer, allocatable :: nonzero_terms_per_element (:) integer(kind=int32) :: nsteps integer(kind=int32) :: number_of_channels integer(kind=int32) :: number_of_nonzero_algebraic_coefficients integer(kind=int32) :: number_of_nonzero_pes_matrix_elements integer(kind=int32) :: number_of_open_basis_levels integer(kind=int32) :: number_of_open_channels integer(kind=int32) :: omegamax integer, allocatable :: open_basis_levels (:) real(kind=dp), allocatable :: open_basis_wavevectors (:) integer(kind=int32) :: parity_exponent integer(kind=int32) :: parity_exponenttmp character(len=200) :: partial_line real(kind=dp), allocatable :: s_matrix_imag (:,:) real(kind=dp), allocatable :: s_matrix_real (:,:) integer(kind=int32) :: size_even integer(kind=int32) :: size_odd integer, allocatable :: smatcheckarr (:) logical :: terminate real(kind=dp) :: time_coupling real(kind=dp) :: time_coupling_start real(kind=dp) :: time_coupling_stop real(kind=dp) :: time_init real(kind=dp) :: time_init_stop real(kind=dp) :: time_jtot real(kind=dp) :: time_jtot_start real(kind=dp) :: time_jtot_stop real(kind=dp) :: time_parity real(kind=dp) :: time_parity_start real(kind=dp) :: time_parity_stop real(kind=dp) :: time_total real(kind=dp) :: time_total_start real(kind=dp) :: time_total_stop logical :: unitarity_block_check real(kind=dp) :: wavvdepth real(kind=dp), allocatable :: wv (:) real(kind=dp), allocatable :: xs_block (:) real(kind=dp), allocatable :: xs_jtot (:) character(len=200) :: xs_line real(kind=dp), allocatable :: xs_total (:) Source Code program SCATTERING !---------------------------------------------------------------------------! use , intrinsic :: iso_fortran_env , only : int32 , sp => real32 , dp => real64 use data_mod use io_mod use radial_coupling_terms_mod , only : read_radial_coupling_terms , & reduce_radial_coupling_terms , interpolate_radial_coupling_terms use channels_mod , only : set_number_of_channels , set_body_fixed_channels , & set_space_fixed_channels , count_open_channels_in_block , & calculate_largest_wavenumber , print_channels use pes_matrix_mod , only : check_nonzero_pes_matrix_elements , & prepare_pes_matrix_elements , print_pes_matrix_elements_summary use propagator_mod , only : numerov use boundary_conditions_mod , only : calculate_sf_matrix_from_bf_matrix , & calculate_k_matrix , calculate_s_matrix use unitarity_check_mod , only : unitarity_check use save_s_matrix_mod , only : save_s_matrix_file_header , save_s_matrix_block_info use state_to_state_cross_sections_mod , only : & calculate_state_to_state_cross_section , & print_largest_partial_cross_sections , check_cross_section_thresholds , & save_partial_xs_file_header , save_partial_xs_single_block use utility_functions_mod , only : write_header , file_io_status , & write_message , float_to_character , integer_to_character , time_count_summary use array_operations_mod , only : append !---------------------------------------------------------------------------! implicit none !---------------------------------------------------------------------------! character ( len = 200 ) :: err_message , partial_line , xs_line integer ( int32 ) :: number_of_nonzero_pes_matrix_elements , & number_of_nonzero_algebraic_coefficients , number_of_channels , size_even , & size_odd , number_of_open_basis_levels , iblock , jtot_ , parity_exponent , & parity_exponenttmp , nsteps , number_of_open_channels , consecutive_blocks_thresholddiag , consecutive_blocks_thresholdoff , & omegamax , lmin , lmax , ltmp , lmat_len , len_even , len_odd , jinddiag , & jindoff1 , jindoff2 , ij , ilevel , iomega , iopen , iopen2 , isize_ , isize_2 , & icheck , icount , icount2 , io_status real ( dp ) :: largest_wavevector , wavvdepth , maxXSdiag , maxXSoff , time_total_start , & time_total_stop , time_total , time_init_stop , time_init , time_jtot_start , & time_jtot_stop , time_jtot , time_parity_start , time_parity_stop , & time_parity , time_coupling_start , time_coupling_stop , time_coupling logical :: unitarity_block_check , terminate integer , allocatable :: channel_indices (:), channels_omega_values (:),& channel_l_values (:), open_basis_levels (:), nonzero_terms_per_element (:),& nonzero_legendre_indices (:), smatcheckarr (:) real ( dp ), allocatable :: wv (:), open_basis_wavevectors (:), & nonzero_algebraic_coefficients (:), xs_total (:), xs_block (:), xs_jtot (:) real ( dp ), allocatable :: BF_log_der_matrix (:,:), SF_log_der_matrix (:,:), & k_matrix (:,:), s_matrix_real (:,:), s_matrix_imag (:,:) !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! ! Initizalization: start the time count !---------------------------------------------------------------------------! call cpu_time ( time_total_start ) !---------------------------------------------------------------------------! ! Initialize fwigxjpf library !---------------------------------------------------------------------------! call fwig_table_init ( 2 * 100 , 9 ) call fwig_temp_init ( 2 * 100 ) !---------------------------------------------------------------------------! ! Print the header !---------------------------------------------------------------------------! call write_header ( \"main\" ) !---------------------------------------------------------------------------! ! Read the input file !---------------------------------------------------------------------------! call read_input_file !---------------------------------------------------------------------------! ! S-matrix file: write input parameters and basis levels !---------------------------------------------------------------------------! call save_s_matrix_file_header !---------------------------------------------------------------------------! ! Prepare the file with the partial XS !---------------------------------------------------------------------------! if ( print_partial_cross_sections ) then call save_partial_xs_file_header endif !---------------------------------------------------------------------------! ! Convert units: starting now, everything is in atomic units !---------------------------------------------------------------------------! call units_conversion !---------------------------------------------------------------------------! ! Read the radial terms of the potential from external file !---------------------------------------------------------------------------! call read_radial_coupling_terms !---------------------------------------------------------------------------! ! Reduce matrix elements that are not needed !---------------------------------------------------------------------------! call reduce_radial_coupling_terms !---------------------------------------------------------------------------! ! Interpolate radial terms !---------------------------------------------------------------------------! call interpolate_radial_coupling_terms !---------------------------------------------------------------------------! ! Search for energetically accessible levels and prepare the arrays that are ! needed in the calculations of the state-to-state XS !---------------------------------------------------------------------------! number_of_open_basis_levels = count_open_basis_levels () call save_open_basis_levels ( number_of_open_basis_levels , open_basis_levels , & open_basis_wavevectors ) !---------------------------------------------------------------------------! ! xs array summed over all blocks !---------------------------------------------------------------------------! call allocate_1d ( xs_total , & number_of_open_basis_levels * number_of_open_basis_levels ) !---------------------------------------------------------------------------! ! xs array a single JTOT value !---------------------------------------------------------------------------! call allocate_1d ( xs_jtot , & number_of_open_basis_levels * number_of_open_basis_levels ) !---------------------------------------------------------------------------! ! xs array a single parity block !---------------------------------------------------------------------------! call allocate_1d ( xs_block , & number_of_open_basis_levels * number_of_open_basis_levels ) !---------------------------------------------------------------------------! ! Initialization is finished !---------------------------------------------------------------------------! call cpu_time ( time_init_stop ) if ( prntlvl . ge . 2 ) call time_count_summary ( time_total_start , time_init_stop , & time_init , \"Initialization completed in \" ) !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! ! Prepare J-blocks !---------------------------------------------------------------------------! ! If JTOTMAX=-1 is called, iterate until convergence is achieved: ! this is managed by consecutive_blocks_thresholddiag and consecutive_blocks_thresholdoff !---------------------------------------------------------------------------! consecutive_blocks_thresholddiag = 0 consecutive_blocks_thresholdoff = 0 iblock = 0 terminate = . false . !---------------------------------------------------------------------------! ! Loop over total angular momentum !---------------------------------------------------------------------------! call write_message ( repeat ( \"*\" , 90 )) call write_message ( repeat ( \" \" , 28 ) // \"*** Loop over JTOT: ***\" ) !---------------------------------------------------------------------------! do jtot_ = jtotmin , jtotmax , jtotstep !------------------------------------------------------------------------! call write_header ( \"block\" , opt_integer_ = jtot_ ) !------------------------------------------------------------------------! call cpu_time ( time_jtot_start ) !------------------------------------------------------------------------! xs_jtot = 0 call set_number_of_channels ( jtot_ , size_even , size_odd ) !------------------------------------------------------------------------! do parity_exponent = 0 , 1 !---------------------------------------------------------------------! call cpu_time ( time_parity_start ) !---------------------------------------------------------------------! select case ( parity_exponent ) case ( 0 ) number_of_channels = size_even case ( 1 ) number_of_channels = size_odd end select !---------------------------------------------------------------------! if ( number_of_channels == 0 ) cycle !---------------------------------------------------------------------! ! Summary of the current block !---------------------------------------------------------------------! iblock = iblock + 1 if ( prntlvl . ge . 1 ) then call write_message ( \"Block number: \" // integer_to_character ( iblock )) call write_message ( \"jtot: \" // & trim ( adjustl ( integer_to_character ( jtot_ ))) // \" parity: \" // & trim ( adjustl ( integer_to_character (( - 1 ) ** parity_exponent ) ))) call write_message ( \"Number of scattering channels: \" // & integer_to_character ( number_of_channels )) endif !---------------------------------------------------------------------! ! Prepare of the basis for each J/p block: ! channels_omega_values holds all values of omega (BF_) ! channel_l_values holds all values of l (SF_) ! channel_indices holds the indices which refer to the basis arrays: !   --   v1level/j1level/elevel !---------------------------------------------------------------------! call allocate_1d ( channels_omega_values , number_of_channels ) call allocate_1d ( channel_l_values , number_of_channels ) call allocate_1d ( channel_indices , number_of_channels ) !---------------------------------------------------------------------! ! Prepare channels_omega_values, channel_indices and channel_l_values !---------------------------------------------------------------------! call set_body_fixed_channels ( jtot_ , parity_exponent , channel_indices , & channels_omega_values ) call set_space_fixed_channels ( jtot_ , parity_exponent , channel_l_values ) !---------------------------------------------------------------------! ! Print the BF quantum numbers on screen !---------------------------------------------------------------------! if ( prntlvl . ge . 1 ) call print_channels ( parity_exponent , & channel_indices , channels_omega_values ) !---------------------------------------------------------------------! ! Determine the number of open (energetically accessible) channels !---------------------------------------------------------------------! number_of_open_channels = count_open_channels_in_block ( channel_indices ) !---------------------------------------------------------------------! ! If there are no open channels, skip this block !---------------------------------------------------------------------! if ( number_of_open_channels == 0 ) then call write_message ( repeat ( '-' , 90 )) call write_message ( \"No open channels for block no.\" // & integer_to_character ( iblock ) ) call write_message ( repeat ( '-' , 90 )) cycle endif !---------------------------------------------------------------------! ! Determine the largest wavevector in the block !---------------------------------------------------------------------! largest_wavevector = calculate_largest_wavenumber ( channel_indices ) !---------------------------------------------------------------------! ! Determine the number of steps on the intermolecular (R) grid ! This is done either directly (if dr > 0) ! or through the number of steps per half de Broglie wavelength !---------------------------------------------------------------------! wavvdepth = dsqrt ( 2 * reduced_mass * vdepth ) if ( dr <= 0 ) then nsteps = nint (( Rmax - Rmin ) / PI * (( largest_wavevector + wavvdepth ) * steps )) else nsteps = nint (( Rmax - Rmin ) / dr ) + 1 endif !---------------------------------------------------------------------! ! Prepare the PES matrix !---------------------------------------------------------------------! call cpu_time ( time_coupling_start ) call check_nonzero_pes_matrix_elements ( channel_indices , & channels_omega_values , number_of_nonzero_pes_matrix_elements , & number_of_nonzero_algebraic_coefficients ) call allocate_1d ( nonzero_terms_per_element , number_of_nonzero_pes_matrix_elements ) call allocate_1d ( nonzero_algebraic_coefficients , number_of_nonzero_algebraic_coefficients ) call allocate_1d ( nonzero_legendre_indices , number_of_nonzero_algebraic_coefficients ) call prepare_pes_matrix_elements ( channel_indices , & channels_omega_values , nonzero_terms_per_element , & nonzero_legendre_indices , nonzero_algebraic_coefficients ) if ( prntlvl . ge . 2 ) call print_pes_matrix_elements_summary ( & number_of_channels , number_of_nonzero_pes_matrix_elements , & number_of_nonzero_algebraic_coefficients ) call cpu_time ( time_coupling_stop ) if ( prntlvl . ge . 2 ) call write_message ( \"Calculations of the coupling \" // & \"matrix took \" // trim ( adjustl ( float_to_character ( & time_coupling_stop - time_coupling_start , \"(E14.8)\" ))) // \" seconds\" ) !---------------------------------------------------------------------! ! Prepare the log-derivative matrix (Eqs. 6.29 and 6.43) ! and the K-matrix (Eq. 6.53) !---------------------------------------------------------------------! call allocate_2d ( BF_log_der_matrix , number_of_channels , number_of_channels ) call allocate_2d ( SF_log_der_matrix , number_of_channels , number_of_channels ) call allocate_2d ( k_matrix , number_of_open_channels , number_of_open_channels ) !---------------------------------------------------------------------! ! Call the propagator: !---------------------------------------------------------------------! call numerov ( number_of_channels , channel_indices , channels_omega_values , & nonzero_terms_per_element ,& nonzero_legendre_indices , nonzero_algebraic_coefficients , nsteps , & jtot_ , BF_log_der_matrix ) call write_message ( \"Coupled equations were solved from \" // & trim ( adjustl ( float_to_character ( Rmin , \"(F10.4)\" ))) // \" a.u. to \" // & trim ( adjustl ( float_to_character ( Rmax , \"(F10.4)\" ))) // \" a.u. in \" // & trim ( adjustl ( integer_to_character ( nsteps ))) // \" steps (dr = \" // & trim ( adjustl ( float_to_character (( rmax - rmin ) / dble ( nsteps - 1 ), & \"(E14.8)\" ))) // \" a.u.)\" ) !---------------------------------------------------------------------! ! Transform the log-derivative matrix to the SF frame !---------------------------------------------------------------------! call calculate_sf_matrix_from_bf_matrix ( number_of_channels , jtot_ , & channel_indices , channels_omega_values , channel_l_values , & BF_log_der_matrix , SF_log_der_matrix ) !---------------------------------------------------------------------! ! Get the K-matrix from log-derivative matrix (Eq. 6.53) !---------------------------------------------------------------------! call calculate_k_matrix ( number_of_channels , SF_log_der_matrix , & number_of_open_channels , channel_indices , channel_l_values ,& rmax , k_matrix ) !---------------------------------------------------------------------! ! Get the S-matrix from the K-matrix (Eq. 6.57) !---------------------------------------------------------------------! call allocate_2d ( s_matrix_real , number_of_open_channels , number_of_open_channels ) call allocate_2d ( s_matrix_imag , number_of_open_channels , number_of_open_channels ) call calculate_s_matrix ( number_of_open_channels , k_matrix , s_matrix_real , s_matrix_imag ) !---------------------------------------------------------------------! ! Array of wavevectors (necessary for the XS calculations) !---------------------------------------------------------------------! call allocate_1d ( wv , number_of_open_channels ) do iopen = 1 , number_of_open_channels wv ( iopen ) = dsqrt (( 2 * reduced_mass * & ( ETOTAL () - elevel ( channel_indices ( iopen ))))) / bohrtoangstrom enddo !---------------------------------------------------------------------! ! S-matrix is written to the binary S-matrix file !---------------------------------------------------------------------! call save_s_matrix_block_info ( jtot_ , parity_exponent , & number_of_open_channels , channel_indices , channel_l_values , wv , & s_matrix_real , s_matrix_imag ) !---------------------------------------------------------------------! ! Check if the S-matrices are unitary !---------------------------------------------------------------------! call unitarity_check ( number_of_open_channels , s_matrix_real , s_matrix_imag , unitarity_block_check ) !---------------------------------------------------------------------! ! If the unitary is not fulfilled, keep the information about this block !---------------------------------------------------------------------! if (. not .( unitarity_block_check )) then call append ( smatcheckarr , jtot_ ) endif !---------------------------------------------------------------------! ! Calculate all available cross-sections !---------------------------------------------------------------------! call calculate_state_to_state_cross_section ( jtot_ , open_basis_levels , & open_basis_wavevectors , s_matrix_real , s_matrix_imag , channel_indices ,& channel_l_values , xs_block ) !---------------------------------------------------------------------! ! Print the results from this parity block to the partial XS file ! and add the calculated partial XS to the xs_jtot array !---------------------------------------------------------------------! if ( print_partial_cross_sections ) then call save_partial_xs_single_block ( jtot_ , iblock , & number_of_open_basis_levels , open_basis_levels , xs_block ) endif do icount = 1 , number_of_open_basis_levels do icount2 = 1 , number_of_open_basis_levels xs_jtot (( icount - 1 ) * number_of_open_basis_levels + icount2 ) = & xs_jtot (( icount - 1 ) * number_of_open_basis_levels + icount2 ) & + xs_block (( icount - 1 ) * number_of_open_basis_levels + icount2 ) enddo enddo !---------------------------------------------------------------------! ! Check the time after each parity block: !---------------------------------------------------------------------! call cpu_time ( time_parity_stop ) if ( prntlvl . ge . 2 ) call time_count_summary ( time_parity_start , & time_parity_stop , time_parity , \"Parity block completed in \" ) !---------------------------------------------------------------------! ! ... end of the loop over parity !---------------------------------------------------------------------! call write_message ( repeat ( \" \" , 43 ) // \"***\" ) enddo !------------------------------------------------------------------------! ! Add the cross-sections from this Jtot block: !------------------------------------------------------------------------! do icount = 1 , number_of_open_basis_levels do icount2 = 1 , number_of_open_basis_levels xs_total (( icount - 1 ) * number_of_open_basis_levels + icount2 ) = & xs_total (( icount - 1 ) * number_of_open_basis_levels + icount2 ) & + xs_jtot (( icount - 1 ) * number_of_open_basis_levels + icount2 ) enddo enddo !------------------------------------------------------------------------! ! Determine the largest partial elastic/inelastic XS in this Jtot block: !------------------------------------------------------------------------! jinddiag = 0 jindoff1 = 0 jindoff2 = 0 maxXSdiag = 0.0_dp maxXSoff = 0.0_dp do icount = 1 , number_of_open_basis_levels do icount2 = 1 , number_of_open_basis_levels if ( open_basis_levels ( icount2 ) == open_basis_levels ( icount )) then if (( xs_jtot (( icount - 1 ) * number_of_open_basis_levels + icount2 )). gt . maxXSdiag ) then maxXSdiag = xs_jtot (( icount - 1 ) * number_of_open_basis_levels + icount2 ) jinddiag = icount endif else if (( xs_jtot (( icount - 1 ) * number_of_open_basis_levels + icount2 )). gt . maxXSoff ) then maxXSoff = xs_jtot (( icount - 1 ) * number_of_open_basis_levels + icount2 ) jindoff1 = icount jindoff2 = icount2 endif endif enddo enddo !-----------------------------------------------------------------------! call print_largest_partial_cross_sections ( jtot_ , maxXSdiag , maxXSoff , jinddiag , & jindoff1 , jindoff2 , open_basis_levels ) !-----------------------------------------------------------------------! if ( jtotmax == 999999 ) then call check_cross_section_thresholds ( maxXSdiag , maxXSoff , & consecutive_blocks_thresholddiag , consecutive_blocks_thresholdoff , terminate ) endif !------------------------------------------------------------------------! ! Check the time after each JTOT block: !------------------------------------------------------------------------! call cpu_time ( time_jtot_stop ) !------------------------------------------------------------------------! ! Print all the XS after current JTOT block !------------------------------------------------------------------------! if ( prntlvl . ge . 3 ) then call write_message ( \"Cross sections for J: \" // & trim ( adjustl ( integer_to_character ( jtot_ ))) // \" and energy: \" // & trim ( adjustl ( float_to_character ( ETOTAL () * hartreetocm , \"(F10.4)\" ))) & // \" cm-1\" ) call write_message ( \"  v1_f  j1_f  <-  v1_i  j1_i\" // repeat ( \" \" , 14 ) & // \"K.E.\" // repeat ( \" \" , 16 ) // \"XS\" ) do icount = 1 , number_of_open_basis_levels do icount2 = 1 , number_of_open_basis_levels write ( xs_line , \"(2X,I4,2X,I4,6X,I4,2X,I4,2X,E16.8,2X,E16.8)\" ) & v1array ( open_basis_levels ( icount2 )), & j1array ( open_basis_levels ( icount2 )), & v1array ( open_basis_levels ( icount )), & j1array ( open_basis_levels ( icount )), & ( etotal () - elevel ( open_basis_levels ( icount ))) * hartreetocm , & xs_total (( icount - 1 ) * number_of_open_basis_levels + icount2 ) call write_message ( xs_line ) enddo enddo endif !------------------------------------------------------------------------! if ( prntlvl . ge . 2 ) call time_count_summary ( time_jtot_start , & time_jtot_stop , time_jtot , \"JTOT block completed in \" ) !------------------------------------------------------------------------! ! terminate the loop if elastic_xs_threshold/inelastic_xs_threshold condition is satisfied !------------------------------------------------------------------------! if ( terminate ) exit enddo call write_message ( repeat ( '*' , 90 )) call write_message ( repeat ( \" \" , 31 ) // \"Loop over JTOT finished\" ) call write_message ( repeat ( '*' , 90 )) call write_message ( \"*\" // repeat ( \" \" , 40 ) // \"SUMMARY\" // repeat ( \" \" , 41 ) & // \"*\" ) call write_message ( repeat ( '*' , 90 )) !---------------------------------------------------------------------------! ! if for some JTOTs the S-matrix did not fulfill the unitary check, ! these are listed here !---------------------------------------------------------------------------! if ( allocated ( smatcheckarr )) then print * call write_message ( repeat ( \"-\" , 90 )) call write_message ( repeat ( \" \" , 37 ) // \"*** WARNING ***\" ) call write_message ( repeat ( \"-\" , 90 )) call write_message ( \"Check unitarity of the S-matrix in the following \" // & \"JTOT blocks:\" ) do icheck = 1 , size ( smatcheckarr ) call write_message ( \"JTOT:\" // repeat ( \" \" , 8 ) // integer_to_character ( & smatcheckarr ( icheck ))) enddo call write_message ( repeat ( \"-\" , 90 )) print * endif !---------------------------------------------------------------------------! ! Print all the calculated XS !---------------------------------------------------------------------------! call write_message ( \"Final state-to-state XS\" ) call write_message ( \"  v1_f  j1_f  <-  v1_i  j1_i\" // repeat ( \" \" , 14 ) // & \"K.E.\" // repeat ( \" \" , 16 ) // \"XS\" ) do icount = 1 , number_of_open_basis_levels do icount2 = 1 , number_of_open_basis_levels write ( xs_line , \"(2X,I4,2X,I4,6X,I4,2X,I4,2X,E16.8,2X,E16.8)\" ) & v1array ( open_basis_levels ( icount2 )), & j1array ( open_basis_levels ( icount2 )), & v1array ( open_basis_levels ( icount )), & j1array ( open_basis_levels ( icount )), & ( etotal () - elevel ( open_basis_levels ( icount ))) * hartreetocm , & xs_total (( icount - 1 ) * number_of_open_basis_levels + icount2 ) call write_message ( xs_line ) enddo enddo !---------------------------------------------------------------------------! call fwig_temp_free (); call fwig_table_free (); !---------------------------------------------------------------------------! ! Stop the time count !---------------------------------------------------------------------------! call cpu_time ( time_total_stop ) call time_count_summary ( time_total_start , time_total_stop , time_total , & \"Total CPU time: \" ) close ( 11 ) close ( 12 ) !---------------------------------------------------------------------------! end program SCATTERING","tags":"","loc":"program/scattering.html"},{"title":"radial_coupling_terms_mod.f90 – the SCATTERING code","text":"This file depends on sourcefile~~radial_coupling_terms_mod.f90~~EfferentGraph sourcefile~radial_coupling_terms_mod.f90 radial_coupling_terms_mod.f90 sourcefile~data_mod.f90 data_mod.f90 sourcefile~radial_coupling_terms_mod.f90->sourcefile~data_mod.f90 sourcefile~utility_functions_mod.f90 utility_functions_mod.f90 sourcefile~radial_coupling_terms_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~input_reader_mod.f90 input_reader_mod.f90 sourcefile~radial_coupling_terms_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~math_functions_mod.f90 math_functions_mod.f90 sourcefile~radial_coupling_terms_mod.f90->sourcefile~math_functions_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~data_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~array_operations_mod.f90 array_operations_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~array_operations_mod.f90 sourcefile~input_validation_mod.f90 input_validation_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~input_validation_mod.f90 sourcefile~math_functions_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~special_functions_mod.f90 special_functions_mod.f90 sourcefile~math_functions_mod.f90->sourcefile~special_functions_mod.f90 sourcefile~input_validation_mod.f90->sourcefile~data_mod.f90 sourcefile~input_validation_mod.f90->sourcefile~utility_functions_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~radial_coupling_terms_mod.f90~~AfferentGraph sourcefile~radial_coupling_terms_mod.f90 radial_coupling_terms_mod.f90 sourcefile~pes_matrix_mod.f90 pes_matrix_mod.f90 sourcefile~pes_matrix_mod.f90->sourcefile~radial_coupling_terms_mod.f90 sourcefile~scattering.f90 scattering.f90 sourcefile~scattering.f90->sourcefile~radial_coupling_terms_mod.f90 sourcefile~scattering.f90->sourcefile~pes_matrix_mod.f90 sourcefile~propagator_mod.f90 propagator_mod.f90 sourcefile~scattering.f90->sourcefile~propagator_mod.f90 sourcefile~propagator_mod.f90->sourcefile~pes_matrix_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules radial_coupling_terms_mod Source Code radial_coupling_terms_mod.f90 Source Code module radial_coupling_terms_mod !! This module provides all functions that handle radial coupling terms !! of the PES. It covers: !! 1. reading radial coupling terms from external file (\"read_radial_coupling_terms\", !!    \"skip_header_lines\", \"read_and_validate_lambda\", \"read_potential_data\", !!    \"validate_r_range\") !! 2. reducing the number of read coupling terms to retain only necessary !!    couplings (\"reduce_radial_coupling_terms\", \"print_pes_quantum_numbers\", !!    \"reduce_coupling_terms\", \"find_reduced_term\") !! 3. interpolation of radial coupling terms (\"interpolate_radial_coupling_terms\") !! 4. providing value of the interpolated radial coupling term (\"get_radial_coupling_term_value\") !!--------------------------------------------------------------------------! use , intrinsic :: iso_fortran_env , only : int32 , sp => real32 , dp => real64 use data_mod use io_mod use utility_functions_mod , only : file_io_status , write_error , write_message use math_functions_mod , only : spline , ispline !---------------------------------------------------------------------------! implicit none !---------------------------------------------------------------------------! private public :: read_radial_coupling_terms , reduce_radial_coupling_terms , & interpolate_radial_coupling_terms , get_radial_coupling_term_value !---------------------------------------------------------------------------! contains !---------------------------------------------------------------------------! !                            Reading procedures !---------------------------------------------------------------------------! subroutine read_radial_coupling_terms !! Reads the radial coupling terms from the external file. !! The file is assumed to be formatted as described in !! \"Supplying radial terms\" section. !! The read radial coupling terms are kept in vmat/read_vmat3D !---------------------------------------------------------------------! character ( len = 200 ) :: err_message integer ( int32 ) :: nrtmp , l1 , iskip_ , lambda_index_ , ir , icol , io_status !---------------------------------------------------------------------! open ( pes_file_unit , file = trim ( potentialfile ), form = 'formatted' , & status = 'old' , iostat = io_status , iomsg = err_message ) call file_io_status ( io_status , err_message , pes_file_unit , 'o' ) !---------------------------------------------------------------------! ! Skip the informative lines at the beginning !---------------------------------------------------------------------! call skip_header_lines !---------------------------------------------------------------------! do lambda_index_ = 1 , nterms call read_and_validate_lambda ( lambda_index_ ) call read_potential_data ( lambda_index_ ) enddo !---------------------------------------------------------------------! close ( pes_file_unit , iostat = io_status , iomsg = err_message ) call file_io_status ( io_status , err_message , pes_file_unit , 'c' ) !---------------------------------------------------------------------! ! Check if supplied radial terms cover a sufficient range of R !---------------------------------------------------------------------! call validate_r_range !---------------------------------------------------------------------! end subroutine read_radial_coupling_terms !---------------------------------------------------------------------------! subroutine skip_header_lines !! Skips the first n_skip_lines (read on input) lines in the pes_file !---------------------------------------------------------------------! integer ( int32 ) :: line_index_ !---------------------------------------------------------------------! do line_index_ = 1 , n_skip_lines read ( pes_file_unit , * ) enddo !---------------------------------------------------------------------! end subroutine skip_header_lines !---------------------------------------------------------------------------! subroutine read_and_validate_lambda ( lambda_index_ ) !! Reads the value of lambda and compares with expected value. !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: lambda_index_ !---------------------------------------------------------------------! integer ( int32 ) :: lambda_ !---------------------------------------------------------------------! read ( pes_file_unit , * ) lambda_ if ( lambda_ . ne . l1tab ( lambda_index_ )) then close ( pes_file_unit ) close ( s_matrix_unit ) if ( print_partial_cross_sections ) close ( partial_file_unit ) call write_error ( \"read_radial_coupling_terms: lambda = \" // & trim ( adjustl ( integer_to_character ( lambda_ ))) // & \" differs from expected value in l1tab (\" // & trim ( adjustl ( integer_to_character ( lambda_index_ ))) // \") = \" // & trim ( adjustl ( integer_to_character ( l1tab ( lambda_index_ ))))) endif !---------------------------------------------------------------------! end subroutine read_and_validate_lambda !---------------------------------------------------------------------------! subroutine read_potential_data ( lambda_index_ ) !! Reads the intermolecular distance and radial coupling terms formatted !! in columns by iterating over number of tabulated ]](R\\ points. !! Immediately converts \\R\\ and radial coupling terms to a.u. !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: lambda_index_ !---------------------------------------------------------------------! integer ( int32 ) :: r_index_ , column_index_ real ( dp ) :: read_line ( total_number_of_coupling_terms + 1 ) !---------------------------------------------------------------------! do r_index_ = 1 , nr read ( pes_file_unit , * ) ( read_line ( column_index_ ), & column_index_ = 1 , total_number_of_coupling_terms + 1 ) rmat ( r_index_ ) = read_line ( 1 ) * radial_term_distance_converter do column_index_ = 1 , total_number_of_coupling_terms read_vmat3D ( r_index_ , lambda_index_ , column_index_ ) & = read_line ( column_index_ + 1 ) * radial_term_energy_converter enddo enddo !---------------------------------------------------------------------! end subroutine read_potential_data !---------------------------------------------------------------------------! subroutine validate_r_range !! Checks if read R values are consistent with rmin and rmax. !---------------------------------------------------------------------! if ( rmin < rmat ( 1 )) then close ( s_matrix_unit ) if ( print_partial_cross_sections ) close ( partial_file_unit ) call write_error ( \"rmin value provided by the user (\" // & trim ( adjustl ( float_to_character ( rmin , \"(F10.4)\" ))) // & \") is smaller than rmin supplied in \" // & trim ( adjustl ( potentialfile )) // \" ( \" // & trim ( adjustl ( float_to_character ( rmat ( 1 ), \"(F10.4)\" ))) // \")\" ) endif !---------------------------------------------------------------------! if ( rmax > rmat ( nr )) then close ( s_matrix_unit ) if ( print_partial_cross_sections ) close ( partial_file_unit ) call write_error ( \"rmax value provided by the user (\" // & trim ( adjustl ( float_to_character ( rmax , \"(F10.4)\" ))) // & \") is larger than rmax supplied in \" // & trim ( adjustl ( potentialfile )) // \" ( \" // & trim ( adjustl ( float_to_character ( rmat ( nr ), \"(F10.4)\" ))) // \")\" ) endif !---------------------------------------------------------------------! end subroutine validate_r_range !---------------------------------------------------------------------------! !                            Reducing procedures !---------------------------------------------------------------------------! subroutine reduce_radial_coupling_terms !! Reduces the read_vmat3D matrix to retain only the necessary coupling terms. !---------------------------------------------------------------------! integer ( int32 ) :: lambda_index_ , radial_index_ , coupling_index_ !---------------------------------------------------------------------! if ( total_number_of_coupling_terms /= minimal_number_of_coupling_terms ) then call write_message ( \"Reducing the number of the radial coupling terms...\" ) call print_pes_quantum_numbers ( \"Original\" , total_number_of_coupling_terms ) call reduce_coupling_terms () call print_pes_quantum_numbers ( \"Reduced\" , minimal_number_of_coupling_terms ) call write_message ( \"Reduced \" // & trim ( adjustl ( integer_to_character ( total_number_of_coupling_terms ))) // & \" radial terms to \" // trim ( adjustl ( integer_to_character ( minimal_number_of_coupling_terms )))) else !------------------------------------------------------------------! ! if there is nothing to be reduced, copy read_vmat3d to vmat3d !------------------------------------------------------------------! vmat3D = read_vmat3D endif !---------------------------------------------------------------------! deallocate ( read_vmat3D ) !---------------------------------------------------------------------! end subroutine reduce_radial_coupling_terms !---------------------------------------------------------------------------! subroutine reduce_coupling_terms !! Reduces the coupling terms based on the existence of couplings. !---------------------------------------------------------------------! integer ( int32 ) :: lambda_index_ , r_index_ , coupling_index_ !---------------------------------------------------------------------! do lambda_index_ = 1 , nterms do r_index_ = 1 , nr do coupling_index_ = 1 , minimal_number_of_coupling_terms vmat3D ( r_index_ , lambda_index_ , coupling_index_ ) = & find_reduced_term ( r_index_ , lambda_index_ , coupling_index_ ) enddo enddo enddo !---------------------------------------------------------------------! end subroutine reduce_coupling_terms !---------------------------------------------------------------------------! function find_reduced_term ( r_index_ , lambda_index_ , coupling_index_ ) & result ( reduced_term ) !! Finds and returns the reduced term for the given indices. !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: r_index_ !! index interating over intermolecular grid integer ( int32 ), intent ( in ) :: lambda_index_ !! index interating over Legendre expansion terms integer ( int32 ), intent ( in ) :: coupling_index_ !! index interating over necessary couplings real ( dp ) :: reduced_term !! (output) sought value of the coupling term !---------------------------------------------------------------------! integer ( int32 ) :: column_index_ !---------------------------------------------------------------------! reduced_term = 0.0_dp do column_index_ = 1 , total_number_of_coupling_terms !---------------------------------------------------------------------! ! iterate over quantum numbers describing all couplings ! (v1/j1/v1p/j1ppes) until necessary couplings are found !---------------------------------------------------------------------! if (( reduced_j1pes ( coupling_index_ ) == j1pes ( column_index_ )). and . & ( reduced_j1ppes ( coupling_index_ ) == j1ppes ( column_index_ )). and . & ( reduced_v1pes ( coupling_index_ ) == v1pes ( column_index_ )). and . & ( reduced_v1ppes ( coupling_index_ ) == v1ppes ( column_index_ ))) then reduced_term = read_vmat3D ( r_index_ , lambda_index_ , column_index_ ) exit endif enddo !---------------------------------------------------------------------! end function find_reduced_term !---------------------------------------------------------------------------! subroutine print_pes_quantum_numbers ( set_type , col_count ) !! Prints quantum numbers describing radial coupling terms of the PES !! based on the provided set type and column count. !---------------------------------------------------------------------! character ( len =* ), intent ( in ) :: set_type !! \"Original\" or \"reduced\" - describes the set of quantum numbers integer ( int32 ), intent ( in ) :: col_count !! number of coupling terms !---------------------------------------------------------------------! integer ( int32 ) :: column_index_ !---------------------------------------------------------------------! if ( prntlvl >= 3 ) then call write_message ( \"*** \" // trim ( set_type ) // & \" number of quantum numbers describing radial coupling terms: \" & // trim ( adjustl ( integer_to_character ( col_count ))) // \" ***\" ) call write_message ( \"Set of quantum numbers:\" ) call write_message ( \"       v1  j1  v1`  j1`\" ) select case ( set_type ) case ( \"Original\" ) do column_index_ = 1 , col_count write ( * , \"(5X,2(2X,I2),2(2X,I2))\" ) v1pes ( column_index_ ), & j1pes ( column_index_ ), v1ppes ( column_index_ ), & j1ppes ( column_index_ ) enddo case ( \"Reduced\" ) do column_index_ = 1 , col_count write ( * , \"(5X,2(2X,I2),2(2X,I2))\" ) & reduced_v1pes ( column_index_ ), & reduced_j1pes ( column_index_ ), & reduced_v1ppes ( column_index_ ), & reduced_j1ppes ( column_index_ ) enddo end select endif end subroutine print_pes_quantum_numbers !---------------------------------------------------------------------------! !                        Interpolation procedure !---------------------------------------------------------------------------! subroutine interpolate_radial_coupling_terms !! Interpolates the radial coupling terms using cubic spline functions. !! The resulting spline coefficients for each coupling term !! are stored in bmat3D, cmat3D, and dmat3D matrices. !---------------------------------------------------------------------! integer ( int32 ) :: lambda_index_ , coupling_index_ real ( dp ) :: spline_coeff_b ( nr ), spline_coeff_c ( nr ), spline_coeff_d ( nr ) !---------------------------------------------------------------------! do lambda_index_ = 1 , nterms do coupling_index_ = 1 , minimal_number_of_coupling_terms !---------------------------------------------------------------! ! Compute spline coefficients for each coupling term !---------------------------------------------------------------! call SPLINE ( nr , rmat , vmat3D (:, lambda_index_ , coupling_index_ ), & spline_coeff_b , spline_coeff_c , spline_coeff_d ) !---------------------------------------------------------------! ! Store coefficients in the respective matrices !---------------------------------------------------------------! bmat3D (:, lambda_index_ , coupling_index_ ) = spline_coeff_b cmat3D (:, lambda_index_ , coupling_index_ ) = spline_coeff_c dmat3D (:, lambda_index_ , coupling_index_ ) = spline_coeff_d enddo enddo !---------------------------------------------------------------------! end subroutine interpolate_radial_coupling_terms !---------------------------------------------------------------------------! !                     Radial coupling term value !---------------------------------------------------------------------------! subroutine get_radial_coupling_term_value ( intermolecular_distance , & lambda_ , v_ , j_ , v_prime_ , j_prime_ , radial_term_value_ ) !! Returns the interpolated value of a specific radial coupling term !! at a given distance. !---------------------------------------------------------------------! real ( dp ), intent ( in ) :: intermolecular_distance !! Intermolecular distance, \\R\\ integer ( int32 ), intent ( in ) :: lambda_ !! Legendre expansion index integer ( int32 ), intent ( in ) :: v_ !! pre-collisional vibrational quantum number integer ( int32 ), intent ( in ) :: j_ !! pre-collisional rotational quantum number integer ( int32 ), intent ( in ) :: v_prime_ !! post-collisional vibrational quantum number integer ( int32 ), intent ( in ) :: j_prime_ !! post-collisional rotational quantum number real ( dp ), intent ( out ) :: radial_term_value_ !! Value of the radial coupling coefficient !---------------------------------------------------------------------! integer ( int32 ) :: lambda_index , coupling_index !---------------------------------------------------------------------! lambda_index = find_lambda_index ( lambda_ ) !---------------------------------------------------------------------! if ( lambda_index == 0 ) then call handle_lambda_index_error ( lambda_ ) return endif !---------------------------------------------------------------------! coupling_index = find_coupling_index ( v_ , j_ , v_prime_ , j_prime_ ) !---------------------------------------------------------------------! if ( coupling_index == 0 ) then call handle_coupling_index_error ( v_ , j_ , v_prime_ , j_prime_ ) return endif !---------------------------------------------------------------------! radial_term_value_ = ISPLINE ( intermolecular_distance , nr , rmat , & vmat3D (:, lambda_index , coupling_index ), & bmat3D (:, lambda_index , coupling_index ), & cmat3D (:, lambda_index , coupling_index ), & dmat3D (:, lambda_index , coupling_index )) !---------------------------------------------------------------------! end subroutine get_radial_coupling_term_value !---------------------------------------------------------------------------! function find_lambda_index ( lambda_ ) result ( result_index_ ) !! Locates given \\\\lambda\\ value in l1tab. !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: lambda_ !! Legendre expansion index, \\\\lambda\\ integer ( int32 ) :: result_index_ !! Index pointing to  \\\\lambda\\ in l1tab !---------------------------------------------------------------------! integer ( int32 ) :: lambda_index_ !---------------------------------------------------------------------! result_index_ = 0 do lambda_index_ = 1 , nterms if ( l1tab ( lambda_index_ ) == lambda_ ) then result_index_ = lambda_index_ exit endif enddo !---------------------------------------------------------------------! end function find_lambda_index !---------------------------------------------------------------------------! subroutine handle_lambda_index_error ( lambda_ ) !! Handles error when \\\\lambda\\ is not found in l1tab. !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: lambda_ !! Legendre expansion index, \\\\lambda\\ !---------------------------------------------------------------------! call write_error ( \"Radial coupling terms with lambda = \" // & trim ( adjustl ( integer_to_character ( lambda_ ))) // \" not found in l1tab\" ) !---------------------------------------------------------------------! end subroutine handle_lambda_index_error !---------------------------------------------------------------------------! function find_coupling_index ( v_ , j_ , v_prime_ , j_prime_ ) result ( result_index_ ) !! Locates the correct quantum number that describes the v/j coupling. !! Note that coupling terms are symmetric with respect to the change !! of pre- and post-collisional quantum numbers. !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: v_ !! pre-collisional vibrational quantum number integer ( int32 ), intent ( in ) :: j_ !! pre-collisional rotational quantum number integer ( int32 ), intent ( in ) :: v_prime_ !! post-collisional vibrational quantum number integer ( int32 ), intent ( in ) :: j_prime_ !! post-collisional rotational quantum number integer ( int32 ) :: result_index_ !! Index pointing to  \\v, j, v&#94;{\\prime}, j&#94;{\\prime}\\ in reduced_* arrays !---------------------------------------------------------------------! integer ( int32 ) :: coupling_index_ !---------------------------------------------------------------------! result_index_ = 0 do coupling_index_ = 1 , minimal_number_of_coupling_terms if (((( reduced_v1pes ( coupling_index_ ) == v_ ). and . & ( reduced_j1pes ( coupling_index_ ). eq . j_ ). and . & ( reduced_v1ppes ( coupling_index_ ). eq . v_prime_ ). and . & ( reduced_j1ppes ( coupling_index_ ). eq . j_prime_ )) & . or . & (( reduced_v1pes ( coupling_index_ ). eq . v_prime_ ). and . & ( reduced_j1pes ( coupling_index_ ). eq . j_prime_ ). and . & ( reduced_v1ppes ( coupling_index_ ). eq . v_ ). and . & ( reduced_j1ppes ( coupling_index_ ). eq . j_ ))) ) then result_index_ = coupling_index_ exit endif enddo !---------------------------------------------------------------------! end function find_coupling_index !---------------------------------------------------------------------------! subroutine handle_coupling_index_error ( v_ , j_ , v_prime_ , j_prime_ ) !! Handles error when the appropriate coupling term is not found. !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: v_ !! pre-collisional vibrational quantum number integer ( int32 ), intent ( in ) :: j_ !! pre-collisional rotational quantum number integer ( int32 ), intent ( in ) :: v_prime_ !! post-collisional vibrational quantum number integer ( int32 ), intent ( in ) :: j_prime_ !! post-collisional rotational quantum number !---------------------------------------------------------------------! call write_error ( \"Coupling term with v = \" // & trim ( adjustl ( integer_to_character ( v_ ))) // \", j = \" // & trim ( adjustl ( integer_to_character ( j_ ))) // \", v` = \" // & trim ( adjustl ( integer_to_character ( v_prime_ ))) // \", j1` = \" // & trim ( adjustl ( integer_to_character ( j_prime_ ))) // \" not found\" ) !---------------------------------------------------------------------! end subroutine handle_coupling_index_error !------------------------------------------------------------------------------! end module radial_coupling_terms_mod","tags":"","loc":"sourcefile/radial_coupling_terms_mod.f90.html"},{"title":"pes_matrix_mod.f90 – the SCATTERING code","text":"This file depends on sourcefile~~pes_matrix_mod.f90~~EfferentGraph sourcefile~pes_matrix_mod.f90 pes_matrix_mod.f90 sourcefile~utility_functions_mod.f90 utility_functions_mod.f90 sourcefile~pes_matrix_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~data_mod.f90 data_mod.f90 sourcefile~pes_matrix_mod.f90->sourcefile~data_mod.f90 sourcefile~input_reader_mod.f90 input_reader_mod.f90 sourcefile~pes_matrix_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~math_functions_mod.f90 math_functions_mod.f90 sourcefile~pes_matrix_mod.f90->sourcefile~math_functions_mod.f90 sourcefile~radial_coupling_terms_mod.f90 radial_coupling_terms_mod.f90 sourcefile~pes_matrix_mod.f90->sourcefile~radial_coupling_terms_mod.f90 sourcefile~array_operations_mod.f90 array_operations_mod.f90 sourcefile~pes_matrix_mod.f90->sourcefile~array_operations_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~data_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~array_operations_mod.f90 sourcefile~input_validation_mod.f90 input_validation_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~input_validation_mod.f90 sourcefile~math_functions_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~special_functions_mod.f90 special_functions_mod.f90 sourcefile~math_functions_mod.f90->sourcefile~special_functions_mod.f90 sourcefile~radial_coupling_terms_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~radial_coupling_terms_mod.f90->sourcefile~data_mod.f90 sourcefile~radial_coupling_terms_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~radial_coupling_terms_mod.f90->sourcefile~math_functions_mod.f90 sourcefile~input_validation_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~input_validation_mod.f90->sourcefile~data_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~pes_matrix_mod.f90~~AfferentGraph sourcefile~pes_matrix_mod.f90 pes_matrix_mod.f90 sourcefile~scattering.f90 scattering.f90 sourcefile~scattering.f90->sourcefile~pes_matrix_mod.f90 sourcefile~propagator_mod.f90 propagator_mod.f90 sourcefile~scattering.f90->sourcefile~propagator_mod.f90 sourcefile~propagator_mod.f90->sourcefile~pes_matrix_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules pes_matrix_mod Source Code pes_matrix_mod.f90 Source Code module pes_matrix_mod !! This module provides functions calculating the algebraic coefficients !! \\ g\\_{{\\lambda},\\gamma,\\gamma'}&#94;{Jp} \\ entering the PES matrix, !! and the full PES matrix (see Eq. 1 in the \"Coupling Matrix\" section). !---------------------------------------------------------------------------! !! Subroutines preparing algebraic coefficients and determining the number !! of non-zero terms of the PES matrix are called only once, !! before Numerov propagator is initialized !---------------------------------------------------------------------------! !! Subroutines calculating the full PES matrix at desired R are called !! within the propagator loop !---------------------------------------------------------------------------! !! The data is organized as follows: !! - number of non-zero terms of the PES matrix due to !!   \\\\bar{\\Omega} = \\bar{\\Omega}'\\ condition is saved as !!   \"number_of_nonzero_pes_matrix_elements\" !! - number of non-vanishing terms in the sum over \\\\lambda\\ !!   in Eq. 1 in the \"Coupling Matrix\" section is saved in a !!   \"nonzero_terms_per_element\" array which is of !!   \"number_of_nonzero_pes_matrix_elements\" size !! - a _total_ number of non-vanishing  \\ g\\_{{\\lambda},\\gamma,\\gamma'}&#94;{Jp} \\ !!   coefficients is saved in \"number_of_nonzero_algebraic_coefficients\" !! - _all_ non-vanishing  \\ g\\_{{\\lambda},\\gamma,\\gamma'}&#94;{Jp} \\ !!   coefficients are saved in \"nonzero_algebraic_coefficients\" array, !!   which is of \"number_of_nonzero_algebraic_coefficients\" size !! - corresponding \\\\lambda\\ value for each non-vanishing coefficient !!   is saved as an index to \"l1tab\" in the \"nonzero_legendre_indices\" !!   array (which is of \"number_of_nonzero_algebraic_coefficients\" size) !---------------------------------------------------------------------------! use , intrinsic :: iso_fortran_env , only : int32 , sp => real32 , dp => real64 use utility_functions_mod , only : write_error , write_message , integer_to_character use data_mod use io_mod use array_operations_mod , only : fill_symmetric_matrix use math_functions_mod , only : percival_seaton_coefficient , & triangle_inequality_holds , is_sum_even , zero_projections_3j_condition use radial_coupling_terms_mod , only : get_radial_coupling_term_value !---------------------------------------------------------------------------! implicit none !---------------------------------------------------------------------------! private public :: check_nonzero_pes_matrix_elements , prepare_pes_matrix_elements , & print_pes_matrix_elements_summary , calculate_pes_matrix !---------------------------------------------------------------------------! contains !---------------------------------------------------------------------------! ! Subroutines preparing algebraic coefficients and determining the number ! of non-zero terms of the PES matrix; these are called only once, ! before Numerov propagator is initialized !---------------------------------------------------------------------------! subroutine check_nonzero_pes_matrix_elements ( channel_indices ,& channels_omega_values , number_of_nonzero_pes_matrix_elements , & number_of_nonzero_algebraic_coefficients ) !! checks the number of non-zero PES matrix elements due to !! the \\bar{\\Omega} = \\bar{\\Omega}' condition, !! \"number_of_nonzero_pes_matrix_elements\", !! and the total number of non-zero algebraic coefficients, !! \\ g\\_{{\\lambda},\\gamma,\\gamma'}&#94;{Jp} \\, in the whole matrix, !! \"number_of_nonzero_algebraic_coefficients\". !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: channel_indices (:) !! holds the indices pointing to the basis arrays integer ( int32 ), intent ( in ) :: channels_omega_values (:) !! holds all values of \\bar{\\Omega} integer ( int32 ), intent ( out ) :: number_of_nonzero_pes_matrix_elements !! number of non-zero terms in the sum () for each non-zero element of the PES matrix integer ( int32 ), intent ( out ) :: number_of_nonzero_algebraic_coefficients !! number of all non-zero algberaix coefficients in the whole PES matrix !---------------------------------------------------------------------! integer ( int32 ) :: count_nonzero_pes_matrix_elements , & count_nonzero_algebraic_coefficients , j_ , j_prime_ , omega_ , & omega_prime_ , lambda_ , channel_index_1_ , channel_index_2_ , legendre_term_index_ !---------------------------------------------------------------------! count_nonzero_algebraic_coefficients = 0 count_nonzero_pes_matrix_elements = 0 do channel_index_1_ = 1 , size ( channel_indices ) j_ = j1array ( channel_indices ( channel_index_1_ )) omega_ = channels_omega_values ( channel_index_1_ ) do channel_index_2_ = 1 , channel_index_1_ j_prime_ = j1array ( channel_indices ( channel_index_2_ )) omega_prime_ = channels_omega_values ( channel_index_2_ ) !---------------------------------------------------------------! if ( omega_ /= omega_prime_ ) cycle !---------------------------------------------------------------! count_nonzero_pes_matrix_elements = & count_nonzero_pes_matrix_elements + 1 do legendre_term_index_ = 1 , nterms lambda_ = l1tab ( legendre_term_index_ ) if (. not . zero_projections_3j_condition ( j_ , j_prime_ , lambda_ )) cycle count_nonzero_algebraic_coefficients = & count_nonzero_algebraic_coefficients + 1 enddo enddo enddo !---------------------------------------------------------------------! number_of_nonzero_algebraic_coefficients = count_nonzero_algebraic_coefficients number_of_nonzero_pes_matrix_elements = count_nonzero_pes_matrix_elements !---------------------------------------------------------------------! end subroutine check_nonzero_pes_matrix_elements !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine prepare_pes_matrix_elements ( channel_indices , & channels_omega_values , nonzero_terms_per_element , & nonzero_legendre_indices , nonzero_algebraic_coefficients ) !! prepares: !! -- nonzero_terms_per_element - number of non-vanishing terms in !!    the sum over \\\\lambda\\ in Eq. 1 in the \"Coupling Matrix\" section !! -- nonzero_legendre_indices - corresponding \\\\lambda\\ value for !!    each non-vanishing coefficient is saved as an index to \"l1tab\" !! -- nonzero_algebraic_coefficients --  holds _all_ non-vanishing !!    \\ g\\_{{\\lambda},\\gamma,\\gamma'}&#94;{Jp} \\ coefficients !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: channel_indices (:) !! holds the indices pointing to the basis arrays integer ( int32 ), intent ( in ) :: channels_omega_values (:) !! holds all values of \\bar{\\Omega} integer ( int32 ), intent ( inout ) :: nonzero_terms_per_element (:) !! keeps the number of non-vanishing elements of the sum over \\\\lambda\\ !! for each non-zero element of the PES matrix integer ( int32 ), intent ( inout ) :: nonzero_legendre_indices (:) !! holds indices pointing to l1tab, which correspond to !! the non-vanishing elements of the sum over \\\\lambda\\ !! for each non-zero element of the PES matrix; real ( dp ), intent ( inout ) :: nonzero_algebraic_coefficients (:) !! holds the values of the non-zero algebraic coefficients !---------------------------------------------------------------------! integer ( int32 ) :: count_nonzero_pes_matrix_elements , & count_nonzero_algebraic_coefficients , count_nonzero_legendre_terms , & j_ , j_prime_ , omega_ , omega_prime_ , lambda_ , channel_index_1_ , & channel_index_2_ , legendre_term_index_ real ( dp ) :: pscoeff !---------------------------------------------------------------------! nonzero_terms_per_element = 0 nonzero_legendre_indices = 0 nonzero_algebraic_coefficients = 0 count_nonzero_algebraic_coefficients = 0 count_nonzero_pes_matrix_elements = 0 !---------------------------------------------------------------------! do channel_index_1_ = 1 , size ( channel_indices ) j_ = j1array ( channel_indices ( channel_index_1_ )) omega_ = channels_omega_values ( channel_index_1_ ) do channel_index_2_ = 1 , channel_index_1_ j_prime_ = j1array ( channel_indices ( channel_index_2_ )) omega_prime_ = channels_omega_values ( channel_index_2_ ) if ( omega_ /= omega_prime_ ) cycle !---------------------------------------------------------------! ! passed \\bar{\\Omega} = \\bar{\\Omega}' condition !---------------------------------------------------------------! count_nonzero_pes_matrix_elements = & count_nonzero_pes_matrix_elements + 1 !---------------------------------------------------------------! ! process a single matrix element: ! determine non-zero terms in the sum over legendre polynomials ! for this element; these are saved to ... !---------------------------------------------------------------! call process_single_matrix_element ( j_ , j_prime_ , omega_ , & count_nonzero_algebraic_coefficients , & count_nonzero_legendre_terms , nonzero_legendre_indices , & nonzero_algebraic_coefficients ) nonzero_terms_per_element ( count_nonzero_pes_matrix_elements )& = count_nonzero_legendre_terms enddo enddo !---------------------------------------------------------------------! end subroutine prepare_pes_matrix_elements !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine process_single_matrix_element ( j_ , j_prime_ , omega_ , & count_nonzero_algebraic_coefficients , count_nonzero_legendre_terms , & nonzero_legendre_indices , nonzero_algebraic_coefficients ) !! calculates the non-zero algebraic coefficients !! \\ g\\_{{\\lambda},\\gamma,\\gamma'}&#94;{Jp} \\ for a single matrix !! element - see Eq. (1) in the \"Coupling matrix\" section; !! algebraic coefficients are saved to nonzero_algebraic_coefficients !! array; corresponding indices to l1tab are saved to !! nonzero_legendre_indices array !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: j_ !! pre-collisional rotational angular momentum integer ( int32 ), intent ( in ) :: j_prime_ !! post-collisional rotational angular momentum integer ( int32 ), intent ( in ) :: omega_ !! \\\\bar{\\Omega}\\ integer ( int32 ), intent ( inout ) :: count_nonzero_algebraic_coefficients !! running index counting non-zero coupling coefficients, !! \\ g\\_{{\\lambda},\\gamma,\\gamma'}&#94;{Jp} \\ in the whole matrix; !! incremented in this subroutine integer ( int32 ), intent ( inout ) :: count_nonzero_legendre_terms !! number of non-zero terms in Legendre expansion for a single !! matrix element of the interaction potential integer ( int32 ), intent ( inout ) :: nonzero_legendre_indices (:) !! holds indices pointing to l1tab, which correspond to !! the non-vanishing elements of the sum over \\\\lambda\\ !! for each non-zero element of the PES matrix; real ( dp ), intent ( inout ) :: nonzero_algebraic_coefficients (:) !! holds values of the non-zero algebraic coefficients !---------------------------------------------------------------------! integer ( int32 ) :: legendre_term_index_ , lambda_ real ( dp ) :: pscoeff !---------------------------------------------------------------------! count_nonzero_legendre_terms = 0 do legendre_term_index_ = 1 , nterms lambda_ = l1tab ( legendre_term_index_ ) !------------------------------------------------------------! ! check the condition on 3-j symbol with zero projections !------------------------------------------------------------! if (. not . zero_projections_3j_condition ( j_ , j_prime_ , lambda_ )) cycle !------------------------------------------------------------! count_nonzero_algebraic_coefficients = & count_nonzero_algebraic_coefficients + 1 !------------------------------------------------------------! ! calculate the Percival-Seaton coefficient !------------------------------------------------------------! pscoeff = percival_seaton_coefficient ( j_ , j_prime_ , lambda_ , omega_ ) !------------------------------------------------------------! ! save the Percival-Seaton coefficient !------------------------------------------------------------! nonzero_algebraic_coefficients ( & count_nonzero_algebraic_coefficients ) = pscoeff !------------------------------------------------------------! ! save indices to l1tab corresponding to \\\\lambda\\ !------------------------------------------------------------! nonzero_legendre_indices ( count_nonzero_algebraic_coefficients )& = legendre_term_index_ !------------------------------------------------------------! count_nonzero_legendre_terms = count_nonzero_legendre_terms + 1 enddo !---------------------------------------------------------------------! end subroutine process_single_matrix_element !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine print_pes_matrix_elements_summary ( number_of_channels , & number_of_nonzero_pes_matrix_elements , & number_of_nonzero_algebraic_coefficients ) !! print a shor summary on the number of non-zero matrix elements !! of the PES matrix !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: number_of_channels !! size of the basis integer ( int32 ), intent ( in ) :: number_of_nonzero_pes_matrix_elements !! number of non-zero terms in the sum () for each non-zero element !! of the PES matrix integer ( int32 ), intent ( in ) :: number_of_nonzero_algebraic_coefficients !! number of all non-zero algberaix coefficients in the whole !! PES matrix !---------------------------------------------------------------------! call write_message ( repeat ( \"*\" , 90 )) call write_message ( repeat ( \" \" , 5 ) // \"Size of the PES matrix: \" // & integer_to_character ( number_of_channels )) call write_message ( repeat ( \" \" , 5 ) // \"Number of non-zero elements \" // & \"of the potential matrix: \" // integer_to_character ( & number_of_nonzero_pes_matrix_elements )) call write_message ( repeat ( \" \" , 5 ) // \"Number of non-zero elements \" // & \" of the PES matrix: \" // integer_to_character ( & number_of_nonzero_algebraic_coefficients )) call write_message ( repeat ( '*' , 90 )) !---------------------------------------------------------------------! end subroutine print_pes_matrix_elements_summary !---------------------------------------------------------------------------! ! Subroutines calculating the full PES matrix at desired R; ! these are called within the propagator loop !---------------------------------------------------------------------------! subroutine calculate_pes_matrix ( total_angular_momentum_ , & intermolecular_distance_ , channel_indices_ , channels_omega_values_ , & nonzero_terms_per_element_ , nonzero_legendre_indices_ , & nonzero_algebraic_coefficients_ , vmatrix ) !! calculates the contribution to the coupling matrix !! from the the interaction potential (PES); !! see Eq. 1 in \"Coupling Matrix\" section; !! diagonal contribution from wavevectors (see the last term in !! Eq. 3 of \"What are coupled equations\" section) is added !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: total_angular_momentum_ !! total angular momentum real ( dp ), intent ( in ) :: intermolecular_distance_ !! intermolecular distance integer ( int32 ), intent ( in ) :: channel_indices_ (:) !! holds the indices pointing to the basis arrays integer ( int32 ), intent ( in ) :: channels_omega_values_ (:) !! holds all values of \\bar{\\Omega} integer ( int32 ), intent ( in ) :: nonzero_terms_per_element_ (:) !! keeps the number of non-vanishing elements of the sum over \\\\lambda\\ !! for each non-zero element of the coupling matrix integer ( int32 ), intent ( in ) :: nonzero_legendre_indices_ (:) !! holds indices pointing to l1tab, which correspond to !! the non-vanishing elements of the sum over \\\\lambda\\ !! for each non-zero element of the coupling matrix; real ( dp ), intent ( in ) :: nonzero_algebraic_coefficients_ (:) !! holds the values of the non-zero algebraic coefficients real ( dp ), intent ( out ) :: vmatrix (:,:) !! (output) - the interaction potential contribution to the coupling matrix !---------------------------------------------------------------------! integer ( int32 ) :: count_nonzero_algebraic_coefficients_ , & count_nonzero_coupling_matrix_elements , & count_nonzero_legendre_terms , channel_index_1_ , channel_index_2_ , & omega_ , omega_prime_ !---------------------------------------------------------------------! vmatrix = 0 count_nonzero_algebraic_coefficients_ = 0 count_nonzero_coupling_matrix_elements = 0 !---------------------------------------------------------------------! do channel_index_1_ = 1 , size ( channel_indices_ ) omega_ = channels_omega_values_ ( channel_index_1_ ) do channel_index_2_ = 1 , channel_index_1_ omega_prime_ = channels_omega_values_ ( channel_index_2_ ) !---------------------------------------------------------------! if ( omega_ /= omega_prime_ ) cycle !---------------------------------------------------------------! count_nonzero_coupling_matrix_elements & = count_nonzero_coupling_matrix_elements + 1 !---------------------------------------------------------------! ! process a single matrix element: ! get number of  non-zero terms in Legendre expansion for this ! matrix element !---------------------------------------------------------------! count_nonzero_legendre_terms & = nonzero_terms_per_element_ ( count_nonzero_coupling_matrix_elements ) !---------------------------------------------------------------! ! implementation of Eq. 1 in \"Coupling Matrix\" section !---------------------------------------------------------------! vmatrix ( channel_index_1_ , channel_index_2_ ) & = calculate_single_pes_matrix_element ( & intermolecular_distance_ , channel_index_1_ , & channel_index_2_ , channel_indices_ , & count_nonzero_legendre_terms , & count_nonzero_algebraic_coefficients_ , & nonzero_legendre_indices_ , nonzero_algebraic_coefficients_ ) !---------------------------------------------------------------! enddo enddo !---------------------------------------------------------------------! call fill_symmetric_matrix ( vmatrix , 'u' ) !---------------------------------------------------------------------! end subroutine calculate_pes_matrix !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! function calculate_single_pes_matrix_element ( intermolecular_distance_ , & channel_index_1_ , channel_index_2_ , channel_indices_ , & count_nonzero_legendre_terms , count_nonzero_algebraic_coefficients_ , & nonzero_legendre_indices_ , nonzero_algebraic_coefficients_ ) result ( matrix_element_ ) !! Implementation of Eq. 1 in \"Coupling Matrix\" section; !! diagonal contribution from wavevectors (see the last term in !! Eq. 3 of \"What are coupled equations\" section) is added !---------------------------------------------------------------------! real ( dp ), intent ( in ) :: intermolecular_distance_ !! intermolecular distance integer ( int32 ), intent ( in ) :: channel_index_1_ , channel_index_2_ !! indices identifying matrix element integer ( int32 ), intent ( in ) :: channel_indices_ (:) !! holds the indices pointing to the basis arrays integer ( int32 ), intent ( in ) :: count_nonzero_legendre_terms !! number of non-zero terms in Legendre expansion for a single !! matrix element of the interaction potential integer ( int32 ), intent ( in ) :: nonzero_legendre_indices_ (:) !! holds indices pointing to l1tab, which correspond to !! the non-vanishing elements of the sum over \\\\lambda\\ !! for each non-zero element of the coupling matrix; real ( dp ), intent ( in ) :: nonzero_algebraic_coefficients_ (:) !! holds the values of the non-zero algebraic coefficients integer ( int32 ), intent ( inout ) :: count_nonzero_algebraic_coefficients_ !! running index counting non-zero coupling coefficients, !! \\ g\\_{{\\lambda},\\gamma,\\gamma'}&#94;{Jp} \\ in the whole matrix; !! incremented in this subroutine real ( dp ) :: matrix_element_ !! matirx element of the interaction potential contribution !! to the coupling matrix !---------------------------------------------------------------------! integer ( int32 ) :: v_ , j_ , v_prime_ , j_prime_ , lambda_ , lambda_index_ real ( dp ) :: internal_energy_ , sum_over_lambda_ , & algebraic_coefficient_ , radial_term_ !---------------------------------------------------------------------! v_ = v1array ( channel_indices_ ( channel_index_1_ )) j_ = j1array ( channel_indices_ ( channel_index_1_ )) v_prime_ = v1array ( channel_indices_ ( channel_index_2_ )) j_prime_ = j1array ( channel_indices_ ( channel_index_2_ )) internal_energy_ = elevel ( channel_indices_ ( channel_index_1_ )) !---------------------------------------------------------------------! sum_over_lambda_ = 0.0_dp do lambda_index_ = 1 , count_nonzero_legendre_terms !------------------------------------------------------------------! count_nonzero_algebraic_coefficients_ & = count_nonzero_algebraic_coefficients_ + 1 !------------------------------------------------------------------! lambda_ = l1tab ( nonzero_legendre_indices_ ( count_nonzero_algebraic_coefficients_ )) algebraic_coefficient_ = nonzero_algebraic_coefficients_ ( count_nonzero_algebraic_coefficients_ ) !------------------------------------------------------------------! call get_radial_coupling_term_value ( intermolecular_distance_ , & lambda_ , v_ , j_ , v_prime_ , j_prime_ , radial_term_ ) !------------------------------------------------------------------! sum_over_lambda_ = sum_over_lambda_ + algebraic_coefficient_ * radial_term_ !------------------------------------------------------------------! enddo matrix_element_ = 2.0_dp * reduced_mass * sum_over_lambda_ !---------------------------------------------------------------------! if ( channel_index_1_ == channel_index_2_ ) then matrix_element_ = matrix_element_ & - wavenumber_squared_from_energy ( internal_energy_ ) endif !---------------------------------------------------------------------! end function calculate_single_pes_matrix_element !------------------------------------------------------------------------------! end module pes_matrix_mod","tags":"","loc":"sourcefile/pes_matrix_mod.f90.html"},{"title":"special_functions_mod.f90 – the SCATTERING code","text":"Files dependent on this one sourcefile~~special_functions_mod.f90~~AfferentGraph sourcefile~special_functions_mod.f90 special_functions_mod.f90 sourcefile~math_functions_mod.f90 math_functions_mod.f90 sourcefile~math_functions_mod.f90->sourcefile~special_functions_mod.f90 sourcefile~radial_coupling_terms_mod.f90 radial_coupling_terms_mod.f90 sourcefile~radial_coupling_terms_mod.f90->sourcefile~math_functions_mod.f90 sourcefile~pes_matrix_mod.f90 pes_matrix_mod.f90 sourcefile~pes_matrix_mod.f90->sourcefile~math_functions_mod.f90 sourcefile~pes_matrix_mod.f90->sourcefile~radial_coupling_terms_mod.f90 sourcefile~boundary_conditions_mod.f90 boundary_conditions_mod.f90 sourcefile~boundary_conditions_mod.f90->sourcefile~math_functions_mod.f90 sourcefile~scattering.f90 scattering.f90 sourcefile~scattering.f90->sourcefile~radial_coupling_terms_mod.f90 sourcefile~scattering.f90->sourcefile~pes_matrix_mod.f90 sourcefile~scattering.f90->sourcefile~boundary_conditions_mod.f90 sourcefile~propagator_mod.f90 propagator_mod.f90 sourcefile~scattering.f90->sourcefile~propagator_mod.f90 sourcefile~propagator_mod.f90->sourcefile~pes_matrix_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules special_functions_mod Source Code special_functions_mod.f90 Source Code module special_functions_mod !! This module holds rctj, rcty, envj, msta1, msta2, ikv, gamma from !! special_functions library, donwloaded from: !! https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html !!  Author: !! !!    Original FORTRAN77 version by Shanjie Zhang, Jianming Jin. !!    FORTRAN90 version by John Burkardt. !! !!  Reference: !! !!    Shanjie Zhang, Jianming Jin, !!    Computation of Special Functions, !!    Wiley, 1996, !!    ISBN: 0-471-11963-6, !!    LC: QA351.C45. !!--------------------------------------------------------------------------! implicit none !--------------------------------------------------------------------------! contains !--------------------------------------------------------------------------! subroutine rctj ( n , x , nm , rj , dj ) !------------------------------------------------------------------------! !! computes Riccati-Bessel function of the first kind, and derivatives. !------------------------------------------------------------------------! !  Licensing: ! !    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, !    they give permission to incorporate this routine into a user program !    provided that the copyright is acknowledged. ! !  Modified: ! !    18 July 2012 ! !  Author: ! !    Shanjie Zhang,Jianming Jin ! !  Reference: ! !    Shanjie Zhang,Jianming Jin, !    Computation of Special Functions, !    Wiley,1996, !    ISBN: 0-471-11963-6, !    LC: QA351.C45. ! !  Parameters: ! !    Input,integer(kind = 4) N,the order of jn(x). ! !    Input,real(kind = 8) X,the argument. ! !    Output,integer(kind = 4) NM,the highest order computed. ! !    Output,real(kind = 8) RJ(0:N),the values of x jn(x). ! !    Output,real(kind = 8) DJ(0:N),the values of [x jn(x)]'. !------------------------------------------------------------------------! implicit none integer ( kind = 4 ) n real ( kind = 8 ) cs real ( kind = 8 ) dj ( 0 : n ) real ( kind = 8 ) f real ( kind = 8 ) f0 real ( kind = 8 ) f1 integer ( kind = 4 ) k integer ( kind = 4 ) m ! ---------------------------------------------------------------------- ! commented because the functions are now in the same module !\t\t  integer(kind = 4) msta1 !\t\t  integer(kind = 4) msta2 ! ---------------------------------------------------------------------- integer ( kind = 4 ) nm real ( kind = 8 ) rj ( 0 : n ) real ( kind = 8 ) rj0 real ( kind = 8 ) rj1 real ( kind = 8 ) x nm = n if ( abs ( x ) < 1.0D-100 ) then do k = 0 , n rj ( k ) = 0.0D+00 dj ( k ) = 0.0D+00 end do dj ( 0 ) = 1.0D+00 return end if rj ( 0 ) = sin ( x ) rj ( 1 ) = rj ( 0 ) / x - cos ( x ) rj0 = rj ( 0 ) rj1 = rj ( 1 ) if ( 2 <= n ) then m = msta1 ( x , 200 ) if ( m < n ) then nm = m else m = msta2 ( x , n , 15 ) end if f0 = 0.0D+00 f1 = 1.0D-100 do k = m , 0 , - 1 f = ( 2.0D+00 * k + 3.0D+00 ) * f1 / x - f0 if ( k <= nm ) then rj ( k ) = f end if f0 = f1 f1 = f end do if ( abs ( rj1 ) < abs ( rj0 )) then cs = rj0 / f else cs = rj1 / f0 end if do k = 0 , nm rj ( k ) = cs * rj ( k ) end do end if dj ( 0 ) = cos ( x ) do k = 1 , nm dj ( k ) = - k * rj ( k ) / x + rj ( k - 1 ) end do return end !------------------------------------------------------------------------! subroutine rcty ( n , x , nm , ry , dy ) !------------------------------------------------------------------------! !! computes Riccati-Bessel function of the second kind, and derivatives. !------------------------------------------------------------------------! ! !  Licensing: ! !    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, !    they give permission to incorporate this routine into a user program !    provided that the copyright is acknowledged. ! !  Modified: ! !    18 July 2012 ! !  Author: ! !    Shanjie Zhang,Jianming Jin ! !  Reference: ! !    Shanjie Zhang,Jianming Jin, !    Computation of Special Functions, !    Wiley,1996, !    ISBN: 0-471-11963-6, !    LC: QA351.C45. ! !  Parameters: ! !    Input,integer(kind = 4) N,the order of yn(x). ! !    Input,real(kind = 8) X,the argument. ! !    Output,integer(kind = 4) NM,the highest order computed. ! !    Output,real(kind = 8) RY(0:N),the values of x yn(x). ! !    Output,real(kind = 8) DY(0:N),the values of [x yn(x)]'. !------------------------------------------------------------------------! implicit none integer ( kind = 4 ) n real ( kind = 8 ) dy ( 0 : n ) integer ( kind = 4 ) k integer ( kind = 4 ) nm real ( kind = 8 ) rf0 real ( kind = 8 ) rf1 real ( kind = 8 ) rf2 real ( kind = 8 ) ry ( 0 : n ) real ( kind = 8 ) x nm = n if ( x < 1.0D-60 ) then do k = 0 , n ry ( k ) = - 1.0D+300 dy ( k ) = 1.0D+300 end do ry ( 0 ) = - 1.0D+00 dy ( 0 ) = 0.0D+00 return end if ry ( 0 ) = - cos ( x ) ry ( 1 ) = ry ( 0 ) / x - sin ( x ) rf0 = ry ( 0 ) rf1 = ry ( 1 ) do k = 2 , n rf2 = ( 2.0D+00 * k - 1.0D+00 ) * rf1 / x - rf0 if ( 1.0D+300 < abs ( rf2 )) then exit end if ry ( k ) = rf2 rf0 = rf1 rf1 = rf2 end do nm = k - 1 dy ( 0 ) = sin ( x ) do k = 1 , nm dy ( k ) = - k * ry ( k ) / x + ry ( k - 1 ) end do return end !------------------------------------------------------------------------! function envj ( n , x ) !------------------------------------------------------------------------! !! utility function used by MSTA1 and MSTA2. !------------------------------------------------------------------------! !  Discussion: ! !    ENVJ estimates -log(Jn(x)) from the estimate !    Jn(x) approx 1/sqrt(2*pi*n) *(e*x/(2*n))&#94;n ! !  Licensing: ! !    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, !    they give permission to incorporate this routine into a user program !    provided that the copyright is acknowledged. ! !  Modified: ! !    14 January 2016 ! !  Author: ! !    Shanjie Zhang,Jianming Jin !    Modifications suggested by Vincent Lafage,11 January 2016. ! !  Reference: ! !    Shanjie Zhang,Jianming Jin, !    Computation of Special Functions, !    Wiley,1996, !    ISBN: 0-471-11963-6, !    LC: QA351.C45. ! !  Parameters: ! !    Input,integer(kind = 4) N,the order of the Bessel function. ! !    Input,real(kind = 8) X,the absolute value of the argument. ! !    Output,real(kind = 8) ENVJ,the value. !------------------------------------------------------------------------! implicit none real ( kind = 8 ) envj real ( kind = 8 ) logten integer ( kind = 4 ) n real ( kind = 8 ) n_r8 real ( kind = 8 ) r8_gamma_log real ( kind = 8 ) x ! !  Original code ! if (. true .) then envj = 0.5D+00 * log10 ( 6.28D+00 * n ) & - n * log10 ( 1.36D+00 * x / n ) ! !  Modification suggested by Vincent Lafage. ! else n_r8 = real ( n , kind = 8 ) logten = log ( 1 0.0D+00 ) envj = r8_gamma_log ( n_r8 + 1.0D+00 ) / logten - n_r8 * log10 ( x ) end if return end !------------------------------------------------------------------------! function msta1 ( x , mp ) !------------------------------------------------------------------------! !! determines a backward recurrence starting point for Jn(x). !------------------------------------------------------------------------! !  Discussion: ! !    This procedure determines the starting point for backward !    recurrence such that the magnitude of !    Jn(x) at that point is about 10&#94;(-MP). ! !  Licensing: ! !    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, !    they give permission to incorporate this routine into a user program !    provided that the copyright is acknowledged. ! !  Modified: ! !    08 July 2012 ! !  Author: ! !    Shanjie Zhang,Jianming Jin ! !  Reference: ! !    Shanjie Zhang,Jianming Jin, !    Computation of Special Functions, !    Wiley,1996, !    ISBN: 0-471-11963-6, !    LC: QA351.C45. ! !  Parameters: ! !    Input,real(kind = 8) X,the argument. ! !    Input,integer(kind = 4) MP,the negative logarithm of the !    desired magnitude. ! !    Output,integer(kind = 4) MSTA1,the starting point. !------------------------------------------------------------------------! implicit none real ( kind = 8 ) a0 !---------------------------------------------------------------------- ! commented because the envj is in the same module !\t\t  real(kind = 8) envj !----------------------------------------------------------------------- real ( kind = 8 ) f real ( kind = 8 ) f0 real ( kind = 8 ) f1 integer ( kind = 4 ) it integer ( kind = 4 ) mp integer ( kind = 4 ) msta1 integer ( kind = 4 ) n0 integer ( kind = 4 ) n1 integer ( kind = 4 ) nn real ( kind = 8 ) x a0 = abs ( x ) n0 = int ( 1.1D+00 * a0 ) + 1 f0 = envj ( n0 , a0 ) - mp n1 = n0 + 5 f1 = envj ( n1 , a0 ) - mp do it = 1 , 20 nn = n1 - ( n1 - n0 ) / ( 1.0D+00 - f0 / f1 ) f = envj ( nn , a0 ) - mp if ( abs ( nn - n1 ) < 1 ) then exit end if n0 = n1 f0 = f1 n1 = nn f1 = f end do msta1 = nn return end !------------------------------------------------------------------------! function msta2 ( x , n , mp ) !------------------------------------------------------------------------! !! determines a backward recurrence starting point for Jn(x). !------------------------------------------------------------------------! !  Discussion: ! !    This procedure determines the starting point for a backward !    recurrence such that all Jn(x) has MP significant digits. ! !    Jianming Jin supplied a modification to this code on 12 January 2016. ! !  Licensing: ! !    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, !    they give permission to incorporate this routine into a user program !    provided that the copyright is acknowledged. ! !  Modified: ! !    14 January 2016 ! !  Author: ! !    Shanjie Zhang,Jianming Jin ! !  Reference: ! !    Shanjie Zhang,Jianming Jin, !    Computation of Special Functions, !    Wiley,1996, !    ISBN: 0-471-11963-6, !    LC: QA351.C45. ! !  Parameters: ! !    Input,real(kind = 8) X,the argument of Jn(x). ! !    Input,integer(kind = 4) N,the order of Jn(x). ! !    Input,integer(kind = 4) MP,the number of significant digits. ! !    Output,integer(kind = 4) MSTA2,the starting point. !------------------------------------------------------------------------! implicit none real ( kind = 8 ) a0 real ( kind = 8 ) ejn !---------------------------------------------------------------------- ! commented because the envj is in the same module !\t\t  real(kind = 8) envj !---------------------------------------------------------------------- real ( kind = 8 ) f real ( kind = 8 ) f0 real ( kind = 8 ) f1 real ( kind = 8 ) hmp integer ( kind = 4 ) it integer ( kind = 4 ) mp integer ( kind = 4 ) msta2 integer ( kind = 4 ) n integer ( kind = 4 ) n0 integer ( kind = 4 ) n1 integer ( kind = 4 ) nn real ( kind = 8 ) obj real ( kind = 8 ) x a0 = abs ( x ) hmp = 0.5D+00 * mp ejn = envj ( n , a0 ) if ( ejn <= hmp ) then obj = mp ! !  Original code: ! !   n0 = int(1.1D+00 * a0) ! !  Updated code: ! n0 = int ( 1.1D+00 * a0 ) + 1 else obj = hmp + ejn n0 = n end if f0 = envj ( n0 , a0 ) - obj n1 = n0 + 5 f1 = envj ( n1 , a0 ) - obj do it = 1 , 20 nn = n1 - ( n1 - n0 ) / ( 1.0D+00 - f0 / f1 ) f = envj ( nn , a0 ) - obj if ( abs ( nn - n1 ) < 1 ) then exit end if n0 = n1 f0 = f1 n1 = nn f1 = f end do msta2 = nn + 10 return end !------------------------------------------------------------------------! end module special_functions_mod","tags":"","loc":"sourcefile/special_functions_mod.f90.html"},{"title":"input_reader_mod.f90 – the SCATTERING code","text":"This file depends on sourcefile~~input_reader_mod.f90~~EfferentGraph sourcefile~input_reader_mod.f90 input_reader_mod.f90 sourcefile~utility_functions_mod.f90 utility_functions_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~array_operations_mod.f90 array_operations_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~array_operations_mod.f90 sourcefile~input_validation_mod.f90 input_validation_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~input_validation_mod.f90 sourcefile~data_mod.f90 data_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~data_mod.f90 sourcefile~input_validation_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~input_validation_mod.f90->sourcefile~data_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~input_reader_mod.f90~~AfferentGraph sourcefile~input_reader_mod.f90 input_reader_mod.f90 sourcefile~radial_coupling_terms_mod.f90 radial_coupling_terms_mod.f90 sourcefile~radial_coupling_terms_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~pes_matrix_mod.f90 pes_matrix_mod.f90 sourcefile~pes_matrix_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~pes_matrix_mod.f90->sourcefile~radial_coupling_terms_mod.f90 sourcefile~scattering.f90 scattering.f90 sourcefile~scattering.f90->sourcefile~input_reader_mod.f90 sourcefile~scattering.f90->sourcefile~radial_coupling_terms_mod.f90 sourcefile~scattering.f90->sourcefile~pes_matrix_mod.f90 sourcefile~channels_mod.f90 channels_mod.f90 sourcefile~scattering.f90->sourcefile~channels_mod.f90 sourcefile~propagator_mod.f90 propagator_mod.f90 sourcefile~scattering.f90->sourcefile~propagator_mod.f90 sourcefile~state_to_state_cross_sections_mod.f90 state_to_state_cross_sections_mod.f90 sourcefile~scattering.f90->sourcefile~state_to_state_cross_sections_mod.f90 sourcefile~boundary_conditions_mod.f90 boundary_conditions_mod.f90 sourcefile~scattering.f90->sourcefile~boundary_conditions_mod.f90 sourcefile~centrifugal_matrix_mod.f90 centrifugal_matrix_mod.f90 sourcefile~centrifugal_matrix_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~channels_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~propagator_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~propagator_mod.f90->sourcefile~pes_matrix_mod.f90 sourcefile~propagator_mod.f90->sourcefile~centrifugal_matrix_mod.f90 sourcefile~state_to_state_cross_sections_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~boundary_conditions_mod.f90->sourcefile~input_reader_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules io_mod Source Code input_reader_mod.f90 Source Code module io_mod !! this module provides following functions and subroutines: !! 1. input_file - reads the input file prepared by the user !! 2. input_check - checks the variables supplied in the input file !! 3. input_summary - summary of the input variables !! 5. etotal (function) - returns the total energy of the system !! 6. wavenumber_squared_from_energy (function) - returns the wavenumber !! 7. units_conversion - converts all physical quantities to atomic units !! 8. count_available_xs (function) - counts energetically accessible !!    levels in the basis !! 9. jaccess (function) - returns jopen and waveopen - arrays needed for !!    calculations of the state-to-state XS !---------------------------------------------------------------------------! use , intrinsic :: iso_fortran_env , only : int32 , sp => real32 , dp => real64 use utility_functions_mod , only : file_io_status , write_error , write_message ,& incorrect_value , integer_to_character , float_to_character use array_operations_mod , only : allocate_1d , allocate_2d , allocate_3d use data_mod use input_validation !------------------------------------------------------------------------------! implicit none !---------------------------------------------------------------------------! contains subroutine read_input_file !! reads the input file prepared by the user using NAMELIST feature !! the code uses 3 namelists: input, basis and potential !------------------------------------------------------------------------! character ( len = 200 ) :: err_message integer ( int32 ) :: ilevel , iilevel , icoupl , icol , il , io_status !------------------------------------------------------------------------! namelist / INPUT / label , reduced_mass , relative_energy_flag , energy , & jtotmin , jtotmax , jtotstep , rmin , rmax , dr , steps , vdepth , & consecutive_blocks_threshold , elastic_xs_threshold , & inelastic_xs_threshold , nlevel , initial , nr , nterms , & total_number_of_coupling_terms , n_skip_lines , iunits , & potentialfile , smatrixfile , print_partial_cross_sections , & partialfile , prntlvl namelist / BASIS / v1array , j1array , elevel namelist / POTENTIAL / l1tab , v1pes , j1pes , v1ppes , j1ppes !------------------------------------------------------------------------------! open ( unit = 5 , action = 'read' , form = 'formatted' , access = 'sequential' , & status = 'old' , iostat = io_status , iomsg = err_message ) call file_io_status ( io_status , err_message , 5 , 'o' ) !------------------------------------------------------------------------------! ! Read the input namelist:                                                     ! !------------------------------------------------------------------------------! read ( unit = 5 , nml = INPUT , iostat = io_status , iomsg = err_message ) call file_io_status ( io_status , err_message , 5 , 'r' ) !------------------------------------------------------------------------------! ! Check if the variables from input namelist are supplied correctly:           ! !------------------------------------------------------------------------------! call check_namelist_input if ( jtotmax . eq . - 1 ) jtotmax = 999999 call allocate_1d ( v1array , nlevel ) call allocate_1d ( j1array , nlevel ) call allocate_1d ( elevel , nlevel ) call allocate_1d ( l1tab , nterms ) call allocate_1d ( v1pes , total_number_of_coupling_terms ) call allocate_1d ( v1ppes , total_number_of_coupling_terms ) call allocate_1d ( j1pes , total_number_of_coupling_terms ) call allocate_1d ( j1ppes , total_number_of_coupling_terms ) select case ( iunits ) case ( 0 ) radial_term_distance_converter = 1.0_dp case ( 1 ) radial_term_distance_converter = bohrtoangstrom end select radial_term_energy_converter = 1.0_dp / hartreetocm !------------------------------------------------------------------------------! ! Read the basis namelist & check if the values were supplied correctly:       ! !------------------------------------------------------------------------------! read ( unit = 5 , nml = BASIS , iostat = io_status , iomsg = err_message ) call file_io_status ( io_status , err_message , 5 , 'r' ) call check_namelist_basis !------------------------------------------------------------------------------! ! If itype = 2/4 the code reads all the total_number_of_coupling_terms coupling terms, but some of   ! ! them will not be used in the calculations. Here, the code prepares           ! ! the arrays of minimal_number_of_coupling_terms size, that will hold only the necessary terms           ! !------------------------------------------------------------------------------! minimal_number_of_coupling_terms = nlevel * ( nlevel + 1 ) / 2 call allocate_1d ( reduced_j1pes , minimal_number_of_coupling_terms ) call allocate_1d ( reduced_j1ppes , minimal_number_of_coupling_terms ) call allocate_1d ( reduced_v1pes , minimal_number_of_coupling_terms ) call allocate_1d ( reduced_v1ppes , minimal_number_of_coupling_terms ) icoupl = 0 do ilevel = 1 , nlevel do iilevel = ilevel , nlevel icoupl = icoupl + 1 reduced_v1pes ( icoupl ) = v1array ( ilevel ) reduced_j1pes ( icoupl ) = j1array ( ilevel ) reduced_v1ppes ( icoupl ) = v1array ( iilevel ) reduced_j1ppes ( icoupl ) = j1array ( iilevel ) enddo enddo !------------------------------------------------------------------------------! ! Read the potential namelist & check if the values were supplied correctly:   ! !------------------------------------------------------------------------------! read ( unit = 5 , nml = POTENTIAL , iostat = io_status , iomsg = err_message ) call file_io_status ( io_status , err_message , 5 , 'r' ) call check_namelist_potential close ( 5 ) !------------------------------------------------------------------------------! ! Prepare the arrays that are needed for interpolation of the coupling terms:  ! !------------------------------------------------------------------------------! call allocate_1d ( rmat , nr ) call allocate_3d ( read_vmat3D , nr , nterms , total_number_of_coupling_terms ) call allocate_3d ( vmat3D , nr , nterms , minimal_number_of_coupling_terms ) call allocate_3d ( bmat3D , nr , nterms , minimal_number_of_coupling_terms ) call allocate_3d ( cmat3D , nr , nterms , minimal_number_of_coupling_terms ) call allocate_3d ( dmat3D , nr , nterms , minimal_number_of_coupling_terms ) !------------------------------------------------------------------------------! ! Summarize the input parameters:                                              ! !------------------------------------------------------------------------------! call input_summary end subroutine read_input_file !------------------------------------------------------------------------------! !------------------------------------------------------------------------------! subroutine input_summary !! summarize the input parameters for the current run !------------------------------------------------------------------------! integer ( int32 ) :: ilevel !------------------------------------------------------------------------! call write_message ( \"User-supplied label: \" // label ) call write_message ( \"Reduced mass: \" // & trim ( adjustl ( float_to_character ( reduced_mass , \"(F10.4)\" ))) // \" a.m.u.\" ) call write_message ( \"*** Energy levels in the basis set: ***\" ) call write_message ( \"   v       j            Energy (cm&#94;{-1})\" ) do ilevel = 1 , nlevel write ( * , \"(I4,4X,I4,16X,F12.4)\" ) v1array ( ilevel ), j1array ( ilevel ), elevel ( ilevel ) enddo write ( * , \"(44X,A3)\" ) \"***\" if ( jtotmax . ne . 999999 ) then call write_message ( \"The equations will be solved \" // & \"for total angular momentum J from \" // & trim ( adjustl ( integer_to_character ( jtotmin ))) // \" to \" & // trim ( adjustl ( integer_to_character ( jtotmax ))) // \" with step \" // & trim ( adjustl ( integer_to_character ( jtotstep )))) else call write_message ( \"The loop over JTOT will be performed from \" // & trim ( adjustl ( integer_to_character ( jtotmin ))) // \" with step \" // & trim ( adjustl ( integer_to_character ( jtotstep ))) // \" until \" // & trim ( adjustl ( integer_to_character ( consecutive_blocks_threshold ))) // & \" consecutive JTOT-blocks contribute less than \" // & trim ( adjustl ( float_to_character ( elastic_xs_threshold , \"(E10.4)\" ))) // & \" A&#94;2 to the elastic XS and less than \" // & trim ( adjustl ( float_to_character ( inelastic_xs_threshold , \"(E10.4)\" ))) // & \" A&#94;2 to the inelastic XS\" ) endif if ( relative_energy_flag . eq . 0 ) then call write_message ( \"The calculations will be performed for the total energy equal to \" & // trim ( adjustl ( float_to_character ( ETOTAL (), \"(F10.4)\" ))) // \" cm-1\" ) else if ( relative_energy_flag . eq . 1 ) then call write_message ( \"Relative kinetic energy of the colliding system: \" // & trim ( adjustl ( float_to_character ( energy , \"(F10.4)\" ))) // \" cm-1\" ) call write_message ( \"The kinetic energy is calculated with respect to the\" // & \" v = \" // trim ( adjustl ( integer_to_character ( v1array ( initial )))) // & \" j = \" // trim ( adjustl ( integer_to_character ( j1array ( initial )))) // & \" level in the basis set with the rotational energy \" // & trim ( adjustl ( float_to_character ( elevel ( initial ), \"(F10.4)\" ))) & // \" cm-1.\" ) call write_message ( \"This gives the total energy equal to \" // & trim ( adjustl ( float_to_character ( ETOTAL (), \"(F10.4)\" ))) // \" cm-1\" ) endif if ( print_partial_cross_sections ) then call write_message ( \"Partial cross sections will be saved into \" // partialfile ) endif call write_message ( \"S-matrix elements will be saved into \" // smatrixfile ) !------------------------------------------------------------------------! end subroutine input_summary !------------------------------------------------------------------------------! subroutine units_conversion !! converts all physical quantities to atomic units !------------------------------------------------------------------------! integer ( int32 ) :: ilevel !------------------------------------------------------------------------! reduced_mass = reduced_mass * amutoau energy = energy / hartreetocm vdepth = vdepth / hartreetocm !------------------------------------------------------------------------! do ilevel = 1 , nlevel elevel ( ilevel ) = elevel ( ilevel ) / hartreetocm enddo !------------------------------------------------------------------------! units_converted = . true . !------------------------------------------------------------------------! end subroutine units_conversion !------------------------------------------------------------------------------! function ETOTAL () result ( etot_ ) !! returns the total energy !------------------------------------------------------------------------! real ( dp ) :: etot_ !------------------------------------------------------------------------! if ( relative_energy_flag . eq . 0 ) then etot_ = energy else if ( relative_energy_flag . eq . 1 ) then etot_ = energy + elevel ( initial ) endif !------------------------------------------------------------------------! end function !------------------------------------------------------------------------------! function wavenumber_squared_from_energy ( energy_ ) result ( k_ ) !! returns the squared wavenumber, \\k_{a}&#94;{2}\\, !! given the energy of a given state, \\E_{a}\\; !! calls etot() function; atomic units in the whole function !! \\ k_{a} = \\sqrt(2 \\mu (E_{tot} - E_{a}) \\ !! since it uses reduced_mass and etotal(), the function checks !! if units are already converted !------------------------------------------------------------------------! real ( dp ), intent ( in ) :: energy_ !! energy of a given state, \\ E_{a} \\, in a.u. real ( dp ) :: k_ !! wavenumber, \\k_{a}\\, in a.u. !------------------------------------------------------------------------! if ( units_converted ) then !---------------------------------------------------------------------! ! abs() is for closed channels, see... !---------------------------------------------------------------------! k_ = 2 * reduced_mass * ( ETOTAL () - energy_ ) else call write_error ( \"wavenumber_squared_from_energy called but units are not \" // & \"converted yet\" ) endif !------------------------------------------------------------------------! end function wavenumber_squared_from_energy !------------------------------------------------------------------------------! function is_open ( energy_ ) result ( is_open_ ) !! checks if a channel/level is energetically accessible (open) !! by comparing energy with etotal() !------------------------------------------------------------------------! real ( dp ), intent ( in ) :: energy_ !! level/channel energy logical :: is_open_ !------------------------------------------------------------------------! is_open_ = ( energy_ <= ETOTAL () ) !------------------------------------------------------------------------! end function is_open !------------------------------------------------------------------------------! function count_open_basis_levels () result ( open_ ) !! counts the energetically accessible levels in the basis !------------------------------------------------------------------------! integer ( int32 ) :: open_ , ilevel !------------------------------------------------------------------------! open_ = 0 do ilevel = 1 , nlevel if ( is_open ( elevel ( ilevel ))) open_ = open_ + 1 enddo !------------------------------------------------------------------------! end function count_open_basis_levels !------------------------------------------------------------------------------! subroutine save_open_basis_levels ( number_of_open_basis_levels , & open_basis_levels , open_basis_wavevectors ) !! saves indices to open levels in the basis and corresponding !! wavenumbers (in A&#94;2) !------------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: number_of_open_basis_levels !! number of energetically accessible levels in the basis integer ( int32 ), intent ( inout ), allocatable :: open_basis_levels (:) !! array holding indices to energetically accessible levels in the basis real ( dp ), intent ( inout ), allocatable :: open_basis_wavevectors (:) !! array holding wavevectors calculated w.r.t energetically accessible levels in the basis !------------------------------------------------------------------------! integer ( int32 ) :: count_ , ilevel !------------------------------------------------------------------------! call allocate_1d ( open_basis_levels , number_of_open_basis_levels ) call allocate_1d ( open_basis_wavevectors , number_of_open_basis_levels ) !------------------------------------------------------------------------! count_ = 0 do ilevel = 1 , nlevel if ( is_open ( elevel ( ilevel ))) then count_ = count_ + 1 open_basis_levels ( count_ ) = ilevel open_basis_wavevectors ( count_ ) = & sqrt ( wavenumber_squared_from_energy ( elevel ( ilevel )) ) / bohrtoangstrom endif enddo !------------------------------------------------------------------------! end subroutine save_open_basis_levels !------------------------------------------------------------------------------! end module io_mod","tags":"","loc":"sourcefile/input_reader_mod.f90.html"},{"title":"math_functions_mod.f90 – the SCATTERING code","text":"This file depends on sourcefile~~math_functions_mod.f90~~EfferentGraph sourcefile~math_functions_mod.f90 math_functions_mod.f90 sourcefile~utility_functions_mod.f90 utility_functions_mod.f90 sourcefile~math_functions_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~special_functions_mod.f90 special_functions_mod.f90 sourcefile~math_functions_mod.f90->sourcefile~special_functions_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~math_functions_mod.f90~~AfferentGraph sourcefile~math_functions_mod.f90 math_functions_mod.f90 sourcefile~radial_coupling_terms_mod.f90 radial_coupling_terms_mod.f90 sourcefile~radial_coupling_terms_mod.f90->sourcefile~math_functions_mod.f90 sourcefile~pes_matrix_mod.f90 pes_matrix_mod.f90 sourcefile~pes_matrix_mod.f90->sourcefile~math_functions_mod.f90 sourcefile~pes_matrix_mod.f90->sourcefile~radial_coupling_terms_mod.f90 sourcefile~boundary_conditions_mod.f90 boundary_conditions_mod.f90 sourcefile~boundary_conditions_mod.f90->sourcefile~math_functions_mod.f90 sourcefile~scattering.f90 scattering.f90 sourcefile~scattering.f90->sourcefile~radial_coupling_terms_mod.f90 sourcefile~scattering.f90->sourcefile~pes_matrix_mod.f90 sourcefile~scattering.f90->sourcefile~boundary_conditions_mod.f90 sourcefile~propagator_mod.f90 propagator_mod.f90 sourcefile~scattering.f90->sourcefile~propagator_mod.f90 sourcefile~propagator_mod.f90->sourcefile~pes_matrix_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules math_functions_mod Source Code math_functions_mod.f90 Source Code module math_functions_mod !! this module holds 4 types of functions: !! -- algebraic functions: percival_seaton_coefficient !! -- geometric functions: triangle_inequality_holds, is_sum_even, zero_projections_3j_condition !! -- bessel functions: groups functions: riccati_bessel_j, bessely and modified_bessel_k_ratio !!    that call special functions from special_functions.f90 library !! -- interpolation procedures: spline and ispline functions for interpolating data !! -- additional functions: rctj, rcty, envj, msta1, msta2, ikv, gamma from !!    special_functions library !---------------------------------------------------------------------------! use , intrinsic :: iso_fortran_env , only : int32 , sp => real32 , dp => real64 use utility_functions_mod , only : write_error , write_warning , & integer_to_character , float_to_character , time_count_summary use special_functions_mod , only : rctj , rcty !---------------------------------------------------------------------------! implicit none contains !---------------------------------------------------------------------------! !                           Algebraic functions !---------------------------------------------------------------------------! function percival_seaton_coefficient ( j_ , j_prime_ , lambda_ , omega_ ) & result ( percival_seaton_coefficient_ ) !! calculates Percival-Seaton coefficients (body-fixed variant) !! \\begin{equation} !! \\label{eq:algebraic_coeffs} !! g_{{\\lambda},\\gamma,\\gamma'}&#94;{Jp} = \\delta_{\\bar{\\Omega},\\bar{\\Omega}'} (-1)&#94;{\\bar{\\Omega}} \\sqrt{(2j+1)(2j'+1)} !! \\begin{pmatrix} !!   j & j' & \\lambda \\\\ 0 & 0 & 0 !! \\end{pmatrix} !! \\begin{pmatrix} !! j & j' & \\lambda \\\\ \\bar{\\Omega} & -\\bar{\\Omega} & 0 \\end{pmatrix}. !! \\end{equation} !------------------------------------------------------------------------! use fwigxjpf , only : fwig3jj !------------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: j_ !! pre-collisional rotational angular momentum integer ( int32 ), intent ( in ) :: j_prime_ !! post-collisional rotational angular momentum integer ( int32 ), intent ( in ) :: omega_ !! \\\\bar{\\Omega}\\ integer ( int32 ), intent ( in ) :: lambda_ !! Legendre expansion coefficient \\ \\lambda\\ real ( dp ) :: percival_seaton_coefficient_ !! (out) result: percival seaton coefficient in the body-fixed frame !------------------------------------------------------------------------! percival_seaton_coefficient_ = ( - 1.0_dp ) ** ( omega_ ) * sqrt ( & real (( 2 * j_ + 1 ) * ( 2 * j_prime_ + 1 ), dp )) & * fwig3jj ( 2 * j_ , 2 * j_prime_ , 2 * lambda_ , 0 , 0 , 0 ) & * fwig3jj ( 2 * j_ , 2 * j_prime_ , 2 * lambda_ , & 2 * omega_ , - 2 * omega_ , 0 ) !------------------------------------------------------------------------! end function percival_seaton_coefficient !---------------------------------------------------------------------------! !                           Geometric functions !---------------------------------------------------------------------------! function triangle_inequality_holds ( x , y , z ) result ( holds ) !! check if the triangle inequality for 3 variables hols !------------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: x , y , z !! variables to check the triangle inequality logical :: holds !! (out) result: true/false !------------------------------------------------------------------------! holds = ( ( x + y >= z ) . and . ( x + z >= y ) . and . ( y + z >= x ) ) !------------------------------------------------------------------------! end function triangle_inequality_holds !---------------------------------------------------------------------------! function is_sum_even ( x , y , z ) result ( sum_even ) !! checks if the sum of 3 integers is an even integer !------------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: x , y , z !! variables to check if the sum is even logical :: sum_even !! (out) result: true/false !------------------------------------------------------------------------! sum_even = ( modulo ( x + y + z , 2 ) == 0 ) !------------------------------------------------------------------------! end function is_sum_even !---------------------------------------------------------------------------! function zero_projections_3j_condition ( x , y , z ) result ( is_valid ) !! checks the condition for nonvanishing 3-j symbol with zero projections: !! triangle inequality on x,y,z and if the sum x+y+z is an even integer !------------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: x , y , z !! variables to check for 3-j symbol conditions logical :: is_valid !! (out) result: true/false if conditions are met !------------------------------------------------------------------------! is_valid = ( triangle_inequality_holds ( x , y , z ) . and . is_sum_even ( x , y , z )) !------------------------------------------------------------------------! end function zero_projections_3j_condition !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! !                             Bessel functions ! these functions handle calling to specific subroutines from ! special_functions.f90 library !---------------------------------------------------------------------------! subroutine riccati_bessel_j ( l_ , x_ , j_ , jp_ ) !! calculates the Riccati-Bessel function of the first kind and its !! first derivative. Calls the rctj function from special_functions.f90 !------------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: l_ !! l - order of the Riccati-Bessel function of the first kind real ( dp ), intent ( in ) :: x_ !! x - argument of the Riccati-Bessel function of the first kind real ( dp ), intent ( inout ) :: j_ !! j_{l} (x) - Riccati-Bessel funciton of the first kind real ( dp ), intent ( inout ) :: jp_ !! j_{l}' (x) - derivative of the Riccati-Bessel funciton of the first kind !------------------------------------------------------------------------! integer ( int32 ) :: highest_order_ real ( dp ), dimension ( l_ + 1 ) :: rj_ , dj_ !------------------------------------------------------------------------! if ( l_ == 0 ) then call rctj ( l_ + 1 , x_ , highest_order_ , rj_ , dj_ ) else call rctj ( l_ , x_ , highest_order_ , rj_ , dj_ ) endif if ( highest_order_ < l_ ) then !---------------------------------------------------------------------! call write_warning ( \"riccati_bessel_j: maximum order of Riccati-Bessel function:\" & // trim ( adjustl ( integer_to_character ( highest_order_ ))) // \"is smaller than \" // & \"requested order l = \" // trim ( adjustl ( integer_to_character ( l_ ))) ) !---------------------------------------------------------------------! j_ = rj_ ( highest_order_ ) jp_ = dj_ ( highest_order_ ) else j_ = rj_ ( l_ + 1 ) jp_ = dj_ ( l_ + 1 ) endif !------------------------------------------------------------------------! end subroutine riccati_bessel_j !---------------------------------------------------------------------------! subroutine riccati_bessel_y ( l_ , x_ , y_ , yp_ ) !! calculates the Riccati-Bessel function of the second kind and its !! first derivative. Calls the rcty function from special_functions.f90 !------------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: l_ !! l - order of the Riccati-Bessel function of the second kind real ( dp ), intent ( in ) :: x_ !! x - argument of the Riccati-Bessel function of the second kind real ( dp ), intent ( inout ) :: y_ !! y_{l} (x) - Riccati-Bessel funciton of the second kind real ( dp ), intent ( inout ) :: yp_ !! y_{l}' (x) - derivative of the Riccati-Bessel funciton of the second kind !------------------------------------------------------------------------! integer ( int32 ) :: highest_order_ real ( dp ), dimension ( l_ + 1 ) :: ry_ , dy_ !------------------------------------------------------------------------! if ( l_ == 0 ) then call rcty ( l_ + 1 , x_ , highest_order_ , ry_ , dy_ ) else call rcty ( l_ , x_ , highest_order_ , ry_ , dy_ ) endif y_ = ry_ ( l_ + 1 ) yp_ = dy_ ( l_ + 1 ) !------------------------------------------------------------------------! if ( highest_order_ < l_ ) then !---------------------------------------------------------------------! call write_warning ( \"riccati_bessel_j: maximum order of Riccati-Bessel function:\" & // trim ( adjustl ( integer_to_character ( highest_order_ ))) // \"is smaller than \" // & \"requested order l = \" // trim ( adjustl ( integer_to_character ( l_ ))) ) !---------------------------------------------------------------------! y_ = ry_ ( highest_order_ ) yp_ = dy_ ( highest_order_ ) else y_ = ry_ ( l_ + 1 ) yp_ = dy_ ( l_ + 1 ) endif !------------------------------------------------------------------------! end subroutine riccati_bessel_y !---------------------------------------------------------------------------! subroutine modified_bessel_k_ratio ( l_ , x_ , ratio_ ) !! calculates the ratio of the modified Bessel function of the second !! kind K_{l_ + 1/2}(x) and its first derivative (Eq. 8 in the !! \"Solution of the coupled equations\" section) !! Uses Temme's algorithm [N. M. Temme, J. Comput. Phys. 19 (1975) 324], !! implemented in \"modified_bessel_temme_algorithm\" subroutine; !! Unfortunately, the \"ikv\" function from special_functions !! library failed at large x_ values. !------------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: l_ !! l - order of the function (without the 1/2 factor!) real ( dp ), intent ( in ) :: x_ !! x - argument of the function real ( dp ), intent ( inout ) :: ratio_ !! ratio of the modified Bessel function of the second kind to its derivative !------------------------------------------------------------------------! real ( dp ) :: order_ , ck_ , dk_ , ek_ !------------------------------------------------------------------------! order_ = real ( l_ , dp ) + 0.5_dp call modified_bessel_temme_algorithm ( order_ , x_ , ck_ , dk_ , ek_ ) ratio_ = dk_ / ck_ !------------------------------------------------------------------------! end subroutine modified_bessel_k_ratio !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine modified_bessel_temme_algorithm ( v , x , ck , dk , ek ) !! Implementation of the Temme's algorithm !! [N. M. Temme, J. Comput. Phys. 19 (1975) 324] to calculating !! modified Bessel functions of the second kind. !! This is a direct modernization of the \"mbessk\" subroutine !! in MOLSCAT: !! https://github.com/molscat/molscat/blob/master/source_code/rbessk.f !------------------------------------------------------------------------! real ( dp ), intent ( in ) :: v , x real ( dp ), intent ( out ) :: ck , dk , ek real ( dp ) :: a , b , c , d , e , f , g , h , p , q , s , sk , y , ak , ak1 , ex , pi integer :: n , m , na , maxit real ( dp ), parameter :: eps = 1.0e-15_dp , xmin = 1.0_dp !------------------------------------------------------------------------! pi = acos ( - 1.0_dp ) if ( v < 0.0_dp . or . x <= 0.0_dp ) then call write_error ( \"modified_bessel_temme_algorithm: Invalid input values for v or x\" ) endif na = int ( v + 0.5_dp ) a = v - na if ( x < xmin ) then ! Small x: Temme's series for small x b = x / 2.0_dp d = - log ( b ) e = a * d c = a * pi if ( abs ( c ) < eps ) then c = 1.0_dp else c = c / sin ( c ) endif if ( abs ( e ) < eps ) then s = 1.0_dp else s = sinh ( e ) / e endif e = exp ( e ) ! Compute the gamma function and its derivatives P and Q ! Replace RGAMMA(A,P,Q) with a modern equivalent if necessary g = e * rgamma ( a , p , q ) e = ( e + 1.0_dp / e ) / 2.0_dp f = c * ( p * e + q * s * d ) e = a * a p = 0.5_dp * g * c q = 0.5_dp / g c = 1.0_dp d = b * b ak = f ak1 = p do n = 1 , maxit f = ( f * n + p + q ) / ( n * n - e ) c = c * d / n p = p / ( n - a ) q = q / ( n + a ) g = c * ( p - n * f ) h = c * f ak = ak + h ak1 = ak1 + g if ( abs ( h / ak ) + abs ( g / ak1 ) < eps ) exit end do f = ak g = ak1 / b ex = 0.0_dp else ! Large x: Temme's PQ method for large x c = 0.25_dp - a * a g = 1.0_dp f = 0.0_dp e = x * cos ( a * pi ) / pi / eps do n = 1 , maxit h = ( 2 * ( n + x ) * g - ( n - 1 + c / n ) * f ) / ( n + 1 ) f = g g = h if ( h * n > e ) exit end do p = f / g q = p b = x + x e = b - 2.0_dp do m = n , 1 , - 1 p = ( m - 1 + c / m ) / ( e + ( m + 1 ) * ( 2.0_dp - p )) q = p * ( q + 1.0_dp ) end do f = sqrt ( pi / b ) / ( 1.0_dp + q ) g = f * ( a + x + 0.5_dp - p ) / x ex = x endif ! Upward recursion p = 0.0_dp if ( na > 0 ) then y = 2.0_dp / x do n = 1 , na h = y * ( a + n ) * g + f f = g g = h if ( abs ( f ) > 4.0_dp ) then p = p + 1.0_dp f = 0.0625_dp * f g = 0.0625_dp * g endif end do endif ck = f dk = ( v / x ) * f - g sk = sqrt ( ck * ck + dk * dk ) ck = ck / sk dk = dk / sk ek = log ( sk ) + p * log ( 1 6.0_dp ) - ex end subroutine modified_bessel_temme_algorithm !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! function rgamma ( x , odd , even ) result ( rgamma_val ) !! Calculates 1/Gamma(1-X); modernized version of Molscat's !! rgamma function; see: !! https://github.com/molscat/molscat/blob/36fa8f93a92f851e9d84245dd6a972e2910541c5/source_code/rbesjy.f !!-----------------------------------------------------------------------! real ( dp ), intent ( in ) :: x real ( dp ), intent ( out ) :: odd , even real ( dp ) :: rgamma_val , x2 , alfa , beta integer :: i real ( dp ), dimension ( 12 ), save :: b = [ & - 0.283876542276024_dp , - 0.076852840844786_dp , & 0.001706305071096_dp , 0.001271927136655_dp , & 0.000076309597586_dp , - 0.000004971736704_dp , & - 0.000000865920800_dp , - 0.000000033126120_dp , & 0.000000001745136_dp , 0.000000000242310_dp , & 0.000000000009161_dp , - 0.000000000000170_dp ] x2 = x * x * 8.0_dp alfa = - 0.000000000000001_dp beta = 0.0_dp do i = 12 , 2 , - 2 beta = - ( 2 * alfa + beta ) alfa = - beta * x2 - alfa + b ( i ) end do even = ( beta / 2.0_dp + alfa ) * x2 - alfa + 0.921870293650453_dp alfa = - 0.000000000000034_dp beta = 0.0_dp do i = 11 , 1 , - 2 beta = - ( 2 * alfa + beta ) alfa = - beta * x2 - alfa + b ( i ) end do odd = 2 * ( alfa + beta ) rgamma_val = odd * x + even end function rgamma !---------------------------------------------------------------------------! !                          Interpolation procedures !---------------------------------------------------------------------------! subroutine spline ( N_ , x_ , y_ , b_ , c_ , d_ ) !! determines b, c and d coefficients of the cubic spline function !! y(x) = y_i + b_i * dx + c_i * dx&#94;2 + d_i * dx&#94;3, !! where dx = x - x_i, and x_i <= x < x_i+1. !! The algorithm is based on !! Gerald, C., and Wheatley, P., \"Applied Numerical Analysis\", Addison-Wesley, 1994. !------------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: N_ !! number of grid points real ( dp ), intent ( in ) :: x_ ( N_ ) !! grid points (ascending order) real ( dp ), intent ( in ) :: y_ ( N_ ) !! tabulated values real ( dp ), intent ( out ) :: b_ ( N_ ), c_ ( N_ ), d_ ( N_ ) !! arrays with coefficients of the spline function !------------------------------------------------------------------------! integer ( int32 ) :: i_ , j_ real ( dp ) :: w_ real ( dp ) :: diff_x_ ( N_ - 1 ) !------------------------------------------------------------------------! ! check if the number of points is larger than 4 !------------------------------------------------------------------------! if ( N_ < 4 ) then call write_error ( \"spline function called with \" // & trim ( adjustl ( integer_to_character ( N_ ))) // \" points\" ) endif !------------------------------------------------------------------------! ! check if x is sorted in ascending order !------------------------------------------------------------------------! do i_ = 2 , N_ if ( x_ ( i_ ) <= x_ ( i_ - 1 )) then call write_error ( \"spline: x values are not in ascending order \" // & \" at index \" // trim ( adjustl ( integer_to_character ( i_ )))) endif end do !------------------------------------------------------------------------! diff_x_ = x_ ( 2 : N_ ) - x_ ( 1 : N_ - 1 ) !------------------------------------------------------------------------! b_ ( 2 : N_ - 1 ) = 2.0_dp * ( diff_x_ ( 1 : N_ - 2 ) + diff_x_ ( 2 : N_ - 1 )) b_ ( 1 ) = - diff_x_ ( 1 ) b_ ( N_ ) = - diff_x_ ( N_ - 1 ) c_ ( 2 : N_ - 1 ) = ( y_ ( 3 : N_ ) - y_ ( 2 : N_ - 1 ) ) / diff_x_ ( 2 : N_ - 1 ) & - ( y_ ( 2 : N_ - 1 ) - y_ ( 1 : N_ - 2 ) ) / diff_x_ ( 1 : N_ - 2 ) c_ ( 1 ) = c_ ( 3 ) / ( x_ ( 4 ) - x_ ( 2 )) - c_ ( 2 ) / ( x_ ( 3 ) - x_ ( 1 )) c_ ( N_ ) = c_ ( N_ - 1 ) / ( x_ ( N_ ) - x_ ( N_ - 2 )) - c_ ( N_ - 2 ) / ( x_ ( N_ - 1 ) - x_ ( N_ - 3 )) c_ ( 1 ) = c_ ( 1 ) / ( x_ ( 4 ) - x_ ( 1 )) * diff_x_ ( 1 ) ** 2 c_ ( N_ ) = - c_ ( N_ ) / ( x_ ( N_ ) - x_ ( N_ - 3 )) * diff_x_ ( N_ - 1 ) ** 2 do i_ = 2 , N_ w_ = diff_x_ ( i_ - 1 ) / b_ ( i_ - 1 ) b_ ( i_ ) = b_ ( i_ ) - w_ * diff_x_ ( i_ - 1 ) c_ ( i_ ) = c_ ( i_ ) - w_ * c_ ( i_ - 1 ) end do c_ ( N_ ) = c_ ( N_ ) / b_ ( N_ ) do j_ = 1 , N_ - 1 i_ = N_ - j_ c_ ( i_ ) = ( c_ ( i_ ) - diff_x_ ( i_ ) * c_ ( i_ + 1 )) / b_ ( i_ ) end do b_ ( 1 : N_ - 1 ) = ( y_ ( 2 : N_ ) - y_ ( 1 : N_ - 1 ) ) / diff_x_ ( 1 : N_ - 1 ) & - ( 2.0_dp * c_ ( 1 : N_ - 1 ) + c_ ( 2 : N_ ) ) * diff_x_ ( 1 : N_ - 1 ) d_ ( 1 : N_ - 1 ) = ( c_ ( 2 : N_ ) - c_ ( 1 : N_ - 1 ) ) / diff_x_ ( 1 : N_ - 1 ) c_ = c_ * 3.0_dp end subroutine spline !---------------------------------------------------------------------------! function ispline ( u_ , N_ , x_ , y_ , b_ , c_ , d_ ) result ( spl_result ) !! returns interpolated value at guven u_ point !! number of points and ascending order of x is not checked since !! ispline is called after \"spline\" where these checks are done !------------------------------------------------------------------------! real ( dp ), intent ( in ) :: u_ !! point at which the tabulated value is interpolated integer ( int32 ), intent ( in ) :: N_ !! number of grid points real ( dp ), intent ( in ) :: x_ ( N_ ) !! grid points real ( dp ), intent ( in ) :: y_ ( N_ ) !! tabulated values real ( dp ), intent ( in ) :: b_ ( N_ ), c_ ( N_ ), d_ ( N_ ) !! arrays with coefficients of the spline function real ( dp ) :: spl_result !! interpolated value at u_ !------------------------------------------------------------------------! integer ( int32 ) :: k_ , l_ , mid_ real ( dp ) :: dx_ !------------------------------------------------------------------------! if ( u_ > x_ ( N_ )) then call write_warning ( \"ispline: point u_ = \" // & trim ( adjustl ( float_to_character ( u_ ))) // \" exceeds the original \" & // \"grid: x(N) = \" // trim ( adjustl ( float_to_character ( x_ ( N_ ))))) spl_result = y_ ( N_ ) else if ( u_ < x_ ( 1 ) ) then call write_warning ( \"ispline: point u_ = \" // & trim ( adjustl ( float_to_character ( u_ ))) // \" exceeds the original \" & // \"grid: x(1) = \" // trim ( adjustl ( float_to_character ( x_ ( 1 ))))) spl_result = y_ ( 1 ) else !---------------------------------------------------------------------! l_ = 1 k_ = N_ + 1 do while ( k_ > l_ + 1 ) mid_ = nint ( ( l_ + k_ ) / 2.0_dp ) if ( x_ ( mid_ ) > u_ ) then k_ = mid_ else l_ = mid_ endif end do dx_ = u_ - x_ ( l_ ) spl_result = y_ ( l_ ) + dx_ * ( b_ ( l_ ) + dx_ * ( c_ ( l_ ) + d_ ( l_ ) * dx_ )) !---------------------------------------------------------------------! endif !------------------------------------------------------------------------! end function ispline !------------------------------------------------------------------------------! end module math_functions_mod","tags":"","loc":"sourcefile/math_functions_mod.f90.html"},{"title":"unitarity_check_mod.f90 – the SCATTERING code","text":"This file depends on sourcefile~~unitarity_check_mod.f90~~EfferentGraph sourcefile~unitarity_check_mod.f90 unitarity_check_mod.f90 sourcefile~data_mod.f90 data_mod.f90 sourcefile~unitarity_check_mod.f90->sourcefile~data_mod.f90 sourcefile~utility_functions_mod.f90 utility_functions_mod.f90 sourcefile~unitarity_check_mod.f90->sourcefile~utility_functions_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~unitarity_check_mod.f90~~AfferentGraph sourcefile~unitarity_check_mod.f90 unitarity_check_mod.f90 sourcefile~scattering.f90 scattering.f90 sourcefile~scattering.f90->sourcefile~unitarity_check_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules unitarity_check_mod Source Code unitarity_check_mod.f90 Source Code module unitarity_check_mod !! This module contains subroutines that check the unitarity condition !! of the S-matrix (see Eq. (13) in \"Solution of coupled equations\") !---------------------------------------------------------------------------! use , intrinsic :: iso_fortran_env , only : int32 , sp => real32 , dp => real64 use data_mod , only : unitary_tolerance use utility_functions_mod , only : write_warning , write_header , write_message !---------------------------------------------------------------------------! implicit none !---------------------------------------------------------------------------! contains !------------------------------------------------------------------------! subroutine unitarity_check ( number_of_open_channels , s_matrix_real , & s_matrix_imag , is_unitary ) !! checks the unitarity of the S-matrix !! (Eq. (13) in \"Solution of coupled equations\") !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: number_of_open_channels !! number of open channels real ( dp ), intent ( in ) :: s_matrix_real ( number_of_open_channels , number_of_open_channels ) !! real part of the S-matrix real ( dp ), intent ( in ) :: s_matrix_imag ( number_of_open_channels , number_of_open_channels ) !! imaginary part of the S-matrix logical , intent ( inout ) :: is_unitary !! (output) if .true. unitarity is fulfilled, .false. otherwise !---------------------------------------------------------------------! integer ( int32 ) :: channel_index real ( dp ) :: sum_of_squares ( number_of_open_channels ) !---------------------------------------------------------------------! is_unitary = . true . !---------------------------------------------------------------------! call write_header ( \"unitarity\" ) !---------------------------------------------------------------------! ! Calculating sum of squares for each channel !---------------------------------------------------------------------! call calculate_sum_of_squares_for_each_channel ( s_matrix_real , & s_matrix_imag , sum_of_squares ) !---------------------------------------------------------------------! ! Checking unitarity for each channel !---------------------------------------------------------------------! is_unitary = check_unitarity_for_each_channel ( sum_of_squares ) !---------------------------------------------------------------------! ! Handling the output message based on unitarity check !---------------------------------------------------------------------! call handle_unitarity_output_message ( is_unitary ) !---------------------------------------------------------------------! end subroutine unitarity_check !------------------------------------------------------------------------! subroutine calculate_sum_of_squares_for_each_channel ( s_matrix_real , & s_matrix_imag , sum_of_squares_ ) !! calculates the sum !! \\ \\sum\\_{\\gamma'} \\Bigl|{S}&#94;{Jp}\\_{\\gamma, \\gamma'}\\Bigr|&#94;{2} \\ !! for all \\\\gamma\\ channels !---------------------------------------------------------------------! real ( dp ), intent ( in ) :: s_matrix_real (:,:) !! real part of the S-matrix real ( dp ), intent ( in ) :: s_matrix_imag (:,:) !! imaginary part of the S-matrix real ( dp ), intent ( out ) :: sum_of_squares_ (:) !! (output) \\ \\sum\\_{\\gamma'} \\Bigl|{S}&#94;{Jp}\\_{\\gamma, \\gamma'}\\Bigr|&#94;{2} \\ !---------------------------------------------------------------------! integer ( int32 ) :: channel_index_ !---------------------------------------------------------------------! do channel_index_ = 1 , size ( s_matrix_real , 1 ) sum_of_squares_ ( channel_index_ ) = & sum ( s_matrix_real ( channel_index_ , :) ** 2 & + s_matrix_imag ( channel_index_ , :) ** 2 ) enddo !---------------------------------------------------------------------! end subroutine calculate_sum_of_squares_for_each_channel !------------------------------------------------------------------------! function check_unitarity_for_each_channel ( sum_of_squares ) & result ( is_unitary_ ) !! checks if the calculated sum of squares equals 1 for each channel !---------------------------------------------------------------------! real ( dp ), intent ( in ) :: sum_of_squares (:) !! \\ \\sum\\_{\\gamma'} \\Bigl|{S}&#94;{Jp}\\_{\\gamma, \\gamma'}\\Bigr|&#94;{2} \\ logical :: is_unitary_ !! (output) if .true. unitarity is fulfilled, .false. otherwise !---------------------------------------------------------------------! integer :: channel_index !---------------------------------------------------------------------! is_unitary_ = . true . do channel_index = 1 , size ( sum_of_squares ) if ( abs ( sum_of_squares ( channel_index ) - 1.0_dp ) > unitary_tolerance ) then is_unitary_ = . false . exit endif end do !---------------------------------------------------------------------! end function check_unitarity_for_each_channel !------------------------------------------------------------------------! subroutine handle_unitarity_output_message ( is_unitary ) !! handle printing messages depending on the outcome of unitarity check !---------------------------------------------------------------------! logical , intent ( in ) :: is_unitary !! if .true. unitarity is fulfilled, .false. otherwise !---------------------------------------------------------------------! if ( is_unitary ) then call write_message ( \"S-matrix unitary condition fulfilled\" ) else call write_warning ( \"Unitary condition is not fulfilled for one or more channels\" ) call write_message ( \"Consider increasing the STEPS parameter\" ) endif !---------------------------------------------------------------------! end subroutine handle_unitarity_output_message !---------------------------------------------------------------------------! end module unitarity_check_mod","tags":"","loc":"sourcefile/unitarity_check_mod.f90.html"},{"title":"array_operations_mod.f90 – the SCATTERING code","text":"Files dependent on this one sourcefile~~array_operations_mod.f90~~AfferentGraph sourcefile~array_operations_mod.f90 array_operations_mod.f90 sourcefile~input_reader_mod.f90 input_reader_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~array_operations_mod.f90 sourcefile~array_operations_invert_symmetric_matrix_submod.f90 array_operations_invert_symmetric_matrix_submod.f90 sourcefile~array_operations_invert_symmetric_matrix_submod.f90->sourcefile~array_operations_mod.f90 sourcefile~pes_matrix_mod.f90 pes_matrix_mod.f90 sourcefile~pes_matrix_mod.f90->sourcefile~array_operations_mod.f90 sourcefile~pes_matrix_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~radial_coupling_terms_mod.f90 radial_coupling_terms_mod.f90 sourcefile~pes_matrix_mod.f90->sourcefile~radial_coupling_terms_mod.f90 sourcefile~centrifugal_matrix_mod.f90 centrifugal_matrix_mod.f90 sourcefile~centrifugal_matrix_mod.f90->sourcefile~array_operations_mod.f90 sourcefile~centrifugal_matrix_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~array_operations_append_submod.f90 array_operations_append_submod.f90 sourcefile~array_operations_append_submod.f90->sourcefile~array_operations_mod.f90 sourcefile~scattering.f90 scattering.f90 sourcefile~scattering.f90->sourcefile~array_operations_mod.f90 sourcefile~scattering.f90->sourcefile~input_reader_mod.f90 sourcefile~scattering.f90->sourcefile~pes_matrix_mod.f90 sourcefile~propagator_mod.f90 propagator_mod.f90 sourcefile~scattering.f90->sourcefile~propagator_mod.f90 sourcefile~boundary_conditions_mod.f90 boundary_conditions_mod.f90 sourcefile~scattering.f90->sourcefile~boundary_conditions_mod.f90 sourcefile~scattering.f90->sourcefile~radial_coupling_terms_mod.f90 sourcefile~state_to_state_cross_sections_mod.f90 state_to_state_cross_sections_mod.f90 sourcefile~scattering.f90->sourcefile~state_to_state_cross_sections_mod.f90 sourcefile~channels_mod.f90 channels_mod.f90 sourcefile~scattering.f90->sourcefile~channels_mod.f90 sourcefile~propagator_mod.f90->sourcefile~array_operations_mod.f90 sourcefile~propagator_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~propagator_mod.f90->sourcefile~pes_matrix_mod.f90 sourcefile~propagator_mod.f90->sourcefile~centrifugal_matrix_mod.f90 sourcefile~array_operations_fill_symmetric_matrix_submod.f90 array_operations_fill_symmetric_matrix_submod.f90 sourcefile~array_operations_fill_symmetric_matrix_submod.f90->sourcefile~array_operations_mod.f90 sourcefile~array_operations_add_scalar_to_diagonal_submod.f90 array_operations_add_scalar_to_diagonal_submod.f90 sourcefile~array_operations_add_scalar_to_diagonal_submod.f90->sourcefile~array_operations_mod.f90 sourcefile~array_operations_allocate_submod.f90 array_operations_allocate_submod.f90 sourcefile~array_operations_allocate_submod.f90->sourcefile~array_operations_mod.f90 sourcefile~boundary_conditions_mod.f90->sourcefile~array_operations_mod.f90 sourcefile~boundary_conditions_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~radial_coupling_terms_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~state_to_state_cross_sections_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~channels_mod.f90->sourcefile~input_reader_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules array_operations_mod Source Code array_operations_mod.f90 Source Code module array_operations_mod !! this module provides supplementary functions and subroutines to handle !! matrix allocation, invertion, appending etc. !---------------------------------------------------------------------------! use , intrinsic :: iso_fortran_env , only : int32 , sp => real32 , dp => real64 implicit none !---------------------------------------------------------------------------! interface allocate_1d pure module subroutine allocate_1d_int32 ( array_ , size_ ) !! allocate a 1d array and fill it with 0s (integer version) integer ( int32 ), intent ( inout ), allocatable :: array_ (:) integer ( int32 ), intent ( in ) :: size_ end subroutine allocate_1d_int32 pure module subroutine allocate_1d_sp ( array_ , size_ ) !! allocate a 1d array and fill it with 0s (single precision version) real ( sp ), intent ( inout ), allocatable :: array_ (:) integer ( int32 ), intent ( in ) :: size_ end subroutine allocate_1d_sp pure module subroutine allocate_1d_dp ( array_ , size_ ) !! allocate a 1d array and fill it with 0s (double precision version) real ( dp ), intent ( inout ), allocatable :: array_ (:) integer ( int32 ), intent ( in ) :: size_ end subroutine allocate_1d_dp end interface !---------------------------------------------------------------------------! interface allocate_2d pure module subroutine allocate_2d_int32 ( array_ , size1_ , size2_ ) !! allocate a 2d array and fill it with 0s (integer version) integer ( int32 ), intent ( inout ), allocatable :: array_ (:,:) integer ( int32 ), intent ( in ) :: size1_ , size2_ end subroutine allocate_2d_int32 pure module subroutine allocate_2d_sp ( array_ , size1_ , size2_ ) !! allocate a 2d array and fill it with 0s (single precision version) real ( sp ), intent ( inout ), allocatable :: array_ (:,:) integer ( int32 ), intent ( in ) :: size1_ , size2_ end subroutine allocate_2d_sp pure module subroutine allocate_2d_dp ( array_ , size1_ , size2_ ) !! allocate a 2d array and fill it with 0s (double precision version) real ( dp ), intent ( inout ), allocatable :: array_ (:,:) integer ( int32 ), intent ( in ) :: size1_ , size2_ end subroutine allocate_2d_dp end interface !---------------------------------------------------------------------------! interface allocate_3d pure module subroutine allocate_3d_int32 ( array_ , size1_ , size2_ , size3_ ) !! allocate a 3d array and fill it with 0s (integer version) integer ( int32 ), intent ( inout ), allocatable :: array_ (:,:,:) integer ( int32 ), intent ( in ) :: size1_ , size2_ , size3_ end subroutine allocate_3d_int32 pure module subroutine allocate_3d_sp ( array_ , size1_ , size2_ , size3_ ) !! allocate a 3d array and fill it with 0s (single precision version) real ( sp ), intent ( inout ), allocatable :: array_ (:,:,:) integer ( int32 ), intent ( in ) :: size1_ , size2_ , size3_ end subroutine allocate_3d_sp pure module subroutine allocate_3d_dp ( array_ , size1_ , size2_ , size3_ ) !! allocate a 3d array and fill it with 0s (double precision version) real ( dp ), intent ( inout ), allocatable :: array_ (:,:,:) integer ( int32 ), intent ( in ) :: size1_ , size2_ , size3_ end subroutine allocate_3d_dp end interface !---------------------------------------------------------------------------! interface append pure module subroutine append_int32 ( array_ , element_ ) !! append element to an array (integer version) integer ( int32 ), intent ( inout ), allocatable :: array_ (:) integer ( int32 ), intent ( in ) :: element_ end subroutine append_int32 pure module subroutine append_sp ( array_ , element_ ) !! append element to an array (single precision version) real ( sp ), intent ( inout ), allocatable :: array_ (:) real ( sp ), intent ( in ) :: element_ end subroutine append_sp pure module subroutine append_dp ( array_ , element_ ) !! append element to an array (double precision version) real ( dp ), intent ( inout ), allocatable :: array_ (:) real ( dp ), intent ( in ) :: element_ end subroutine append_dp end interface !---------------------------------------------------------------------------! !   interface print_square_matrix !      module subroutine print_square_matrix_int32(matrix_, tol_) !         !! print elements of the square matrix with given tolerance (integer version) !         integer(int32), intent(in)     :: matrix_(:,:) !         real(dp), optional, intent(in) :: tol_ !      end subroutine print_square_matrix_int32 !      module subroutine print_square_matrix_sp(matrix_, tol_) !         !! print elements of the square matrix with given tolerance (single precision version) !         real(sp), intent(in)           :: matrix_(:,:) !         real(dp), optional, intent(in) :: tol_ !      end subroutine print_square_matrix_sp !      module subroutine print_square_matrix_dp(matrix_, tol_) !         !! print elements of the square matrix with given tolerance (double precision version) !         real(dp), intent(in)           :: matrix_(:,:) !         real(dp), optional, intent(in) :: tol_ !      end subroutine print_square_matrix_dp !   end interface !---------------------------------------------------------------------------! interface invert_symmetric_matrix module subroutine invert_symmetric_matrix_int32 ( matrix_ ) !! invert a symmetric matrix using DSYTRI method (integer version) integer ( int32 ), intent ( inout ) :: matrix_ (:,:) end subroutine invert_symmetric_matrix_int32 module subroutine invert_symmetric_matrix_sp ( matrix_ ) !! invert a symmetric matrix using DSYTRI method (single precision version) real ( sp ), intent ( inout ) :: matrix_ (:,:) end subroutine invert_symmetric_matrix_sp module subroutine invert_symmetric_matrix_dp ( matrix_ ) !! invert a symmetric matrix using DSYTRI method (double precision version) real ( dp ), intent ( inout ) :: matrix_ (:,:) end subroutine invert_symmetric_matrix_dp end interface !---------------------------------------------------------------------------! interface fill_symmetric_matrix module subroutine fill_symmetric_matrix_int32 ( matrix_ , upper_lower_ ) !! fill the upper/lower triangle of a symmetric matrix (integer version) integer ( int32 ), intent ( inout ) :: matrix_ (:,:) character ( len = 1 ), intent ( in ) :: upper_lower_ end subroutine fill_symmetric_matrix_int32 module subroutine fill_symmetric_matrix_sp ( matrix_ , upper_lower_ ) !! fill the upper/lower triangle of a symmetric matrix (single precision version) real ( sp ), intent ( inout ) :: matrix_ (:,:) character ( len = 1 ), intent ( in ) :: upper_lower_ end subroutine fill_symmetric_matrix_sp module subroutine fill_symmetric_matrix_dp ( matrix_ , upper_lower_ ) !! fill the upper/lower triangle of a symmetric matrix (double precision version) real ( dp ), intent ( inout ) :: matrix_ (:,:) character ( len = 1 ), intent ( in ) :: upper_lower_ end subroutine fill_symmetric_matrix_dp end interface !---------------------------------------------------------------------------! interface add_scalar_to_diagonal module subroutine add_scalar_to_diagonal_int32 ( matrix_ , scalar_ ) !! add a scalar value to the matrix diagonal (integer version) integer ( int32 ), intent ( inout ) :: matrix_ (:,:) integer ( int32 ), intent ( in ) :: scalar_ end subroutine add_scalar_to_diagonal_int32 module subroutine add_scalar_to_diagonal_sp ( matrix_ , scalar_ ) !! add a scalar value to the matrix diagonal (single precision version) real ( sp ), intent ( inout ) :: matrix_ (:,:) real ( sp ), intent ( in ) :: scalar_ end subroutine add_scalar_to_diagonal_sp module subroutine add_scalar_to_diagonal_dp ( matrix_ , scalar_ ) !!! add a scalar value to the matrix diagonal (double precision version) real ( dp ), intent ( inout ) :: matrix_ (:,:) real ( dp ), intent ( in ) :: scalar_ end subroutine add_scalar_to_diagonal_dp end interface !---------------------------------------------------------------------------! end module array_operations_mod","tags":"","loc":"sourcefile/array_operations_mod.f90.html"},{"title":"array_operations_invert_symmetric_matrix_submod.f90 – the SCATTERING code","text":"This file depends on sourcefile~~array_operations_invert_symmetric_matrix_submod.f90~~EfferentGraph sourcefile~array_operations_invert_symmetric_matrix_submod.f90 array_operations_invert_symmetric_matrix_submod.f90 sourcefile~array_operations_mod.f90 array_operations_mod.f90 sourcefile~array_operations_invert_symmetric_matrix_submod.f90->sourcefile~array_operations_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules array_operations_invert_symmetric_matrix_submod Source Code array_operations_invert_symmetric_matrix_submod.f90 Source Code submodule ( array_operations_mod ) array_operations_invert_symmetric_matrix_submod !! a submodule for append subroutines implicit none contains module subroutine invert_symmetric_matrix_int32 ( matrix_ ) !! invert a symmetric matrix using DSYTRI method (integer version) integer ( int32 ), intent ( inout ) :: matrix_ (:,:) !---------------------------------------------------------------------! write ( * , * ) \"Integer version of Lapack inversion procedures does not exist\" write ( * , * ) \"Convert the integer arrays to real\" stop !---------------------------------------------------------------------! end subroutine invert_symmetric_matrix_int32 module subroutine invert_symmetric_matrix_sp ( matrix_ ) !! invert a symmetric matrix using SSYTRI method (single precision version) real ( sp ), intent ( inout ) :: matrix_ (:,:) !---------------------------------------------------------------------! integer ( int32 ) :: size_1_ , size_2_ , size_ , lwork_ , nb_ , ok_ , ILAENV integer ( int32 ), allocatable :: pivot_ (:) real ( sp ), allocatable :: work_ (:) !---------------------------------------------------------------------! size_1_ = size ( matrix_ , dim = 1 ) size_2_ = size ( matrix_ , dim = 2 ) if ( size_1_ . eq . size_2_ ) then size_ = size_1_ else print * , \"Error in invert_symmetric_matrix_dp: size in dim = 1 (\" , size_1_ ,& \") is different than in dim = 2 (\" , size_2_ , \")\" print * , \"Adapt this subroutine to rectangle matrices\" stop endif !---------------------------------------------------------------------! if ( allocated ( pivot_ )) deallocate ( pivot_ ) allocate ( pivot_ ( size_ )) !---------------------------------------------------------------------! nb_ = ILAENV ( 1 , 'SSYTRF' , 'L' , size_ , - 1 , - 1 , - 1 ) lwork_ = nb_ * size_ if ( allocated ( work_ )) deallocate ( work_ ) allocate ( work_ ( lwork_ )) work_ = 0 !---------------------------------------------------------------------! call SSYTRF ( 'L' , size_ , matrix_ , size_ , pivot_ , work_ , lwork_ , ok_ ) if ( ok_ /= 0 ) then write ( * , * ) \"DSYTRF failed with status:\" , ok_ stop endif !---------------------------------------------------------------------! call SSYTRI ( 'L' , size_ , matrix_ , size_ , pivot_ , work_ , ok_ ) if ( ok_ /= 0 ) then write ( * , * ) \"DSYTRI failed with status:\" , ok_ stop endif !---------------------------------------------------------------------! end subroutine invert_symmetric_matrix_sp module subroutine invert_symmetric_matrix_dp ( matrix_ ) !! invert a symmetric matrix using DSYTRI method (double precision version) real ( dp ), intent ( inout ) :: matrix_ (:,:) !---------------------------------------------------------------------! integer ( int32 ) :: size_1_ , size_2_ , size_ , lwork_ , nb_ , ok_ , ILAENV , i_size_ , i_size_2_ integer ( int32 ), allocatable :: pivot_ (:) real ( dp ), allocatable :: work_ (:) !---------------------------------------------------------------------! size_1_ = size ( matrix_ , dim = 1 ) size_2_ = size ( matrix_ , dim = 2 ) if ( size_1_ . eq . size_2_ ) then size_ = size_1_ else print * , \"Error in invert_symmetric_matrix_dp: size in dim = 1 (\" , size_1_ ,& \") is different than in dim = 2 (\" , size_2_ , \")\" print * , \"Adapt this subroutine to rectangle matrices\" stop endif !---------------------------------------------------------------------! if ( allocated ( pivot_ )) deallocate ( pivot_ ) allocate ( pivot_ ( size_ )) !---------------------------------------------------------------------! nb_ = ILAENV ( 1 , 'DSYTRF' , 'L' , size_ , - 1 , - 1 , - 1 ) lwork_ = nb_ * size_ if ( allocated ( work_ )) deallocate ( work_ ) allocate ( work_ ( lwork_ )) work_ = 0 !---------------------------------------------------------------------! call DSYTRF ( 'L' , size_ , matrix_ , size_ , pivot_ , work_ , lwork_ , ok_ ) if ( ok_ /= 0 ) then write ( * , * ) \"DSYTRF failed with status:\" , ok_ stop endif !---------------------------------------------------------------------! call DSYTRI ( 'L' , size_ , matrix_ , size_ , pivot_ , work_ , ok_ ) if ( ok_ /= 0 ) then write ( * , * ) \"DSYTRI failed with status:\" , ok_ stop endif !---------------------------------------------------------------------! end subroutine invert_symmetric_matrix_dp end submodule array_operations_invert_symmetric_matrix_submod","tags":"","loc":"sourcefile/array_operations_invert_symmetric_matrix_submod.f90.html"},{"title":"array_operations_append_submod.f90 – the SCATTERING code","text":"This file depends on sourcefile~~array_operations_append_submod.f90~~EfferentGraph sourcefile~array_operations_append_submod.f90 array_operations_append_submod.f90 sourcefile~array_operations_mod.f90 array_operations_mod.f90 sourcefile~array_operations_append_submod.f90->sourcefile~array_operations_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules array_operations_append_submod Source Code array_operations_append_submod.f90 Source Code submodule ( array_operations_mod ) array_operations_append_submod !! a submodule for append subroutines implicit none contains pure module subroutine append_int32 ( array_ , element_ ) !! append element to an array (intger version) integer ( int32 ), allocatable , intent ( inout ) :: array_ (:) integer ( int32 ), intent ( in ) :: element_ !---------------------------------------------------------------------! integer ( int32 ), allocatable :: tmp_array_ (:) !---------------------------------------------------------------------! if ( allocated ( array_ )) then allocate ( tmp_array_ ( size ( array_ ) + 1 )) tmp_array_ (: size ( array_ )) = array_ (:) tmp_array_ ( size ( array_ ) + 1 ) = element_ deallocate ( array_ ) allocate ( array_ ( size ( tmp_array_ ))) call move_alloc ( tmp_array_ , array_ ) else allocate ( array_ ( 1 )) array_ ( 1 ) = element_ endif end subroutine append_int32 pure module subroutine append_sp ( array_ , element_ ) !! append element to an array (single precision version) real ( sp ), allocatable , intent ( inout ) :: array_ (:) real ( sp ), intent ( in ) :: element_ !---------------------------------------------------------------------! real ( sp ), allocatable :: tmp_array_ (:) !---------------------------------------------------------------------! if ( allocated ( array_ )) then allocate ( tmp_array_ ( size ( array_ ) + 1 )) tmp_array_ (: size ( array_ )) = array_ (:) tmp_array_ ( size ( array_ ) + 1 ) = element_ deallocate ( array_ ) allocate ( array_ ( size ( tmp_array_ ))) call move_alloc ( tmp_array_ , array_ ) else allocate ( array_ ( 1 )) array_ ( 1 ) = element_ endif end subroutine append_sp pure module subroutine append_dp ( array_ , element_ ) !! append element to an array (double precision version) real ( dp ), allocatable , intent ( inout ) :: array_ (:) real ( dp ), intent ( in ) :: element_ !---------------------------------------------------------------------! real ( dp ), allocatable :: tmp_array_ (:) !---------------------------------------------------------------------! if ( allocated ( array_ )) then allocate ( tmp_array_ ( size ( array_ ) + 1 )) tmp_array_ (: size ( array_ )) = array_ (:) tmp_array_ ( size ( array_ ) + 1 ) = element_ deallocate ( array_ ) allocate ( array_ ( size ( tmp_array_ ))) call move_alloc ( tmp_array_ , array_ ) else allocate ( array_ ( 1 )) array_ ( 1 ) = element_ endif end subroutine append_dp end submodule array_operations_append_submod","tags":"","loc":"sourcefile/array_operations_append_submod.f90.html"},{"title":"centrifugal_matrix_mod.f90 – the SCATTERING code","text":"This file depends on sourcefile~~centrifugal_matrix_mod.f90~~EfferentGraph sourcefile~centrifugal_matrix_mod.f90 centrifugal_matrix_mod.f90 sourcefile~data_mod.f90 data_mod.f90 sourcefile~centrifugal_matrix_mod.f90->sourcefile~data_mod.f90 sourcefile~array_operations_mod.f90 array_operations_mod.f90 sourcefile~centrifugal_matrix_mod.f90->sourcefile~array_operations_mod.f90 sourcefile~input_reader_mod.f90 input_reader_mod.f90 sourcefile~centrifugal_matrix_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~data_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~array_operations_mod.f90 sourcefile~utility_functions_mod.f90 utility_functions_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~input_validation_mod.f90 input_validation_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~input_validation_mod.f90 sourcefile~input_validation_mod.f90->sourcefile~data_mod.f90 sourcefile~input_validation_mod.f90->sourcefile~utility_functions_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~centrifugal_matrix_mod.f90~~AfferentGraph sourcefile~centrifugal_matrix_mod.f90 centrifugal_matrix_mod.f90 sourcefile~propagator_mod.f90 propagator_mod.f90 sourcefile~propagator_mod.f90->sourcefile~centrifugal_matrix_mod.f90 sourcefile~scattering.f90 scattering.f90 sourcefile~scattering.f90->sourcefile~propagator_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules centrifugal_matrix_mod Source Code centrifugal_matrix_mod.f90 Source Code module centrifugal_matrix_mod !! This module calculates the centrifugal matrix - see the second term !! in Eq. 3 in \"What are coupled equations?\" section. !---------------------------------------------------------------------------! use , intrinsic :: iso_fortran_env , only : int32 , sp => real32 , dp => real64 use data_mod use io_mod use array_operations_mod , only : invert_symmetric_matrix , fill_symmetric_matrix !---------------------------------------------------------------------------! implicit none !---------------------------------------------------------------------------! private public :: calculate_centrifugal_matrix !---------------------------------------------------------------------------! contains !---------------------------------------------------------------------------! !                           Centrifugal matrix !---------------------------------------------------------------------------! subroutine calculate_centrifugal_matrix ( total_angular_momentum_ , & channel_indices_ , channels_omega_values_ , centrifugal_matrix_ ) !! calculates the (R**2)*centrifugal matrix from the second term !! of Eq. 3 in \"What are coupled equations?\" section; !! Matrix elements are given in Eq. 4 and 6 of \"Coupling Matrix\" secion !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: total_angular_momentum_ !! total angular momentum integer ( int32 ), intent ( in ) :: channel_indices_ (:) !! holds the indices pointing to the basis arrays integer ( int32 ), intent ( in ) :: channels_omega_values_ (:) !! holds all values of \\bar{\\Omega} real ( dp ), intent ( out ) :: centrifugal_matrix_ (:,:) !! (output) - (R**2)*centrifugal matrix !---------------------------------------------------------------------! integer ( int32 ) :: omega_ , omega_prime_ , v_ , j_ , v_prime_ , j_prime_ , & channel_index_1_ , channel_index_2_ real ( dp ) :: centtmp , delta_1_ , delta_2_ !---------------------------------------------------------------------! centrifugal_matrix_ = 0 do channel_index_1_ = 1 , size ( channel_indices_ ) v_ = v1array ( channel_indices_ ( channel_index_1_ )) j_ = j1array ( channel_indices_ ( channel_index_1_ )) omega_ = channels_omega_values_ ( channel_index_1_ ) delta_1_ = delta_for_zero_omega ( omega_ ) do channel_index_2_ = 1 , channel_index_1_ v_prime_ = v1array ( channel_indices_ ( channel_index_2_ )) j_prime_ = j1array ( channel_indices_ ( channel_index_2_ )) omega_prime_ = channels_omega_values_ ( channel_index_2_ ) delta_2_ = delta_for_zero_omega ( omega_prime_ ) !---------------------------------------------------------------! if ( v_ /= v_prime_ . or . j_ /= j_prime_ . or . & abs ( omega_ - omega_prime_ ) > 1 ) then cycle endif !---------------------------------------------------------------! if ( omega_ == omega_prime_ ) then !------------------------------------------------------------! ! Eq. 4 in \"Coupling Matrix\" section !------------------------------------------------------------! centrifugal_matrix_ ( channel_index_1_ , channel_index_2_ ) & = calculate_diagonal_centrifugal_element ( & total_angular_momentum_ , j_ , omega_ ) else !------------------------------------------------------------! ! Eq. 5 in \"Coupling Matrix\" section !------------------------------------------------------------! centrifugal_matrix_ ( channel_index_1_ , channel_index_2_ ) & = calculate_offdiagonal_centrifugal_element ( & total_angular_momentum_ , j_ , omega_ , omega_prime_ , & delta_1_ , delta_2_ ) endif !---------------------------------------------------------------! enddo enddo !---------------------------------------------------------------------! call fill_symmetric_matrix ( centrifugal_matrix_ , 'u' ) !---------------------------------------------------------------------! end subroutine calculate_centrifugal_matrix !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! function delta_for_zero_omega ( omega_ ) result ( delta_ ) !! Checks if the input value equals 0; used in the calculation !! of off-diagonal elements of the centrifugal matrix; see !! Eq. 5 in \"Coupling Matrix\" section !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: omega_ !! input value which is to be compared with 0 real ( dp ) :: delta_ !! (output) 1 if omega_ = 0, 0 otherwise !---------------------------------------------------------------------! if ( omega_ == 0 ) then delta_ = 1.0_dp else delta_ = 0.0_dp endif !---------------------------------------------------------------------! end function delta_for_zero_omega !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! function calculate_diagonal_centrifugal_element ( total_angular_momentum_ , & j_ , omega_ ) result ( diagonal_element_ ) !! calculates diagonal element of the centrifgual matrix, see !! Eq. 4 in \"Coupling Matrix\" section !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: total_angular_momentum_ !! total angular momentum integer ( int32 ), intent ( in ) :: j_ !! rotational angular momentum integer ( int32 ), intent ( in ) :: omega_ !! \\\\bar{\\Omega}\\ real ( dp ) :: diagonal_element_ !! (output) value of the diagonal element of the coupling matrix !---------------------------------------------------------------------! diagonal_element_ = real ( & total_angular_momentum_ * ( total_angular_momentum_ + 1 ) & + j_ * ( j_ + 1 ) - 2 * omega_ ** 2 , dp ) !---------------------------------------------------------------------! end function calculate_diagonal_centrifugal_element !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! function calculate_offdiagonal_centrifugal_element ( & total_angular_momentum_ , j_ , omega_ , omega_prime_ , delta_1_ , delta_2_ )& result ( offdiagonal_element_ ) !! calculates off-diagonal element of the centrifgual matrix, see !! Eq. 5 in \"Coupling Matrix\" section !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: total_angular_momentum_ !! total angular momentum integer ( int32 ), intent ( in ) :: j_ !! rotational angular momentum integer ( int32 ), intent ( in ) :: omega_ !! \\\\bar{\\Omega}\\ integer ( int32 ), intent ( in ) :: omega_prime_ !! \\\\bar{\\Omega}'\\ real ( dp ), intent ( in ) :: delta_1_ , delta_2_ !! Kronecker delta functions determined earlier real ( dp ) :: offdiagonal_element_ !! (output) value of the off-diagonal element of the coupling matrix !---------------------------------------------------------------------! offdiagonal_element_ = - sqrt ( real ( & ( total_angular_momentum_ * ( total_angular_momentum_ + 1 ) & - omega_ * omega_prime_ ) * ( j_ * ( j_ + 1 ) - omega_ * omega_prime_ ),& dp )) * sqrt ( ( 1.0_dp + delta_1_ ) * ( 1.0_dp + delta_2_ ) ) !---------------------------------------------------------------------! end function calculate_offdiagonal_centrifugal_element !------------------------------------------------------------------------------! end module centrifugal_matrix_mod","tags":"","loc":"sourcefile/centrifugal_matrix_mod.f90.html"},{"title":"scattering.f90 – the SCATTERING code","text":"This file depends on sourcefile~~scattering.f90~~EfferentGraph sourcefile~scattering.f90 scattering.f90 sourcefile~radial_coupling_terms_mod.f90 radial_coupling_terms_mod.f90 sourcefile~scattering.f90->sourcefile~radial_coupling_terms_mod.f90 sourcefile~data_mod.f90 data_mod.f90 sourcefile~scattering.f90->sourcefile~data_mod.f90 sourcefile~input_reader_mod.f90 input_reader_mod.f90 sourcefile~scattering.f90->sourcefile~input_reader_mod.f90 sourcefile~pes_matrix_mod.f90 pes_matrix_mod.f90 sourcefile~scattering.f90->sourcefile~pes_matrix_mod.f90 sourcefile~channels_mod.f90 channels_mod.f90 sourcefile~scattering.f90->sourcefile~channels_mod.f90 sourcefile~save_s_matrix_mod.f90 save_s_matrix_mod.f90 sourcefile~scattering.f90->sourcefile~save_s_matrix_mod.f90 sourcefile~utility_functions_mod.f90 utility_functions_mod.f90 sourcefile~scattering.f90->sourcefile~utility_functions_mod.f90 sourcefile~propagator_mod.f90 propagator_mod.f90 sourcefile~scattering.f90->sourcefile~propagator_mod.f90 sourcefile~state_to_state_cross_sections_mod.f90 state_to_state_cross_sections_mod.f90 sourcefile~scattering.f90->sourcefile~state_to_state_cross_sections_mod.f90 sourcefile~unitarity_check_mod.f90 unitarity_check_mod.f90 sourcefile~scattering.f90->sourcefile~unitarity_check_mod.f90 sourcefile~array_operations_mod.f90 array_operations_mod.f90 sourcefile~scattering.f90->sourcefile~array_operations_mod.f90 sourcefile~boundary_conditions_mod.f90 boundary_conditions_mod.f90 sourcefile~scattering.f90->sourcefile~boundary_conditions_mod.f90 sourcefile~radial_coupling_terms_mod.f90->sourcefile~data_mod.f90 sourcefile~radial_coupling_terms_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~radial_coupling_terms_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~math_functions_mod.f90 math_functions_mod.f90 sourcefile~radial_coupling_terms_mod.f90->sourcefile~math_functions_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~data_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~array_operations_mod.f90 sourcefile~input_validation_mod.f90 input_validation_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~input_validation_mod.f90 sourcefile~pes_matrix_mod.f90->sourcefile~radial_coupling_terms_mod.f90 sourcefile~pes_matrix_mod.f90->sourcefile~data_mod.f90 sourcefile~pes_matrix_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~pes_matrix_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~pes_matrix_mod.f90->sourcefile~array_operations_mod.f90 sourcefile~pes_matrix_mod.f90->sourcefile~math_functions_mod.f90 sourcefile~channels_mod.f90->sourcefile~data_mod.f90 sourcefile~channels_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~channels_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~save_s_matrix_mod.f90->sourcefile~data_mod.f90 sourcefile~save_s_matrix_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~propagator_mod.f90->sourcefile~data_mod.f90 sourcefile~propagator_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~propagator_mod.f90->sourcefile~pes_matrix_mod.f90 sourcefile~propagator_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~propagator_mod.f90->sourcefile~array_operations_mod.f90 sourcefile~centrifugal_matrix_mod.f90 centrifugal_matrix_mod.f90 sourcefile~propagator_mod.f90->sourcefile~centrifugal_matrix_mod.f90 sourcefile~state_to_state_cross_sections_mod.f90->sourcefile~data_mod.f90 sourcefile~state_to_state_cross_sections_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~state_to_state_cross_sections_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~unitarity_check_mod.f90->sourcefile~data_mod.f90 sourcefile~unitarity_check_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~boundary_conditions_mod.f90->sourcefile~data_mod.f90 sourcefile~boundary_conditions_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~boundary_conditions_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~boundary_conditions_mod.f90->sourcefile~array_operations_mod.f90 sourcefile~boundary_conditions_mod.f90->sourcefile~math_functions_mod.f90 sourcefile~math_functions_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~special_functions_mod.f90 special_functions_mod.f90 sourcefile~math_functions_mod.f90->sourcefile~special_functions_mod.f90 sourcefile~input_validation_mod.f90->sourcefile~data_mod.f90 sourcefile~input_validation_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~centrifugal_matrix_mod.f90->sourcefile~data_mod.f90 sourcefile~centrifugal_matrix_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~centrifugal_matrix_mod.f90->sourcefile~array_operations_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Programs SCATTERING Source Code scattering.f90 Source Code program SCATTERING !---------------------------------------------------------------------------! use , intrinsic :: iso_fortran_env , only : int32 , sp => real32 , dp => real64 use data_mod use io_mod use radial_coupling_terms_mod , only : read_radial_coupling_terms , & reduce_radial_coupling_terms , interpolate_radial_coupling_terms use channels_mod , only : set_number_of_channels , set_body_fixed_channels , & set_space_fixed_channels , count_open_channels_in_block , & calculate_largest_wavenumber , print_channels use pes_matrix_mod , only : check_nonzero_pes_matrix_elements , & prepare_pes_matrix_elements , print_pes_matrix_elements_summary use propagator_mod , only : numerov use boundary_conditions_mod , only : calculate_sf_matrix_from_bf_matrix , & calculate_k_matrix , calculate_s_matrix use unitarity_check_mod , only : unitarity_check use save_s_matrix_mod , only : save_s_matrix_file_header , save_s_matrix_block_info use state_to_state_cross_sections_mod , only : & calculate_state_to_state_cross_section , & print_largest_partial_cross_sections , check_cross_section_thresholds , & save_partial_xs_file_header , save_partial_xs_single_block use utility_functions_mod , only : write_header , file_io_status , & write_message , float_to_character , integer_to_character , time_count_summary use array_operations_mod , only : append !---------------------------------------------------------------------------! implicit none !---------------------------------------------------------------------------! character ( len = 200 ) :: err_message , partial_line , xs_line integer ( int32 ) :: number_of_nonzero_pes_matrix_elements , & number_of_nonzero_algebraic_coefficients , number_of_channels , size_even , & size_odd , number_of_open_basis_levels , iblock , jtot_ , parity_exponent , & parity_exponenttmp , nsteps , number_of_open_channels , consecutive_blocks_thresholddiag , consecutive_blocks_thresholdoff , & omegamax , lmin , lmax , ltmp , lmat_len , len_even , len_odd , jinddiag , & jindoff1 , jindoff2 , ij , ilevel , iomega , iopen , iopen2 , isize_ , isize_2 , & icheck , icount , icount2 , io_status real ( dp ) :: largest_wavevector , wavvdepth , maxXSdiag , maxXSoff , time_total_start , & time_total_stop , time_total , time_init_stop , time_init , time_jtot_start , & time_jtot_stop , time_jtot , time_parity_start , time_parity_stop , & time_parity , time_coupling_start , time_coupling_stop , time_coupling logical :: unitarity_block_check , terminate integer , allocatable :: channel_indices (:), channels_omega_values (:),& channel_l_values (:), open_basis_levels (:), nonzero_terms_per_element (:),& nonzero_legendre_indices (:), smatcheckarr (:) real ( dp ), allocatable :: wv (:), open_basis_wavevectors (:), & nonzero_algebraic_coefficients (:), xs_total (:), xs_block (:), xs_jtot (:) real ( dp ), allocatable :: BF_log_der_matrix (:,:), SF_log_der_matrix (:,:), & k_matrix (:,:), s_matrix_real (:,:), s_matrix_imag (:,:) !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! ! Initizalization: start the time count !---------------------------------------------------------------------------! call cpu_time ( time_total_start ) !---------------------------------------------------------------------------! ! Initialize fwigxjpf library !---------------------------------------------------------------------------! call fwig_table_init ( 2 * 100 , 9 ) call fwig_temp_init ( 2 * 100 ) !---------------------------------------------------------------------------! ! Print the header !---------------------------------------------------------------------------! call write_header ( \"main\" ) !---------------------------------------------------------------------------! ! Read the input file !---------------------------------------------------------------------------! call read_input_file !---------------------------------------------------------------------------! ! S-matrix file: write input parameters and basis levels !---------------------------------------------------------------------------! call save_s_matrix_file_header !---------------------------------------------------------------------------! ! Prepare the file with the partial XS !---------------------------------------------------------------------------! if ( print_partial_cross_sections ) then call save_partial_xs_file_header endif !---------------------------------------------------------------------------! ! Convert units: starting now, everything is in atomic units !---------------------------------------------------------------------------! call units_conversion !---------------------------------------------------------------------------! ! Read the radial terms of the potential from external file !---------------------------------------------------------------------------! call read_radial_coupling_terms !---------------------------------------------------------------------------! ! Reduce matrix elements that are not needed !---------------------------------------------------------------------------! call reduce_radial_coupling_terms !---------------------------------------------------------------------------! ! Interpolate radial terms !---------------------------------------------------------------------------! call interpolate_radial_coupling_terms !---------------------------------------------------------------------------! ! Search for energetically accessible levels and prepare the arrays that are ! needed in the calculations of the state-to-state XS !---------------------------------------------------------------------------! number_of_open_basis_levels = count_open_basis_levels () call save_open_basis_levels ( number_of_open_basis_levels , open_basis_levels , & open_basis_wavevectors ) !---------------------------------------------------------------------------! ! xs array summed over all blocks !---------------------------------------------------------------------------! call allocate_1d ( xs_total , & number_of_open_basis_levels * number_of_open_basis_levels ) !---------------------------------------------------------------------------! ! xs array a single JTOT value !---------------------------------------------------------------------------! call allocate_1d ( xs_jtot , & number_of_open_basis_levels * number_of_open_basis_levels ) !---------------------------------------------------------------------------! ! xs array a single parity block !---------------------------------------------------------------------------! call allocate_1d ( xs_block , & number_of_open_basis_levels * number_of_open_basis_levels ) !---------------------------------------------------------------------------! ! Initialization is finished !---------------------------------------------------------------------------! call cpu_time ( time_init_stop ) if ( prntlvl . ge . 2 ) call time_count_summary ( time_total_start , time_init_stop , & time_init , \"Initialization completed in \" ) !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! ! Prepare J-blocks !---------------------------------------------------------------------------! ! If JTOTMAX=-1 is called, iterate until convergence is achieved: ! this is managed by consecutive_blocks_thresholddiag and consecutive_blocks_thresholdoff !---------------------------------------------------------------------------! consecutive_blocks_thresholddiag = 0 consecutive_blocks_thresholdoff = 0 iblock = 0 terminate = . false . !---------------------------------------------------------------------------! ! Loop over total angular momentum !---------------------------------------------------------------------------! call write_message ( repeat ( \"*\" , 90 )) call write_message ( repeat ( \" \" , 28 ) // \"*** Loop over JTOT: ***\" ) !---------------------------------------------------------------------------! do jtot_ = jtotmin , jtotmax , jtotstep !------------------------------------------------------------------------! call write_header ( \"block\" , opt_integer_ = jtot_ ) !------------------------------------------------------------------------! call cpu_time ( time_jtot_start ) !------------------------------------------------------------------------! xs_jtot = 0 call set_number_of_channels ( jtot_ , size_even , size_odd ) !------------------------------------------------------------------------! do parity_exponent = 0 , 1 !---------------------------------------------------------------------! call cpu_time ( time_parity_start ) !---------------------------------------------------------------------! select case ( parity_exponent ) case ( 0 ) number_of_channels = size_even case ( 1 ) number_of_channels = size_odd end select !---------------------------------------------------------------------! if ( number_of_channels == 0 ) cycle !---------------------------------------------------------------------! ! Summary of the current block !---------------------------------------------------------------------! iblock = iblock + 1 if ( prntlvl . ge . 1 ) then call write_message ( \"Block number: \" // integer_to_character ( iblock )) call write_message ( \"jtot: \" // & trim ( adjustl ( integer_to_character ( jtot_ ))) // \" parity: \" // & trim ( adjustl ( integer_to_character (( - 1 ) ** parity_exponent ) ))) call write_message ( \"Number of scattering channels: \" // & integer_to_character ( number_of_channels )) endif !---------------------------------------------------------------------! ! Prepare of the basis for each J/p block: ! channels_omega_values holds all values of omega (BF_) ! channel_l_values holds all values of l (SF_) ! channel_indices holds the indices which refer to the basis arrays: !   --   v1level/j1level/elevel !---------------------------------------------------------------------! call allocate_1d ( channels_omega_values , number_of_channels ) call allocate_1d ( channel_l_values , number_of_channels ) call allocate_1d ( channel_indices , number_of_channels ) !---------------------------------------------------------------------! ! Prepare channels_omega_values, channel_indices and channel_l_values !---------------------------------------------------------------------! call set_body_fixed_channels ( jtot_ , parity_exponent , channel_indices , & channels_omega_values ) call set_space_fixed_channels ( jtot_ , parity_exponent , channel_l_values ) !---------------------------------------------------------------------! ! Print the BF quantum numbers on screen !---------------------------------------------------------------------! if ( prntlvl . ge . 1 ) call print_channels ( parity_exponent , & channel_indices , channels_omega_values ) !---------------------------------------------------------------------! ! Determine the number of open (energetically accessible) channels !---------------------------------------------------------------------! number_of_open_channels = count_open_channels_in_block ( channel_indices ) !---------------------------------------------------------------------! ! If there are no open channels, skip this block !---------------------------------------------------------------------! if ( number_of_open_channels == 0 ) then call write_message ( repeat ( '-' , 90 )) call write_message ( \"No open channels for block no.\" // & integer_to_character ( iblock ) ) call write_message ( repeat ( '-' , 90 )) cycle endif !---------------------------------------------------------------------! ! Determine the largest wavevector in the block !---------------------------------------------------------------------! largest_wavevector = calculate_largest_wavenumber ( channel_indices ) !---------------------------------------------------------------------! ! Determine the number of steps on the intermolecular (R) grid ! This is done either directly (if dr > 0) ! or through the number of steps per half de Broglie wavelength !---------------------------------------------------------------------! wavvdepth = dsqrt ( 2 * reduced_mass * vdepth ) if ( dr <= 0 ) then nsteps = nint (( Rmax - Rmin ) / PI * (( largest_wavevector + wavvdepth ) * steps )) else nsteps = nint (( Rmax - Rmin ) / dr ) + 1 endif !---------------------------------------------------------------------! ! Prepare the PES matrix !---------------------------------------------------------------------! call cpu_time ( time_coupling_start ) call check_nonzero_pes_matrix_elements ( channel_indices , & channels_omega_values , number_of_nonzero_pes_matrix_elements , & number_of_nonzero_algebraic_coefficients ) call allocate_1d ( nonzero_terms_per_element , number_of_nonzero_pes_matrix_elements ) call allocate_1d ( nonzero_algebraic_coefficients , number_of_nonzero_algebraic_coefficients ) call allocate_1d ( nonzero_legendre_indices , number_of_nonzero_algebraic_coefficients ) call prepare_pes_matrix_elements ( channel_indices , & channels_omega_values , nonzero_terms_per_element , & nonzero_legendre_indices , nonzero_algebraic_coefficients ) if ( prntlvl . ge . 2 ) call print_pes_matrix_elements_summary ( & number_of_channels , number_of_nonzero_pes_matrix_elements , & number_of_nonzero_algebraic_coefficients ) call cpu_time ( time_coupling_stop ) if ( prntlvl . ge . 2 ) call write_message ( \"Calculations of the coupling \" // & \"matrix took \" // trim ( adjustl ( float_to_character ( & time_coupling_stop - time_coupling_start , \"(E14.8)\" ))) // \" seconds\" ) !---------------------------------------------------------------------! ! Prepare the log-derivative matrix (Eqs. 6.29 and 6.43) ! and the K-matrix (Eq. 6.53) !---------------------------------------------------------------------! call allocate_2d ( BF_log_der_matrix , number_of_channels , number_of_channels ) call allocate_2d ( SF_log_der_matrix , number_of_channels , number_of_channels ) call allocate_2d ( k_matrix , number_of_open_channels , number_of_open_channels ) !---------------------------------------------------------------------! ! Call the propagator: !---------------------------------------------------------------------! call numerov ( number_of_channels , channel_indices , channels_omega_values , & nonzero_terms_per_element ,& nonzero_legendre_indices , nonzero_algebraic_coefficients , nsteps , & jtot_ , BF_log_der_matrix ) call write_message ( \"Coupled equations were solved from \" // & trim ( adjustl ( float_to_character ( Rmin , \"(F10.4)\" ))) // \" a.u. to \" // & trim ( adjustl ( float_to_character ( Rmax , \"(F10.4)\" ))) // \" a.u. in \" // & trim ( adjustl ( integer_to_character ( nsteps ))) // \" steps (dr = \" // & trim ( adjustl ( float_to_character (( rmax - rmin ) / dble ( nsteps - 1 ), & \"(E14.8)\" ))) // \" a.u.)\" ) !---------------------------------------------------------------------! ! Transform the log-derivative matrix to the SF frame !---------------------------------------------------------------------! call calculate_sf_matrix_from_bf_matrix ( number_of_channels , jtot_ , & channel_indices , channels_omega_values , channel_l_values , & BF_log_der_matrix , SF_log_der_matrix ) !---------------------------------------------------------------------! ! Get the K-matrix from log-derivative matrix (Eq. 6.53) !---------------------------------------------------------------------! call calculate_k_matrix ( number_of_channels , SF_log_der_matrix , & number_of_open_channels , channel_indices , channel_l_values ,& rmax , k_matrix ) !---------------------------------------------------------------------! ! Get the S-matrix from the K-matrix (Eq. 6.57) !---------------------------------------------------------------------! call allocate_2d ( s_matrix_real , number_of_open_channels , number_of_open_channels ) call allocate_2d ( s_matrix_imag , number_of_open_channels , number_of_open_channels ) call calculate_s_matrix ( number_of_open_channels , k_matrix , s_matrix_real , s_matrix_imag ) !---------------------------------------------------------------------! ! Array of wavevectors (necessary for the XS calculations) !---------------------------------------------------------------------! call allocate_1d ( wv , number_of_open_channels ) do iopen = 1 , number_of_open_channels wv ( iopen ) = dsqrt (( 2 * reduced_mass * & ( ETOTAL () - elevel ( channel_indices ( iopen ))))) / bohrtoangstrom enddo !---------------------------------------------------------------------! ! S-matrix is written to the binary S-matrix file !---------------------------------------------------------------------! call save_s_matrix_block_info ( jtot_ , parity_exponent , & number_of_open_channels , channel_indices , channel_l_values , wv , & s_matrix_real , s_matrix_imag ) !---------------------------------------------------------------------! ! Check if the S-matrices are unitary !---------------------------------------------------------------------! call unitarity_check ( number_of_open_channels , s_matrix_real , s_matrix_imag , unitarity_block_check ) !---------------------------------------------------------------------! ! If the unitary is not fulfilled, keep the information about this block !---------------------------------------------------------------------! if (. not .( unitarity_block_check )) then call append ( smatcheckarr , jtot_ ) endif !---------------------------------------------------------------------! ! Calculate all available cross-sections !---------------------------------------------------------------------! call calculate_state_to_state_cross_section ( jtot_ , open_basis_levels , & open_basis_wavevectors , s_matrix_real , s_matrix_imag , channel_indices ,& channel_l_values , xs_block ) !---------------------------------------------------------------------! ! Print the results from this parity block to the partial XS file ! and add the calculated partial XS to the xs_jtot array !---------------------------------------------------------------------! if ( print_partial_cross_sections ) then call save_partial_xs_single_block ( jtot_ , iblock , & number_of_open_basis_levels , open_basis_levels , xs_block ) endif do icount = 1 , number_of_open_basis_levels do icount2 = 1 , number_of_open_basis_levels xs_jtot (( icount - 1 ) * number_of_open_basis_levels + icount2 ) = & xs_jtot (( icount - 1 ) * number_of_open_basis_levels + icount2 ) & + xs_block (( icount - 1 ) * number_of_open_basis_levels + icount2 ) enddo enddo !---------------------------------------------------------------------! ! Check the time after each parity block: !---------------------------------------------------------------------! call cpu_time ( time_parity_stop ) if ( prntlvl . ge . 2 ) call time_count_summary ( time_parity_start , & time_parity_stop , time_parity , \"Parity block completed in \" ) !---------------------------------------------------------------------! ! ... end of the loop over parity !---------------------------------------------------------------------! call write_message ( repeat ( \" \" , 43 ) // \"***\" ) enddo !------------------------------------------------------------------------! ! Add the cross-sections from this Jtot block: !------------------------------------------------------------------------! do icount = 1 , number_of_open_basis_levels do icount2 = 1 , number_of_open_basis_levels xs_total (( icount - 1 ) * number_of_open_basis_levels + icount2 ) = & xs_total (( icount - 1 ) * number_of_open_basis_levels + icount2 ) & + xs_jtot (( icount - 1 ) * number_of_open_basis_levels + icount2 ) enddo enddo !------------------------------------------------------------------------! ! Determine the largest partial elastic/inelastic XS in this Jtot block: !------------------------------------------------------------------------! jinddiag = 0 jindoff1 = 0 jindoff2 = 0 maxXSdiag = 0.0_dp maxXSoff = 0.0_dp do icount = 1 , number_of_open_basis_levels do icount2 = 1 , number_of_open_basis_levels if ( open_basis_levels ( icount2 ) == open_basis_levels ( icount )) then if (( xs_jtot (( icount - 1 ) * number_of_open_basis_levels + icount2 )). gt . maxXSdiag ) then maxXSdiag = xs_jtot (( icount - 1 ) * number_of_open_basis_levels + icount2 ) jinddiag = icount endif else if (( xs_jtot (( icount - 1 ) * number_of_open_basis_levels + icount2 )). gt . maxXSoff ) then maxXSoff = xs_jtot (( icount - 1 ) * number_of_open_basis_levels + icount2 ) jindoff1 = icount jindoff2 = icount2 endif endif enddo enddo !-----------------------------------------------------------------------! call print_largest_partial_cross_sections ( jtot_ , maxXSdiag , maxXSoff , jinddiag , & jindoff1 , jindoff2 , open_basis_levels ) !-----------------------------------------------------------------------! if ( jtotmax == 999999 ) then call check_cross_section_thresholds ( maxXSdiag , maxXSoff , & consecutive_blocks_thresholddiag , consecutive_blocks_thresholdoff , terminate ) endif !------------------------------------------------------------------------! ! Check the time after each JTOT block: !------------------------------------------------------------------------! call cpu_time ( time_jtot_stop ) !------------------------------------------------------------------------! ! Print all the XS after current JTOT block !------------------------------------------------------------------------! if ( prntlvl . ge . 3 ) then call write_message ( \"Cross sections for J: \" // & trim ( adjustl ( integer_to_character ( jtot_ ))) // \" and energy: \" // & trim ( adjustl ( float_to_character ( ETOTAL () * hartreetocm , \"(F10.4)\" ))) & // \" cm-1\" ) call write_message ( \"  v1_f  j1_f  <-  v1_i  j1_i\" // repeat ( \" \" , 14 ) & // \"K.E.\" // repeat ( \" \" , 16 ) // \"XS\" ) do icount = 1 , number_of_open_basis_levels do icount2 = 1 , number_of_open_basis_levels write ( xs_line , \"(2X,I4,2X,I4,6X,I4,2X,I4,2X,E16.8,2X,E16.8)\" ) & v1array ( open_basis_levels ( icount2 )), & j1array ( open_basis_levels ( icount2 )), & v1array ( open_basis_levels ( icount )), & j1array ( open_basis_levels ( icount )), & ( etotal () - elevel ( open_basis_levels ( icount ))) * hartreetocm , & xs_total (( icount - 1 ) * number_of_open_basis_levels + icount2 ) call write_message ( xs_line ) enddo enddo endif !------------------------------------------------------------------------! if ( prntlvl . ge . 2 ) call time_count_summary ( time_jtot_start , & time_jtot_stop , time_jtot , \"JTOT block completed in \" ) !------------------------------------------------------------------------! ! terminate the loop if elastic_xs_threshold/inelastic_xs_threshold condition is satisfied !------------------------------------------------------------------------! if ( terminate ) exit enddo call write_message ( repeat ( '*' , 90 )) call write_message ( repeat ( \" \" , 31 ) // \"Loop over JTOT finished\" ) call write_message ( repeat ( '*' , 90 )) call write_message ( \"*\" // repeat ( \" \" , 40 ) // \"SUMMARY\" // repeat ( \" \" , 41 ) & // \"*\" ) call write_message ( repeat ( '*' , 90 )) !---------------------------------------------------------------------------! ! if for some JTOTs the S-matrix did not fulfill the unitary check, ! these are listed here !---------------------------------------------------------------------------! if ( allocated ( smatcheckarr )) then print * call write_message ( repeat ( \"-\" , 90 )) call write_message ( repeat ( \" \" , 37 ) // \"*** WARNING ***\" ) call write_message ( repeat ( \"-\" , 90 )) call write_message ( \"Check unitarity of the S-matrix in the following \" // & \"JTOT blocks:\" ) do icheck = 1 , size ( smatcheckarr ) call write_message ( \"JTOT:\" // repeat ( \" \" , 8 ) // integer_to_character ( & smatcheckarr ( icheck ))) enddo call write_message ( repeat ( \"-\" , 90 )) print * endif !---------------------------------------------------------------------------! ! Print all the calculated XS !---------------------------------------------------------------------------! call write_message ( \"Final state-to-state XS\" ) call write_message ( \"  v1_f  j1_f  <-  v1_i  j1_i\" // repeat ( \" \" , 14 ) // & \"K.E.\" // repeat ( \" \" , 16 ) // \"XS\" ) do icount = 1 , number_of_open_basis_levels do icount2 = 1 , number_of_open_basis_levels write ( xs_line , \"(2X,I4,2X,I4,6X,I4,2X,I4,2X,E16.8,2X,E16.8)\" ) & v1array ( open_basis_levels ( icount2 )), & j1array ( open_basis_levels ( icount2 )), & v1array ( open_basis_levels ( icount )), & j1array ( open_basis_levels ( icount )), & ( etotal () - elevel ( open_basis_levels ( icount ))) * hartreetocm , & xs_total (( icount - 1 ) * number_of_open_basis_levels + icount2 ) call write_message ( xs_line ) enddo enddo !---------------------------------------------------------------------------! call fwig_temp_free (); call fwig_table_free (); !---------------------------------------------------------------------------! ! Stop the time count !---------------------------------------------------------------------------! call cpu_time ( time_total_stop ) call time_count_summary ( time_total_start , time_total_stop , time_total , & \"Total CPU time: \" ) close ( 11 ) close ( 12 ) !---------------------------------------------------------------------------! end program SCATTERING !------------------------------------------------------------------------------! !------------------------------------------------------------------------------!","tags":"","loc":"sourcefile/scattering.f90.html"},{"title":"array_operations_fill_symmetric_matrix_submod.f90 – the SCATTERING code","text":"This file depends on sourcefile~~array_operations_fill_symmetric_matrix_submod.f90~~EfferentGraph sourcefile~array_operations_fill_symmetric_matrix_submod.f90 array_operations_fill_symmetric_matrix_submod.f90 sourcefile~array_operations_mod.f90 array_operations_mod.f90 sourcefile~array_operations_fill_symmetric_matrix_submod.f90->sourcefile~array_operations_mod.f90 sourcefile~utility_functions_mod.f90 utility_functions_mod.f90 sourcefile~array_operations_fill_symmetric_matrix_submod.f90->sourcefile~utility_functions_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules array_operations_fill_symmetric_matrix_submod Source Code array_operations_fill_symmetric_matrix_submod.f90 Source Code submodule ( array_operations_mod ) array_operations_fill_symmetric_matrix_submod !! a submodule for append subroutines use utility_functions_mod , only : to_lowercase implicit none contains module subroutine fill_symmetric_matrix_int32 ( matrix_ , upper_lower_ ) !! Fill the upper/lower triangle of a symmetric matrix (integer). integer , intent ( inout ) :: matrix_ (:,:) character ( len = 1 ), intent ( in ) :: upper_lower_ !---------------------------------------------------------------------! integer :: i_ , size_1_ , size_2_ , size_ !---------------------------------------------------------------------! size_1_ = size ( matrix_ , dim = 1 ) size_2_ = size ( matrix_ , dim = 2 ) if ( size_1_ . eq . size_2_ ) then size_ = size_1_ else print * , \"Error in fill_symmetric_matrix_int: size in dim = 1 (\" , size_1_ ,& \") is different than in dim = 2 (\" , size_2_ , \")\" print * , \"Adapt this subroutine to rectangle matrices\" stop endif !---------------------------------------------------------------------! select case ( to_lowercase ( upper_lower_ )) case ( 'l' ) do i_ = 1 , size_ - 1 matrix_ ( i_ + 1 : size_ , i_ ) = matrix_ ( i_ , i_ + 1 : size_ ) enddo case ( 'u' ) do i_ = 1 , size_ - 1 matrix_ ( i_ , i_ + 1 : size_ ) = matrix_ ( i_ + 1 : size_ , i_ ) enddo case default write ( * , * ) \"Invalid argument to fill_symmetric_matrix_int32 subroutine\" write ( * , * ) \"upper_lower_:\" , upper_lower_ write ( * , * ) \"'u' or 'l' expected\" stop end select !---------------------------------------------------------------------! end subroutine fill_symmetric_matrix_int32 module subroutine fill_symmetric_matrix_sp ( matrix_ , upper_lower_ ) !! Fill the upper/lower triangle of a symmetric matrix (single precision). real ( sp ), intent ( inout ) :: matrix_ (:,:) character ( len = 1 ), intent ( in ) :: upper_lower_ !---------------------------------------------------------------------! integer :: i_ , size_1_ , size_2_ , size_ !---------------------------------------------------------------------! size_1_ = size ( matrix_ , dim = 1 ) size_2_ = size ( matrix_ , dim = 2 ) if ( size_1_ . eq . size_2_ ) then size_ = size_1_ else print * , \"Error in fill_symmetric_matrix_sp: size in dim = 1 (\" , size_1_ ,& \") is different than in dim = 2 (\" , size_2_ , \")\" print * , \"Adapt this subroutine to rectangle matrices\" stop endif !---------------------------------------------------------------------! select case ( to_lowercase ( upper_lower_ )) case ( 'l' ) do i_ = 1 , size_ - 1 matrix_ ( i_ + 1 : size_ , i_ ) = matrix_ ( i_ , i_ + 1 : size_ ) enddo case ( 'u' ) do i_ = 1 , size_ - 1 matrix_ ( i_ , i_ + 1 : size_ ) = matrix_ ( i_ + 1 : size_ , i_ ) enddo case default write ( * , * ) \"Invalid argument to fill_symmetric_matrix_sp subroutine\" write ( * , * ) \"upper_lower_:\" , upper_lower_ write ( * , * ) \"'u' or 'l' expected\" stop end select !---------------------------------------------------------------------! end subroutine fill_symmetric_matrix_sp module subroutine fill_symmetric_matrix_dp ( matrix_ , upper_lower_ ) !! fill the upper/lower triangle of a symmetric matrix real ( dp ), intent ( inout ) :: matrix_ (:,:) character ( len = 1 ), intent ( in ) :: upper_lower_ !---------------------------------------------------------------------! integer :: i_ , size_1_ , size_2_ , size_ !---------------------------------------------------------------------! size_1_ = size ( matrix_ , dim = 1 ) size_2_ = size ( matrix_ , dim = 2 ) if ( size_1_ . eq . size_2_ ) then size_ = size_1_ else print * , \"Error in fill_symmetric_matrix_dp: size in dim = 1 (\" , size_1_ ,& \") is different than in dim = 2 (\" , size_2_ , \")\" print * , \"Adapt this subroutine to rectangle matrices\" stop endif !---------------------------------------------------------------------! select case ( to_lowercase ( upper_lower_ )) case ( 'l' ) do i_ = 1 , size_ - 1 matrix_ ( i_ + 1 : size_ , i_ ) = matrix_ ( i_ , i_ + 1 : size_ ) enddo case ( 'u' ) do i_ = 1 , size_ - 1 matrix_ ( i_ , i_ + 1 : size_ ) = matrix_ ( i_ + 1 : size_ , i_ ) enddo case default write ( * , * ) \"Invalid argument of the fill_symetric_matrix_dp subroutine\" write ( * , * ) \"upper_lower_\" , upper_lower_ write ( * , * ) \"'u' or 'l' expected\" stop end select !---------------------------------------------------------------------! end subroutine fill_symmetric_matrix_dp end submodule array_operations_fill_symmetric_matrix_submod","tags":"","loc":"sourcefile/array_operations_fill_symmetric_matrix_submod.f90.html"},{"title":"data_mod.f90 – the SCATTERING code","text":"Files dependent on this one sourcefile~~data_mod.f90~~AfferentGraph sourcefile~data_mod.f90 data_mod.f90 sourcefile~radial_coupling_terms_mod.f90 radial_coupling_terms_mod.f90 sourcefile~radial_coupling_terms_mod.f90->sourcefile~data_mod.f90 sourcefile~input_reader_mod.f90 input_reader_mod.f90 sourcefile~radial_coupling_terms_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~data_mod.f90 sourcefile~input_validation_mod.f90 input_validation_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~input_validation_mod.f90 sourcefile~pes_matrix_mod.f90 pes_matrix_mod.f90 sourcefile~pes_matrix_mod.f90->sourcefile~data_mod.f90 sourcefile~pes_matrix_mod.f90->sourcefile~radial_coupling_terms_mod.f90 sourcefile~pes_matrix_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~centrifugal_matrix_mod.f90 centrifugal_matrix_mod.f90 sourcefile~centrifugal_matrix_mod.f90->sourcefile~data_mod.f90 sourcefile~centrifugal_matrix_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~channels_mod.f90 channels_mod.f90 sourcefile~channels_mod.f90->sourcefile~data_mod.f90 sourcefile~channels_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~scattering.f90 scattering.f90 sourcefile~scattering.f90->sourcefile~data_mod.f90 sourcefile~scattering.f90->sourcefile~radial_coupling_terms_mod.f90 sourcefile~scattering.f90->sourcefile~input_reader_mod.f90 sourcefile~scattering.f90->sourcefile~pes_matrix_mod.f90 sourcefile~scattering.f90->sourcefile~channels_mod.f90 sourcefile~save_s_matrix_mod.f90 save_s_matrix_mod.f90 sourcefile~scattering.f90->sourcefile~save_s_matrix_mod.f90 sourcefile~propagator_mod.f90 propagator_mod.f90 sourcefile~scattering.f90->sourcefile~propagator_mod.f90 sourcefile~unitarity_check_mod.f90 unitarity_check_mod.f90 sourcefile~scattering.f90->sourcefile~unitarity_check_mod.f90 sourcefile~state_to_state_cross_sections_mod.f90 state_to_state_cross_sections_mod.f90 sourcefile~scattering.f90->sourcefile~state_to_state_cross_sections_mod.f90 sourcefile~boundary_conditions_mod.f90 boundary_conditions_mod.f90 sourcefile~scattering.f90->sourcefile~boundary_conditions_mod.f90 sourcefile~save_s_matrix_mod.f90->sourcefile~data_mod.f90 sourcefile~propagator_mod.f90->sourcefile~data_mod.f90 sourcefile~propagator_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~propagator_mod.f90->sourcefile~pes_matrix_mod.f90 sourcefile~propagator_mod.f90->sourcefile~centrifugal_matrix_mod.f90 sourcefile~input_validation_mod.f90->sourcefile~data_mod.f90 sourcefile~unitarity_check_mod.f90->sourcefile~data_mod.f90 sourcefile~state_to_state_cross_sections_mod.f90->sourcefile~data_mod.f90 sourcefile~state_to_state_cross_sections_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~boundary_conditions_mod.f90->sourcefile~data_mod.f90 sourcefile~boundary_conditions_mod.f90->sourcefile~input_reader_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules data_mod Source Code data_mod.f90 Source Code module data_mod !! ... use , intrinsic :: iso_fortran_env , only : int32 , sp => real32 , dp => real64 !------------------------------------------------------------------------------! implicit none !------------------------------------------------------------------------------! character ( len = 80 ) :: label = \"Test scattering calculations\" !! user-defined label character ( len = 80 ) :: potentialfile = \"RadialTerms.dat\" !! name of the file with tabulated radial coupling terms of the PES character ( len = 80 ) :: smatrixfile = \"SmatrixFile.dat\" !! name of the S-matrix file character ( len = 80 ) :: partialfile = \"PartialFile.dat\" !! name of the file holding partial state-to-state cross-sections integer ( int32 ) :: relative_energy_flag = 0 !! if set to 0, \"energy\" is interpreted as the total energy, !! if set to 1, \"energy\" is interpreted as kinetic energy calculated with !! respect to selected \"initial\" level integer ( int32 ) :: jtotmin = 0 , jtotmax = - 1 , jtotstep = 1 !! range of total angular momenta, for which coupled equations are solved integer ( int32 ) :: steps = 10 !! number of steps per half-de Broglie wavelength of the scattering system; !! if provided on input, the number of \\R\\-grid points is determined !! as \\N = \\frac{R\\_{max}-R\\_{min}}{\\pi(k\\_{max}+k\\_{vdepth})}\\mathrm{steps}\\, !! where \\k\\_{max}\\ is the largest wavevector in a given block, !! and \\k\\_{vdepth}\\ is the correction due to the depth of the potential, !! see \"vdepth\" integer ( int32 ) :: consecutive_blocks_threshold = 1 !! number of consecutive blocks for which the threshold condition !! on cross-sections needs to be fulfilled to terminate calculations !! if \"jtotmax\" = -1 integer ( int32 ) :: initial = - 1 !! if \"relative_energy_flag\" = 1, \"initial\" points to a specific level !! in the basis indicating the initial molecular level integer ( int32 ) :: nlevel = - 1 !! number of rovibrational levels in the basis integer ( int32 ) :: nr = - 1 !! number of grid points for the radial coupling terms in the potential expansion integer ( int32 ) :: nterms = - 1 !! number of the radial coupling terms in the potential expansion integer ( int32 ) :: total_number_of_coupling_terms = 1 !! total number of coupling terms provided in \"potentialfile\" integer ( int32 ) :: n_skip_lines = 0 !! number of lines that at the beginning of \"potentialfile\" that are to be skipped integer ( int32 ) :: iunits = 0 !! TO BE CORRECTED integer ( int32 ) :: prntlvl = 2 !! print level control; should be >= 0 logical :: print_partial_cross_sections = . false . !! if .true. partial cross-sections will be saved to \"partialfile\" real ( dp ) :: reduced_mass = - 1.0_dp !! reduced mass of the scattering system real ( dp ) :: energy = - 1.0_dp !! if \"relative_energy_flag\" = 0, \"energy\" is the total energy (kinetic+internal) !! if \"relative_energy_flag\" = 1, \"energy\" is the kinetic energy real ( dp ) :: rmin = - 1.0_dp , rmax = - 1.0_dp !! range of the propagation real ( dp ) :: dr = - 1.0_dp !! if >=0, dr is used to determine number of steps on the \\R\\ grid; !! otherwise, grid is determined from \"steps\" real ( dp ) :: vdepth = 0.0_dp !! the absolute value of the depth of the potential, included !! in the determination of the step size of the propagator through !! \\k\\_{vdepth} = \\sqrt{2\\mu(\\mathrm{vdepth})}\\ real ( dp ) :: elastic_xs_threshold = 0.1_dp !! threshold condition on elastic cross-sections used in \"jtotmax\"=-1 real ( dp ) :: inelastic_xs_threshold = 0.1_dp !! threshold condition on elastic cross-sections used in \"jtotmax\"=-1 !---------------------------------------------------------------------------! integer ( int32 ) :: minimal_number_of_coupling_terms !! minimal number of coupling terms based on levels provided in the basis real ( dp ) :: radial_term_distance_converter , radial_term_energy_converter !---------------------------------------------------------------------------! integer ( int32 ), parameter :: input_unit = 5 integer ( int32 ), parameter :: pes_file_unit = 8 integer ( int32 ), parameter :: s_matrix_unit = 11 integer ( int32 ), parameter :: partial_file_unit = 12 !---------------------------------------------------------------------------! real ( dp ), parameter :: amutoau = 182 2.8884862d0 real ( dp ), parameter :: bohrtoangstrom = 0.5291772109d0 real ( dp ), parameter :: hartreetocm = 21947 4.631363d0 real ( dp ), parameter :: pi = dacos ( - 1.d0 ) real ( dp ), parameter :: unitary_tolerance = 1e-6_dp !---------------------------------------------------------------------------! integer ( int32 ), allocatable :: v1array (:) !! array holding vibrational quantum numbers, of nlevel size integer ( int32 ), allocatable :: j1array (:) !! array holding rotational quantum numbers, of nlevel size, integer ( int32 ), allocatable :: l1tab (:) !! array holding legendre indices of the PES expansion, \\\\lambda), !! of nterms size; see Eq. 2 in the \"Coupling Matrix\" section integer ( int32 ), allocatable :: v1pes (:), j1pes (:), v1ppes (:), j1ppes (:) !! arrays holding quantum numbers of radial coupling terms: !! \\\\eta = v, j\\, and \\\\eta' = v', j'\\, of \"total_number_of_coupling_terms\"size; !! see Eq. 2 in the \"Coupling Matrix\" section integer ( int32 ), allocatable :: reduced_v1pes (:), reduced_j1pes (:), & reduced_v1ppes (:), reduced_j1ppes (:) !! arrays holding quantum numbers of the _necessary_ radial coupling terms !! (based on levels provided in the basis): !! \\\\eta = v, j\\, and \\\\eta' = v', j'\\, of \"minimal_number_of_coupling_terms\" size; !! see Eq. 2 in the \"Coupling Matrix\" section real ( dp ), allocatable :: elevel (:) !! array holding energies of rovibrational levels of the molecule, corresponding to !! v1array and j1array elements; of nlevel size !---------------------------------------------------------------------------! real ( dp ), allocatable :: rmat (:) !! array holding \\R\\ grid points, filled while reading radial coupling !! terms from the \"potentialfile\"; of \"nr\" size real ( dp ), allocatable :: read_vmat3D (:,:,:) !! array holding read radial coupling terms of the PES; !! the 3 dimensions correspond to \\R, \\lambda, \\eta \\eta'\\ grids !! and are of (nr, nterms, total_number_of_coupling_terms) size real ( dp ), allocatable :: vmat3D (:,:,:) !! array holding _necessary_ radial coupling terms of the PES !! (based on levels provided in the basis); !! the 3 dimensions correspond to \\R, \\lambda, \\eta \\eta'\\ grids !! and are of (nr, nterms, minimal_number_of_coupling_terms) size real ( dp ), allocatable :: bmat3D (:,:,:), cmat3D (:,:,:), dmat3D (:,:,:) !! arrays holding spline coefficients interpolating vmat3D logical :: pes_file_exists = . false . !! a flag for checking existence of \"potentialfile\" -> MOVE logical :: units_converted = . false . !! if .true. mass and energy units are converted !---------------------------------------------------------------------------! end module data_mod","tags":"","loc":"sourcefile/data_mod.f90.html"},{"title":"boundary_conditions_mod.f90 – the SCATTERING code","text":"This file depends on sourcefile~~boundary_conditions_mod.f90~~EfferentGraph sourcefile~boundary_conditions_mod.f90 boundary_conditions_mod.f90 sourcefile~data_mod.f90 data_mod.f90 sourcefile~boundary_conditions_mod.f90->sourcefile~data_mod.f90 sourcefile~math_functions_mod.f90 math_functions_mod.f90 sourcefile~boundary_conditions_mod.f90->sourcefile~math_functions_mod.f90 sourcefile~input_reader_mod.f90 input_reader_mod.f90 sourcefile~boundary_conditions_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~utility_functions_mod.f90 utility_functions_mod.f90 sourcefile~boundary_conditions_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~array_operations_mod.f90 array_operations_mod.f90 sourcefile~boundary_conditions_mod.f90->sourcefile~array_operations_mod.f90 sourcefile~math_functions_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~special_functions_mod.f90 special_functions_mod.f90 sourcefile~math_functions_mod.f90->sourcefile~special_functions_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~data_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~array_operations_mod.f90 sourcefile~input_validation_mod.f90 input_validation_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~input_validation_mod.f90 sourcefile~input_validation_mod.f90->sourcefile~data_mod.f90 sourcefile~input_validation_mod.f90->sourcefile~utility_functions_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~boundary_conditions_mod.f90~~AfferentGraph sourcefile~boundary_conditions_mod.f90 boundary_conditions_mod.f90 sourcefile~scattering.f90 scattering.f90 sourcefile~scattering.f90->sourcefile~boundary_conditions_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules boundary_conditions_mod Source Code boundary_conditions_mod.f90 Source Code module boundary_conditions_mod !! This module contains subroutines that transform the asymptotic !! log-derivative matrix into the scattering S-matrix !! (see \"Solution of coupled equations\" section) !---------------------------------------------------------------------------! use , intrinsic :: iso_fortran_env , only : int32 , sp => real32 , dp => real64 use data_mod use io_mod use fwigxjpf , only : fwig3jj use math_functions_mod , only : riccati_bessel_j , riccati_bessel_y , & modified_bessel_k_ratio use utility_functions_mod , only : write_warning , write_header use array_operations_mod , only : invert_symmetric_matrix , fill_symmetric_matrix !---------------------------------------------------------------------------! implicit none !---------------------------------------------------------------------------! private public :: calculate_sf_matrix_from_bf_matrix , calculate_k_matrix , & calculate_s_matrix !---------------------------------------------------------------------------! contains !---------------------------------------------------------------------------! function p_coeff ( total_angular_momentum_ , j_ , l_ , omega_ ) result ( p_coeff_ ) !! calculates the P coefficients from Eq. (3) in !! \"Solution of coupled equations\" !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: total_angular_momentum_ !! total angular momentum integer ( int32 ), intent ( in ) :: j_ !! rotational quantum number integer ( int32 ), intent ( in ) :: l_ !! orbital angular momentum integer ( int32 ), intent ( in ) :: omega_ !! projection of j on the BF-Z axis real ( dp ) :: p_coeff_ !! result - P function (Eq. (3) in \"Solution of coupled equations\") !---------------------------------------------------------------------! real ( dp ) :: delta_ !---------------------------------------------------------------------! delta_ = 0.d0 if ( omega_ == 0 ) delta_ = 1.0_dp p_coeff_ = ( - 1.0_dp ) ** ( total_angular_momentum_ + omega_ ) * dsqrt ( 2.0_dp )& * dsqrt ( real ( 2 * l_ + 1 , dp )) & * fwig3jj ( 2 * j_ , 2 * total_angular_momentum_ , 2 * l_ , & 2 * omega_ , - 2 * omega_ , 0 ) / dsqrt ( 1.0_dp + delta_ ) !---------------------------------------------------------------------! end function p_coeff !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine calculate_single_SF_element ( number_of_channels , & total_angular_momentum_ , v_ , j_ , vp_ , jp_ , l_ , lp_ , & channel_indices , channels_omega_values , bf_matrix , sf_element ) !! calculates a single space-fixed matrix element from Eq. (2) in !! \"Solution of coupled equations\" !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: number_of_channels !! size of the basis integer ( int32 ), intent ( in ) :: total_angular_momentum_ !! total angular momentum integer ( int32 ), intent ( in ) :: v_ , j_ , vp_ , jp_ !! vibrational and rotational quantum numbers integer ( int32 ), intent ( in ) :: l_ , lp_ !! orbital angular momenta integer ( int32 ), intent ( in ) :: channel_indices ( number_of_channels ) !! holds the indices pointing to the basis arrays integer ( int32 ), intent ( in ) :: channels_omega_values ( number_of_channels ) !! holds all values of \\bar{\\Omega} real ( dp ), intent ( in ) :: bf_matrix ( number_of_channels , number_of_channels ) !! matrix in the BF frame real ( dp ), intent ( out ) :: sf_element !! (output) matrix element in the SF frame !---------------------------------------------------------------------! integer ( int32 ) :: channel_index_1_ , channel_index_2_ real ( dp ) :: p_coeff_outer , p_coeff_inner , sum_outer , sum_inner !---------------------------------------------------------------------! sum_outer = 0.0_dp do channel_index_1_ = 1 , number_of_channels if ( v1array ( channel_indices ( channel_index_1_ )) /= v_ . or . & j1array ( channel_indices ( channel_index_1_ )) /= j_ ) cycle p_coeff_outer = p_coeff ( total_angular_momentum_ , j_ , l_ , & channels_omega_values ( channel_index_1_ )) sum_inner = 0.0_dp do channel_index_2_ = 1 , number_of_channels if ( v1array ( channel_indices ( channel_index_2_ )) /= vp_ . or . & j1array ( channel_indices ( channel_index_2_ )) /= jp_ ) cycle p_coeff_inner = p_coeff ( total_angular_momentum_ , jp_ , lp_ , & channels_omega_values ( channel_index_2_ )) sum_inner = sum_inner + p_coeff_inner * bf_matrix ( channel_index_1_ , channel_index_2_ ) end do sum_outer = sum_outer + p_coeff_outer * sum_inner end do sf_element = sum_outer !---------------------------------------------------------------------! end subroutine calculate_single_SF_element !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine calculate_sf_matrix_from_bf_matrix ( number_of_channels , & total_angular_momentum_ , channel_indices , & channels_omega_values , channel_l_values , bf_matrix , sf_matrix ) !! takes as an input matrix in the body-fixed frame and transforms it !! to the spec-fixed frame; iterates over all matrix elements !! and calls calculate_single_SF_element !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: number_of_channels !! size of the basis integer ( int32 ), intent ( in ) :: total_angular_momentum_ !! total angular momentum integer ( int32 ), intent ( in ) :: channel_indices ( number_of_channels ) !! holds the indices pointing to the basis arrays integer ( int32 ), intent ( in ) :: channels_omega_values ( number_of_channels ) !! holds all values of \\bar{\\Omega} integer ( int32 ), intent ( in ) :: channel_l_values ( number_of_channels ) !! holds all values of l real ( dp ), intent ( in ) :: bf_matrix ( number_of_channels , number_of_channels ) !! matrix in the BF frame real ( dp ), intent ( inout ) :: sf_matrix ( number_of_channels , number_of_channels ) !! (output) matrix in the SF frame !---------------------------------------------------------------------! integer ( int32 ) :: l_ , lp_ , omega_ , omegap_ , v1_ , j1_ , v1p_ , j1p_ , channel_index_1_ , channel_index_2_ real ( dp ) :: single_sf_element !---------------------------------------------------------------------! do channel_index_1_ = 1 , number_of_channels v1_ = v1array ( channel_indices ( channel_index_1_ )) j1_ = j1array ( channel_indices ( channel_index_1_ )) l_ = channel_l_values ( channel_index_1_ ) do channel_index_2_ = 1 , number_of_channels v1p_ = v1array ( channel_indices ( channel_index_2_ )) j1p_ = j1array ( channel_indices ( channel_index_2_ )) lp_ = channel_l_values ( channel_index_2_ ) call calculate_single_SF_element ( number_of_channels , & total_angular_momentum_ , v1_ , j1_ , v1p_ , j1p_ , l_ , lp_ , & channel_indices , channels_omega_values , bf_matrix , & single_sf_element ) sf_matrix ( channel_index_1_ , channel_index_2_ ) = single_sf_element enddo enddo !---------------------------------------------------------------------! end subroutine calculate_sf_matrix_from_bf_matrix !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine calculate_k_matrix ( number_of_channels , log_der_matrix , & number_of_open_channels , channel_indices , channel_l_values , & r_ , k_matrix ) !! calculates the K-matrix from log-derivative matrix using Eq. (4) in !! \"Solution of coupled equations\" !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: number_of_channels !! y-matrix is of number_of_channels x number_of_channels size real ( dp ), intent ( in ) :: log_der_matrix ( number_of_channels , number_of_channels ) !! asymptotic log-derivative matrix integer ( int32 ), intent ( in ) :: number_of_open_channels !! number of open channels integer ( int32 ), intent ( in ) :: channel_indices ( number_of_channels ) !! holds the indices pointing to the basis arrays integer ( int32 ), intent ( in ) :: channel_l_values ( number_of_channels ) !! holds all values of l real ( dp ), intent ( in ) :: r_ !! Rmax real ( dp ), intent ( inout ) :: k_matrix ( number_of_open_channels , number_of_open_channels ) !! K-matrix !---------------------------------------------------------------------! integer ( int32 ) :: open_channel_index_ , closed_channel_index_ , & channel_index_ , status_ , l_ real ( dp ) :: wavenumber , x , j_element_ , jp_element_ , n_element_ , & np_element_ , ratio integer ( int32 ) :: open_channels_indices ( number_of_open_channels ) integer ( int32 ) :: closed_channels_indices ( number_of_channels - number_of_open_channels ) real ( dp ) :: diag_n_matrix ( number_of_channels , number_of_channels ), & diag_np_matrix ( number_of_channels , number_of_channels ), & diag_j_matrix ( number_of_channels , number_of_open_channels ), & diag_jp_matrix ( number_of_channels , number_of_open_channels ) !---------------------------------------------------------------------! ! diag_j_matrix   -  diagonal J matrix (Eqs. 5, 7) ! diag_jp_matrix  -  diagonal J`matrix (derivative of J) ! diag_n_matrix   -  diagonal N matrix (Eqs. 6, 8) ! diag_np_matrix  -  diagonal N`matrix (derivative of N) !---------------------------------------------------------------------! diag_j_matrix = 0 diag_jp_matrix = 0 diag_n_matrix = 0 diag_np_matrix = 0 !---------------------------------------------------------------------! open_channel_index_ = 0 closed_channel_index_ = 0 !---------------------------------------------------------------------! ! save indices to open and closed channels ! this is because channels might not be sorted eneregetically !---------------------------------------------------------------------! do channel_index_ = 1 , number_of_channels if ( is_open ( elevel ( channel_indices ( channel_index_ )))) then open_channel_index_ = open_channel_index_ + 1 open_channels_indices ( open_channel_index_ ) = channel_index_ else closed_channel_index_ = closed_channel_index_ + 1 closed_channels_indices ( closed_channel_index_ ) = channel_index_ endif enddo !---------------------------------------------------------------------! ! Prepare J, J', N and N' matrices (Eqs. 5-6) ! open channels: !---------------------------------------------------------------------! do open_channel_index_ = 1 , number_of_open_channels wavenumber = sqrt ( wavenumber_squared_from_energy ( & elevel ( channel_indices ( open_channels_indices ( open_channel_index_ ))))) x = wavenumber * r_ l_ = channel_l_values ( open_channels_indices ( open_channel_index_ )) call riccati_bessel_j ( & l_ , x , j_element_ , jp_element_ ) diag_j_matrix ( open_channel_index_ , open_channel_index_ ) & = ( wavenumber ) ** ( - 0.5d0 ) * j_element_ diag_jp_matrix ( open_channel_index_ , open_channel_index_ ) & = ( wavenumber ) ** ( 0.5d0 ) * jp_element_ call riccati_bessel_y ( l_ , x , n_element_ , np_element_ ) diag_n_matrix ( open_channel_index_ , open_channel_index_ ) & = ( wavenumber ) ** ( - 0.5d0 ) * n_element_ diag_np_matrix ( open_channel_index_ , open_channel_index_ ) & = ( wavenumber ) ** ( 0.5d0 ) * np_element_ enddo !---------------------------------------------------------------------! ! Prepare J, J', N and N' matrices (Eqs. 7-8) ! closed channels: !---------------------------------------------------------------------! do closed_channel_index_ = 1 , number_of_channels - number_of_open_channels wavenumber = sqrt ( abs ( wavenumber_squared_from_energy ( & elevel ( channel_indices ( closed_channels_indices ( closed_channel_index_ )))))) x = wavenumber * r_ l_ = channel_l_values ( closed_channels_indices ( closed_channel_index_ )) call modified_bessel_k_ratio ( l_ , x , ratio ) !------------------------------------------------------------------! ! substitution for closed channels, (Eqs. 10 - 11) !------------------------------------------------------------------! diag_n_matrix ( number_of_open_channels + closed_channel_index_ , & number_of_open_channels + closed_channel_index_ ) = 1.d0 diag_np_matrix ( number_of_open_channels + closed_channel_index_ , & number_of_open_channels + closed_channel_index_ ) = wavenumber * ratio enddo !---------------------------------------------------------------------! -----------------------> consider a separate function call DGEMM ( 'N' , 'N' , number_of_channels , number_of_channels , & number_of_channels , 1.0d0 , log_der_matrix , number_of_channels , diag_n_matrix , & number_of_channels , - 1.d0 , diag_np_matrix , number_of_channels ) call DGEMM ( 'N' , 'N' , number_of_channels , number_of_open_channels , & number_of_channels , - 1.0d0 , log_der_matrix , number_of_channels , diag_j_matrix , & number_of_channels , 1.d0 , diag_jp_matrix , number_of_channels ) !---------------------------------------------------------------------! call DGESV ( number_of_channels , number_of_open_channels , diag_np_matrix , & number_of_channels , diag_j_matrix , diag_jp_matrix , number_of_channels , status_ ) !---------------------------------------------------------------------! k_matrix = diag_jp_matrix ( 1 : number_of_open_channels , 1 : number_of_open_channels ) !---------------------------------------------------------------------! end subroutine calculate_k_matrix !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine calculate_s_matrix ( number_of_open_channels , k_matrix , & s_matrix_real , s_matrix_imag ) !! calculates S-matrix from open-open portion of the K-matrix using !! Eq. (12) in \"Solution of coupled equations\" !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: number_of_open_channels !! number of open channels real ( dp ), intent ( in ) :: k_matrix ( number_of_open_channels , number_of_open_channels ) !! K-matrix real ( dp ), intent ( inout ) :: s_matrix_real ( number_of_open_channels , number_of_open_channels ) !! (output) real part of the S-matrix real ( dp ), intent ( inout ) :: s_matrix_imag ( number_of_open_channels , number_of_open_channels ) !! (output) imaginary part of the S-matrix !---------------------------------------------------------------------! integer ( int32 ) :: open_channel_index_1_ , open_channel_index_2_ real ( dp ) :: s_tmp_matrix ( number_of_open_channels , number_of_open_channels ) !---------------------------------------------------------------------! s_matrix_real = 0 s_matrix_imag = 0 !---------------------------------------------------------------------! !---------------------------------------------------------------------! call DGEMM ( 'N' , 'N' , number_of_open_channels , number_of_open_channels , & number_of_open_channels , 0.5d0 , k_matrix , number_of_open_channels , & k_matrix , number_of_open_channels , 0.d0 , s_tmp_matrix , number_of_open_channels ) !---------------------------------------------------------------------! do open_channel_index_1_ = 1 , number_of_open_channels s_tmp_matrix ( open_channel_index_1_ , open_channel_index_1_ ) = & s_tmp_matrix ( open_channel_index_1_ , open_channel_index_1_ ) + 0.5d0 enddo !---------------------------------------------------------------------! call invert_symmetric_matrix ( s_tmp_matrix ) call fill_symmetric_matrix ( s_tmp_matrix , 'u' ) !---------------------------------------------------------------------! call DGEMM ( 'N' , 'N' , number_of_open_channels , number_of_open_channels , & number_of_open_channels , - 1.0d0 , s_tmp_matrix , number_of_open_channels ,& k_matrix , number_of_open_channels , 0.d0 , s_matrix_imag , number_of_open_channels ) !---------------------------------------------------------------------! do open_channel_index_1_ = 1 , number_of_open_channels do open_channel_index_2_ = 1 , number_of_open_channels s_matrix_real ( open_channel_index_1_ , open_channel_index_2_ ) = & s_tmp_matrix ( open_channel_index_1_ , open_channel_index_2_ ) enddo s_matrix_real ( open_channel_index_1_ , open_channel_index_1_ ) = & s_matrix_real ( open_channel_index_1_ , open_channel_index_1_ ) - 1.d0 enddo !---------------------------------------------------------------------! end subroutine calculate_s_matrix !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! end module boundary_conditions_mod","tags":"","loc":"sourcefile/boundary_conditions_mod.f90.html"},{"title":"input_validation_mod.f90 – the SCATTERING code","text":"This file depends on sourcefile~~input_validation_mod.f90~~EfferentGraph sourcefile~input_validation_mod.f90 input_validation_mod.f90 sourcefile~utility_functions_mod.f90 utility_functions_mod.f90 sourcefile~input_validation_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~data_mod.f90 data_mod.f90 sourcefile~input_validation_mod.f90->sourcefile~data_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~input_validation_mod.f90~~AfferentGraph sourcefile~input_validation_mod.f90 input_validation_mod.f90 sourcefile~input_reader_mod.f90 input_reader_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~input_validation_mod.f90 sourcefile~radial_coupling_terms_mod.f90 radial_coupling_terms_mod.f90 sourcefile~radial_coupling_terms_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~pes_matrix_mod.f90 pes_matrix_mod.f90 sourcefile~pes_matrix_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~pes_matrix_mod.f90->sourcefile~radial_coupling_terms_mod.f90 sourcefile~scattering.f90 scattering.f90 sourcefile~scattering.f90->sourcefile~input_reader_mod.f90 sourcefile~scattering.f90->sourcefile~radial_coupling_terms_mod.f90 sourcefile~scattering.f90->sourcefile~pes_matrix_mod.f90 sourcefile~channels_mod.f90 channels_mod.f90 sourcefile~scattering.f90->sourcefile~channels_mod.f90 sourcefile~propagator_mod.f90 propagator_mod.f90 sourcefile~scattering.f90->sourcefile~propagator_mod.f90 sourcefile~state_to_state_cross_sections_mod.f90 state_to_state_cross_sections_mod.f90 sourcefile~scattering.f90->sourcefile~state_to_state_cross_sections_mod.f90 sourcefile~boundary_conditions_mod.f90 boundary_conditions_mod.f90 sourcefile~scattering.f90->sourcefile~boundary_conditions_mod.f90 sourcefile~centrifugal_matrix_mod.f90 centrifugal_matrix_mod.f90 sourcefile~centrifugal_matrix_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~channels_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~propagator_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~propagator_mod.f90->sourcefile~pes_matrix_mod.f90 sourcefile~propagator_mod.f90->sourcefile~centrifugal_matrix_mod.f90 sourcefile~state_to_state_cross_sections_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~boundary_conditions_mod.f90->sourcefile~input_reader_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules input_validation Source Code input_validation_mod.f90 Source Code module input_validation !! This module provides subroutines validating read values !---------------------------------------------------------------------------! use , intrinsic :: iso_fortran_env , only : int32 , sp => real32 , dp => real64 use utility_functions_mod , only : write_error , write_message ,& incorrect_value , integer_to_character use data_mod !---------------------------------------------------------------------------! implicit none !---------------------------------------------------------------------------! contains !---------------------------------------------------------------------------! subroutine check_namelist_input !! Check variables read from namelist \"input\" !---------------------------------------------------------------------! if ( reduced_mass . lt . 0 ) then call incorrect_value ( \"reduced_mass\" , reduced_mass , 5 ) endif if (( relative_energy_flag . ne . 0 ). and .( relative_energy_flag . ne . 1 )) then call incorrect_value ( \"relative_energy_flag\" , relative_energy_flag , 5 ) endif if ( energy . lt . 0 ) then call incorrect_value ( \"energy\" , energy , 5 ) endif if ( rmin . le . 0 ) then call incorrect_value ( \"rmin\" , rmin , 5 ) endif if ( rmax . le . 0 ) then call incorrect_value ( \"rmax\" , rmax , 5 ) endif if ( rmax . lt . rmin ) then call incorrect_value ( \"rmax/rmin\" , rmax / rmin , 5 ) endif if ( steps . le . 0.d0 ) then call incorrect_value ( \"steps\" , steps , 5 ) endif if ( vdepth . lt . 0.d0 ) then call incorrect_value ( \"vdepth\" , vdepth , 5 ) endif if ( jtotmin . lt . 0 ) then call incorrect_value ( \"jtotmin\" , jtotmin , 5 ) endif if ( jtotmax . lt . 0 ) then if ( consecutive_blocks_threshold . lt . 0 ) then call write_message ( \"JTOTMAX < 0:\" ) call incorrect_value ( \"consecutive_blocks_threshold\" , consecutive_blocks_threshold , 5 ) endif if ( elastic_xs_threshold . lt . 0 ) then call write_message ( \"JTOTMAX < 0:\" ) call incorrect_value ( \"elastic_xs_threshold\" , elastic_xs_threshold , 5 ) endif if ( inelastic_xs_threshold . lt . 0 ) then call write_message ( \"JTOTMAX < 0:\" ) call incorrect_value ( \"inelastic_xs_threshold\" , inelastic_xs_threshold , 5 ) endif else if ( jtotmax . lt . jtotmin ) then call write_message ( \"jtotmax is smaller than jtotmin\" ) call incorrect_value ( \"jtotmax/jtotmin\" , & real ( jtotmax / jtotmin , dp ), 5 ) endif endif if ( nlevel . le . 0 ) then call incorrect_value ( \"nlevel\" , nlevel , 5 ) endif if ( relative_energy_flag . eq . 1 ) then if ( initial . le . 0 ) then call write_message ( \"relative_energy_flag = 1:\" ) call incorrect_value ( \"initial\" , initial , 5 ) endif if ( initial . gt . nlevel ) then call write_message ( \"relative_energy_flag = 1:\" ) call write_message ( \"nlevel = \" // & trim ( adjustl ( integer_to_character ( nlevel )))) call incorrect_value ( \"initial > nlevel\" , initial , 5 ) endif endif if ( nr . le . 0 ) then call incorrect_value ( \"nr\" , nr , 5 ) endif if ( nterms . le . 0 ) then call incorrect_value ( \"nterms\" , nterms , 5 ) endif if ( total_number_of_coupling_terms . le . 0 ) then call incorrect_value ( \"total_number_of_coupling_terms\" , total_number_of_coupling_terms , 5 ) endif if ( n_skip_lines . lt . 0 ) then call incorrect_value ( \"n_skip_lines\" , n_skip_lines , 5 ) endif if (( iunits . ne . 0 ). and .( iunits . ne . 1 )) then call incorrect_value ( \"iunits\" , iunits , 5 ) endif inquire ( file = potentialfile , exist = pes_file_exists ) if ( pes_file_exists . eqv .. false .) then call write_error ( trim ( adjustl ( potentialfile )) // \" does not exist\" ) endif if ( prntlvl . lt . 0 ) then call incorrect_value ( \"prntlvl\" , prntlvl , 5 ) endif !---------------------------------------------------------------------! end subroutine check_namelist_input !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine check_namelist_basis !! Check variables read from namelist \"basis\" !---------------------------------------------------------------------! integer ( int32 ) :: level_index_ !---------------------------------------------------------------------! do level_index_ = 1 , nlevel if ( v1array ( level_index_ ). lt . 0 ) then call incorrect_value ( \"v1array(\" // & integer_to_character ( level_index_ ) // \")\" , v1array ( level_index_ ), 5 ) endif if ( j1array ( level_index_ ). lt . 0 ) then call incorrect_value ( \"j1array(\" // & integer_to_character ( level_index_ ) // \")\" , j1array ( level_index_ ), 5 ) endif if ( elevel ( level_index_ ). lt . 0.0_dp ) then call incorrect_value ( \"elevel(\" // & integer_to_character ( level_index_ ) // \")\" , elevel ( level_index_ ), 5 ) endif enddo end subroutine check_namelist_basis !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine check_namelist_potential !! Check variables read from namelist \"potential\" !---------------------------------------------------------------------! integer ( int32 ) :: legendre_index_ , column_index_ !---------------------------------------------------------------------! do legendre_index_ = 1 , nterms if ( l1tab ( legendre_index_ ). lt . 0 ) then call incorrect_value ( \"l1tab(\" // & integer_to_character ( legendre_index_ ) // \")\" , & l1tab ( legendre_index_ ), 5 ) endif enddo do column_index_ = 1 , total_number_of_coupling_terms if ( v1pes ( column_index_ ). lt . 0 ) then call incorrect_value ( \"v1pes(\" // & integer_to_character ( column_index_ ) // \")\" , & v1pes ( column_index_ ), 5 ) endif if ( j1pes ( column_index_ ). lt . 0 ) then call incorrect_value ( \"j1pes(\" // & integer_to_character ( column_index_ ) // \")\" , & j1pes ( column_index_ ), 5 ) endif if ( v1ppes ( column_index_ ). lt . 0 ) then call incorrect_value ( \"vp1pes(\" // & integer_to_character ( column_index_ ) // \")\" , & v1ppes ( column_index_ ), 5 ) endif if ( j1ppes ( column_index_ ). lt . 0 ) then call incorrect_value ( \"j1ppes(\" // & integer_to_character ( column_index_ ) // \")\" , & j1ppes ( column_index_ ), 5 ) endif enddo end subroutine check_namelist_potential !------------------------------------------------------------------------------! end module input_validation","tags":"","loc":"sourcefile/input_validation_mod.f90.html"},{"title":"array_operations_add_scalar_to_diagonal_submod.f90 – the SCATTERING code","text":"This file depends on sourcefile~~array_operations_add_scalar_to_diagonal_submod.f90~~EfferentGraph sourcefile~array_operations_add_scalar_to_diagonal_submod.f90 array_operations_add_scalar_to_diagonal_submod.f90 sourcefile~array_operations_mod.f90 array_operations_mod.f90 sourcefile~array_operations_add_scalar_to_diagonal_submod.f90->sourcefile~array_operations_mod.f90 sourcefile~utility_functions_mod.f90 utility_functions_mod.f90 sourcefile~array_operations_add_scalar_to_diagonal_submod.f90->sourcefile~utility_functions_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules array_operations_add_scalar_to_diagonal_submod Source Code array_operations_add_scalar_to_diagonal_submod.f90 Source Code submodule ( array_operations_mod ) array_operations_add_scalar_to_diagonal_submod !! a submodule for add_scalar_to_diagonal subroutines use utility_functions_mod , only : to_lowercase implicit none contains module subroutine add_scalar_to_diagonal_int32 ( matrix_ , scalar_ ) !! add a scalar value to the matrix diagonal  (integer). integer ( int32 ), intent ( inout ) :: matrix_ (:,:) integer ( int32 ), intent ( in ) :: scalar_ !---------------------------------------------------------------------! integer ( int32 ) :: i_ , size_ !---------------------------------------------------------------------! size_ = size ( matrix_ , dim = 1 ) !---------------------------------------------------------------------! do i_ = 1 , size_ matrix_ ( i_ , i_ ) = matrix_ ( i_ , i_ ) + scalar_ enddo !---------------------------------------------------------------------! end subroutine add_scalar_to_diagonal_int32 module subroutine add_scalar_to_diagonal_sp ( matrix_ , scalar_ ) !! add a scalar value to the matrix diagonal (single precision). real ( sp ), intent ( inout ) :: matrix_ (:,:) real ( sp ), intent ( in ) :: scalar_ !---------------------------------------------------------------------! integer ( int32 ) :: i_ , size_ !---------------------------------------------------------------------! size_ = size ( matrix_ , dim = 1 ) !---------------------------------------------------------------------! do i_ = 1 , size_ matrix_ ( i_ , i_ ) = matrix_ ( i_ , i_ ) + scalar_ enddo !---------------------------------------------------------------------! end subroutine add_scalar_to_diagonal_sp module subroutine add_scalar_to_diagonal_dp ( matrix_ , scalar_ ) !! add a scalar value to the matrix diagonal real ( dp ), intent ( inout ) :: matrix_ (:,:) real ( dp ), intent ( in ) :: scalar_ !---------------------------------------------------------------------! integer ( int32 ) :: i_ , size_ !---------------------------------------------------------------------! size_ = size ( matrix_ , dim = 1 ) !---------------------------------------------------------------------! do i_ = 1 , size_ matrix_ ( i_ , i_ ) = matrix_ ( i_ , i_ ) + scalar_ enddo !---------------------------------------------------------------------! end subroutine add_scalar_to_diagonal_dp end submodule array_operations_add_scalar_to_diagonal_submod","tags":"","loc":"sourcefile/array_operations_add_scalar_to_diagonal_submod.f90.html"},{"title":"propagator_mod.f90 – the SCATTERING code","text":"This file depends on sourcefile~~propagator_mod.f90~~EfferentGraph sourcefile~propagator_mod.f90 propagator_mod.f90 sourcefile~data_mod.f90 data_mod.f90 sourcefile~propagator_mod.f90->sourcefile~data_mod.f90 sourcefile~utility_functions_mod.f90 utility_functions_mod.f90 sourcefile~propagator_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~input_reader_mod.f90 input_reader_mod.f90 sourcefile~propagator_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~pes_matrix_mod.f90 pes_matrix_mod.f90 sourcefile~propagator_mod.f90->sourcefile~pes_matrix_mod.f90 sourcefile~centrifugal_matrix_mod.f90 centrifugal_matrix_mod.f90 sourcefile~propagator_mod.f90->sourcefile~centrifugal_matrix_mod.f90 sourcefile~array_operations_mod.f90 array_operations_mod.f90 sourcefile~propagator_mod.f90->sourcefile~array_operations_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~data_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~array_operations_mod.f90 sourcefile~input_validation_mod.f90 input_validation_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~input_validation_mod.f90 sourcefile~pes_matrix_mod.f90->sourcefile~data_mod.f90 sourcefile~pes_matrix_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~pes_matrix_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~pes_matrix_mod.f90->sourcefile~array_operations_mod.f90 sourcefile~radial_coupling_terms_mod.f90 radial_coupling_terms_mod.f90 sourcefile~pes_matrix_mod.f90->sourcefile~radial_coupling_terms_mod.f90 sourcefile~math_functions_mod.f90 math_functions_mod.f90 sourcefile~pes_matrix_mod.f90->sourcefile~math_functions_mod.f90 sourcefile~centrifugal_matrix_mod.f90->sourcefile~data_mod.f90 sourcefile~centrifugal_matrix_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~centrifugal_matrix_mod.f90->sourcefile~array_operations_mod.f90 sourcefile~input_validation_mod.f90->sourcefile~data_mod.f90 sourcefile~input_validation_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~radial_coupling_terms_mod.f90->sourcefile~data_mod.f90 sourcefile~radial_coupling_terms_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~radial_coupling_terms_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~radial_coupling_terms_mod.f90->sourcefile~math_functions_mod.f90 sourcefile~math_functions_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~special_functions_mod.f90 special_functions_mod.f90 sourcefile~math_functions_mod.f90->sourcefile~special_functions_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~propagator_mod.f90~~AfferentGraph sourcefile~propagator_mod.f90 propagator_mod.f90 sourcefile~scattering.f90 scattering.f90 sourcefile~scattering.f90->sourcefile~propagator_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules propagator_mod Source Code propagator_mod.f90 Source Code module propagator_mod !! This modules contains the subroutines used by the renormalized !! Numerov propagator. !----------------------------------------------------------------------------! use , intrinsic :: iso_fortran_env , only : int32 , sp => real32 , dp => real64 use data_mod use io_mod use array_operations_mod , only : invert_symmetric_matrix , fill_symmetric_matrix , add_scalar_to_diagonal use centrifugal_matrix_mod , only : calculate_centrifugal_matrix use pes_matrix_mod , only : calculate_pes_matrix use utility_functions_mod , only : time_count_summary !---------------------------------------------------------------------------! implicit none !---------------------------------------------------------------------------! private public :: numerov !---------------------------------------------------------------------------! contains !---------------------------------------------------------------------------! subroutine numerov ( number_of_channels_ , channel_indices_ , & channels_omega_values_ , nonzero_terms_per_element_ , & nonzero_legendre_indices_ , nonzero_algebraic_coefficients_ , & number_of_steps_ , total_angular_momentum_ , log_der_matrix_ ) !! renormalized Numerov propagator !! ... !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: number_of_channels_ !! size of the basis integer ( int32 ), intent ( in ) :: channel_indices_ ( number_of_channels_ ) !! holds the indices pointing to the basis arrays integer ( int32 ), intent ( in ) :: channels_omega_values_ ( number_of_channels_ ) !! holds all values of \\bar{\\Omega} integer ( int32 ), intent ( in ) :: nonzero_terms_per_element_ (:) !! keeps the number of non-zero terms in the sum (Eq. (6.21)) for !! each non-zero element of W/V integer ( int32 ), intent ( in ) :: nonzero_legendre_indices_ (:) !! holds the proper indices pointing to l1/l2/lltabs, which !! correspond to the non-vanishing elements of the sum  (Eq. (6.21)) !! for each non-zero element of W/V real ( dp ), intent ( in ) :: nonzero_algebraic_coefficients_ (:) !! holds the values of the non-zero algebraic coefficients integer ( int32 ), intent ( in ) :: number_of_steps_ !! number of steps from rmin to rmax integer ( int32 ), intent ( in ) :: total_angular_momentum_ !! total angular momentum real ( dp ), intent ( inout ) :: log_der_matrix_ ( number_of_channels_ , number_of_channels_ ) !! resulting log-derivative matrix at RMAX !---------------------------------------------------------------------! integer ( int32 ) :: i , channel_index_1_ , channel_index_2_ real ( dp ) :: start , finish , intermolecular_distance_ , step_numerov_ , calculation_time_ real ( dp ), dimension ( number_of_channels_ , number_of_channels_ ) :: & centrifugal_matrix_ , & t_matrix_minus_ , t_matrix_ , t_matrix_plus_ , r_matrix_ , & r_matrix_rmax_ , r_matrix_plus_ !---------------------------------------------------------------------! CALL CPU_TIME ( start ) step_numerov_ = ( rmax - rmin ) / dble ( number_of_steps_ - 1 ) intermolecular_distance_ = rmin !---------------------------------------------------------------------! ! Initial setup: calculate centrifugal matrix and R_matrix at Rmin + 1 !---------------------------------------------------------------------! call initial_setup ( number_of_channels_ , step_numerov_ , total_angular_momentum_ , & intermolecular_distance_ , channel_indices_ , channels_omega_values_ ,& nonzero_terms_per_element_ , nonzero_legendre_indices_ , & nonzero_algebraic_coefficients_ , centrifugal_matrix_ , r_matrix_ ) !---------------------------------------------------------------------! ! Propagation loop !---------------------------------------------------------------------! do i = 2 , number_of_steps_ - 2 !------------------------------------------------------------------! intermolecular_distance_ = rmin + ( i - 1 ) * step_numerov_ !------------------------------------------------------------------! call general_propagation_step ( number_of_channels_ , step_numerov_ , & total_angular_momentum_ , intermolecular_distance_ , channel_indices_ , & channels_omega_values_ , nonzero_terms_per_element_ , nonzero_legendre_indices_ , & nonzero_algebraic_coefficients_ , centrifugal_matrix_ , r_matrix_ ) !------------------------------------------------------------------! end do !---------------------------------------------------------------------! call handle_final_propagation_steps ( number_of_channels_ , step_numerov_ , & total_angular_momentum_ , channel_indices_ , & channels_omega_values_ , nonzero_terms_per_element_ , nonzero_legendre_indices_ , & nonzero_algebraic_coefficients_ , centrifugal_matrix_ , r_matrix_ , & t_matrix_minus_ , t_matrix_ , t_matrix_plus_ , r_matrix_rmax_ , r_matrix_plus_ ) !---------------------------------------------------------------------! CALL CPU_TIME ( finish ) !---------------------------------------------------------------------! ! Eq. (6.29) !---------------------------------------------------------------------! call calculate_log_der_matrix ( step_numerov_ , number_of_channels_ , & t_matrix_minus_ , t_matrix_ , t_matrix_plus_ , r_matrix_rmax_ , r_matrix_plus_ , log_der_matrix_ ) !---------------------------------------------------------------------! if ( prntlvl . ge . 2 ) then call time_count_summary ( start , finish , calculation_time_ , & \"Propagation completed in \" ) endif !---------------------------------------------------------------------! end subroutine numerov !------------------------------------------------------------------------! !------------------------------------------------------------------------! subroutine initial_setup ( number_of_channels_ , step_numerov_ , total_angular_momentum_ , & intermolecular_distance_ , channel_indices_ , channels_omega_values_ , & nonzero_terms_per_element_ , nonzero_legendre_indices_ , & nonzero_algebraic_coefficients_ , centrifugal_matrix_ , r_matrix_ ) !! ... !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: number_of_channels_ !! size of the basis real ( dp ), intent ( in ) :: step_numerov_ !! step of the propagator integer ( int32 ), intent ( in ) :: total_angular_momentum_ !! total angular momentum real ( dp ), intent ( in ) :: intermolecular_distance_ !! intermolecular distance integer ( int32 ), intent ( in ) :: channel_indices_ ( number_of_channels_ ) !! holds the indices pointing to the basis arrays integer ( int32 ), intent ( in ) :: channels_omega_values_ ( number_of_channels_ ) !! holds all values of \\bar{\\Omega} integer ( int32 ), intent ( in ) :: nonzero_terms_per_element_ (:) !! keeps the number of non-vanishing elements of the sum over \\\\lambda\\ !! for each non-zero element of the coupling matrix integer ( int32 ), intent ( in ) :: nonzero_legendre_indices_ (:) !! holds indices pointing to l1tab, which correspond to !! the non-vanishing elements of the sum over \\\\lambda\\ !! for each non-zero element of the coupling matrix; real ( dp ), intent ( in ) :: nonzero_algebraic_coefficients_ (:) !! holds the values of the non-zero algebraic coefficients real ( dp ), intent ( inout ) :: centrifugal_matrix_ ( number_of_channels_ , number_of_channels_ ) !! (R**2)*centrifugal matrix - calculated once, will be used throughout the propagation real ( dp ), intent ( inout ) :: r_matrix_ ( number_of_channels_ , number_of_channels_ ) !! R-matrix at Rmin !---------------------------------------------------------------------! real ( dp ), dimension ( number_of_channels_ , number_of_channels_ ) :: & pes_matrix_ , coupling_matrix_ , t_matrix_ , u_matrix_ !---------------------------------------------------------------------! ! Calculate centrifugal matrix !---------------------------------------------------------------------! call calculate_centrifugal_matrix ( total_angular_momentum_ , & channel_indices_ , channels_omega_values_ , centrifugal_matrix_ ) !---------------------------------------------------------------------! ! Calculate PES matrix at rmin !---------------------------------------------------------------------! call calculate_pes_matrix ( total_angular_momentum_ , & intermolecular_distance_ , channel_indices_ , & channels_omega_values_ , nonzero_terms_per_element_ , & nonzero_legendre_indices_ , nonzero_algebraic_coefficients_ , pes_matrix_ ) !---------------------------------------------------------------------! ! Merge centrifugal and PES matrix into Coupling matrix !---------------------------------------------------------------------! call calculate_coupling_matrix ( intermolecular_distance_ , pes_matrix_ , & centrifugal_matrix_ , coupling_matrix_ ) !---------------------------------------------------------------------! ! Calculate initial T-matrix and U-matrix !---------------------------------------------------------------------! call calculate_t_matrix ( step_numerov_ , coupling_matrix_ , t_matrix_ ) call calculate_u_matrix ( t_matrix_ , u_matrix_ ) !---------------------------------------------------------------------! ! Initialize R-matrix: R-matrix at rmin + 1 = U-matrix at rmin !---------------------------------------------------------------------! r_matrix_ = u_matrix_ !---------------------------------------------------------------------! end subroutine initial_setup !------------------------------------------------------------------------! !------------------------------------------------------------------------! subroutine general_propagation_step ( number_of_channels_ , step_numerov_ , total_angular_momentum_ , & intermolecular_distance_ , channel_indices_ , channels_omega_values_ , & nonzero_terms_per_element_ , nonzero_legendre_indices_ , & nonzero_algebraic_coefficients_ , centrifugal_matrix_ , r_matrix_ , is_t_matrix_required_ , t_matrix_returned_ ) !! ... !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: number_of_channels_ !! size of the basis real ( dp ), intent ( in ) :: step_numerov_ !! step of the propagator integer ( int32 ), intent ( in ) :: total_angular_momentum_ !! total angular momentum real ( dp ), intent ( in ) :: intermolecular_distance_ !! intermolecular distance integer ( int32 ), intent ( in ) :: channel_indices_ ( number_of_channels_ ) !! holds the indices pointing to the basis arrays integer ( int32 ), intent ( in ) :: channels_omega_values_ ( number_of_channels_ ) !! holds all values of \\bar{\\Omega} integer ( int32 ), intent ( in ) :: nonzero_terms_per_element_ (:) !! keeps the number of non-vanishing elements of the sum over \\\\lambda\\ !! for each non-zero element of the PES matrix integer ( int32 ), intent ( in ) :: nonzero_legendre_indices_ (:) !! holds indices pointing to l1tab, which correspond to !! the non-vanishing elements of the sum over \\\\lambda\\ !! for each non-zero element of the PES matrix; real ( dp ), intent ( in ) :: nonzero_algebraic_coefficients_ (:) !! holds the values of the non-zero algebraic coefficients real ( dp ), intent ( in ) :: centrifugal_matrix_ ( number_of_channels_ , number_of_channels_ ) !! (R**2)*centrifugal matrix - real ( dp ), intent ( inout ) :: r_matrix_ ( number_of_channels_ , number_of_channels_ ) !! on input: R-matrix at previous step !! on output: R-matrix at next step logical , intent ( in ), optional :: is_t_matrix_required_ !! ... real ( dp ), intent ( out ), optional :: t_matrix_returned_ ( number_of_channels_ , number_of_channels_ ) !! on input: R-matrix at previous step !! on output: R-matrix at next step !---------------------------------------------------------------------! real ( dp ), dimension ( number_of_channels_ , number_of_channels_ ) :: & pes_matrix_ , coupling_matrix_ , t_matrix_ , u_matrix_ , r_matrix_plus_ !---------------------------------------------------------------------! ! Calculate PES matrix at R !---------------------------------------------------------------------! call calculate_pes_matrix ( total_angular_momentum_ , & intermolecular_distance_ , channel_indices_ , & channels_omega_values_ , nonzero_terms_per_element_ , & nonzero_legendre_indices_ , nonzero_algebraic_coefficients_ , pes_matrix_ ) !---------------------------------------------------------------------! ! Merge centrifugal and PES matrix into Coupling matrix !---------------------------------------------------------------------! call calculate_coupling_matrix ( intermolecular_distance_ , pes_matrix_ , & centrifugal_matrix_ , coupling_matrix_ ) !---------------------------------------------------------------------! ! Calculate T-matrix and U-matrix !---------------------------------------------------------------------! call calculate_t_matrix ( step_numerov_ , coupling_matrix_ , t_matrix_ ) call calculate_u_matrix ( t_matrix_ , u_matrix_ ) !---------------------------------------------------------------------! ! Invert R matrix from previous step !---------------------------------------------------------------------! call invert_symmetric_matrix ( r_matrix_ ) call fill_symmetric_matrix ( r_matrix_ , 'u' ) !------------------------------------------------------------------! ! R_{n+1} = U_{n} - R_{n}&#94;{-1} !------------------------------------------------------------------! r_matrix_plus_ = u_matrix_ - r_matrix_ !------------------------------------------------------------------! ! Move R_{n+1} to R_{n} !------------------------------------------------------------------! r_matrix_ = r_matrix_plus_ !------------------------------------------------------------------! if ( present ( is_t_matrix_required_ ) . and . is_t_matrix_required_ ) then t_matrix_returned_ = t_matrix_ endif !---------------------------------------------------------------------! end subroutine general_propagation_step !------------------------------------------------------------------------! !------------------------------------------------------------------------! subroutine handle_final_propagation_steps ( number_of_channels_ , & step_numerov_ , total_angular_momentum_ , & channel_indices_ , channels_omega_values_ , & nonzero_terms_per_element_ , nonzero_legendre_indices_ , & nonzero_algebraic_coefficients_ , centrifugal_matrix_ , r_matrix_ , & t_matrix_minus_ , t_matrix_ , t_matrix_plus_ , r_matrix_rmax_ , r_matrix_plus_ ) !! Handles propagation at the last two grid points: !! R_{N-1} and R_{N}: provides T-matrix at N-1, N and N+1 points !! and the Ratio matrix at N and N+1 points !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: number_of_channels_ !! size of the basis real ( dp ), intent ( in ) :: step_numerov_ !! step of the propagator integer ( int32 ), intent ( in ) :: total_angular_momentum_ !! total angular momentum integer ( int32 ), intent ( in ) :: channel_indices_ ( number_of_channels_ ) !! holds the indices pointing to the basis arrays integer ( int32 ), intent ( in ) :: channels_omega_values_ ( number_of_channels_ ) !! holds all values of \\bar{\\Omega} integer ( int32 ), intent ( in ) :: nonzero_terms_per_element_ (:) !! keeps the number of non-vanishing elements of the sum over \\\\lambda\\ !! for each non-zero element of the PES matrix integer ( int32 ), intent ( in ) :: nonzero_legendre_indices_ (:) !! holds indices pointing to l1tab, which correspond to !! the non-vanishing elements of the sum over \\\\lambda\\ !! for each non-zero element of the PES matrix; real ( dp ), intent ( in ) :: nonzero_algebraic_coefficients_ (:) !! holds the values of the non-zero algebraic coefficients real ( dp ), intent ( in ) :: centrifugal_matrix_ ( number_of_channels_ , number_of_channels_ ) !! \\R&#94;{2} \\cdot\\ centrifugal matrix - real ( dp ), intent ( inout ) :: r_matrix_ ( number_of_channels_ , number_of_channels_ ) !! Ratio matrix at N-1 step real ( dp ), intent ( out ) :: t_matrix_minus_ ( number_of_channels_ , number_of_channels_ ) !! T-matrix at N-1 step real ( dp ), intent ( out ) :: t_matrix_ ( number_of_channels_ , number_of_channels_ ) !! T-matrix at N step real ( dp ), intent ( out ) :: t_matrix_plus_ ( number_of_channels_ , number_of_channels_ ) !! T-matrix at N+1 step real ( dp ), intent ( out ) :: r_matrix_rmax_ ( number_of_channels_ , number_of_channels_ ) !! Ratio matrix at N step real ( dp ), intent ( out ) :: r_matrix_plus_ ( number_of_channels_ , number_of_channels_ ) !! Ratio matrix at N+1 step !---------------------------------------------------------------------! logical :: is_t_matrix_required_ real ( dp ) :: intermolecular_distance_ real ( dp ), dimension ( number_of_channels_ , number_of_channels_ ) :: & pes_matrix_ , coupling_matrix_ , u_matrix_ !---------------------------------------------------------------------! is_t_matrix_required_ = . true . !---------------------------------------------------------------------! ! N - 1 step !---------------------------------------------------------------------! intermolecular_distance_ = rmax - step_numerov_ call general_propagation_step ( number_of_channels_ , step_numerov_ , & total_angular_momentum_ , intermolecular_distance_ , & channel_indices_ , channels_omega_values_ , & nonzero_terms_per_element_ , nonzero_legendre_indices_ , & nonzero_algebraic_coefficients_ , centrifugal_matrix_ , r_matrix_ , & is_t_matrix_required_ , t_matrix_minus_ ) r_matrix_rmax_ = r_matrix_ !---------------------------------------------------------------------! ! N  step !---------------------------------------------------------------------! intermolecular_distance_ = intermolecular_distance_ + step_numerov_ call general_propagation_step ( number_of_channels_ , step_numerov_ , & total_angular_momentum_ , intermolecular_distance_ , & channel_indices_ , channels_omega_values_ , & nonzero_terms_per_element_ , nonzero_legendre_indices_ , & nonzero_algebraic_coefficients_ , centrifugal_matrix_ , r_matrix_ , & is_t_matrix_required_ , t_matrix_ ) r_matrix_plus_ = r_matrix_ !---------------------------------------------------------------------! ! N + 1 step !---------------------------------------------------------------------! intermolecular_distance_ = intermolecular_distance_ + step_numerov_ call general_propagation_step ( number_of_channels_ , step_numerov_ , & total_angular_momentum_ , intermolecular_distance_ , & channel_indices_ , channels_omega_values_ , & nonzero_terms_per_element_ , nonzero_legendre_indices_ , & nonzero_algebraic_coefficients_ , centrifugal_matrix_ , r_matrix_ , & is_t_matrix_required_ , t_matrix_plus_ ) !---------------------------------------------------------------------! end subroutine handle_final_propagation_steps !------------------------------------------------------------------------! !------------------------------------------------------------------------! subroutine calculate_coupling_matrix ( intermolecular_distance_ , & pes_matrix_ , centrifugal_matrix_ , coupling_matrix_ ) !! Combines the contribution from the interaction potential, total and !! and internal energy (pes_matrix_) with centrifugal matrix !! \\ W_{\\mathrm{N}} = V_{\\mathrm{N}} + 1/R&#94;{2} L&#94;{2} \\ !---------------------------------------------------------------------! real ( dp ), intent ( in ) :: intermolecular_distance_ !! intermolecular distance real ( dp ), intent ( in ) :: pes_matrix_ (:,:) !! holds contribution from the interaction potential, total and !! and internal energy real ( dp ), intent ( in ) :: centrifugal_matrix_ (:,:) !! \\R&#94;{2}\\ centrifugal matrix real ( dp ), intent ( inout ) :: coupling_matrix_ (:,:) !! (output) Coupling (W) matrix !---------------------------------------------------------------------! coupling_matrix_ = pes_matrix_ & + ( 1.0_dp / intermolecular_distance_ ** 2.0_dp ) * centrifugal_matrix_ !---------------------------------------------------------------------! end subroutine calculate_coupling_matrix !------------------------------------------------------------------------! !------------------------------------------------------------------------! subroutine calculate_t_matrix ( step_ , coupling_matrix_ , t_matrix_ ) !! Calculates the T-matrix from the coupling matrix at grid point N: !! \\ T_{\\mathrm{N}} = h&#94;{2}/12 W_{\\mathrm{N}} \\ !---------------------------------------------------------------------! real ( dp ), intent ( in ) :: step_ !! step of the propagator real ( dp ), intent ( in ) :: coupling_matrix_ (:,:) !! Coupling (W) matrix v real ( dp ), intent ( inout ) :: t_matrix_ (:,:) !! (output) T-matrix at grid point N !---------------------------------------------------------------------! t_matrix_ = ( step_ ** 2.0_dp ) / 1 2.0_dp * coupling_matrix_ !---------------------------------------------------------------------! end subroutine calculate_t_matrix !------------------------------------------------------------------------! !------------------------------------------------------------------------! subroutine calculate_u_matrix ( t_matrix_ , u_matrix_ ) !! Calculates the U-matrix from T-matrix at grid point N: !! \\U_{\\mathrm{N}} = 12(\\mathbf{I} - 10 T_{\\mathrm{N}})&#94;{-1} - 10 \\mathbf{I}\\ !---------------------------------------------------------------------! real ( dp ), intent ( in ) :: t_matrix_ (:,:) !! T-matrix at grid point N real ( dp ), intent ( inout ) :: u_matrix_ (:,:) !! (output) U-matrix at grid point N !---------------------------------------------------------------------! integer ( int32 ) :: channel_index_ !---------------------------------------------------------------------! u_matrix_ = - t_matrix_ call add_scalar_to_diagonal ( u_matrix_ , 1.0_dp ) call invert_symmetric_matrix ( u_matrix_ ) call fill_symmetric_matrix ( u_matrix_ , 'u' ) u_matrix_ = 1 2.0_dp * u_matrix_ call add_scalar_to_diagonal ( u_matrix_ , - 1 0.0_dp ) !---------------------------------------------------------------------! end subroutine calculate_u_matrix !------------------------------------------------------------------------! !------------------------------------------------------------------------! subroutine calculate_log_der_matrix ( step_ , number_of_channels_ , & t_matrix_minus_ , t_matrix_ , t_matrix_plus_ , r_matrix_ , r_matrix_plus_ ,& log_der_matrix_ ) !! calculates the log-derivative matrix from !! \\begin{equation} !! {Y}_{\\rm N} = \\frac{1}{h} \\Biggl(\\Bigl(\\frac{1}{2}\\mathbf{I}-{T}_{\\rm{N}+1}\\Bigr) !! \\Bigl(\\mathbf{I}-{T}_{\\rm{N}+1}\\Bigr)&#94;{-1} {R}_{\\rm{N}+1} - !! \\Bigl(\\frac{1}{2}\\mathbf{I}-{T}_{\\rm{N}-1}\\Bigr) !! \\Bigl(\\mathbf{I}-\\mathbf{T}_{\\rm{N}-1}\\Bigr)&#94;{-1}\\mathbf{R}_{\\rm{N}}&#94;{-1} !! \\Biggr)\\Bigl(\\mathbf{I}-{T}_{\\rm{N}}\\Bigr) !! \\end{equation} !! called by numerov at the end of the propagation !---------------------------------------------------------------------! real ( dp ), intent ( in ) :: step_ !! propagator step integer ( int32 ), intent ( in ) :: number_of_channels_ !! number of scattering channels in the block real ( dp ), intent ( in ) :: t_matrix_minus_ ( number_of_channels_ , number_of_channels_ ) !! T-matrix at R_{max - 1} real ( dp ), intent ( in ) :: t_matrix_ ( number_of_channels_ , number_of_channels_ ) !! T-matrix at R_{max} real ( dp ), intent ( in ) :: t_matrix_plus_ ( number_of_channels_ , number_of_channels_ ) !! T-matrix at R_{max + 1} real ( dp ), intent ( in ) :: r_matrix_ ( number_of_channels_ , number_of_channels_ ) !! R-matrix at R_{max} real ( dp ), intent ( in ) :: r_matrix_plus_ ( number_of_channels_ , number_of_channels_ ) !! R-matrix at R_{max + 1} real ( dp ), intent ( inout ) :: log_der_matrix_ ( number_of_channels_ , number_of_channels_ ) !! log-derivative matrix !---------------------------------------------------------------------! integer ( int32 ) :: channel_index_1_ real ( dp ) :: matrix_a_ ( number_of_channels_ , number_of_channels_ ), & matrix_b_ ( number_of_channels_ , number_of_channels_ ), & matrix_c_ ( number_of_channels_ , number_of_channels_ ), & matrix_d_ ( number_of_channels_ , number_of_channels_ ), & matrix_e_ ( number_of_channels_ , number_of_channels_ ), & matrix_ab_ ( number_of_channels_ , number_of_channels_ ), & matrix_cd_ ( number_of_channels_ , number_of_channels_ ), & left_matrix_ ( number_of_channels_ , number_of_channels_ ), & right_matrix_ ( number_of_channels_ , number_of_channels_ ), & working_r_matrix_ ( number_of_channels_ , number_of_channels_ ), & matrix_difference_ ( number_of_channels_ , number_of_channels_ ) !---------------------------------------------------------------------! log_der_matrix_ = 0 !---------------------------------------------------------------------! ! First bracket: (1/2 I - T_{N+1}) !---------------------------------------------------------------------! matrix_a_ = - t_matrix_plus_ call add_scalar_to_diagonal ( matrix_a_ , 0.5_dp ) !---------------------------------------------------------------------! ! Second bracket: (I - T_{N+1})&#94;{-1} !---------------------------------------------------------------------! matrix_b_ = - t_matrix_plus_ call add_scalar_to_diagonal ( matrix_b_ , 1.0_dp ) call invert_symmetric_matrix ( matrix_b_ ) call fill_symmetric_matrix ( matrix_b_ , \"u\" ) !---------------------------------------------------------------------! ! Third bracket: (1/2 I - T_{N-1}) !---------------------------------------------------------------------! matrix_c_ = - t_matrix_minus_ call add_scalar_to_diagonal ( matrix_c_ , 0.5_dp ) !---------------------------------------------------------------------! ! Fourth bracket: (I - T_{N-1})&#94;{-1} !---------------------------------------------------------------------! matrix_d_ = - t_matrix_minus_ call add_scalar_to_diagonal ( matrix_d_ , 1.0_dp ) call invert_symmetric_matrix ( matrix_d_ ) call fill_symmetric_matrix ( matrix_d_ , \"u\" ) !---------------------------------------------------------------------! ! Last bracket: (I - T_{N}) !---------------------------------------------------------------------! matrix_e_ = - t_matrix_ call add_scalar_to_diagonal ( matrix_e_ , 1.0_dp ) !---------------------------------------------------------------------! ! Copy R_{N} to another matrix (r_matrix_ is protected as intent(in)) !---------------------------------------------------------------------! working_r_matrix_ = r_matrix_ call invert_symmetric_matrix ( working_r_matrix_ ) call fill_symmetric_matrix ( working_r_matrix_ , \"u\" ) !---------------------------------------------------------------------! ! The first term in the large bracket: ! (1/2 I - T_{N+1}) (I - T_{N+1})&#94;{-1} R_{N+1} !---------------------------------------------------------------------! CALL DGEMM ( 'N' , 'N' , number_of_channels_ , number_of_channels_ , & number_of_channels_ , 1.0_dp , matrix_a_ , number_of_channels_ , matrix_b_ ,& number_of_channels_ , 0.0_dp , matrix_ab_ , number_of_channels_ ) CALL DGEMM ( 'N' , 'N' , number_of_channels_ , number_of_channels_ , & number_of_channels_ , 1.0_dp , matrix_ab_ , number_of_channels_ , & r_matrix_plus_ , number_of_channels_ , 0.0_dp , left_matrix_ , number_of_channels_ ) !---------------------------------------------------------------------! ! The second term in the large bracket: ! (1/2 I - T_{N-1}) (I - T_{N-1})&#94;{-1} R_{N}&#94;{-1} !---------------------------------------------------------------------! CALL DGEMM ( 'N' , 'N' , number_of_channels_ , number_of_channels_ , & number_of_channels_ , 1.0_dp , matrix_c_ , number_of_channels_ , matrix_d_ ,& number_of_channels_ , 0.0_dp , matrix_cd_ , number_of_channels_ ) CALL DGEMM ( 'N' , 'N' , number_of_channels_ , number_of_channels_ , & number_of_channels_ , 1.0_dp , matrix_cd_ , number_of_channels_ , & working_r_matrix_ , number_of_channels_ , 0.0_dp , right_matrix_ , number_of_channels_ ) !---------------------------------------------------------------------! ! Substract the two terms in the large bracket !---------------------------------------------------------------------! matrix_difference_ = left_matrix_ - right_matrix_ !---------------------------------------------------------------------! ! Multiply the product by (I - T_{N}) !---------------------------------------------------------------------! CALL DGEMM ( 'N' , 'N' , number_of_channels_ , number_of_channels_ , & number_of_channels_ , 1.0_dp / step_ , matrix_difference_ , & number_of_channels_ , matrix_e_ , number_of_channels_ , 0.0_dp , & log_der_matrix_ , number_of_channels_ ) !---------------------------------------------------------------------! end subroutine calculate_log_der_matrix !------------------------------------------------------------------------------! end module propagator_mod","tags":"","loc":"sourcefile/propagator_mod.f90.html"},{"title":"utility_functions_mod.f90 – the SCATTERING code","text":"Files dependent on this one sourcefile~~utility_functions_mod.f90~~AfferentGraph sourcefile~utility_functions_mod.f90 utility_functions_mod.f90 sourcefile~input_reader_mod.f90 input_reader_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~input_validation_mod.f90 input_validation_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~input_validation_mod.f90 sourcefile~radial_coupling_terms_mod.f90 radial_coupling_terms_mod.f90 sourcefile~radial_coupling_terms_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~radial_coupling_terms_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~math_functions_mod.f90 math_functions_mod.f90 sourcefile~radial_coupling_terms_mod.f90->sourcefile~math_functions_mod.f90 sourcefile~math_functions_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~channels_mod.f90 channels_mod.f90 sourcefile~channels_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~channels_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~pes_matrix_mod.f90 pes_matrix_mod.f90 sourcefile~pes_matrix_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~pes_matrix_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~pes_matrix_mod.f90->sourcefile~radial_coupling_terms_mod.f90 sourcefile~pes_matrix_mod.f90->sourcefile~math_functions_mod.f90 sourcefile~save_s_matrix_mod.f90 save_s_matrix_mod.f90 sourcefile~save_s_matrix_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~scattering.f90 scattering.f90 sourcefile~scattering.f90->sourcefile~utility_functions_mod.f90 sourcefile~scattering.f90->sourcefile~input_reader_mod.f90 sourcefile~scattering.f90->sourcefile~radial_coupling_terms_mod.f90 sourcefile~scattering.f90->sourcefile~channels_mod.f90 sourcefile~scattering.f90->sourcefile~pes_matrix_mod.f90 sourcefile~scattering.f90->sourcefile~save_s_matrix_mod.f90 sourcefile~propagator_mod.f90 propagator_mod.f90 sourcefile~scattering.f90->sourcefile~propagator_mod.f90 sourcefile~unitarity_check_mod.f90 unitarity_check_mod.f90 sourcefile~scattering.f90->sourcefile~unitarity_check_mod.f90 sourcefile~state_to_state_cross_sections_mod.f90 state_to_state_cross_sections_mod.f90 sourcefile~scattering.f90->sourcefile~state_to_state_cross_sections_mod.f90 sourcefile~boundary_conditions_mod.f90 boundary_conditions_mod.f90 sourcefile~scattering.f90->sourcefile~boundary_conditions_mod.f90 sourcefile~propagator_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~propagator_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~propagator_mod.f90->sourcefile~pes_matrix_mod.f90 sourcefile~centrifugal_matrix_mod.f90 centrifugal_matrix_mod.f90 sourcefile~propagator_mod.f90->sourcefile~centrifugal_matrix_mod.f90 sourcefile~array_operations_fill_symmetric_matrix_submod.f90 array_operations_fill_symmetric_matrix_submod.f90 sourcefile~array_operations_fill_symmetric_matrix_submod.f90->sourcefile~utility_functions_mod.f90 sourcefile~array_operations_add_scalar_to_diagonal_submod.f90 array_operations_add_scalar_to_diagonal_submod.f90 sourcefile~array_operations_add_scalar_to_diagonal_submod.f90->sourcefile~utility_functions_mod.f90 sourcefile~input_validation_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~unitarity_check_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~state_to_state_cross_sections_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~state_to_state_cross_sections_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~boundary_conditions_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~boundary_conditions_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~boundary_conditions_mod.f90->sourcefile~math_functions_mod.f90 sourcefile~centrifugal_matrix_mod.f90->sourcefile~input_reader_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules utility_functions_mod Source Code utility_functions_mod.f90 Source Code module utility_functions_mod !! utility_functions_mod contains functions which handle writing !! messages/errors/warnings on screen, formatting headers, summary of the !! calculations and a few other supporting functions. !---------------------------------------------------------------------------! use , intrinsic :: iso_fortran_env , only : int32 , sp => real32 , dp => real64 , & output_unit !---------------------------------------------------------------------------! implicit none private public :: write_header , write_message , write_warning , write_error , time_count_summary , & alloc_status , file_io_status , incorrect_value , to_lowercase , & integer_to_character , float_to_character !---------------------------------------------------------------------------! character ( len =* ), parameter :: letters = & \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\" character ( len =* ), parameter :: uppercase = letters ( 1 : 26 ) character ( len =* ), parameter :: lowercase = letters ( 27 :) !---------------------------------------------------------------------------! interface incorrect_value !! interface for the following message: !! ``incorrect value encountered: !!   variable_name = variable_value`` module procedure incorrect_value_ch !! for character variables module procedure incorrect_value_int32 !! for integer variables module procedure incorrect_value_sp !! for single precision variables module procedure incorrect_value_dp !! for double precision variables end interface !---------------------------------------------------------------------------! contains !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine write_message ( message_ , unit_ ) !! writes a message on a chosen unit !---------------------------------------------------------------------! character ( len = * ), intent ( in ) :: message_ !! a message to be written integer ( int32 ), optional , intent ( in ) :: unit_ !! optional, unit where the message will be written !---------------------------------------------------------------------! if ( present ( unit_ )) then write ( unit_ , '(a)' ) trim ( message_ ) else write ( output_unit , '(a)' ) trim ( message_ ) endif !---------------------------------------------------------------------! end subroutine write_message !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine write_warning ( message_ , unit_ ) !! writes a warning message on a chosen unit !---------------------------------------------------------------------! character ( len = * ), intent ( in ) :: message_ !! a message to be written integer ( int32 ), optional , intent ( in ) :: unit_ !! optional, unit where the message will be written !---------------------------------------------------------------------! call write_message ( 'Warning: ' // trim ( message_ ), unit_ ) !---------------------------------------------------------------------! end subroutine write_warning !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine write_error ( message_ , unit_ ) !! writes an error message on a chosen unit !---------------------------------------------------------------------! character ( len = * ), intent ( in ) :: message_ !! a message to be written integer ( int32 ), optional , intent ( in ) :: unit_ !! optional, unit where the message will be written !---------------------------------------------------------------------! call write_message ( 'Error: ' // trim ( message_ ), unit_ ) stop !---------------------------------------------------------------------! end subroutine write_error !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine write_header ( header_type , opt_integer_ ) !! writes headers on screen character ( len = * ), intent ( in ) :: header_type !! specifies the type of the header: 'main', 'input_read', !! 'input_check', 'input_summary', 'initialization', 'check_norm', !! 'save_basis', 'save_pes', 'radial_terms', 'save_radial_terms', !! 'reconstruction' integer ( int32 ), optional , intent ( in ) :: opt_integer_ !! optional integer used in case \"block\" to pass jtot value !---------------------------------------------------------------------! character ( len = 100 ) :: header_star , header_str character ( len = 10 ) :: tmp_str_ integer ( int32 ) :: len_str_ !---------------------------------------------------------------------! select case ( trim ( header_type )) case ( 'main' ) write ( header_star , fmt = \"(a90)\" ) repeat ( \"*\" , 90 ) call write_message ( header_star ) call write_message ( header_star ) write ( header_str , fmt = '(a,25x,a43,20x,a)' ) & '*' , 'BIGOS quantum scattering package, vs. 0.00.' , '*' call write_message ( header_str ) write ( header_str , fmt = '(a,36x,a19,33x,a)' ) & '*' , 'the SCATTERING code' , '*' call write_message ( header_str ) write ( header_str , fmt = '(a,29x,a31,28x,a)' ) & '*' , 'adjusted for H2-He calculations' , '*' call write_message ( header_str ) write ( header_str , fmt = '(a,37x,a17,34x,a)' ) & '*' , 'by Hubert Jozwiak' , '*' call write_message ( header_str ) write ( header_str , fmt = '(a,40x,a11,37x,a)' ) & '*' , '20/12/2023 ' , '*' call write_message ( header_str ) call write_message ( header_star ) case ( 'block' ) call write_message ( repeat ( '*' , 90 )) if ( present ( opt_integer_ )) then write ( tmp_str_ , \"(i10)\" ) opt_integer_ len_str_ = len_trim ( tmp_str_ ) write ( * , '(\"*\", A, \"JTOT = \", A, A, \"*\")' ) & repeat ( ' ' , 40 - len_str_ ), tmp_str_ , repeat ( ' ' , 41 ) call write_message ( repeat ( '*' , 90 )) else call write_error ( \"**** JTOT value not provided in \" // & \"write_header_block ****\" ) endif case ( 'unitarity' ) call write_message ( repeat ( \" \" , 43 ) // \"***\" ) call write_message ( \"Check of the unitarity of the S-matrix:\" ) call write_message ( repeat ( \" \" , 34 ) // \"*** S-matrix elements: ***\" ) call write_message ( \"   ROW   COL\" // repeat ( \" \" , 15 ) // \"S**2\" // & repeat ( \" \" , 17 ) // \"RE (S)\" // repeat ( \" \" , 17 ) // \"IM (S)\" ) case default call incorrect_value ( 'header_type (write_header)' , header_type ) end select !---------------------------------------------------------------------! end subroutine write_header !   !---------------------------------------------------------------------------! !   !---------------------------------------------------------------------------! !      subroutine write_summary(total_, inp_read_, inp_check_, inp_summary_,    & !          units_, grids_, system_, normalization_, pes_save_, basis_save_,     & !          radterm_calcs_, radterm_save_, reconstruct_) !         !! writes the summary on screen !         !---------------------------------------------------------------------! !         real(dp), intent(in)           :: total_, inp_read_, inp_check_,      & !           inp_summary_, units_, grids_, system_, normalization_, pes_save_,   & !           basis_save_, radterm_calcs_, radterm_save_, reconstruct_ !            !! total time of the run & time intervals for smaller tasks !            !! completed by the code; if a task wasn't invoked, print '---' !            !! on screen !         !---------------------------------------------------------------------! !         real(dp), parameter  :: zero_tolerance = 1.0e-12_dp !         !---------------------------------------------------------------------! !         character(len = 100) :: header_star, header_str, line !         !---------------------------------------------------------------------! !         call write_message('') !         write(header_star, fmt = '(a72)') repeat('*', 72) !         call write_message(header_star) !         write(header_str, fmt = '(a,23x,a,x,es11.4,x,a,22x,a)')               & !                 '*','Finished in',total_,'s','*' !         call write_message(header_str) !         call write_message(header_star) !         if (inp_read_.gt.zero_tolerance) then !            write(line, fmt = '(a,24x,es11.4,x,a,22x,a)')                      & !                    '* Input read', inp_read_, 's', '*' !         else !            write(line, fmt = '(a,24x,6x,a,26x,a)')                            & !                    '* Input read', '---', '*' !         endif !         call write_message(line) !         if (inp_check_.gt.zero_tolerance) then !            write(line, fmt = '(a,23x,es11.4,x,a,22x,a)')                      & !                    '* Input check', inp_check_, 's', '*' !         else !            write(line, fmt = '(a,23x,6x,a,26x,a)')                            & !                    '* Input check', '---', '*' !         endif !         call write_message(line) !         if (inp_summary_.gt.zero_tolerance) then !            write(line, fmt = '(a,21x,es11.4,x,a,22x,a)')                      & !                    '* Input summary', inp_summary_, 's', '*' !         else !            write(line, fmt = '(a,21x,6x,a,26x,a)')                            & !                    '* Input summary', '---', '*' !         endif !         call write_message(line) !         if (units_.gt.zero_tolerance) then !            write(line, fmt = '(a,17x,es11.4,x,a,22x,a)')                      & !                    '* Units preparation', units_, 's', '*' !         else !            write(line, fmt = '(a,17x,6x,a,26x,a)')                            & !                    '* Units preparation', '---', '*' !         endif !         call write_message(line) !         if (grids_.gt.zero_tolerance) then !            write(line, fmt = '(a,17x,es11.4,x,a,22x,a)')                      & !                    '* Grids preparation', grids_, 's', '*' !         else !            write(line, fmt = '(a,17x,6x,a,26x,a)')                            & !                    '* Grids preparation', '---', '*' !         endif !         call write_message(line) !         if (system_.gt.zero_tolerance) then !            write(line, fmt = '(a,11x,es11.4,x,a,22x,a)')                      & !                    '* PES & basis preparation', system_, 's', '*' !         else !            write(line, fmt = '(a,11x,6x,a,26x,a)')                            & !                    '* PES & basis preparation', '---', '*' !         endif !         call write_message(line) !         if (normalization_.gt.zero_tolerance) then !            write(line, fmt = '(a,15x,es11.4,x,a,22x,a)')                      & !                    '* Normalization check', normalization_, 's', '*' !         else !            write(line, fmt = '(a,15x,6x,a,26x,a)')                            & !                    '* Normalization check', '---', '*' !         endif !         call write_message(line) !         if (pes_save_.gt.zero_tolerance) then !            write(line, fmt = '(a,24x,es11.4,x,a,22x,a)')                      & !                    '* Saving PES', pes_save_, 's', '*' !         else !            write(line, fmt = '(a,24x,6x,a,26x,a)')                            & !                    '* Saving PES', '---', '*' !         endif !         call write_message(line) !         if (basis_save_.gt.zero_tolerance) then !            write(line, fmt = '(a,22x,es11.4,x,a,22x,a)')                      & !                    '* Saving basis', basis_save_, 's', '*' !         else !            write(line, fmt = '(a,22x,6x,a,26x,a)')                            & !                    '* Saving basis', '---', '*' !         endif !         call write_message(line) !         if (radterm_calcs_.gt.zero_tolerance) then !            write(line, fmt = '(a,9x,es11.4,x,a,22x,a)')                       & !                    '* Radial terms calculations', radterm_calcs_, 's', '*' !         else !            write(line, fmt = '(a,9x,6x,a,26x,a)')                             & !                    '* Radial terms calculations', '---', '*' !         endif !         call write_message(line) !         if (radterm_save_.gt.zero_tolerance) then !            write(line, fmt = '(a,15x,es11.4,x,a,22x,a)')                      & !                    '* Saving radial terms', radterm_save_, 's', '*' !         else !            write(line, fmt = '(a,15x,6x,a,26x,a)')                            & !                    '* Saving radial terms', '---', '*' !         endif !         call write_message(line) !         if (reconstruct_.gt.zero_tolerance) then !            write(line, fmt = '(a,9x,es11.4,x,a,22x,a)')                       & !                    '* Reconstruction of the PES', reconstruct_, 's', '*' !         else !            write(line, fmt = '(a,9x,6x,a,26x,a)')                             & !                    '* Reconstruction of the PES', '---', '*' !         endif !         call write_message(line) !         write(line, fmt = '(a,24x,es11.4,x,a,22x,a)')                         & !                 '* Total time', total_, 's', '*' !         call write_message(line) !         call write_message(header_star) !         !---------------------------------------------------------------------! !      end subroutine write_summary !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine time_count_summary ( start_ , stop_ , time_ , message_ ) !! print the message about the time it took to complete a single task !---------------------------------------------------------------------! real ( dp ), intent ( in ) :: start_ !! initial time real ( dp ), intent ( in ) :: stop_ !! final time real ( dp ), intent ( out ) :: time_ !! stop_ - start_ character ( len = * ), optional , intent ( in ) :: message_ !! (optional) a message to print instead of a default !! \"Completed in ... s\" !---------------------------------------------------------------------! character ( len = 12 ) :: default_message = 'Completed in' character ( len = 100 ) :: time_msg !---------------------------------------------------------------------! time_ = stop_ - start_ if ( present ( message_ )) then write ( time_msg , fmt = '(a,x,a,es11.4,x,a)' ) & '--' , trim ( message_ ), time_ , 's' else write ( time_msg , fmt = '(a,x,a,es11.4,x,a)' ) & '--' , default_message , time_ , 's' endif call write_message ( time_msg ) !---------------------------------------------------------------------! end subroutine time_count_summary !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine alloc_status ( istat_ , message_ , op_ , unit_ ) !! check the status after allocation !---------------------------------------------------------------------! integer ( int32 ) :: istat_ !! result of stat=istat in (de)allocate character ( len = * ), intent ( in ) :: message_ !! a message to be written character ( len = 1 ), intent ( in ) :: op_ !! 'a' for allocation, 'd' for deallocation integer ( int32 ), optional , intent ( in ) :: unit_ !! optional, unit where the message will be written !---------------------------------------------------------------------! character ( len = :), allocatable :: add_prefix_ !---------------------------------------------------------------------! add_prefix_ = '' if ( istat_ /= 0 ) then select case ( op_ ) case ( 'a' ) add_prefix_ = 'memory allocation: ' // trim ( message_ ) case ( 'd' ) add_prefix_ = 'memory deallocation: ' // trim ( message_ ) case default call write_error & ( 'Incorrect op_ argument in alloc_status subroutine (' & // trim ( op_ ) // ')' ) end select call write_error ( add_prefix_ , unit_ ) endif !---------------------------------------------------------------------! end subroutine alloc_status !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine file_io_status ( istat_ , iomsg_ , channel_ , op_ , unit_ ) !! check the status during various io operations on files !---------------------------------------------------------------------! integer ( int32 ) :: istat_ !! result of iostat in open/read/write/close character ( len = * ), intent ( in ) :: iomsg_ !! result of iomsg in open/read/write/close integer ( int32 ), intent ( in ) :: channel_ !! name of the file character ( len = 1 ), intent ( in ) :: op_ !! 'o' for opening of the file, 'r' for reading, 'w' for writing, !! 'c' for closing integer ( int32 ), optional , intent ( in ) :: unit_ !! optional, unit where the message will be written !---------------------------------------------------------------------! character ( len = :), allocatable :: add_prefix_ !---------------------------------------------------------------------! add_prefix_ = '' if ( istat_ /= 0 ) then select case ( op_ ) case ( 'o' ) add_prefix_ = 'opening file on channel: ' // & integer_to_character ( channel_ ) case ( 'r' ) add_prefix_ = 'reading file on channel: ' // & integer_to_character ( channel_ ) case ( 'w' ) add_prefix_ = 'writing to file on channel: ' // & integer_to_character ( channel_ ) case ( 'c' ) add_prefix_ = 'closing file on channel: ' // & integer_to_character ( channel_ ) case default call write_error & ( 'Incorrect op_ argument in file_io_status subroutine (' & // trim ( op_ ) // ')' ) end select call write_error ( trim ( add_prefix_ ) // \" with message: \" // iomsg_ , unit_ ) endif !---------------------------------------------------------------------! end subroutine file_io_status !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine incorrect_value_ch ( name_ , value_ , unit_ ) !! ``incorrect value encountered: !!   variable_name = variable_value`` !---------------------------------------------------------------------! character ( len = * ), intent ( in ) :: name_ !! name of the variable character ( len = * ), intent ( in ) :: value_ !! value of the variable integer ( int32 ), optional , intent ( in ) :: unit_ !! optional, unit where the message will be written !---------------------------------------------------------------------! character ( len = :), allocatable :: add_prefix_ !---------------------------------------------------------------------! add_prefix_ = 'Incorrect value encountered:  ' // trim ( name_ ) // ' = ' // & trim ( value_ ) call write_error ( add_prefix_ , unit_ ) !---------------------------------------------------------------------! end subroutine incorrect_value_ch !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine incorrect_value_int32 ( name_ , value_ , unit_ ) !! ``incorrect value encountered: !!   variable_name = variable_value`` !---------------------------------------------------------------------! character ( len = * ), intent ( in ) :: name_ !! name of the variable integer ( int32 ), intent ( in ) :: value_ !! value of the variable integer ( int32 ), optional , intent ( in ) :: unit_ !! optional, unit where the message will be written !---------------------------------------------------------------------! character ( len = 20 ) :: tmp_ character ( len = :), allocatable :: add_prefix_ !---------------------------------------------------------------------! write ( tmp_ , '(i5)' ) value_ add_prefix_ = 'Incorrect value encountered:  ' // trim ( name_ ) // ' = ' // & trim ( tmp_ ) call write_error ( add_prefix_ , unit_ ) !---------------------------------------------------------------------! end subroutine incorrect_value_int32 !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine incorrect_value_sp ( name_ , value_ , unit_ ) !! ``incorrect value encountered: !!   variable_name = variable_value`` !---------------------------------------------------------------------! character ( len = * ), intent ( in ) :: name_ !! name of the variable real ( sp ), intent ( in ) :: value_ !! value of the variable integer ( int32 ), optional , intent ( in ) :: unit_ !! optional, unit where the message will be written !---------------------------------------------------------------------! character ( len = 16 ), allocatable :: tmp_ character ( len = :), allocatable :: add_prefix_ !---------------------------------------------------------------------! write ( tmp_ , '(e16.8)' ) value_ add_prefix_ = 'Incorrect value encountered:  ' // trim ( name_ ) // ' = ' // & trim ( tmp_ ) call write_error ( add_prefix_ , unit_ ) !---------------------------------------------------------------------! end subroutine incorrect_value_sp !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine incorrect_value_dp ( name_ , value_ , unit_ ) !! ``incorrect value encountered: !!   variable_name = variable_value`` !---------------------------------------------------------------------! character ( len = * ), intent ( in ) :: name_ !! name of the variable real ( dp ), intent ( in ) :: value_ !! value of the variable integer ( int32 ), optional , intent ( in ) :: unit_ !! optional, unit where the message will be written !---------------------------------------------------------------------! character ( len = 16 ), allocatable :: tmp_ character ( len = :), allocatable :: add_prefix_ !---------------------------------------------------------------------! write ( tmp_ , '(e16.8)' ) value_ add_prefix_ = 'Incorrect value encountered:  ' // trim ( name_ ) // ' = ' // & trim ( tmp_ ) call write_error ( add_prefix_ , unit_ ) !---------------------------------------------------------------------! end subroutine incorrect_value_dp !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! function to_lowercase ( str ) result ( low_str ) !! forces lowercase on given string !---------------------------------------------------------------------! character ( len =* ), intent ( in ) :: str !! input string character ( len = len ( str )) :: low_str !! output (lowercase) string !---------------------------------------------------------------------! integer ( int32 ) :: i !---------------------------------------------------------------------! do i = 1 , len ( str ) low_str ( i : i ) = char_to_lowercase ( str ( i : i )) enddo !---------------------------------------------------------------------! end function to_lowercase !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! function char_to_lowercase ( s ) result ( l_s ) !! forces lowercase on a single character !---------------------------------------------------------------------! character ( len = 1 ), intent ( in ) :: s !! input character character ( len = 1 ) :: l_s !! output (lowercase) character !---------------------------------------------------------------------! integer ( int32 ) :: indx !---------------------------------------------------------------------! indx = index ( uppercase , s ) if ( indx > 0 ) then l_s = lowercase ( indx : indx ) else l_s = s endif !---------------------------------------------------------------------! end function char_to_lowercase !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! function integer_to_character ( i ) result ( res ) !! transfers integer to a character !---------------------------------------------------------------------! integer , intent ( in ) :: i !! input integer character ( len = 32 ) :: res !! output character !---------------------------------------------------------------------! write ( res , '(i0)' ) i res = adjustl ( res ) !---------------------------------------------------------------------! end function integer_to_character !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! function float_to_character ( f , format_string ) result ( res ) !! Converts a floating-point number to a character string. !---------------------------------------------------------------------! real ( dp ), intent ( in ) :: f !! input floating-point number character ( len =* ), intent ( in ), optional :: format_string !! Optional format string. character ( len = 64 ) :: res !! Output character string. !---------------------------------------------------------------------! character ( len = 32 ) :: default_format , user_format !---------------------------------------------------------------------! ! Default format: 6 decimal places !---------------------------------------------------------------------! default_format = '(F0.6)' !---------------------------------------------------------------------! if ( present ( format_string )) then user_format = trim ( format_string ) else user_format = default_format endif !---------------------------------------------------------------------! write ( res , user_format ) f res = adjustl ( res ) !---------------------------------------------------------------------! end function float_to_character !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! end module utility_functions_mod","tags":"","loc":"sourcefile/utility_functions_mod.f90.html"},{"title":"save_s_matrix_mod.f90 – the SCATTERING code","text":"This file depends on sourcefile~~save_s_matrix_mod.f90~~EfferentGraph sourcefile~save_s_matrix_mod.f90 save_s_matrix_mod.f90 sourcefile~data_mod.f90 data_mod.f90 sourcefile~save_s_matrix_mod.f90->sourcefile~data_mod.f90 sourcefile~utility_functions_mod.f90 utility_functions_mod.f90 sourcefile~save_s_matrix_mod.f90->sourcefile~utility_functions_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~save_s_matrix_mod.f90~~AfferentGraph sourcefile~save_s_matrix_mod.f90 save_s_matrix_mod.f90 sourcefile~scattering.f90 scattering.f90 sourcefile~scattering.f90->sourcefile~save_s_matrix_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules save_s_matrix_mod Source Code save_s_matrix_mod.f90 Source Code module save_s_matrix_mod !! This module provides procedures that save selective information !! to the S-matrix file !---------------------------------------------------------------------------! use , intrinsic :: iso_fortran_env , only : int32 , sp => real32 , dp => real64 use data_mod use utility_functions_mod , only : file_io_status !---------------------------------------------------------------------------! implicit none !---------------------------------------------------------------------------! private public :: save_s_matrix_file_header , save_s_matrix_block_info !---------------------------------------------------------------------------! contains !---------------------------------------------------------------------------! subroutine save_s_matrix_file_header !! save \"header\" of the S-matrix file: !! -- label, \"itype\", number of levels in the basis, reduced mass of the system !! -- vibrational and rotational quantum numbers !! -- rovibrational energies !! -- index pointing to the initial level and the kinetic/total energy !---------------------------------------------------------------------! character ( len = 200 ) :: err_message integer ( int32 ) :: io_status , ilevel !---------------------------------------------------------------------! open ( s_matrix_unit , file = trim ( smatrixfile ), form = 'unformatted' , & iostat = io_status , iomsg = err_message ) call file_io_status ( io_status , err_message , s_matrix_unit , \"o\" ) !---------------------------------------------------------------------! write ( s_matrix_unit ) label , 2 , nlevel , reduced_mass write ( s_matrix_unit ) ( v1array ( ilevel ), j1array ( ilevel ), ilevel = 1 , nlevel ) write ( s_matrix_unit ) ( elevel ( ilevel ), ilevel = 1 , nlevel ) write ( s_matrix_unit ) initial , energy !---------------------------------------------------------------------! end subroutine save_s_matrix_file_header !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine save_s_matrix_block_info ( total_angular_momentum , parity_exponent , & number_of_open_channels , channel_indices , channel_l_values , wv , & s_matrix_real , s_matrix_imag ) !! save information about current block !! -- total angular momentum, parity exponent, number of open channels !!    in the current block !! -- array of indices pointing to the basis arrays, array holding !!    \\l\\ values, wavenumbers !! -- real part of the S-matrix !! -- imaginary part of the S-matrix !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: total_angular_momentum integer ( int32 ), intent ( in ) :: parity_exponent integer ( int32 ), intent ( in ) :: number_of_open_channels integer ( int32 ), intent ( in ) :: channel_indices ( number_of_open_channels ) integer ( int32 ), intent ( in ) :: channel_l_values ( number_of_open_channels ) real ( dp ), intent ( in ) :: wv ( number_of_open_channels ) real ( dp ), intent ( in ) :: s_matrix_real ( number_of_open_channels , number_of_open_channels ) real ( dp ), intent ( in ) :: s_matrix_imag ( number_of_open_channels , number_of_open_channels ) !---------------------------------------------------------------------! integer ( int32 ) :: channel_index_ , channel_index_2_ !---------------------------------------------------------------------! write ( s_matrix_unit ) total_angular_momentum , parity_exponent , number_of_open_channels write ( s_matrix_unit ) ( channel_indices ( channel_index_ ), & channel_l_values ( channel_index_ ), wv ( channel_index_ ), & channel_index_ = 1 , number_of_open_channels ) write ( s_matrix_unit )(( s_matrix_real ( channel_index_ , channel_index_2_ ),& channel_index_2_ = 1 , channel_index_ ), channel_index_ = 1 , number_of_open_channels ) write ( s_matrix_unit ) (( s_matrix_imag ( channel_index_ , channel_index_2_ ),& channel_index_2_ = 1 , channel_index_ ), channel_index_ = 1 , number_of_open_channels ) !---------------------------------------------------------------------! end subroutine save_s_matrix_block_info !---------------------------------------------------------------------------! end module save_s_matrix_mod","tags":"","loc":"sourcefile/save_s_matrix_mod.f90.html"},{"title":"channels_mod.f90 – the SCATTERING code","text":"This file depends on sourcefile~~channels_mod.f90~~EfferentGraph sourcefile~channels_mod.f90 channels_mod.f90 sourcefile~data_mod.f90 data_mod.f90 sourcefile~channels_mod.f90->sourcefile~data_mod.f90 sourcefile~input_reader_mod.f90 input_reader_mod.f90 sourcefile~channels_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~utility_functions_mod.f90 utility_functions_mod.f90 sourcefile~channels_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~data_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~array_operations_mod.f90 array_operations_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~array_operations_mod.f90 sourcefile~input_validation_mod.f90 input_validation_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~input_validation_mod.f90 sourcefile~input_validation_mod.f90->sourcefile~data_mod.f90 sourcefile~input_validation_mod.f90->sourcefile~utility_functions_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~channels_mod.f90~~AfferentGraph sourcefile~channels_mod.f90 channels_mod.f90 sourcefile~scattering.f90 scattering.f90 sourcefile~scattering.f90->sourcefile~channels_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules channels_mod Source Code channels_mod.f90 Source Code module channels_mod !! This module provides subroutines that set the number of channels in the !! block, save quantum numbers for each channel (both in body- and space-fixed !! cases) and print quantum numbers on screen !---------------------------------------------------------------------------! use , intrinsic :: iso_fortran_env , only : int32 , sp => real32 , dp => real64 use data_mod use io_mod use utility_functions_mod , only : write_error , write_message , write_warning , & integer_to_character , float_to_character !---------------------------------------------------------------------------! implicit none !---------------------------------------------------------------------------! private public :: set_number_of_channels , set_body_fixed_channels , & set_space_fixed_channels , count_open_channels_in_block , & calculate_largest_wavenumber , print_channels !---------------------------------------------------------------------------! contains !------------------------------------------------------------------------! subroutine set_number_of_channels ( total_angular_momentum_ , & number_of_channels_even_parity_block , number_of_channels_odd_parity_block ) !! determine the number of scattering channels in each parity block !! for given total angular momentum in both body-fixed and !! space-fixed frames !---------------------------------------------------------------------! !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: total_angular_momentum_ !! total angular momentum integer ( int32 ), intent ( out ) :: number_of_channels_even_parity_block !! number of channels in the p = 1 (even parity) block integer ( int32 ), intent ( out ) :: number_of_channels_odd_parity_block !! number of channels in the p = -1 (odd parity) block !---------------------------------------------------------------------! integer ( int32 ) :: number_of_channels_even_parity_block_sf , & number_of_channels_odd_parity_block_sf !---------------------------------------------------------------------! ! body-fixed frame !---------------------------------------------------------------------! call calculate_number_of_channels_body_fixed ( total_angular_momentum_ , & number_of_channels_even_parity_block , number_of_channels_odd_parity_block ) !---------------------------------------------------------------------! ! space-fixed frame !---------------------------------------------------------------------! call calculate_number_of_channels_space_fixed ( total_angular_momentum_ , & number_of_channels_even_parity_block_sf , number_of_channels_odd_parity_block_sf ) !---------------------------------------------------------------------! ! Check if the number of channels is the same !---------------------------------------------------------------------! call check_number_of_channels ( number_of_channels_even_parity_block , & number_of_channels_even_parity_block_sf , \"even\" ) call check_number_of_channels ( number_of_channels_odd_parity_block , & number_of_channels_odd_parity_block_sf , \"odd\" ) !---------------------------------------------------------------------! end subroutine set_number_of_channels !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine calculate_number_of_channels_body_fixed ( & total_angular_momentum_ , number_of_channels_even_parity_block , & number_of_channels_odd_parity_block ) !! calculate number of channels in even and odd parity !! blocks in the body-fixed frame; !! in principle, \\\\bar{\\Omega}\\in \\langle 0, \\mathrm{min}(j, J)), !! but number of channels additionally depends on the !! sign of \\ p (-1)&#94;{J} \\: channels with !! \\\\bar{\\Omega}=0\\ values enter blocks with !! \\ p (-1)&#94;{J} = + 1 \\ _only_; !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: total_angular_momentum_ !! total angular momentum integer ( int32 ), intent ( inout ) :: number_of_channels_even_parity_block !! number of channels in the p = 1 (even parity) block integer ( int32 ), intent ( inout ) :: number_of_channels_odd_parity_block !! number of channels in the p = -1 (odd parity) block !---------------------------------------------------------------------! integer ( int32 ) :: level_index_ , omega_max_ !---------------------------------------------------------------------! number_of_channels_even_parity_block = 0 number_of_channels_odd_parity_block = 0 do level_index_ = 1 , nlevel omega_max_ = min ( j1array ( level_index_ ), total_angular_momentum_ ) call update_channel_counts_body_fixed ( omega_max_ , total_angular_momentum_ , & number_of_channels_even_parity_block , number_of_channels_odd_parity_block ) end do !---------------------------------------------------------------------! end subroutine calculate_number_of_channels_body_fixed !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine update_channel_counts_body_fixed ( omega_max_ , & total_angular_momentum_ , number_of_channels_even_parity_block , & number_of_channels_odd_parity_block ) !! updates number_of_channels_even and number_of_channels_odd !! in the body-fixed frame for given \\J\\ and \\\\bar{Omega}_{max}\\ !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: omega_max_ !! largest value of \\\\bar{\\Omega}\\, for given !! rotational and total angular momenta integer ( int32 ), intent ( in ) :: total_angular_momentum_ !! total angular momentum integer ( int32 ), intent ( inout ) :: number_of_channels_even_parity_block !! number of channels for the p = 1 block integer ( int32 ), intent ( inout ) :: number_of_channels_odd_parity_block !! number of channels for the p = -1 block !---------------------------------------------------------------------! if ( mod ( total_angular_momentum_ , 2 ) == 0 ) then !------------------------------------------------------------------! ! Even J: channels with Omega = 0 only count in the even parity block !------------------------------------------------------------------! number_of_channels_even_parity_block = number_of_channels_even_parity_block + omega_max_ + 1 number_of_channels_odd_parity_block = number_of_channels_odd_parity_block + omega_max_ else !------------------------------------------------------------------! ! Odd J: channels with Omega = 0 only count in the odd parity block !------------------------------------------------------------------! number_of_channels_odd_parity_block = number_of_channels_odd_parity_block + omega_max_ + 1 number_of_channels_even_parity_block = number_of_channels_even_parity_block + omega_max_ endif !---------------------------------------------------------------------! end subroutine update_channel_counts_body_fixed !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine calculate_number_of_channels_space_fixed ( & total_angular_momentum_ , number_of_channels_even_parity_block , & number_of_channels_odd_parity_block ) !! calculate number of channels in even and odd parity !! blocks in the space-fixed frame based on available !! values of orbital angular momentum: !! \\ l \\in \\langle |j-J|, j+J \\rangle \\; !! parity is defined as \\p= (-1)&#94;{j+l}\\ !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: total_angular_momentum_ !! total angular momentum integer ( int32 ), intent ( inout ) :: number_of_channels_even_parity_block !! number of channels in the p = 1 (even parity) block integer ( int32 ), intent ( inout ) :: number_of_channels_odd_parity_block !! number of channels in the p = -1 (odd parity) block !---------------------------------------------------------------------! integer ( int32 ) :: level_index_ , l_min_ , l_max_ !---------------------------------------------------------------------! number_of_channels_even_parity_block = 0 number_of_channels_odd_parity_block = 0 do level_index_ = 1 , nlevel l_min_ = abs ( total_angular_momentum_ - j1array ( level_index_ )) l_max_ = total_angular_momentum_ + j1array ( level_index_ ) call update_channel_counts_space_fixed ( l_min_ , l_max_ , level_index_ , & number_of_channels_even_parity_block , number_of_channels_odd_parity_block ) end do !---------------------------------------------------------------------! end subroutine calculate_number_of_channels_space_fixed !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine update_channel_counts_space_fixed ( l_min_ , l_max_ , level_index_ , & number_of_channels_even_parity_block , number_of_channels_odd_parity_block ) !! updates number_of_channels_even and number_of_channels_odd !! in the space-fixed frame for given !! range of orbital angular momentum !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: l_min_ !! smallest value of \\ l = |j-J|\\ integer ( int32 ), intent ( in ) :: l_max_ !! largest value of \\ l = j+J\\ integer ( int32 ), intent ( in ) :: level_index_ !! index pointing to speceific \\j\\ value in j1array integer ( int32 ), intent ( inout ) :: number_of_channels_even_parity_block !! number of channels for the p = 1 block integer ( int32 ), intent ( inout ) :: number_of_channels_odd_parity_block !! number of channels for the p = -1 block !---------------------------------------------------------------------! integer ( int32 ) :: l_ !---------------------------------------------------------------------! do l_ = l_min_ , l_max_ if ( mod ( j1array ( level_index_ ) + l_ , 2 ) == 0 ) then number_of_channels_even_parity_block = & number_of_channels_even_parity_block + 1 else number_of_channels_odd_parity_block = & number_of_channels_odd_parity_block + 1 endif end do !---------------------------------------------------------------------! end subroutine update_channel_counts_space_fixed !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine check_number_of_channels ( number_of_channels_bf , & number_of_channels_sf , parity_block ) !! check if the number of channels is the same in body-fixed !! and space-fixed frames !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: number_of_channels_bf !! number of channels in the body-fixed frame integer ( int32 ), intent ( in ) :: number_of_channels_sf !! number of channels in the space-fixed frame character ( len =* ), intent ( in ) :: parity_block !! \"even\" or \"odd\", for printing purposes !---------------------------------------------------------------------! if ( number_of_channels_bf /= number_of_channels_sf ) then call write_error ( \"Different number of channels in \" // parity_block & // \" block (BF = \" // trim ( adjustl ( integer_to_character ( number_of_channels_bf ))) & // \", SF = \" // trim ( adjustl ( integer_to_character ( number_of_channels_sf ))) & // \"); check set_number_of_channels\" ) endif end subroutine check_number_of_channels !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine set_body_fixed_channels ( total_angular_momentum_ , & parity_exponent_ , channel_indices , channels_omega_values ) !! Prepares the channel_indices array which holds indices that refer to the !! basis arrays: v1level/j1level/elevel, and channels_omega_values which holds values !! of \\bar{\\Omega} !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: total_angular_momentum_ !! total angular momentum integer ( int32 ), intent ( in ) :: parity_exponent_ !! parity exponent of the block (0 if p = +1, 1 if p = -1) integer ( int32 ), intent ( inout ) :: channel_indices (:) !! holds the indices pointing to the basis arrays integer ( int32 ), intent ( inout ) :: channels_omega_values (:) !! holds all values of \\bar{\\Omega} !---------------------------------------------------------------------! integer ( int32 ) :: level_index_ , channel_index_ , omega_max_ , parity_term_exponent_ !---------------------------------------------------------------------! ! due to construction of body-fixed basis states: ! |v j \\bar{\\Omega} J p > = N (|v j \\bar{\\Omega} J > !                         + p (-1)&#94;{J} |v j -\\bar{\\Omega} J > ) ! we are interested in the exponent of the \"p (-1)&#94;{J}\" term !---------------------------------------------------------------------! parity_term_exponent_ = mod ( parity_exponent_ + total_angular_momentum_ , 2 ) !---------------------------------------------------------------------! channel_index_ = 0 !---------------------------------------------------------------------! do level_index_ = 1 , nlevel omega_max_ = min ( j1array ( level_index_ ), total_angular_momentum_ ) call update_body_fixed_channels_info ( omega_max_ , parity_term_exponent_ , & level_index_ , channel_index_ , channel_indices , channels_omega_values ) enddo !---------------------------------------------------------------------! end subroutine set_body_fixed_channels !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine update_body_fixed_channels_info ( omega_max_ , parity_term_exponent_ , & level_index_ , channel_index_ , channel_indices , channels_omega_values ) !! update channel_indices array which holds indices within the !! loop over level_index_ in set_body_fixed_channels !---------------------------------------------------------------------! integer ( int32 ) :: omega_max_ !! largest value of \\\\bar{\\Omega}\\, for given !! rotational and total angular momenta integer ( int32 ) :: parity_term_exponent_ !! exponent of the \\p (-1)&#94;{J}\\ term integer ( int32 ) :: level_index_ !! indices pointing to the basis arrays integer ( int32 ), intent ( inout ) :: channel_index_ !! index pointing to the current value in channel_indices !! and channels_omega_values; incremented in this subroutine integer ( int32 ), intent ( inout ) :: channel_indices (:) !! holds the indices pointing to the basis arrays integer ( int32 ), intent ( inout ) :: channels_omega_values (:) !! holds all values of \\bar{\\Omega} !---------------------------------------------------------------------! integer ( int32 ) :: omega_ , omega_start_ !---------------------------------------------------------------------! ! if p (-1)&#94;{J} = 1, \\bar{\\Omega} states enter the basis ! otherwise, \\bar{\\Omega} > 0; to avoid redundancy, we handle this ! with omega_start_ which is 0 if parity_term_exponent_ is 0, ! otherwise 1 !---------------------------------------------------------------------! omega_start_ = parity_term_exponent_ !---------------------------------------------------------------------! do omega_ = omega_start_ , omega_max_ channel_index_ = channel_index_ + 1 if ( channel_index_ > size ( channel_indices )) then call write_error ( \"channel_index_ out of bounds of \" // & \"channel_indices in set_body_fixed_channels.\" ) end if channels_omega_values ( channel_index_ ) = omega_ channel_indices ( channel_index_ ) = level_index_ enddo !---------------------------------------------------------------------! end subroutine update_body_fixed_channels_info !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine set_space_fixed_channels ( total_angular_momentum_ , & parity_exponent_ , channel_l_values ) !! Prepares the channel_l_values array which holds values of !! orbital angular momentum, \\l\\, a space-fixed-frame quantum number. !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: total_angular_momentum_ !! total angular momentum integer ( int32 ), intent ( in ) :: parity_exponent_ !! parity exponent of the block (0 if p = +1, 1 if p = -1) integer ( int32 ), intent ( inout ) :: channel_l_values (:) !! holds all values of l !---------------------------------------------------------------------! integer :: level_index_ , l_min_ , l_max_ , l_ , channel_index_ !---------------------------------------------------------------------! channel_index_ = 0 do level_index_ = 1 , nlevel l_min_ = abs ( total_angular_momentum_ - j1array ( level_index_ )) l_max_ = total_angular_momentum_ + j1array ( level_index_ ) do l_ = l_min_ , l_max_ if ( mod ( l_ + j1array ( level_index_ ), 2 ) == parity_exponent_ ) then channel_index_ = channel_index_ + 1 if ( channel_index_ > size ( channel_l_values )) then call write_error ( \"channel_index_ out of bounds of \" // & \"channel_l_values in set_space_fixed_channels.\" ) end if channel_l_values ( channel_index_ ) = l_ endif enddo enddo !---------------------------------------------------------------------! end subroutine set_space_fixed_channels !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! function count_open_channels_in_block ( channel_indices ) & result ( number_of_open_channels_ ) !! counts the energetically accessible channels in the given block !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: channel_indices (:) !! holds the indices pointing to the basis arrays integer ( int32 ) :: number_of_open_channels_ !! (output) number of open channels !---------------------------------------------------------------------! integer ( int32 ) :: channel_index_ !---------------------------------------------------------------------! number_of_open_channels_ = 0 do channel_index_ = 1 , size ( channel_indices ) if ( is_open ( elevel ( channel_indices ( channel_index_ )))) then number_of_open_channels_ = number_of_open_channels_ + 1 endif enddo !---------------------------------------------------------------------! end function count_open_channels_in_block !------------------------------------------------------------------------! !------------------------------------------------------------------------! function calculate_largest_wavenumber ( channel_indices ) result ( largest_wavenumber_ ) !! Calculates the largest wave number in the block; !! called only if there are any open channels !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: channel_indices (:) !! holds the indices pointing to the basis arrays real ( dp ) :: largest_wavenumber_ !! (output) the largest wave number (wavmax) in the block !---------------------------------------------------------------------! integer ( int32 ) :: channel_index_ real ( dp ) :: wavenumber_ !---------------------------------------------------------------------! wavenumber_ = 0.0_dp !---------------------------------------------------------------------! do channel_index_ = 1 , size ( channel_indices ) if ( is_open ( elevel ( channel_indices ( channel_index_ )))) then wavenumber_ = sqrt ( wavenumber_squared_from_energy ( elevel ( channel_indices ( channel_index_ ))) ) largest_wavenumber_ = max ( largest_wavenumber_ , wavenumber_ ) endif enddo !---------------------------------------------------------------------! end function calculate_largest_wavenumber !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine print_channels ( parity_exponent_ , channel_indices , & channels_omega_values ) !! prints information about body-fixed channels on screen !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: parity_exponent_ !! parity exponent of the block (0 if p = +1, 1 if p = -1) integer ( int32 ), intent ( inout ) :: channel_indices (:) !! holds the indices pointing to the basis arrays integer ( int32 ), intent ( inout ) :: channels_omega_values (:) !! holds all values of \\bar{\\Omega} !---------------------------------------------------------------------! integer ( int32 ) :: channel_index_ , v_ , j_ , omega_ , parity_ real ( dp ) :: internal_energy_ , wavenumber_ !---------------------------------------------------------------------! call write_message ( \"  v1      j1     omega      p\" // repeat ( \" \" , 10 ) & // \"E_vj\" // repeat ( \" \" , 16 ) // \"wv\" ) !---------------------------------------------------------------------! do channel_index_ = 1 , size ( channel_indices ) v_ = v1array ( channel_indices ( channel_index_ )) j_ = j1array ( channel_indices ( channel_index_ )) omega_ = channels_omega_values ( channel_index_ ) parity_ = ( - 1 ) ** parity_exponent_ internal_energy_ = elevel ( channel_indices ( channel_index_ )) !------------------------------------------------------------------! ! format for open channels: !------------------------------------------------------------------! if ( is_open ( internal_energy_ )) then wavenumber_ = sqrt ( wavenumber_squared_from_energy ( internal_energy_ ) ) call write_channel_line ( v_ , j_ , omega_ , parity_ , & internal_energy_ , wavenumber_ ) !------------------------------------------------------------------! ! format for closed channels: !------------------------------------------------------------------! else call write_channel_line ( v_ , j_ , omega_ , parity_ , internal_energy_ ) endif !------------------------------------------------------------------! enddo !---------------------------------------------------------------------! end subroutine print_channels !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine write_channel_line ( v_ , j_ , omega_ , parity_ , internal_energy_ , & wavenumber_ ) ! Subroutine arguments integer ( int32 ), intent ( in ) :: v_ !! vibrational quantum number integer ( int32 ), intent ( in ) :: j_ !! rotational quantum number integer ( int32 ), intent ( in ) :: omega_ !! \\\\bar{\\Omega}\\ integer ( int32 ), intent ( in ) :: parity_ !! parity of the block real ( dp ), intent ( in ) :: internal_energy_ !! \\E_{vj}\\ real ( dp ), intent ( in ), optional :: wavenumber_ !! (optional) if the channel is open, print information !! about the wavenumber !---------------------------------------------------------------------! character ( len = 200 ) :: line_ !---------------------------------------------------------------------! ! Check if wavenumber is provided !---------------------------------------------------------------------! if ( present ( wavenumber_ )) then write ( line_ , \"(I4,4X,I4,6X,I4,5X,I2,2X,F12.4,4X,F14.8)\" ) & v_ , j_ , omega_ , parity_ , internal_energy_ * hartreetocm , & wavenumber_ / bohrtoangstrom else write ( line_ , \"(I4,4X,I4,6X,I4,5X,I2,2X,F12.4,4X,'--------------')\" )& v_ , j_ , omega_ , parity_ , internal_energy_ * hartreetocm endif !---------------------------------------------------------------------! ! Print the formatted line !---------------------------------------------------------------------! call write_message ( line_ ) !---------------------------------------------------------------------! end subroutine write_channel_line !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! end module channels_mod","tags":"","loc":"sourcefile/channels_mod.f90.html"},{"title":"state_to_state_cross_sections_mod.f90 – the SCATTERING code","text":"This file depends on sourcefile~~state_to_state_cross_sections_mod.f90~~EfferentGraph sourcefile~state_to_state_cross_sections_mod.f90 state_to_state_cross_sections_mod.f90 sourcefile~data_mod.f90 data_mod.f90 sourcefile~state_to_state_cross_sections_mod.f90->sourcefile~data_mod.f90 sourcefile~input_reader_mod.f90 input_reader_mod.f90 sourcefile~state_to_state_cross_sections_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~utility_functions_mod.f90 utility_functions_mod.f90 sourcefile~state_to_state_cross_sections_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~data_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~array_operations_mod.f90 array_operations_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~array_operations_mod.f90 sourcefile~input_validation_mod.f90 input_validation_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~input_validation_mod.f90 sourcefile~input_validation_mod.f90->sourcefile~data_mod.f90 sourcefile~input_validation_mod.f90->sourcefile~utility_functions_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~state_to_state_cross_sections_mod.f90~~AfferentGraph sourcefile~state_to_state_cross_sections_mod.f90 state_to_state_cross_sections_mod.f90 sourcefile~scattering.f90 scattering.f90 sourcefile~scattering.f90->sourcefile~state_to_state_cross_sections_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules state_to_state_cross_sections_mod Source Code state_to_state_cross_sections_mod.f90 Source Code module state_to_state_cross_sections_mod !! This module provides functions and subroutines for calculating and analyzing !! state-to-state cross-sections. It is divided into three main parts: !! 1. Calculating cross-sections: Functions for computing state-to-state !!    cross-sections based on quantum states, S-matrix, and scattering parameters. !!    (\"calculate_state_to_state_cross_section\", \"compute_individual_cross_section\", !!    \"get_block_indices\", \"sum_cross_section_contributions\", !!    \"compute_real_component\", \"compute_imag_component\") !! 2. Printing cross-sections: Subroutines to output the largest partial !!    cross-sections, providing both basic and detailed information. !!    (\"print_largest_partial_cross_sections\", \"print_basic_cross_section_info\", !!    \"print_detailed_cross_section_info\") !! 3. Threshold checking: Subroutine to check if the computed cross-sections !!    meet specified convergence conditions !!    (\"check_cross_section_thresholds\") !---------------------------------------------------------------------------! use , intrinsic :: iso_fortran_env , only : int32 , sp => real32 , dp => real64 use data_mod use io_mod use utility_functions_mod , only : write_message , time_count_summary !---------------------------------------------------------------------------! implicit none !---------------------------------------------------------------------------! private public :: calculate_state_to_state_cross_section , & print_largest_partial_cross_sections , save_partial_xs_file_header , & save_partial_xs_single_block , check_cross_section_thresholds !---------------------------------------------------------------------------! contains !---------------------------------------------------------------------------! !                         Calculating cross-sections !---------------------------------------------------------------------------! subroutine calculate_state_to_state_cross_section ( & total_angular_momentum_ , open_basis_levels_ , open_basis_wavevectors_ , & s_matrix_real_ , s_matrix_imag_ , channel_indices_ , channel_l_values_ , & cross_section_array_ ) !! Calculates all state-to-state cross-sections. !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: total_angular_momentum_ !! total angular momentum integer ( int32 ), intent ( in ) :: open_basis_levels_ (:) !! holds indices to the basis arrays which correspond to open channels real ( dp ), intent ( in ) :: open_basis_wavevectors_ (:) !! holds wavenumbers k_{i} real ( dp ), intent ( in ) :: s_matrix_real_ (:,:), s_matrix_imag_ (:,:) !! real and imaginary parts of the S-matrix integer ( int32 ), intent ( in ) :: channel_indices_ (:) !! holds the indices pointing to the basis arrays integer ( int32 ), intent ( in ) :: channel_l_values_ (:) !! holds all values of l real ( dp ), intent ( inout ) :: cross_section_array_ (:) !! array holding all XSs !---------------------------------------------------------------------! integer ( int32 ) :: number_of_open_basis_levels_ , initial_state_ , & final_state_ real ( dp ) :: start_time , finish_time , calculation_time !---------------------------------------------------------------------! call CPU_TIME ( start_time ) number_of_open_basis_levels_ = size ( open_basis_levels_ ) cross_section_array_ = 0 !---------------------------------------------------------------------! do initial_state_ = 1 , number_of_open_basis_levels_ do final_state_ = 1 , number_of_open_basis_levels_ cross_section_array_ (( initial_state_ - 1 ) & * number_of_open_basis_levels_ + final_state_ ) = & compute_individual_cross_section ( initial_state_ , final_state_ ,& open_basis_levels_ , open_basis_wavevectors_ , & s_matrix_real_ , s_matrix_imag_ , channel_indices_ , & channel_l_values_ , total_angular_momentum_ ) enddo enddo !---------------------------------------------------------------------! CALL CPU_TIME ( finish_time ) if ( prntlvl >= 2 ) then call time_count_summary ( start_time , finish_time , calculation_time , & \"Cross-sections calculations completed in \" ) endif !---------------------------------------------------------------------! end !------------------------------------------------------------------------------! !------------------------------------------------------------------------------! function compute_individual_cross_section ( initial_state_ , final_state_ , & open_basis_levels_ , open_basis_wavevectors_ , s_matrix_real_ , & s_matrix_imag_ , channel_indices_ , channel_l_values_ , & total_angular_momentum_ ) result ( cross_section_ ) !! Calculates cross-section for a given initial and final state. !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: initial_state_ !! index pointing to the intial state in basis arrays integer ( int32 ), intent ( in ) :: final_state_ !! index pointing to the final state in basis arrays integer ( int32 ), intent ( in ) :: open_basis_levels_ (:) !! holds indices to the basis arrays which correspond to open channels real ( dp ), intent ( in ) :: open_basis_wavevectors_ (:) !! holds wavenumbers k_{i} real ( dp ), intent ( in ) :: s_matrix_real_ (:,:), s_matrix_imag_ (:,:) !! real and imaginary parts of the S-matrix integer ( int32 ), intent ( in ) :: channel_indices_ (:) !! holds the indices pointing to the basis arrays integer ( int32 ), intent ( in ) :: channel_l_values_ (:) !! holds all values of l integer ( int32 ), intent ( in ) :: total_angular_momentum_ !! total angular momentum real ( dp ) :: cross_section_ !! (output) cross-section !---------------------------------------------------------------------! integer ( int32 ) :: initial_index_ , final_index_ , v_initial_ , & j_initial_ , v_final_ , j_final_ real ( dp ) :: wavevector_initial_ , sum_contributions_ integer ( int32 ), allocatable :: init_block_indices_ (:), & final_block_indices_ (:) !---------------------------------------------------------------------! initial_index_ = open_basis_levels_ ( initial_state_ ) v_initial_ = v1array ( initial_index_ ) j_initial_ = j1array ( initial_index_ ) wavevector_initial_ = open_basis_wavevectors_ ( initial_state_ ) !---------------------------------------------------------------------! final_index_ = open_basis_levels_ ( final_state_ ) v_final_ = v1array ( final_index_ ) j_final_ = j1array ( final_index_ ) !---------------------------------------------------------------------! init_block_indices_ = get_block_indices ( v_initial_ , j_initial_ , & channel_indices_ ) final_block_indices_ = get_block_indices ( v_final_ , j_final_ , & channel_indices_ ) !---------------------------------------------------------------------! sum_contributions_ = sum_cross_section_contributions ( & init_block_indices_ , final_block_indices_ , s_matrix_real_ , & s_matrix_imag_ , channel_l_values_ ) !---------------------------------------------------------------------! cross_section_ = sum_contributions_ & * real ( 2 * total_angular_momentum_ + 1 , dp ) & / ( real ( 2 * j_initial_ + 1 , dp ) * wavevector_initial_ ** 2.0_dp ) * pi !---------------------------------------------------------------------! end function compute_individual_cross_section !------------------------------------------------------------------------------! !------------------------------------------------------------------------------! function get_block_indices ( v_ , j_ , channel_indices_ ) result ( block_indices_ ) !! Returns indices from channel_indices_ that match the specified quantum state. integer ( int32 ), intent ( in ) :: v_ !! vibrational quantum number integer ( int32 ), intent ( in ) :: j_ !! rotational quantum number integer ( int32 ), intent ( in ) :: channel_indices_ (:) !! holds the indices pointing to the basis arrays integer ( int32 ), allocatable :: block_indices_ (:) !! (output) indices that match the specified quantum state !---------------------------------------------------------------------! integer ( int32 ) :: number_of_channels_ , match_count_ , index_ !---------------------------------------------------------------------! number_of_channels_ = size ( channel_indices_ ) match_count_ = 0 !---------------------------------------------------------------------! ! Count the number of matches to preallocate the array !---------------------------------------------------------------------! do index_ = 1 , number_of_channels_ if ( v1array ( channel_indices_ ( index_ )) == v_ . and . & j1array ( channel_indices_ ( index_ )) == j_ ) then match_count_ = match_count_ + 1 endif enddo !---------------------------------------------------------------------! ! Allocate array with the correct size !---------------------------------------------------------------------! allocate ( block_indices_ ( match_count_ )) match_count_ = 0 !---------------------------------------------------------------------! ! Fill the array with matching indices. !---------------------------------------------------------------------! do index_ = 1 , number_of_channels_ if ( v1array ( channel_indices_ ( index_ )) == v_ . and . & j1array ( channel_indices_ ( index_ )) == j_ ) then match_count_ = match_count_ + 1 block_indices_ ( match_count_ ) = index_ endif enddo !---------------------------------------------------------------------! end function get_block_indices !------------------------------------------------------------------------------! !------------------------------------------------------------------------------! function sum_cross_section_contributions ( init_indices_ , final_indices_ , & s_matrix_real_ , s_matrix_imag_ , channel_l_values_ ) result ( sum_contributions_ ) !! Sum the contributions to the cross-section from S-matrix components !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: init_indices_ (:) !! indices pointing to basis element involving initial state integer ( int32 ), intent ( in ) :: final_indices_ (:) !! indices pointing to basis element involving final state integer ( int32 ), intent ( in ) :: channel_l_values_ (:) !! holds all values of l real ( dp ), intent ( in ) :: s_matrix_real_ (:,:), s_matrix_imag_ (:,:) !! real and imaginary parts of the S-matrix real ( dp ) :: sum_contributions_ !! (output) contribution to the cross-section from S-matrix components !---------------------------------------------------------------------! integer ( int32 ) :: initial_index_ , final_index_ , l_initial_ , l_final_ real ( dp ) :: term_real_ , term_imag_ , term_squared_ !---------------------------------------------------------------------! sum_contributions_ = 0.0_dp do initial_index_ = 1 , size ( init_indices_ ) l_initial_ = channel_l_values_ ( init_indices_ ( initial_index_ )) do final_index_ = 1 , size ( final_indices_ ) l_final_ = channel_l_values_ ( final_indices_ ( final_index_ )) term_real_ = compute_real_component ( & init_indices_ ( initial_index_ ), final_indices_ ( final_index_ ), & l_initial_ , l_final_ , s_matrix_real_ ) term_imag_ = compute_imag_component ( & init_indices_ ( initial_index_ ), final_indices_ ( final_index_ ), & s_matrix_imag_ ) term_squared_ = term_real_ ** 2.0_dp + term_imag_ ** 2.0_dp sum_contributions_ = sum_contributions_ + term_squared_ end do end do end function sum_cross_section_contributions !------------------------------------------------------------------------------! !------------------------------------------------------------------------------! function compute_real_component ( initial_index_ , final_index_ , l_initial_ , & l_final_ , s_matrix_real_ ) result ( real_contribution_ ) !! Computes the real part of the cross-section contribution for given indices. !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: initial_index_ !! index pointing to the basis element involving initial state integer ( int32 ), intent ( in ) :: final_index_ !! index pointing to the basis element involving final state integer ( int32 ), intent ( in ) :: l_initial_ !! pre-collisional \\l\\ value integer ( int32 ), intent ( in ) :: l_final_ !! post-collisional \\l\\ value real ( dp ), intent ( in ) :: s_matrix_real_ (:,:) !! real part of the S-matrix real ( dp ) :: real_contribution_ !! (output) contribution to the cross-section from real part of the S-matrix !---------------------------------------------------------------------! if ( l_initial_ == l_final_ ) then if ( initial_index_ == final_index_ ) then real_contribution_ = 1.0_dp - s_matrix_real_ ( initial_index_ , final_index_ ) else real_contribution_ = - s_matrix_real_ ( initial_index_ , final_index_ ) endif else real_contribution_ = - s_matrix_real_ ( initial_index_ , final_index_ ) endif end function compute_real_component !------------------------------------------------------------------------------! !------------------------------------------------------------------------------! function compute_imag_component ( initial_index_ , final_index_ , s_matrix_imag_ ) result ( imag_contribution_ ) !! Computes the imaginary part of the cross-section contribution for given indices. !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: initial_index_ !! index pointing to the basis element involving initial state integer ( int32 ), intent ( in ) :: final_index_ !! index pointing to the basis element involving final state real ( dp ), intent ( in ) :: s_matrix_imag_ (:,:) !! imaginary part of the S-matrix real ( dp ) :: imag_contribution_ !! (output) contribution to the cross-section from imaginary part of the S-matrix !---------------------------------------------------------------------! imag_contribution_ = - s_matrix_imag_ ( initial_index_ , final_index_ ) !---------------------------------------------------------------------! end function compute_imag_component !---------------------------------------------------------------------------! !                        Printing cross-sections !---------------------------------------------------------------------------! subroutine print_largest_partial_cross_sections ( total_angular_momentum_ , & largest_elastic_xs_ , largest_inelastic_xs_ , elastic_index_ , & inelastic_index_1_ , inelastic_index_2_ , open_basis_levels_ ) !! Print the largest partial elastic and inelastic state-to-state !! cross-sections in a given block. !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: total_angular_momentum_ !! total angular momentum real ( dp ), intent ( in ) :: largest_elastic_xs_ !! the largest partial elastic state-to-state XS in the block real ( dp ), intent ( in ) :: largest_inelastic_xs_ !! the largest partial inelastic state-to-state XS in the block integer ( int32 ), intent ( in ) :: elastic_index_ !! index pointing indirectly to quantum numbers associated with !! the largest partial elastic state-to-state XS in the block integer ( int32 ), intent ( in ) :: inelastic_index_1_ , inelastic_index_2_ !! indices pointing indirectly to quantum numbers associated with !! the largest partial inelastic state-to-state XS in the block integer ( int32 ), intent ( in ) :: open_basis_levels_ (:) !! holds indices to the basis arrays that correspond to open channels !---------------------------------------------------------------------! if ( prntlvl <= 2 ) then call print_basic_cross_section_info ( total_angular_momentum_ , & largest_elastic_xs_ , \"elastic\" ) call print_basic_cross_section_info ( total_angular_momentum_ , & largest_inelastic_xs_ , \"inelastic\" ) else if ( prntlvl >= 3 ) then call print_detailed_cross_section_info ( total_angular_momentum_ , & largest_elastic_xs_ , elastic_index_ , elastic_index_ , & open_basis_levels_ , \"elastic\" ) call print_detailed_cross_section_info ( total_angular_momentum_ , & largest_inelastic_xs_ , inelastic_index_1_ , inelastic_index_2_ , & open_basis_levels_ , \"inelastic\" ) endif !---------------------------------------------------------------------! call write_message ( repeat ( \" \" , 43 ) // \"***\" ) !---------------------------------------------------------------------! end subroutine print_largest_partial_cross_sections !------------------------------------------------------------------------------! !------------------------------------------------------------------------------! subroutine print_basic_cross_section_info ( total_angular_momentum_ , & cross_section_value_ , type_label_ ) !! Prints basic information about the largest elastic and inelastic !! state-to-state xs (prntlvl <= 2) !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: total_angular_momentum_ !! total angular momentum real ( dp ), intent ( in ) :: cross_section_value_ !! value of the cross-section character ( len =* ), intent ( in ) :: type_label_ !! \"elastic\" or \"inelastic\" !---------------------------------------------------------------------! call write_message ( \"Largest partial \" // trim ( type_label_ ) // & \" state-to-state for JTOT = \" // & trim ( adjustl ( integer_to_character ( total_angular_momentum_ ))) // & \": \" // trim ( adjustl ( float_to_character ( cross_section_value_ )))) !---------------------------------------------------------------------! end subroutine print_basic_cross_section_info !------------------------------------------------------------------------------! !------------------------------------------------------------------------------! subroutine print_detailed_cross_section_info ( total_angular_momentum_ , & cross_section_value_ , index_1_ , index_2_ , open_basis_levels_ , & type_label_ ) !! Prints detailed information about the largest elastic and inelastic !! state-to-state xs (prntlvl >= 3) !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: total_angular_momentum_ !! total angular momentum integer ( int32 ), intent ( in ) :: index_1_ , index_2_ !! indices pointing indirectly to quantum numbers associated with !! the largest partial XS in the block real ( dp ), intent ( in ) :: cross_section_value_ !! value of the cross-section integer ( int32 ), intent ( in ) :: open_basis_levels_ (:) !! holds indices to the basis arrays that correspond to open channels character ( len =* ), intent ( in ) :: type_label_ !! \"elastic\" or \"inelastic\" !---------------------------------------------------------------------! character ( len = 200 ) :: header_line_ , line_ !---------------------------------------------------------------------! call write_message ( \"Largest partial \" // trim ( type_label_ ) // & \" state-to-state for JTOT = \" // & trim ( adjustl ( integer_to_character ( total_angular_momentum_ )))) write ( header_line_ , \"(2x,a4,2x,a4,2x,a2,2x,a4,2x,a4,16x,a2)\" ) & \"v1_f\" , \"j1_f\" , \"<-\" , \"v1_i\" , \"j1_i\" , \"XS\" call write_message ( header_line_ ) !---------------------------------------------------------------------! write ( line_ , \"(2X,I4,2X,I4,6X,I4,2X,I4,2X,E16.8)\" ) & v1array ( open_basis_levels_ ( index_1_ )), & j1array ( open_basis_levels_ ( index_1_ )), & v1array ( open_basis_levels_ ( index_2_ )), & j1array ( open_basis_levels_ ( index_2_ )), cross_section_value_ call write_message ( line_ ) !---------------------------------------------------------------------! end subroutine print_detailed_cross_section_info !---------------------------------------------------------------------------! !                        Saving partial cross-sections !---------------------------------------------------------------------------! subroutine save_partial_xs_file_header !! save \"header\" of the partial cross-sections file: !! -- label, \"itype\", number of levels in the basis, reduced mass of the system !! -- vibrational and rotational quantum numbers !! -- rovibrational energies !! -- index pointing to the initial level and the kinetic/total energy !---------------------------------------------------------------------! character ( len = 200 ) :: err_message integer ( int32 ) :: io_status , ilevel !---------------------------------------------------------------------! open ( partial_file_unit , file = trim ( partialfile ), form = 'formatted' , & status = 'unknown' , iostat = io_status , iomsg = err_message ) call file_io_status ( io_status , err_message , partial_file_unit , \"o\" ) !---------------------------------------------------------------------! call write_message ( \"  jtot  iblock  v1_f  j1_f  <-  v1_i  j1_i'\" // & repeat ( \" \" , 13 ) // \"K.E.\" // repeat ( \" \" , 16 ) // \"XS\" , & unit_ = partial_file_unit ) !---------------------------------------------------------------------! end subroutine save_partial_xs_file_header !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine save_partial_xs_single_block ( jtot_ , block_number_ , & number_of_open_basis_levels , open_basis_levels , xs_block ) !! ... !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: jtot_ integer ( int32 ), intent ( in ) :: block_number_ integer ( int32 ), intent ( in ) :: number_of_open_basis_levels integer ( int32 ), intent ( in ) :: open_basis_levels ( number_of_open_basis_levels ) real ( dp ), intent ( in ) :: xs_block ( number_of_open_basis_levels * number_of_open_basis_levels ) !---------------------------------------------------------------------! character ( len = 200 ) :: partial_line integer ( int32 ) :: level_index_ , level_index_2_ !---------------------------------------------------------------------! do level_index_ = 1 , number_of_open_basis_levels do level_index_2_ = 1 , number_of_open_basis_levels write ( partial_line , & \"(I6,2X,I6,2X,I4,2X,I4,6X,I4,2X,I4,2X,E16.8,2X,E16.8)\" ) & jtot_ , block_number_ , v1array ( open_basis_levels ( level_index_ )), & j1array ( open_basis_levels ( level_index_ )), & v1array ( open_basis_levels ( level_index_ )), & j1array ( open_basis_levels ( level_index_ )), & ( etotal () - elevel ( open_basis_levels ( level_index_ ))) * hartreetocm , & xs_block (( level_index_ - 1 ) * number_of_open_basis_levels + level_index_2_ ) call write_message ( partial_line , unit_ = 12 ) enddo enddo !---------------------------------------------------------------------! end subroutine save_partial_xs_single_block !---------------------------------------------------------------------------! !                           Threshold checking !---------------------------------------------------------------------------! subroutine check_cross_section_thresholds ( largest_elastic_xs_ , & largest_inelastic_xs_ , consecutive_elastic_ , consecutive_inelastic_ , & terminate_ ) !! Checks if the elastic_xs_threshold (threshold for elastic XS) and inelastic_xs_threshold !! (threshold for inelastic XS) conditions are already fulfilled. !---------------------------------------------------------------------! real ( dp ), intent ( in ) :: largest_elastic_xs_ !! largest elastic XS in the block real ( dp ), intent ( in ) :: largest_inelastic_xs_ !! largest inelastic XS in the block integer ( int32 ), intent ( inout ) :: consecutive_elastic_ !! number of consecutive blocks meeting condition on elastic XS integer ( int32 ), intent ( inout ) :: consecutive_inelastic_ !! number of consecutive blocks meeting condition on inelastic XS logical , intent ( inout ) :: terminate_ !! flag to indicate termination of loop based on thresholds !---------------------------------------------------------------------! logical :: is_elastic_xs_within_threshold , is_inelastic_xs_within_threshold !---------------------------------------------------------------------! terminate_ = . false . is_elastic_xs_within_threshold = ( largest_elastic_xs_ <= elastic_xs_threshold ) is_inelastic_xs_within_threshold = ( largest_inelastic_xs_ <= inelastic_xs_threshold ) if ( is_elastic_xs_within_threshold ) then consecutive_elastic_ = consecutive_elastic_ + 1 else consecutive_elastic_ = 0 endif if ( is_inelastic_xs_within_threshold ) then consecutive_inelastic_ = consecutive_inelastic_ + 1 else consecutive_inelastic_ = 0 endif if (( consecutive_elastic_ >= consecutive_blocks_threshold ). and . & ( consecutive_inelastic_ >= consecutive_blocks_threshold )) then terminate_ = . true . endif !---------------------------------------------------------------------! end subroutine check_cross_section_thresholds !------------------------------------------------------------------------------! !------------------------------------------------------------------------------! end module state_to_state_cross_sections_mod","tags":"","loc":"sourcefile/state_to_state_cross_sections_mod.f90.html"},{"title":"array_operations_allocate_submod.f90 – the SCATTERING code","text":"This file depends on sourcefile~~array_operations_allocate_submod.f90~~EfferentGraph sourcefile~array_operations_allocate_submod.f90 array_operations_allocate_submod.f90 sourcefile~array_operations_mod.f90 array_operations_mod.f90 sourcefile~array_operations_allocate_submod.f90->sourcefile~array_operations_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules array_operations_allocate_submod Source Code array_operations_allocate_submod.f90 Source Code submodule ( array_operations_mod ) array_operations_allocate_submod !! a submodule for allocate subroutines implicit none contains !------------------------------------------------------------------------! pure module subroutine allocate_1d_int32 ( array_ , size_ ) !! allocate a 1d array and fill it with 0s (intger version) integer ( int32 ), allocatable , intent ( inout ) :: array_ (:) integer ( int32 ), intent ( in ) :: size_ !---------------------------------------------------------------------! if ( allocated ( array_ )) deallocate ( array_ ) allocate ( array_ ( size_ )) array_ = 0 !---------------------------------------------------------------------! end subroutine allocate_1d_int32 !------------------------------------------------------------------------! pure module subroutine allocate_1d_sp ( array_ , size_ ) !! allocate a 1d array and fill it with 0s (single precision version) real ( sp ), allocatable , intent ( inout ) :: array_ (:) integer ( int32 ), intent ( in ) :: size_ !---------------------------------------------------------------------! if ( allocated ( array_ )) deallocate ( array_ ) allocate ( array_ ( size_ )) array_ = 0 !---------------------------------------------------------------------! end subroutine allocate_1d_sp !------------------------------------------------------------------------! pure module subroutine allocate_1d_dp ( array_ , size_ ) !! allocate a 1d array and fill it with 0s (double precision version) real ( dp ), allocatable , intent ( inout ) :: array_ (:) integer ( int32 ), intent ( in ) :: size_ !---------------------------------------------------------------------! if ( allocated ( array_ )) deallocate ( array_ ) allocate ( array_ ( size_ )) array_ = 0 !---------------------------------------------------------------------! end subroutine allocate_1d_dp !------------------------------------------------------------------------! !------------------------------------------------------------------------! pure module subroutine allocate_2d_int32 ( array_ , size1_ , size2_ ) !! allocate a 2d array and fill it with 0s (intger version) integer ( int32 ), allocatable , intent ( inout ) :: array_ (:,:) integer ( int32 ), intent ( in ) :: size1_ , size2_ !---------------------------------------------------------------------! if ( allocated ( array_ )) deallocate ( array_ ) allocate ( array_ ( size1_ , size2_ )) array_ = 0 !---------------------------------------------------------------------! end subroutine allocate_2d_int32 !------------------------------------------------------------------------! pure module subroutine allocate_2d_sp ( array_ , size1_ , size2_ ) !! allocate a 2d array and fill it with 0s (single precision version) real ( sp ), allocatable , intent ( inout ) :: array_ (:,:) integer ( int32 ), intent ( in ) :: size1_ , size2_ !---------------------------------------------------------------------! if ( allocated ( array_ )) deallocate ( array_ ) allocate ( array_ ( size1_ , size2_ )) array_ = 0 !---------------------------------------------------------------------! end subroutine allocate_2d_sp !------------------------------------------------------------------------! pure module subroutine allocate_2d_dp ( array_ , size1_ , size2_ ) !! allocate a 2d array and fill it with 0s (double precision version) real ( dp ), allocatable , intent ( inout ) :: array_ (:,:) integer ( int32 ), intent ( in ) :: size1_ , size2_ !---------------------------------------------------------------------! if ( allocated ( array_ )) deallocate ( array_ ) allocate ( array_ ( size1_ , size2_ )) array_ = 0 !---------------------------------------------------------------------! end subroutine allocate_2d_dp !------------------------------------------------------------------------! !------------------------------------------------------------------------! pure module subroutine allocate_3d_int32 ( array_ , size1_ , size2_ , size3_ ) !! allocate a 3d array and fill it with 0s (intger version) integer ( int32 ), allocatable , intent ( inout ) :: array_ (:,:,:) integer ( int32 ), intent ( in ) :: size1_ , size2_ , size3_ !---------------------------------------------------------------------! if ( allocated ( array_ )) deallocate ( array_ ) allocate ( array_ ( size1_ , size2_ , size3_ )) array_ = 0 !---------------------------------------------------------------------! end subroutine allocate_3d_int32 !------------------------------------------------------------------------! pure module subroutine allocate_3d_sp ( array_ , size1_ , size2_ , size3_ ) !! allocate a 3d array and fill it with 0s (single precision version) real ( sp ), allocatable , intent ( inout ) :: array_ (:,:,:) integer ( int32 ), intent ( in ) :: size1_ , size2_ , size3_ !---------------------------------------------------------------------! if ( allocated ( array_ )) deallocate ( array_ ) allocate ( array_ ( size1_ , size2_ , size3_ )) array_ = 0 !---------------------------------------------------------------------! end subroutine allocate_3d_sp !------------------------------------------------------------------------! pure module subroutine allocate_3d_dp ( array_ , size1_ , size2_ , size3_ ) !! allocate a 3d array and fill it with 0s (double precision version) real ( dp ), allocatable , intent ( inout ) :: array_ (:,:,:) integer ( int32 ), intent ( in ) :: size1_ , size2_ , size3_ !---------------------------------------------------------------------! if ( allocated ( array_ )) deallocate ( array_ ) allocate ( array_ ( size1_ , size2_ , size3_ )) array_ = 0 !---------------------------------------------------------------------! end subroutine allocate_3d_dp !------------------------------------------------------------------------! !------------------------------------------------------------------------! end submodule array_operations_allocate_submod","tags":"","loc":"sourcefile/array_operations_allocate_submod.f90.html"},{"title":"Program Description – the SCATTERING code","text":"The purpose of the SCATTERING code is to solve the coupled equations for a given scattering system, provide the\nscattering S-matrix elements, and calculate the state-to-state cross-sections. Contrary to other publically available codes, such as MOLSCAT ,\nor Hibridon , the SCATTERING code solves coupled equations in the body-fixed (BF) frame,\nwhere the coupling matrix exhibits a predominantly block-diagonal structure with blocks interconnected by centrifugal terms.\nThis significantly reduces computational time and memory requirements. The theory of non-reactive scattering in systems with arbitrary angular momenta in the BF frame was developed Launay ,\nand was recently recalled in the context of scattering calculations for He-perturbed shape of HD\nrovibrational resonances (see Stankiewicz et al ) and O 2 -perturbed resonances of HCl \n(see Olejnik et al ). We briefly summarize it in the Theoretical Background section. Structure of the code The user controls the code through the input file and by supplying properly-formatted radial coupling terms. \nThe input file is interpreted by io_mod module and the radial coupling terms are \nread and interpolated by subroutines kept in potential module. scattering is the central program. After reading the input file and radial coupling terms, \nit performs a loop over the total angular momentum and parity. For each iteration, the main program determines all expansion coefficients\n g_{\\boldsymbol{\\lambda},\\gamma,\\gamma'}&#94;{Jp}  (see Eq. (3) in the Coupling Matrix section).\nIn the next step, the propagation of the log-derivative matrix takes place through numerov that are kept in propagator_mod.f90 .\nThe resulting BF-log-derivative matrix is transformed to the SF-system using subroutines from boundary_conditions_mod module\nwhich also involves procedures that determine the scattering S-matrix (see Solution of the coupled equations section).\nThe main part of the code calls for the partial state-to-state cross sections calculated \nby subroutines kept in statetostateXS . The results are written to the S-matrix file (see S-matrix file ). The output file contains the information about each  J - and  p -labeled block and, if needed, provides the accumulated state-to-state cross sections .","tags":"","loc":"page/index.html"},{"title":"Theoretical background – the SCATTERING code","text":"The theory of non-reactive scattering in systems with arbitrary angular momenta in the BF frame was developed Launay ,\nand was recently recalled in the context of scattering calculations for He-perturbed shape of HD\nrovibrational resonances (see Stankiewicz et al ) and O 2 -perturbed resonances of HCl \n(see Olejnik et al ). We briefly summarize it in this section: What are coupled equations? Coupling Matrix Solutions of the coupled equations State-to-state cross-sections","tags":"","loc":"page/background/index.html"},{"title":"What are coupled equations? – the SCATTERING code","text":"In quantum scattering, coupled equations are sets of differential equations that describe \ndynamics of colliding molecules and/or atoms under the influence of the interaction potential. \nThese equations are \"coupled\" because the solution for one equation depends on the solutions of the others. \nIn the context of diatom-atom collisions, these equations account for rotational and vibrational states of the diatom and the relative motion of the colliding partners. Coupled equations are derived from time-independent Schrodinger equation, by expanding the scattering wave function\nin the chosen basis,  |\\gamma \\rangle  which leads to a set of coupled differential equations on the\nexpansion coefficients,  f_{\\gamma} (R) . The basis states  |\\gamma \\rangle  define the collision channels.\nIn the total angular momentum ( J ) representation, the coupled equations are block-diagonal with respect\nto total angular momentum and parity: Here,  W  is the coupling matrix which involves the contribution from the atom - molecule interaction energy,  {V}&#94;{Jp}_{\\gamma, \\gamma'}(R) ,\nrelative motion of atom with respect to the molecule, quantified by the square relative angular momentum operator,  \\mathbf{L}&#94;{2\\,Jp}_{\\gamma, \\gamma'}  , \nand relatvie kinetic energy of the colliding pair, expressed using wavevector,  k_{\\gamma} = \\sqrt{2\\mu(E - E_{\\mathrm{mol}})} .\n \\mu   is the reduced mass of the atom - molecule system,  E  is the total energy and  E_{\\mathrm{mol}}  is the internal (rovibrational)\nenergy of the molecule. For diatom ( &#94;{1}\\Sigma ) - atom ( &#94;{1}S ) scattering in the BF frame, collision channels are defined through \nvibrational and rotational quantum numbers of the molecule,  v  and  j , \nand the absolute value of the projection of the rotational angular momentum of the molecule (and the total angular momentum)\non the intermolecular axis,  \\bar{\\Omega} . Note In this section,  \\gamma  is a shorthand notation for a set of quantum numbers, \n \\gamma = v, j, \\bar{\\Omega}, J .","tags":"","loc":"page/background/coupled_equations.html"},{"title":"Coupling Matrix – the SCATTERING code","text":"Coupling matrix In order to construct the coupling matrix, we need the explicit form of matrix elements of  {W}&#94;{Jp}_{\\gamma, \\gamma'}(R) . Matrix elements of the interaction potential are given as Here,  v_{\\boldsymbol{\\lambda},\\gamma,\\gamma'} (R)  denotes the radial coupling terms of the potential energy surface: i.e. the 3D molecule - atom PES,  V(R, r, \\theta) , averaged over Legendre polynomials,  P_{\\lambda} (\\cos\\theta), \nand rovibrational wave functions of the isolated molecule,   \\chi_{\\eta}(r) , where  \\eta = v, j.\nNote that they are independent of  J  and  p . Note Radial coupling terms are calculated separately and provided to the SCATTERING code in a tabulated form: they are read\nin by the potential_read procedure and interpolated (see also Supplying radial coupling terms )\nby potential_interpolation . These subroutines are placed in the potential_mod module. Interpolated radial coupling terms at aritrary  R  are provided by the radtermvalue procedure from the propagators module.  g_{{\\lambda},\\gamma,\\gamma'}&#94;{Jp}  are the algebraic coefficients of the expansion which stem from matrix elements of Legendre polynomials, \n P_{\\lambda} (\\cos\\theta)  in the  \\gamma  basis. They are given as where quantities in brackets are the 3-j symbols. Note The SCATTERING code uses 3-j symbols calculated by the wigxjpf library H. T. Johansson and C. Forssén, Fast and Accurate Evaluation of Wigner 3j, 6j, and 9j Symbols Using Prime Factorization and Multiword Integer Arithmetic, SIAM J. Sci. Comput., 38(1) (2016), A376-A384. See eprint or Pre-print (2015) Algebraic coefficients are R-independent and are calculated only once per each block. \nNote that they are block-diagonal with respect to \\bar{\\Omega}. Note Calculation of  g_{{\\lambda},\\gamma,\\gamma'}&#94;{Jp}  algebraic coefficients is handled \nby the check_nonzero_coupling_matrix_elements and prepare_coupling_matrix_elements procedures from the algebraic_coefficients module. Procedure check_nonzero_coupling_matrix_elements first checks how many\nmatrix elements fulfill the  \\delta_{\\bar{\\Omega},\\bar{\\Omega}'}  condition - this is saved in the number_of_nonzero_coupling_matrix_elements variable.\nOn top of that, for each non-zero matrix element, the number of non-zero terms in the sum over \\lambda\nis checked and saved in number_of_nonzero_coupling_coefficients variable.\nThe coefficients are calculated with prepare_coupling_matrix_elements procedure and saved\nin the nonzero_coupling_coefficients variable.\nThe corresponding  \\lambda  indices are written indirectly in nonzero_legendre_indices array\nwhich holds indices to l1tab . Note The total contribution from the interaction potential, Eq. \\eqref{eq:pes_contribution}, is determined by pes_contribution procedure from propagators module. The centrifugal term,  \\mathbf{L}&#94;{2\\,Jp}_{\\gamma, \\gamma'} , is block-diagonal with respect to the rotational quantum number  j .\nTerms diagonal with respect to  \\bar{\\Omega}  are given as The centrifugal term additionally introduces couplings with  \\bar{\\Omega}  and  \\bar{\\Omega}' = \\bar{\\Omega} \\pm 1  blocks Note Matrix elements,  \\mathbf{L}&#94;{2\\,Jp}_{\\gamma, \\gamma'} , are calculated by the centrifugal_matrix subroutine from the propagators module.\nThese are called only once per block, at the begining of the numerov procedure.","tags":"","loc":"page/background/coupling_matrix.html"},{"title":"Solution of the coupled equations – the SCATTERING code","text":"Solution of the coupled equations Coupled equations are solved numerically. The SCATTERING code uses renormalized Numerov's algorithm (see Johnson )\nto propagate the log-derivative of  {f}&#94;{Jp}_{\\gamma} (R): Note Renormalized Numerov's algorithm is implemented in numerov procedure in propagators module. At the last point of propagation,  R_{max} , the log-derivative matrix is transformed to the space-fixed (SF) frame using the following transformation where the coefficients of the transformation are given as Note The transformation between arbitrary BF and SF matrices is implemented in boundary_conditions_mod : Eq. \\eqref{eq:BF-SF-transform} is implemented in calculate_sf_matrix_from_bf_matrix and calculate_single_sf_element subroutines, while Eq. \\eqref{eq:p-coeff} is handled by the p_coeff function. In the next step, the SF log-derivative matrix is then transformed to the reactance K-matrix through the following equation Here,   {J}  and  {N}  are diagonal matrices with elements depending on whether the corresponding \n \\gamma  level is energetically accessible ( E - E_{\\gamma} \\geq 0  ) or inaccessible (  E-E_{\\gamma} < 0 ).\nThese two cases are referred to as open and closed channels, respectively.\nFor the open channels, the  {J}  and  {N}  matrices take the following form: where  S_{l}(k_{\\gamma}R)  and  C_{l}(k_{\\gamma}R)  are Riccati-Bessel functions of the first and second kind, respectively. For the closed channels: with  I_{l+\\frac{1}{2}}(k_{\\gamma} R)  and  K_{l+\\frac{1}{2}}(k_{\\gamma} R)  being the modified Bessel functions of the first and second kind.\nPrimes in the formula for the reactance matrix denote derivatives of the Bessel functions. Note The SCATTERING code uses Riccati-Bessel and modified Bessel functions calculated by the special_functions library Shanjie Zhang, Jianming Jin, Computation of Special Functions, Wiley, 1996, ISBN: 0-471-11963-6, LC: QA351.C45. The  {K}&#94;{Jp}  matrix takes the block form: where  {K}_{oo} ,  {K}_{oc} ,  {K}_{co}  and  {K}_{cc}  are open-open, open-closed,\n closed-open and closed-closed submatrices of  {K}&#94;{Jp} . It can be shown (see Johnson ),\nthat the open-open part of the  reactance matrix is not changed upon the following replacement: This allows to avoid computational problems with modified Bessel functions. The same transformation is applied for the  {N}  and  {N}'  matrices. Note This part of calculations, starting from Eq. \\eqref{eq:log-der-to-K},\nis handled by the calculate_k_matrix subroutine in the boundary_conditions_mod module. Finally, the scattering S-matrix  {S}&#94;{Jp}  is obtained from the open-open portion of  {K}&#94;{Jp}  Note Eq. \\eqref{eq:K-to-S} is implemented in the calculate_s_matrix procedure in the boundary_conditions_mod module. The S-matrices are saved to external, binary file, in a manner similar to the one used by MOLSCAT (see S-matrix file ). Every time the S-matrix is determined, the code checks if the unitary condition is fulfilled If this condition is not fulfilled for several $J,p$ blocks, the code lists these blocks at the end of the output file\nand suggests to increase the steps parameter or to reduce the dr value. Note Eq. \\eqref{eq:sunitarity} is implemented in the unitarity_check procedure in the unitarity_check_mod module.","tags":"","loc":"page/background/solution.html"},{"title":"Cross-sections – the SCATTERING code","text":"Cross-sections Apart from S-matrices, the SCATTERING code calculates the state-to-state cross-sections: Note Cross-sections calculations take place within the statetostateXS module, in the calculate_sts_xs procedure.","tags":"","loc":"page/background/cross_sections.html"},{"title":"Input file – the SCATTERING code","text":"Input file Note The input file is read at the beginning of the calculations by subroutine read_input_file from the io_mod module. This subroutine uses namelist method of reading input files into the source code. Each input file should consist of three groups: INPUT, BASIS and POTENTIAL.\nNote that the names of the groups correspond to the ones used by MOLSCAT. The INPUT group defines the most important information about each run: label (character) - 80-character string describing the code run. reduced_mass (double precision) - value of the reduced mass of the collisional system, in atomic mass units. relative_energy_flag (integer) - can only take two values: relative_energy_flag = 0 (default), energy is interpreted as the total energy of the colliding system; initial is ignored, relative_energy_flag = 1, energy is interpreted as the relative kinetic energy, calculated with respect to the initial level in the basis. energy (double precision) - its interpretation depends on relative_energy_flag . initial (integer) - see relative_energy_flag . jtotmin , jtotmax , jtotstep (integers) - the calculations are performed from\n  J_{min} =  jtotmin to   J_{max} =  jtotmax with  \\Delta J =  jtotstep .\n  If jtotmax = -1, calculations are performed until consecutive_blocks_threshold consecutive values of total angular momentum contribute less than elastic_xs_threshold to the elastic state-to-state cross sections, and less than inelastic_xs_threshold to the inelastic state-to-state cross sections. rmin , rmax (double precision) - the propagation is performed from  R_{min} =  rmin to\n R_{max} =  rmax . Note that there are no subroutines responsible for the extrapolation of the radial terms implemented in the code. dr (double precision) - if positive, it corresponds to the step of the propagator (in  a_{0}  ). steps (integer) - number of steps per half-wavelength of de Broglie's wavefunction of the system (see Sec.~\\ref{sec:Scattering-Details-Scattering}). vdepth (double precision, 0 by default) - the user is advised to specify the absolute value of the depth of the potential energy surface, \nwhich is included in the determination of the step size of the propagator (see Sec.~\\ref{sec:Scattering-Details-Scattering}). consecutive_blocks_threshold (integer), elastic_xs_threshold , inelastic_xs_threshold (double precision), see ( jtotmin , jtotmax and jtotstep ). nlevel (integer) - number of levels in the basis set. nr (integer) - number of the grid points for the radial coupling terms in the potential expansion. nterms (integer) - number of  \\lambda  terms in the potential expansion, see Eq. (3) in Coupling Matrix section. total_number_of_coupling_terms (integer) - determines the total number of columns containing the radial coupling terms (see Supplying radial coupling terms ). n_skip_lines (integer) - number of lines at the beginning of the radial coupling terms file, which will be ignored while reading (see Supplying radial coupling terms ). iunits (integer) - if the  R  grid in the radial coupling terms file is given in atomic units (  a_{0}  ), choose iunits =0.\n If the radial distance is given in \\AA, put iunits = 1. potentialfile (character, RadialTerms.dat by default) - the name of the file with the radial coupling terms. smatrixfile (character, SmatrixFile.dat by default) - the name of the s-matrix file. print_partial_cross_sections (integer) - if partial cross sections (for each parity block, within each $J$-block) are needed, put print_partial_cross_sections = 1. Otherwise, put print_partial_cross_sections = 0. partialfile (character, PartialFile.dat by default) - the name of the file with partial cross sections. prntlvl (integer, 2 by default): prntlvl = 0, basic information about a run, prntlvl = 1, information about each block is printed on screen, prntlvl = 2, information about the calculation time of some of the important parts of the code is printed, prntlvl = 3, accumulated state-to-state cross sections are printed on screen after each total angular momentum block, prntlvl  >  4, S-matrices are printed on screen. BASIS group specifies the vibrational and rotational quantum numbers of colliding molecules and the energy levels of rovibrational states v1array (integer array of nlevel size) - keeps values of the vibrational ( v ) quantum numbers that describe the levels of a diatomic molecule. j1array (integer array of nlevel size) - keeps values of the rotational ( j ) quantum numbers that describe the levels of a diatomic molecule. elevel (double precision array of nlevel size) - keeps energies of the rovibrational levels of a diatomic molecule, in cm &#94;{-1} . POTENTIAL group describes the quantum numbers of the radial coupling terms,  v_{\\boldsymbol{\\lambda},\\gamma,\\gamma'} (R) , see Eq. (3) in Coupling Matrix section.\nThis group of variables involves: l1tab (integer array of nterms size) - keeps values of  \\lambda  indices, describing the radial terms of the potential. v1pes , j1pes , v1ppes , j1ppes (integer arrays of total_number_of_coupling_terms size) keep values of  v, j, v', j'  indices of the radial coupling terms of the potential.","tags":"","loc":"page/inputfile.html"},{"title":"Installation – the SCATTERING code","text":"Prerequisites Make A modern Fortran compiler, such as GNU Fortran Compiler (gfortran) or Intel Fortran Compiler (ifort) LAPACK and BLAS libraries Git (optional) Get the source code Using git git clone https://github.com/hjozwiak-umk/bigos_h2he.git ./bigos_dir This will create a directory ./bigos_dir on the local machine. Enter this directory. Without git Download the source code as a zip file . Extract the contents to ./bigos_dir and enter this directory. Building instructions Linux Windows","tags":"","loc":"page/installation/index.html"},{"title":"Linux – the SCATTERING code","text":"Before building the code, make sure that all the necessary tools and libraries are installed sudo apt install make gfortran liblapack-dev libblas-dev git Building instructions Enter the cloned directory cd bigos_dir Build the project using make all Note The script will extract the wigxjpf library in ./libs directory, and then build and compile the contents of ./src directory. The executable, scattering.x , is located in the main directory. You can now run make test to make sure that you recover reference outputs in the ref/ directory.","tags":"","loc":"page/installation/ubuntu.html"},{"title":"Windows – the SCATTERING code","text":"Before building the code, make sure that all the necessary tools and libraries are installed Here, we provide a step-by-step instruction for installation of the necessary packages using Cygwin . Download the Cygwin installer from the official website Launch Cygwin setup. Choose \"Install from Internet\". Set up a Root directory. Set up a local package directory. Choose \"Use System Proxy Settings\". Choose A Download Site. After a while, a new \"Select Packages\" window appears. Navigate to \"Full\" list in the upper right corner: Locate necessery packages: make , gcc-fortran , liblapack-devel , libopenblas , git and unzip . Choose the most recent version. Proceed with the installation and close the Setup window. Launch Cygwin Terminal Clone the repository from git git clone https://github.com/hjozwiak-umk/bigos_h2he.git ./bigos_dir Enter the cloned directory cd bigos_dir Build the project using make all Note The script will extract the wigxjpf library in ./libs directory, and then build and compile the contents of ./src directory. The executable, scattering.x , is located in the main directory. You can now run make test to make sure that you recover reference outputs in the ref/ directory.","tags":"","loc":"page/installation/windows11.html"},{"title":"Supplying radial terms – the SCATTERING code","text":"Supplying the radial coupling terms of the potential energy surface The code reads radial coupling terms from a separate file. The reading process is controlled by both the input file and pes_read_mod.f90 . The radial terms file starts with n_skip_lines lines which describe the file and are ignored by the code.\nThe reading procedure is continued using two loops: the first one over nterms (number of radial terms, which match the size of l1tab ),\n and the second one over nr (the number of points on the  R -grid).\nThe code assumes that each loop over nterms begins with a current value of}  \\lambda , and that the radial coupling terms are ordered in columns, where the first column corresponds to the  R -grid.\nAdditional loop over totalcol reads radial terms which couple different  v, j  and  v', j'  states.\nThe order of columns in the radial terms file must correspond to the values supplied in the v1pes , j1pes , v1ppes , j1ppes arrays in the input file. Modify the potential_read subroutine in pes_read_mod.f90 , if the radial terms file has a different format. The user can supply a larger set of terms that describe the coupling between different rovibrational states ( v, j  and   v', j'  ) than actually needed.\nThe POTENTIALREDUCTION subroutine from pes_read_mod.f90 will only pick and interpolate the necessary terms.\nNote that the procedure will be skipped if totalcol  <=  nlevel  \\cdot  (nlevel+1)/2.","tags":"","loc":"page/radialterms.html"},{"title":"S-matrix file – the SCATTERING code","text":"S-matrix file The following information is saved to the S-matrix binary file: label , \"2\" (a code name for diatom - atom scattering in the BIGOS package), nlevel , reducedmass (in atomic mass untis), (v1array(ilevel), j1array(ilevel), ilevel = 1, nlevel) (elevel(ilevel), ilevel = 1, nlevel) (in cm -1 ) initial, energy (in cm -1 ) jtot_, parity_index, number_of_open_channels (current value of  J ,  p  (if  p=1 , parity_index = 0, if  p = -1 , parity_index = 1) and number of open channels within the block) (channels_level_indices(iopen), channels_l_values(iopen), wv(iopen), iopen = 1, number_of_open_channels) (channels_level_indices is an integer array which keeps the values of pointers to the v1array and j1array, channels_l_values is an array containing all  l  values\ncorresponding to open channels, wv keeps values of  k_{\\gamma}  for each open channel (in 1/\\AA)). (srmatrix(iopen,iopen2), iopen2 = 1, iopen), iopen = 1, nopen) (real part of the S-matrix; only the lower triangle of the matrix is saved) (simatrix(iopen,iopen2), iopen2 = 1, iopen), iopen = 1, nopen) (imaginary part of the S-matrix; only the lower triangle of the matrix is saved) The last four steps are repeated for each block, looping over parity and total angular momentum.","tags":"","loc":"page/smatrixfile.html"}]}
var tipuesearch = {"pages":[{"title":" the SCATTERING code ","text":"the SCATTERING code BIGOS – B inary I nelastic scattering and G eneralized O ptical cross S ection package is a set of FORTRAN 90 codes that\nallow the user to obtain various physical quantities related to the scattering problem involving diatomic molecules and\natoms. The package is being developed at the Nicolaus Copernicus University in Toruń. Here, we present the SCATTERINC code, the central part of the BIGOS package.\nThe purpose of the SCATTERING code is to solve the coupled equations for a given scattering system, provide the\nscattering S-matrix elements and calculate the state-to-state cross-sections. Please read the Program Description . Note This version of the code is adjusted for diatom - atom collision systems, in particular the H 2 - He system. Please, refer to this version of the code by citing the following paper H. Jozwiak, F. Thibault, A. Viel, P. Wcislo, F. Lique, Rovibrational (de-)excitation of H 2 by He revisited https://doi.org/10.48550/arXiv.2311.09890 Developer Info Hubert Jóźwiak","tags":"home","loc":"index.html"},{"title":"envj – the SCATTERING code","text":"public  function envj(n, x) utility function used by MSTA1 and MSTA2. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: x Return Value real(kind=8) Called by proc~~envj~~CalledByGraph proc~envj envj proc~msta1 msta1 proc~msta1->proc~envj proc~msta2 msta2 proc~msta2->proc~envj proc~ikv ikv proc~ikv->proc~msta1 proc~ikv->proc~msta2 proc~rctj rctj proc~rctj->proc~msta1 proc~rctj->proc~msta2 proc~modified_bessel_k_ratio modified_bessel_k_ratio proc~modified_bessel_k_ratio->proc~ikv proc~riccati_bessel_j riccati_bessel_j proc~riccati_bessel_j->proc~rctj proc~calculate_k_matrix calculate_k_matrix proc~calculate_k_matrix->proc~modified_bessel_k_ratio proc~calculate_k_matrix->proc~riccati_bessel_j program~scattering SCATTERING program~scattering->proc~calculate_k_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables logten n_r8 r8_gamma_log Variables Type Visibility Attributes Name Initial real(kind=8), public :: logten real(kind=8), public :: n_r8 real(kind=8), public :: r8_gamma_log","tags":"","loc":"proc/envj.html"},{"title":"msta1 – the SCATTERING code","text":"public  function msta1(x, mp) determines a backward recurrence starting point for Jn(x). Arguments Type Intent Optional Attributes Name real(kind=8) :: x integer(kind=4) :: mp Return Value integer(kind=4) Calls proc~~msta1~~CallsGraph proc~msta1 msta1 proc~envj envj proc~msta1->proc~envj Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~msta1~~CalledByGraph proc~msta1 msta1 proc~ikv ikv proc~ikv->proc~msta1 proc~rctj rctj proc~rctj->proc~msta1 proc~modified_bessel_k_ratio modified_bessel_k_ratio proc~modified_bessel_k_ratio->proc~ikv proc~riccati_bessel_j riccati_bessel_j proc~riccati_bessel_j->proc~rctj proc~calculate_k_matrix calculate_k_matrix proc~calculate_k_matrix->proc~modified_bessel_k_ratio proc~calculate_k_matrix->proc~riccati_bessel_j program~scattering SCATTERING program~scattering->proc~calculate_k_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables a0 f f0 f1 it n0 n1 nn Variables Type Visibility Attributes Name Initial real(kind=8), public :: a0 real(kind=8), public :: f real(kind=8), public :: f0 real(kind=8), public :: f1 integer(kind=4), public :: it integer(kind=4), public :: n0 integer(kind=4), public :: n1 integer(kind=4), public :: nn","tags":"","loc":"proc/msta1.html"},{"title":"msta2 – the SCATTERING code","text":"public  function msta2(x, n, mp) determines a backward recurrence starting point for Jn(x). Arguments Type Intent Optional Attributes Name real(kind=8) :: x integer(kind=4) :: n integer(kind=4) :: mp Return Value integer(kind=4) Calls proc~~msta2~~CallsGraph proc~msta2 msta2 proc~envj envj proc~msta2->proc~envj Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~msta2~~CalledByGraph proc~msta2 msta2 proc~ikv ikv proc~ikv->proc~msta2 proc~rctj rctj proc~rctj->proc~msta2 proc~modified_bessel_k_ratio modified_bessel_k_ratio proc~modified_bessel_k_ratio->proc~ikv proc~riccati_bessel_j riccati_bessel_j proc~riccati_bessel_j->proc~rctj proc~calculate_k_matrix calculate_k_matrix proc~calculate_k_matrix->proc~modified_bessel_k_ratio proc~calculate_k_matrix->proc~riccati_bessel_j program~scattering SCATTERING program~scattering->proc~calculate_k_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables a0 ejn f f0 f1 hmp it n0 n1 nn obj Variables Type Visibility Attributes Name Initial real(kind=8), public :: a0 real(kind=8), public :: ejn real(kind=8), public :: f real(kind=8), public :: f0 real(kind=8), public :: f1 real(kind=8), public :: hmp integer(kind=4), public :: it integer(kind=4), public :: n0 integer(kind=4), public :: n1 integer(kind=4), public :: nn real(kind=8), public :: obj","tags":"","loc":"proc/msta2.html"},{"title":"gamma – the SCATTERING code","text":"public  subroutine gamma(x, ga) evaluates the Gamma function. Arguments Type Intent Optional Attributes Name real(kind=8) :: x real(kind=8) :: ga Contents Variables g gr k m m1 pi r z Variables Type Visibility Attributes Name Initial real(kind=8), public, dimension ( 26 ) :: g = (/1.0D+00, 0.5772156649015329D+00, -0.6558780715202538D+00, -0.420026350340952D-01, 0.1665386113822915D+00, -0.421977345555443D-01, -0.96219715278770D-02, 0.72189432466630D-02, -0.11651675918591D-02, -0.2152416741149D-03, 0.1280502823882D-03, -0.201348547807D-04, -0.12504934821D-05, 0.11330272320D-05, -0.2056338417D-06, 0.61160950D-08, 0.50020075D-08, -0.11812746D-08, 0.1043427D-09, 0.77823D-11, -0.36968D-11, 0.51D-12, -0.206D-13, -0.54D-14, 0.14D-14, 0.1D-15/) real(kind=8), public :: gr integer(kind=4), public :: k integer(kind=4), public :: m integer(kind=4), public :: m1 real(kind=8), public, parameter :: pi = 3.141592653589793D+00 real(kind=8), public :: r real(kind=8), public :: z","tags":"","loc":"proc/gamma.html"},{"title":"ikv – the SCATTERING code","text":"public  subroutine ikv(v, x, vm, bi, di, bk, dk) computes modified Bessel function Iv(x) and Kv(x) and their derivatives. Arguments Type Intent Optional Attributes Name real(kind=8) :: v real(kind=8) :: x real(kind=8) :: vm real(kind=8) :: bi (0:*) real(kind=8) :: di (0:*) real(kind=8) :: bk (0:*) real(kind=8) :: dk (0:*) Calls proc~~ikv~~CallsGraph proc~ikv ikv proc~msta1 msta1 proc~ikv->proc~msta1 proc~msta2 msta2 proc~ikv->proc~msta2 proc~envj envj proc~msta1->proc~envj proc~msta2->proc~envj Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~ikv~~CalledByGraph proc~ikv ikv proc~modified_bessel_k_ratio modified_bessel_k_ratio proc~modified_bessel_k_ratio->proc~ikv proc~calculate_k_matrix calculate_k_matrix proc~calculate_k_matrix->proc~modified_bessel_k_ratio program~scattering SCATTERING program~scattering->proc~calculate_k_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables a1 a2 bi0 bk0 bk1 bk2 ca cb cs ct f f1 f2 gan gap k k0 m n pi piv r r1 r2 sum v0 v0n v0p vt w0 wa ww x2 Variables Type Visibility Attributes Name Initial real(kind=8), public :: a1 real(kind=8), public :: a2 real(kind=8), public :: bi0 real(kind=8), public :: bk0 real(kind=8), public :: bk1 real(kind=8), public :: bk2 real(kind=8), public :: ca real(kind=8), public :: cb real(kind=8), public :: cs real(kind=8), public :: ct real(kind=8), public :: f real(kind=8), public :: f1 real(kind=8), public :: f2 real(kind=8), public :: gan real(kind=8), public :: gap integer(kind=4), public :: k integer(kind=4), public :: k0 integer(kind=4), public :: m integer(kind=4), public :: n real(kind=8), public :: pi real(kind=8), public :: piv real(kind=8), public :: r real(kind=8), public :: r1 real(kind=8), public :: r2 real(kind=8), public :: sum real(kind=8), public :: v0 real(kind=8), public :: v0n real(kind=8), public :: v0p real(kind=8), public :: vt real(kind=8), public :: w0 real(kind=8), public :: wa real(kind=8), public :: ww real(kind=8), public :: x2","tags":"","loc":"proc/ikv.html"},{"title":"rctj – the SCATTERING code","text":"public  subroutine rctj(n, x, nm, rj, dj) computes Riccati-Bessel function of the first kind, and derivatives. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: x integer(kind=4) :: nm real(kind=8) :: rj (0:n) real(kind=8) :: dj (0:n) Calls proc~~rctj~~CallsGraph proc~rctj rctj proc~msta1 msta1 proc~rctj->proc~msta1 proc~msta2 msta2 proc~rctj->proc~msta2 proc~envj envj proc~msta1->proc~envj proc~msta2->proc~envj Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~rctj~~CalledByGraph proc~rctj rctj proc~riccati_bessel_j riccati_bessel_j proc~riccati_bessel_j->proc~rctj proc~calculate_k_matrix calculate_k_matrix proc~calculate_k_matrix->proc~riccati_bessel_j program~scattering SCATTERING program~scattering->proc~calculate_k_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables cs f f0 f1 k m rj0 rj1 Variables Type Visibility Attributes Name Initial real(kind=8), public :: cs real(kind=8), public :: f real(kind=8), public :: f0 real(kind=8), public :: f1 integer(kind=4), public :: k integer(kind=4), public :: m real(kind=8), public :: rj0 real(kind=8), public :: rj1","tags":"","loc":"proc/rctj.html"},{"title":"rcty – the SCATTERING code","text":"public  subroutine rcty(n, x, nm, ry, dy) computes Riccati-Bessel function of the second kind, and derivatives. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: x integer(kind=4) :: nm real(kind=8) :: ry (0:n) real(kind=8) :: dy (0:n) Called by proc~~rcty~~CalledByGraph proc~rcty rcty proc~riccati_bessel_y riccati_bessel_y proc~riccati_bessel_y->proc~rcty proc~calculate_k_matrix calculate_k_matrix proc~calculate_k_matrix->proc~riccati_bessel_y program~scattering SCATTERING program~scattering->proc~calculate_k_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables k rf0 rf1 rf2 Variables Type Visibility Attributes Name Initial integer(kind=4), public :: k real(kind=8), public :: rf0 real(kind=8), public :: rf1 real(kind=8), public :: rf2","tags":"","loc":"proc/rcty.html"},{"title":"ETOTAL – the SCATTERING code","text":"public  function ETOTAL() result(etot_) returns the total energy Arguments None Return Value real(kind=dp) Called by proc~~etotal~~CalledByGraph proc~etotal ETOTAL proc~wavenumberekin WAVENUMBEREKIN proc~wavenumberekin->proc~etotal proc~calculate_k_matrix calculate_k_matrix proc~calculate_k_matrix->proc~etotal proc~print_bf_channels print_bf_channels proc~print_bf_channels->proc~etotal proc~count_open_basis_levels count_open_basis_levels proc~count_open_basis_levels->proc~etotal proc~numerov numerov proc~numerov->proc~etotal proc~set_number_of_open_channels_wavmax set_number_of_open_channels_wavmax proc~set_number_of_open_channels_wavmax->proc~etotal program~scattering SCATTERING program~scattering->proc~etotal program~scattering->proc~calculate_k_matrix program~scattering->proc~print_bf_channels program~scattering->proc~count_open_basis_levels program~scattering->proc~numerov program~scattering->proc~set_number_of_open_channels_wavmax proc~save_open_basis_levels save_open_basis_levels program~scattering->proc~save_open_basis_levels proc~read_input_file read_input_file program~scattering->proc~read_input_file proc~input_summary input_summary proc~input_summary->proc~etotal proc~input_summary->proc~wavenumberekin proc~save_open_basis_levels->proc~etotal proc~read_input_file->proc~input_summary Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/etotal.html"},{"title":"WAVENUMBEREKIN – the SCATTERING code","text":"public  function WAVENUMBEREKIN() result(k_) returns the wavenumber (in 1/A&#94;{2}) Arguments None Return Value real(kind=dp) Calls proc~~wavenumberekin~~CallsGraph proc~wavenumberekin WAVENUMBEREKIN proc~etotal ETOTAL proc~wavenumberekin->proc~etotal proc~write_error write_error proc~wavenumberekin->proc~write_error proc~write_message write_message proc~write_error->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~wavenumberekin~~CalledByGraph proc~wavenumberekin WAVENUMBEREKIN proc~input_summary input_summary proc~input_summary->proc~wavenumberekin proc~read_input_file read_input_file proc~read_input_file->proc~input_summary program~scattering SCATTERING program~scattering->proc~read_input_file Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/wavenumberekin.html"},{"title":"count_open_basis_levels – the SCATTERING code","text":"public  function count_open_basis_levels() result(open_) counts the energetically accessible levels in the basis Arguments None Return Value integer(kind=int32) Calls proc~~count_open_basis_levels~~CallsGraph proc~count_open_basis_levels count_open_basis_levels proc~etotal ETOTAL proc~count_open_basis_levels->proc~etotal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~count_open_basis_levels~~CalledByGraph proc~count_open_basis_levels count_open_basis_levels program~scattering SCATTERING program~scattering->proc~count_open_basis_levels Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables ilevel Source Code count_open_basis_levels Variables Type Visibility Attributes Name Initial integer(kind=int32), public :: ilevel Source Code function count_open_basis_levels () result ( open_ ) !! counts the energetically accessible levels in the basis !---------------------------------------------------------------------! integer ( int32 ) :: open_ , ilevel !---------------------------------------------------------------------! open_ = 0 do ilevel = 1 , nlevel if ( ETOTAL () - elevel ( ilevel ). ge . 0 ) then open_ = open_ + 1 endif enddo !---------------------------------------------------------------------! end function count_open_basis_levels","tags":"","loc":"proc/count_open_basis_levels.html"},{"title":"input_check – the SCATTERING code","text":"public  subroutine input_check(nmlistind) checks if the supplied input parameters are correct Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: nmlistind nmlistind = 1: namelist INPUT\nnmlistind = 2: namelist BASIS\nnmlistind = 3: namelist POTENTIAL Calls proc~~input_check~~CallsGraph proc~input_check input_check interface~incorrect_value incorrect_value proc~input_check->interface~incorrect_value proc~write_message write_message proc~input_check->proc~write_message proc~write_error write_error proc~input_check->proc~write_error proc~integer_to_character integer_to_character proc~input_check->proc~integer_to_character proc~write_error->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~input_check~~CalledByGraph proc~input_check input_check proc~read_input_file read_input_file proc~read_input_file->proc~input_check program~scattering SCATTERING program~scattering->proc~read_input_file Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables icol il ilevel Source Code input_check Variables Type Visibility Attributes Name Initial integer(kind=int32), public :: icol integer(kind=int32), public :: il integer(kind=int32), public :: ilevel Source Code subroutine input_check ( nmlistind ) !! checks if the supplied input parameters are correct !------------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: nmlistind !! nmlistind = 1: namelist INPUT !! nmlistind = 2: namelist BASIS !! nmlistind = 3: namelist POTENTIAL !------------------------------------------------------------------------! integer ( int32 ) :: ilevel , il , icol !------------------------------------------------------------------------! if ( nmlistind . eq . 1 ) then !------------------------------------------------------------------------! ! Namelist input: !------------------------------------------------------------------------! if ( reducedmass . lt . 0 ) then call incorrect_value ( \"reducedmass\" , reducedmass , 5 ) endif if (( ietoterel . ne . 0 ). and .( ietoterel . ne . 1 )) then call incorrect_value ( \"ietoterel\" , ietoterel , 5 ) endif if ( energy . lt . 0 ) then call incorrect_value ( \"energy\" , energy , 5 ) endif if ( rmin . le . 0 ) then call incorrect_value ( \"rmin\" , rmin , 5 ) endif if ( rmax . le . 0 ) then call incorrect_value ( \"rmax\" , rmax , 5 ) endif if ( rmax . lt . rmin ) then call incorrect_value ( \"rmax/rmin\" , rmax / rmin , 5 ) endif if ( steps . le . 0.d0 ) then call incorrect_value ( \"steps\" , steps , 5 ) endif if ( vdepth . lt . 0.d0 ) then call incorrect_value ( \"vdepth\" , vdepth , 5 ) endif if ( jtotmin . lt . 0 ) then call incorrect_value ( \"jtotmin\" , jtotmin , 5 ) endif if ( jtotmax . lt . 0 ) then if ( ncac . lt . 0 ) then call write_message ( \"JTOTMAX < 0:\" ) call incorrect_value ( \"ncac\" , ncac , 5 ) endif if ( dtol . lt . 0 ) then call write_message ( \"JTOTMAX < 0:\" ) call incorrect_value ( \"dtol\" , dtol , 5 ) endif if ( otol . lt . 0 ) then call write_message ( \"JTOTMAX < 0:\" ) call incorrect_value ( \"otol\" , otol , 5 ) endif else if ( jtotmax . lt . jtotmin ) then call write_message ( \"jtotmax is smaller than jtotmin\" ) call incorrect_value ( \"jtotmax/jtotmin\" , & real ( jtotmax / jtotmin , dp ), 5 ) endif endif if ( nlevel . le . 0 ) then call incorrect_value ( \"nlevel\" , nlevel , 5 ) endif if ( ietoterel . eq . 1 ) then if ( initial . le . 0 ) then call write_message ( \"ietoterel = 1:\" ) call incorrect_value ( \"initial\" , initial , 5 ) endif if ( initial . gt . nlevel ) then call write_message ( \"ietoterel = 1:\" ) call write_message ( \"nlevel = \" // integer_to_character ( nlevel )) call incorrect_value ( \"initial > nlevel\" , initial , 5 ) endif endif if ( nr . le . 0 ) then call incorrect_value ( \"nr\" , nr , 5 ) endif if ( nterms . le . 0 ) then call incorrect_value ( \"nterms\" , nterms , 5 ) endif if ( totalcol . le . 0 ) then call incorrect_value ( \"totalcol\" , totalcol , 5 ) endif if ( n_skip_lines . lt . 0 ) then call incorrect_value ( \"n_skip_lines\" , n_skip_lines , 5 ) endif if (( iunits . ne . 0 ). and .( iunits . ne . 1 )) then call incorrect_value ( \"iunits\" , iunits , 5 ) endif inquire ( file = potentialfile , exist = pes_file_exists ) if ( pes_file_exists . eqv .. false .) then call write_error ( trim ( adjustl ( potentialfile )) // \" does not exist\" ) endif if (( ipart . ne . 0 ). and .( ipart . ne . 1 )) then call incorrect_value ( \"ipart\" , ipart , 5 ) endif if ( prntlvl . lt . 0 ) then call incorrect_value ( \"prntlvl\" , prntlvl , 5 ) endif !------------------------------------------------------------------------! else if ( nmlistind . eq . 2 ) then !------------------------------------------------------------------------! ! Namelist basis: !------------------------------------------------------------------------! do ilevel = 1 , nlevel if ( v1array ( ilevel ). lt . 0 ) then call incorrect_value ( \"v1array(\" // integer_to_character ( ilevel ) // \")\" , v1array ( ilevel ), 5 ) endif if ( j1array ( ilevel ). lt . 0 ) then call incorrect_value ( \"j1array(\" // integer_to_character ( ilevel ) // \")\" , j1array ( ilevel ), 5 ) endif if ( elevel ( ilevel ). lt . 0.0_dp ) then call incorrect_value ( \"elevel(\" // integer_to_character ( ilevel ) // \")\" , elevel ( ilevel ), 5 ) endif enddo !------------------------------------------------------------------------! else if ( nmlistind . eq . 3 ) then !------------------------------------------------------------------------! ! Namelist potential: !------------------------------------------------------------------------! do il = 1 , nterms if ( l1tab ( il ). lt . 0 ) then call incorrect_value ( \"l1tab(\" // integer_to_character ( il ) // \")\" , l1tab ( il ), 5 ) endif enddo do icol = 1 , totalcol if ( v1pes ( icol ). lt . 0 ) then call incorrect_value ( \"v1pes(\" // integer_to_character ( icol ) // \")\" , v1pes ( icol ), 5 ) endif if ( j1pes ( icol ). lt . 0 ) then call incorrect_value ( \"j1pes(\" // integer_to_character ( icol ) // \")\" , j1pes ( icol ), 5 ) endif if ( v1ppes ( icol ). lt . 0 ) then call incorrect_value ( \"vp1pes(\" // integer_to_character ( icol ) // \")\" , v1ppes ( icol ), 5 ) endif if ( j1ppes ( icol ). lt . 0 ) then call incorrect_value ( \"j1ppes(\" // integer_to_character ( icol ) // \")\" , j1ppes ( icol ), 5 ) endif enddo endif !------------------------------------------------------------------------! end subroutine input_check","tags":"","loc":"proc/input_check.html"},{"title":"input_summary – the SCATTERING code","text":"public  subroutine input_summary() summarize the input parameters for the current run Arguments None Calls proc~~input_summary~~CallsGraph proc~input_summary input_summary proc~write_message write_message proc~input_summary->proc~write_message proc~wavenumberekin WAVENUMBEREKIN proc~input_summary->proc~wavenumberekin proc~etotal ETOTAL proc~input_summary->proc~etotal proc~float_to_character float_to_character proc~input_summary->proc~float_to_character proc~integer_to_character integer_to_character proc~input_summary->proc~integer_to_character proc~wavenumberekin->proc~etotal proc~write_error write_error proc~wavenumberekin->proc~write_error proc~write_error->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~input_summary~~CalledByGraph proc~input_summary input_summary proc~read_input_file read_input_file proc~read_input_file->proc~input_summary program~scattering SCATTERING program~scattering->proc~read_input_file Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables ilevel Source Code input_summary Variables Type Visibility Attributes Name Initial integer(kind=int32), public :: ilevel Source Code subroutine input_summary !! summarize the input parameters for the current run !------------------------------------------------------------------------! integer ( int32 ) :: ilevel !------------------------------------------------------------------------! call write_message ( \"User-supplied label: \" // label ) call write_message ( \"Reduced mass: \" // & trim ( adjustl ( float_to_character ( reducedmass , \"(F10.4)\" ))) // \" a.m.u.\" ) call write_message ( \"*** Energy levels in the basis set: ***\" ) call write_message ( \"   v       j            Energy (cm&#94;{-1})\" ) do ilevel = 1 , nlevel write ( * , \"(I4,4X,I4,16X,F12.4)\" ) v1array ( ilevel ), j1array ( ilevel ), elevel ( ilevel ) enddo write ( * , \"(44X,A3)\" ) \"***\" if ( jtotmax . ne . 999999 ) then call write_message ( \"The equations will be solved \" // & \"for total angular momentum J from \" // & trim ( adjustl ( integer_to_character ( jtotmin ))) // \" to \" & // trim ( adjustl ( integer_to_character ( jtotmax ))) // \" with step \" // & trim ( adjustl ( integer_to_character ( jtotstep )))) else call write_message ( \"The loop over JTOT will be performed from \" // & trim ( adjustl ( integer_to_character ( jtotmin ))) // \" with step \" // & trim ( adjustl ( integer_to_character ( jtotstep ))) // \" until \" // & trim ( adjustl ( integer_to_character ( ncac ))) // & \" consecutive JTOT-blocks contribute less than \" // & trim ( adjustl ( float_to_character ( dtol , \"(E10.4)\" ))) // & \" A&#94;2 to the elastic XS and less than \" // & trim ( adjustl ( float_to_character ( otol , \"(E10.4)\" ))) // & \" A&#94;2 to the inelastic XS\" ) endif if ( ietoterel . eq . 0 ) then call write_message ( \"The calculations will be performed for the total energy equal to \" & // trim ( adjustl ( float_to_character ( ETOTAL (), \"(F10.4)\" ))) // \" cm-1\" ) else if ( ietoterel . eq . 1 ) then call write_message ( \"Relative kinetic energy of the colliding system: \" // & trim ( adjustl ( float_to_character ( energy , \"(F10.4)\" ))) // \" cm-1\" ) call write_message ( \"and the corresponding wavenumber: \" // & trim ( adjustl ( float_to_character ( WAVENUMBEREKIN (), \"(F10.4)\" ))) // & \" 1/Ang\" ) call write_message ( \"The kinetic energy is calculated with respect to the\" // & \" v = \" // trim ( adjustl ( integer_to_character ( v1array ( initial )))) // & \" j = \" // trim ( adjustl ( integer_to_character ( j1array ( initial )))) // & \" level in the basis set with the rotational energy \" // & trim ( adjustl ( float_to_character ( elevel ( initial ), \"(F10.4)\" ))) & // \" cm-1.\" ) call write_message ( \"This gives the total energy equal to \" // & trim ( adjustl ( float_to_character ( ETOTAL (), \"(F10.4)\" ))) // \" cm-1\" ) endif if ( ipart . eq . 1 ) then call write_message ( \"Partial cross sections will be saved into \" // partialfile ) endif call write_message ( \"S-matrix elements will be saved into \" // smatrixfile ) !------------------------------------------------------------------------! end subroutine input_summary","tags":"","loc":"proc/input_summary.html"},{"title":"read_input_file – the SCATTERING code","text":"public  subroutine read_input_file() reads the input file prepared by the user using NAMELIST feature\nthe code uses 3 namelists: input, basis and potential Arguments None Calls proc~~read_input_file~~CallsGraph proc~read_input_file read_input_file interface~allocate_3d allocate_3d proc~read_input_file->interface~allocate_3d proc~input_check input_check proc~read_input_file->proc~input_check proc~input_summary input_summary proc~read_input_file->proc~input_summary proc~file_io_status file_io_status proc~read_input_file->proc~file_io_status interface~allocate_1d allocate_1d proc~read_input_file->interface~allocate_1d proc~write_message write_message proc~input_check->proc~write_message interface~incorrect_value incorrect_value proc~input_check->interface~incorrect_value proc~write_error write_error proc~input_check->proc~write_error proc~integer_to_character integer_to_character proc~input_check->proc~integer_to_character proc~input_summary->proc~write_message proc~etotal ETOTAL proc~input_summary->proc~etotal proc~wavenumberekin WAVENUMBEREKIN proc~input_summary->proc~wavenumberekin proc~input_summary->proc~integer_to_character proc~float_to_character float_to_character proc~input_summary->proc~float_to_character proc~file_io_status->proc~write_error proc~file_io_status->proc~integer_to_character proc~wavenumberekin->proc~etotal proc~wavenumberekin->proc~write_error proc~write_error->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~read_input_file~~CalledByGraph proc~read_input_file read_input_file program~scattering SCATTERING program~scattering->proc~read_input_file Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables err_message icol icoupl iilevel il ilevel io_status Source Code read_input_file Variables Type Visibility Attributes Name Initial character(len=200), public :: err_message integer(kind=int32), public :: icol integer(kind=int32), public :: icoupl integer(kind=int32), public :: iilevel integer(kind=int32), public :: il integer(kind=int32), public :: ilevel integer(kind=int32), public :: io_status Source Code subroutine read_input_file !! reads the input file prepared by the user using NAMELIST feature !! the code uses 3 namelists: input, basis and potential !------------------------------------------------------------------------! character ( len = 200 ) :: err_message integer ( int32 ) :: ilevel , iilevel , icoupl , icol , il , io_status !------------------------------------------------------------------------! namelist / INPUT / label , reducedmass , ietoterel , energy , & jtotmin , jtotmax , jtotstep , rmin , rmax , dr , steps , vdepth , & ncac , dtol , otol , nlevel , initial , nr , nterms , totalcol , & n_skip_lines , iunits , potentialfile , smatrixfile , ipart , partialfile , & prntlvl namelist / BASIS / v1array , j1array , elevel namelist / POTENTIAL / l1tab , l2tab , lltab , v1pes , j1pes , v1ppes , j1ppes !------------------------------------------------------------------------------! ! Pre-declaration of variables                                                 ! !------------------------------------------------------------------------------! ! The most important variables (if they are not specified, the code stops):    ! !------------------------------------------------------------------------------! reducedmass = - 1.0_dp energy = - 1.0_dp rmin = - 1.0_dp rmax = - 1.0_dp nlevel = - 1 initial = - 1 nr = - 1 nterms = - 1 !------------------------------------------------------------------------------! ! Additional variables (the code runs with the pre-declared values):           ! !------------------------------------------------------------------------------! ietoterel = 0 jtotmin = 0 jtotmax = - 1 jtotstep = 1 dr = - 1.0_dp steps = 10 vdepth = 0.0_dp ncac = 1 dtol = 0.1_dp otol = 0.1_dp totalcol = 1 n_skip_lines = 0 iunits = 0 potentialfile = 'RadialTerms.dat' smatrixfile = 'SmatrixFile.dat' ipart = 0 partialfile = 'PartialFile.dat' prntlvl = 2 !------------------------------------------------------------------------------! open ( unit = 5 , action = 'read' , form = 'formatted' , access = 'sequential' , & status = 'old' , iostat = io_status , iomsg = err_message ) call file_io_status ( io_status , err_message , 5 , 'o' ) !------------------------------------------------------------------------------! ! Read the input namelist:                                                     ! !------------------------------------------------------------------------------! read ( unit = 5 , nml = INPUT , iostat = io_status , iomsg = err_message ) call file_io_status ( io_status , err_message , 5 , 'r' ) !------------------------------------------------------------------------------! ! Check if the variables from input namelist are supplied correctly:           ! !------------------------------------------------------------------------------! call input_check ( 1 ) if ( jtotmax . eq . - 1 ) jtotmax = 999999 call allocate_1d ( v1array , nlevel ) call allocate_1d ( j1array , nlevel ) call allocate_1d ( elevel , nlevel ) call allocate_1d ( l1tab , nterms ) call allocate_1d ( v1pes , totalcol ) call allocate_1d ( v1ppes , totalcol ) call allocate_1d ( j1pes , totalcol ) call allocate_1d ( j1ppes , totalcol ) !------------------------------------------------------------------------------! ! Read the basis namelist & check if the values were supplied correctly:       ! !------------------------------------------------------------------------------! read ( unit = 5 , nml = BASIS , iostat = io_status , iomsg = err_message ) call file_io_status ( io_status , err_message , 5 , 'r' ) call input_check ( 2 ) !------------------------------------------------------------------------------! ! If itype = 2/4 the code reads all the totalcol coupling terms, but some of   ! ! them will not be used in the calculations. Here, the code prepares           ! ! the arrays of ncoupl size, that will hold only the necessary terms           ! !------------------------------------------------------------------------------! ncoupl = nlevel * ( nlevel + 1 ) / 2 call allocate_1d ( reduced_j1pes , ncoupl ) call allocate_1d ( reduced_j1ppes , ncoupl ) call allocate_1d ( reduced_v1pes , ncoupl ) call allocate_1d ( reduced_v1ppes , ncoupl ) icoupl = 0 do ilevel = 1 , nlevel do iilevel = ilevel , nlevel icoupl = icoupl + 1 reduced_v1pes ( icoupl ) = v1array ( ilevel ) reduced_j1pes ( icoupl ) = j1array ( ilevel ) reduced_v1ppes ( icoupl ) = v1array ( iilevel ) reduced_j1ppes ( icoupl ) = j1array ( iilevel ) enddo enddo !------------------------------------------------------------------------------! ! Read the potential namelist & check if the values were supplied correctly:   ! !------------------------------------------------------------------------------! read ( unit = 5 , nml = POTENTIAL , iostat = io_status , iomsg = err_message ) call file_io_status ( io_status , err_message , 5 , 'r' ) call input_check ( 3 ) close ( 5 ) !------------------------------------------------------------------------------! ! Prepare the arrays that are needed for interpolation of the coupling terms:  ! !------------------------------------------------------------------------------! call allocate_1d ( rmat , nr ) call allocate_1d ( b , nr ) call allocate_1d ( c , nr ) call allocate_1d ( d , nr ) call allocate_3d ( read_vmat3D , nr , nterms , totalcol ) call allocate_3d ( vmat3D , nr , nterms , ncoupl ) call allocate_3d ( bmat3D , nr , nterms , ncoupl ) call allocate_3d ( cmat3D , nr , nterms , ncoupl ) call allocate_3d ( dmat3D , nr , nterms , ncoupl ) !------------------------------------------------------------------------------! ! Summarize the input parameters:                                              ! !------------------------------------------------------------------------------! call input_summary end subroutine read_input_file","tags":"","loc":"proc/read_input_file.html"},{"title":"save_open_basis_levels – the SCATTERING code","text":"public  subroutine save_open_basis_levels(number_of_open_basis_levels, open_basis_levels, open_basis_wavevectors) saves indices to open levels in the basis and corresponding\nwavenumbers Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: number_of_open_basis_levels number of energetically accessible levels in the basis integer(kind=int32), intent(inout) :: open_basis_levels (number_of_open_basis_levels) array holding indices to energetically accessible levels in the basis real(kind=dp), intent(inout) :: open_basis_wavevectors (number_of_open_basis_levels) array holding wavevectors calculated w.r.t energetically accessible levels in the basis Calls proc~~save_open_basis_levels~~CallsGraph proc~save_open_basis_levels save_open_basis_levels proc~etotal ETOTAL proc~save_open_basis_levels->proc~etotal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~save_open_basis_levels~~CalledByGraph proc~save_open_basis_levels save_open_basis_levels program~scattering SCATTERING program~scattering->proc~save_open_basis_levels Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables count_ ilevel Source Code save_open_basis_levels Variables Type Visibility Attributes Name Initial integer(kind=int32), public :: count_ integer(kind=int32), public :: ilevel Source Code subroutine save_open_basis_levels ( number_of_open_basis_levels , & open_basis_levels , open_basis_wavevectors ) !! saves indices to open levels in the basis and corresponding !! wavenumbers !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: number_of_open_basis_levels !! number of energetically accessible levels in the basis integer ( int32 ), intent ( inout ) :: open_basis_levels ( number_of_open_basis_levels ) !! array holding indices to energetically accessible levels in the basis real ( dp ), intent ( inout ) :: open_basis_wavevectors ( number_of_open_basis_levels ) !! array holding wavevectors calculated w.r.t energetically accessible levels in the basis !---------------------------------------------------------------------! integer ( int32 ) :: count_ , ilevel !---------------------------------------------------------------------! count_ = 0 do ilevel = 1 , nlevel if ( ETOTAL () - elevel ( ilevel ) >= 0 ) then count_ = count_ + 1 open_basis_levels ( count_ ) = ilevel open_basis_wavevectors ( count_ ) = dsqrt (( 2 * reducedmass & * ( ETOTAL () - elevel ( ilevel )))) / bohrtoangstrom endif enddo !---------------------------------------------------------------------! end subroutine save_open_basis_levels","tags":"","loc":"proc/save_open_basis_levels.html"},{"title":"units_conversion – the SCATTERING code","text":"public  subroutine units_conversion() converts all physical quantities to atomic units Arguments None Called by proc~~units_conversion~~CalledByGraph proc~units_conversion units_conversion program~scattering SCATTERING program~scattering->proc~units_conversion Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables ilevel Source Code units_conversion Variables Type Visibility Attributes Name Initial integer(kind=int32), public :: ilevel Source Code subroutine units_conversion !! converts all physical quantities to atomic units !---------------------------------------------------------------------! integer ( int32 ) :: ilevel !---------------------------------------------------------------------! reducedmass = reducedmass * amutoau energy = energy / hartreetocm vdepth = vdepth / hartreetocm !---------------------------------------------------------------------! do ilevel = 1 , nlevel elevel ( ilevel ) = elevel ( ilevel ) / hartreetocm enddo !---------------------------------------------------------------------! end subroutine units_conversion","tags":"","loc":"proc/units_conversion.html"},{"title":"is_sum_even – the SCATTERING code","text":"public  function is_sum_even(x, y, z) result(sum_even) checks if the sum of 3 integers is an even integer Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x variables to check if the sum is even integer(kind=int32), intent(in) :: y variables to check if the sum is even integer(kind=int32), intent(in) :: z variables to check if the sum is even Return Value integer(kind=int32) (out) result: 1 = true, 0 = false Called by proc~~is_sum_even~~CalledByGraph proc~is_sum_even is_sum_even proc~check_nonzero_coupling_matrix_elements check_nonzero_coupling_matrix_elements proc~check_nonzero_coupling_matrix_elements->proc~is_sum_even proc~prepare_coupling_matrix_elements prepare_coupling_matrix_elements proc~prepare_coupling_matrix_elements->proc~is_sum_even program~scattering SCATTERING program~scattering->proc~check_nonzero_coupling_matrix_elements program~scattering->proc~prepare_coupling_matrix_elements Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code is_sum_even Source Code function is_sum_even ( x , y , z ) result ( sum_even ) !! checks if the sum of 3 integers is an even integer !------------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: x , y , z !! variables to check if the sum is even integer ( int32 ) :: sum_even !! (out) result: 1 = true, 0 = false !------------------------------------------------------------------------! sum_even = merge ( 1 , 0 , modulo ( x + y + z , 2 ) == 0 ) !------------------------------------------------------------------------! end function is_sum_even","tags":"","loc":"proc/is_sum_even.html"},{"title":"ispline – the SCATTERING code","text":"public  function ispline(u_, N_, x_, y_, b_, c_, d_) result(spl_result) returns interpolated value at guven u_ point\nnumber of points and ascending order of x is not checked since\nispline is called after \"spline\" where these checks are done Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: u_ point at which the tabulated value is interpolated integer(kind=int32), intent(in) :: N_ number of grid points real(kind=dp), intent(in) :: x_ (N_) grid points real(kind=dp), intent(in) :: y_ (N_) tabulated values real(kind=dp), intent(in) :: b_ (N_) arrays with coefficients of the spline function real(kind=dp), intent(in) :: c_ (N_) arrays with coefficients of the spline function real(kind=dp), intent(in) :: d_ (N_) arrays with coefficients of the spline function Return Value real(kind=dp) interpolated value at u_ Calls proc~~ispline~~CallsGraph proc~ispline ispline proc~float_to_character float_to_character proc~ispline->proc~float_to_character proc~write_warning write_warning proc~ispline->proc~write_warning proc~write_message write_message proc~write_warning->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~ispline~~CalledByGraph proc~ispline ispline proc~radtermvalue RADTERMVALUE proc~radtermvalue->proc~ispline proc~pes_contribution pes_contribution proc~pes_contribution->proc~radtermvalue proc~numerov numerov proc~numerov->proc~pes_contribution program~scattering SCATTERING program~scattering->proc~numerov Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables dx_ k_ l_ mid_ Source Code ispline Variables Type Visibility Attributes Name Initial real(kind=dp), public :: dx_ integer(kind=int32), public :: k_ integer(kind=int32), public :: l_ integer(kind=int32), public :: mid_ Source Code function ispline ( u_ , N_ , x_ , y_ , b_ , c_ , d_ ) result ( spl_result ) !! returns interpolated value at guven u_ point !! number of points and ascending order of x is not checked since !! ispline is called after \"spline\" where these checks are done !------------------------------------------------------------------------! real ( dp ), intent ( in ) :: u_ !! point at which the tabulated value is interpolated integer ( int32 ), intent ( in ) :: N_ !! number of grid points real ( dp ), intent ( in ) :: x_ ( N_ ) !! grid points real ( dp ), intent ( in ) :: y_ ( N_ ) !! tabulated values real ( dp ), intent ( in ) :: b_ ( N_ ), c_ ( N_ ), d_ ( N_ ) !! arrays with coefficients of the spline function real ( dp ) :: spl_result !! interpolated value at u_ !------------------------------------------------------------------------! integer ( int32 ) :: k_ , l_ , mid_ real ( dp ) :: dx_ !------------------------------------------------------------------------! if ( u_ > x_ ( N_ )) then call write_warning ( \"ispline: point u_ = \" // & trim ( adjustl ( float_to_character ( u_ ))) // \" exceeds the original \" & // \"grid: x(N) = \" // trim ( adjustl ( float_to_character ( x_ ( N_ ))))) spl_result = y_ ( N_ ) else if ( u_ < x_ ( 1 ) ) then call write_warning ( \"ispline: point u_ = \" // & trim ( adjustl ( float_to_character ( u_ ))) // \" exceeds the original \" & // \"grid: x(1) = \" // trim ( adjustl ( float_to_character ( x_ ( 1 ))))) spl_result = y_ ( 1 ) else !---------------------------------------------------------------------! l_ = 1 k_ = N_ + 1 do while ( k_ > l_ + 1 ) mid_ = nint ( ( l_ + k_ ) / 2.0_dp ) if ( x_ ( mid_ ) > u_ ) then k_ = mid_ else l_ = mid_ endif end do dx_ = u_ - x_ ( l_ ) spl_result = y_ ( l_ ) + dx_ * ( b_ ( l_ ) + dx_ * ( c_ ( l_ ) + d_ ( l_ ) * dx_ )) !---------------------------------------------------------------------! endif !------------------------------------------------------------------------! end function ispline","tags":"","loc":"proc/ispline.html"},{"title":"triangle_inequality_holds – the SCATTERING code","text":"public  function triangle_inequality_holds(x, y, z) result(triang) check if the triangle inequality for 3 variables hols Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x variables to check the triangle inequality integer(kind=int32), intent(in) :: y variables to check the triangle inequality integer(kind=int32), intent(in) :: z variables to check the triangle inequality Return Value integer(kind=int32) (out) result: 1 = true, 0 = false Called by proc~~triangle_inequality_holds~~CalledByGraph proc~triangle_inequality_holds triangle_inequality_holds proc~check_nonzero_coupling_matrix_elements check_nonzero_coupling_matrix_elements proc~check_nonzero_coupling_matrix_elements->proc~triangle_inequality_holds proc~prepare_coupling_matrix_elements prepare_coupling_matrix_elements proc~prepare_coupling_matrix_elements->proc~triangle_inequality_holds program~scattering SCATTERING program~scattering->proc~check_nonzero_coupling_matrix_elements program~scattering->proc~prepare_coupling_matrix_elements Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code triangle_inequality_holds Source Code function triangle_inequality_holds ( x , y , z ) result ( triang ) !! check if the triangle inequality for 3 variables hols !------------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: x , y , z !! variables to check the triangle inequality integer ( int32 ) :: triang !! (out) result: 1 = true, 0 = false !------------------------------------------------------------------------! triang = 0 if ( x + y >= z . and . x + z >= y . and . y + z >= x ) then triang = 1 endif !------------------------------------------------------------------------! end function triangle_inequality_holds","tags":"","loc":"proc/triangle_inequality_holds.html"},{"title":"modified_bessel_k_ratio – the SCATTERING code","text":"public  subroutine modified_bessel_k_ratio(l_, x_, ratio_) calculates the ratio of the modified Bessel function of the second\nkind K_{l_ + 1/2}(x) and its first derivative (Eq. ...)\nUses ikv function from special_functions.f90 Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: l_ l - order of the function (without the 1/2 factor!) real(kind=dp), intent(in) :: x_ x - argument of the function real(kind=dp), intent(inout) :: ratio_ ratio of the modified Bessel function of the second kind to its derivative Calls proc~~modified_bessel_k_ratio~~CallsGraph proc~modified_bessel_k_ratio modified_bessel_k_ratio proc~ikv ikv proc~modified_bessel_k_ratio->proc~ikv proc~write_warning write_warning proc~modified_bessel_k_ratio->proc~write_warning proc~integer_to_character integer_to_character proc~modified_bessel_k_ratio->proc~integer_to_character proc~msta1 msta1 proc~ikv->proc~msta1 proc~msta2 msta2 proc~ikv->proc~msta2 proc~write_message write_message proc~write_warning->proc~write_message proc~envj envj proc~msta1->proc~envj proc~msta2->proc~envj Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~modified_bessel_k_ratio~~CalledByGraph proc~modified_bessel_k_ratio modified_bessel_k_ratio proc~calculate_k_matrix calculate_k_matrix proc~calculate_k_matrix->proc~modified_bessel_k_ratio program~scattering SCATTERING program~scattering->proc~calculate_k_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables bi_arr_ bk_arr_ di_arr_ dk_arr_ highest_order_ highest_order_real_ order_ Source Code modified_bessel_k_ratio Variables Type Visibility Attributes Name Initial real(kind=dp), public, dimension(l_+1) :: bi_arr_ real(kind=dp), public, dimension(l_+1) :: bk_arr_ real(kind=dp), public, dimension(l_+1) :: di_arr_ real(kind=dp), public, dimension(l_+1) :: dk_arr_ integer(kind=int32), public :: highest_order_ real(kind=dp), public :: highest_order_real_ real(kind=dp), public :: order_ Source Code subroutine modified_bessel_k_ratio ( l_ , x_ , ratio_ ) !! calculates the ratio of the modified Bessel function of the second !! kind K_{l_ + 1/2}(x) and its first derivative (Eq. ...) !! Uses ikv function from special_functions.f90 !------------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: l_ !! l - order of the function (without the 1/2 factor!) real ( dp ), intent ( in ) :: x_ !! x - argument of the function real ( dp ), intent ( inout ) :: ratio_ !! ratio of the modified Bessel function of the second kind to its derivative !------------------------------------------------------------------------! integer ( int32 ) :: highest_order_ real ( dp ) :: order_ , highest_order_real_ real ( dp ), dimension ( l_ + 1 ) :: bi_arr_ , di_arr_ , bk_arr_ , dk_arr_ !------------------------------------------------------------------------! order_ = real ( l_ , dp ) + 0.5_dp call ikv ( order_ , x_ , highest_order_real_ , bi_arr_ , di_arr_ , bk_arr_ , dk_arr_ ) highest_order_ = nint ( highest_order_real_ - 0.5_dp ) !------------------------------------------------------------------------! if ( highest_order_ < l_ ) then !---------------------------------------------------------------------! call write_warning ( \"modified_bessel_k_ratio: maximum order of modified Bessel function:\" & // trim ( adjustl ( integer_to_character ( highest_order_ ))) // \"is smaller than \" // & \"requested order l = \" // trim ( adjustl ( integer_to_character ( l_ ))) ) !---------------------------------------------------------------------! ratio_ = dk_arr_ ( highest_order_ ) / bk_arr_ ( highest_order_ ) else ratio_ = dk_arr_ ( l_ + 1 ) / bk_arr_ ( l_ + 1 ) endif !------------------------------------------------------------------------! end subroutine modified_bessel_k_ratio","tags":"","loc":"proc/modified_bessel_k_ratio.html"},{"title":"riccati_bessel_j – the SCATTERING code","text":"public  subroutine riccati_bessel_j(l_, x_, j_, jp_) calculates the Riccati-Bessel function of the first kind and its\nfirst derivative. Calls the rctj function from special_functions.f90 Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: l_ l - order of the Riccati-Bessel function of the first kind real(kind=dp), intent(in) :: x_ x - argument of the Riccati-Bessel function of the first kind real(kind=dp), intent(inout) :: j_ j_{l} (x) - Riccati-Bessel funciton of the first kind real(kind=dp), intent(inout) :: jp_ j_{l}' (x) - derivative of the Riccati-Bessel funciton of the first kind Calls proc~~riccati_bessel_j~~CallsGraph proc~riccati_bessel_j riccati_bessel_j proc~rctj rctj proc~riccati_bessel_j->proc~rctj proc~write_warning write_warning proc~riccati_bessel_j->proc~write_warning proc~integer_to_character integer_to_character proc~riccati_bessel_j->proc~integer_to_character proc~msta1 msta1 proc~rctj->proc~msta1 proc~msta2 msta2 proc~rctj->proc~msta2 proc~write_message write_message proc~write_warning->proc~write_message proc~envj envj proc~msta1->proc~envj proc~msta2->proc~envj Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~riccati_bessel_j~~CalledByGraph proc~riccati_bessel_j riccati_bessel_j proc~calculate_k_matrix calculate_k_matrix proc~calculate_k_matrix->proc~riccati_bessel_j program~scattering SCATTERING program~scattering->proc~calculate_k_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables dj_ highest_order_ rj_ Source Code riccati_bessel_j Variables Type Visibility Attributes Name Initial real(kind=dp), public, dimension(l_+1) :: dj_ integer(kind=int32), public :: highest_order_ real(kind=dp), public, dimension(l_+1) :: rj_ Source Code subroutine riccati_bessel_j ( l_ , x_ , j_ , jp_ ) !! calculates the Riccati-Bessel function of the first kind and its !! first derivative. Calls the rctj function from special_functions.f90 !------------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: l_ !! l - order of the Riccati-Bessel function of the first kind real ( dp ), intent ( in ) :: x_ !! x - argument of the Riccati-Bessel function of the first kind real ( dp ), intent ( inout ) :: j_ !! j_{l} (x) - Riccati-Bessel funciton of the first kind real ( dp ), intent ( inout ) :: jp_ !! j_{l}' (x) - derivative of the Riccati-Bessel funciton of the first kind !------------------------------------------------------------------------! integer ( int32 ) :: highest_order_ real ( dp ), dimension ( l_ + 1 ) :: rj_ , dj_ !------------------------------------------------------------------------! if ( l_ == 0 ) then call rctj ( l_ + 1 , x_ , highest_order_ , rj_ , dj_ ) else call rctj ( l_ , x_ , highest_order_ , rj_ , dj_ ) endif if ( highest_order_ < l_ ) then !---------------------------------------------------------------------! call write_warning ( \"riccati_bessel_j: maximum order of Riccati-Bessel function:\" & // trim ( adjustl ( integer_to_character ( highest_order_ ))) // \"is smaller than \" // & \"requested order l = \" // trim ( adjustl ( integer_to_character ( l_ ))) ) !---------------------------------------------------------------------! j_ = rj_ ( highest_order_ ) jp_ = dj_ ( highest_order_ ) else j_ = rj_ ( l_ + 1 ) jp_ = dj_ ( l_ + 1 ) endif !------------------------------------------------------------------------! end subroutine riccati_bessel_j","tags":"","loc":"proc/riccati_bessel_j.html"},{"title":"riccati_bessel_y – the SCATTERING code","text":"public  subroutine riccati_bessel_y(l_, x_, y_, yp_) calculates the Riccati-Bessel function of the second kind and its\nfirst derivative. Calls the rcty function from special_functions.f90 Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: l_ l - order of the Riccati-Bessel function of the second kind real(kind=dp), intent(in) :: x_ x - argument of the Riccati-Bessel function of the second kind real(kind=dp), intent(inout) :: y_ y_{l} (x) - Riccati-Bessel funciton of the second kind real(kind=dp), intent(inout) :: yp_ y_{l}' (x) - derivative of the Riccati-Bessel funciton of the second kind Calls proc~~riccati_bessel_y~~CallsGraph proc~riccati_bessel_y riccati_bessel_y proc~rcty rcty proc~riccati_bessel_y->proc~rcty proc~write_warning write_warning proc~riccati_bessel_y->proc~write_warning proc~integer_to_character integer_to_character proc~riccati_bessel_y->proc~integer_to_character proc~write_message write_message proc~write_warning->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~riccati_bessel_y~~CalledByGraph proc~riccati_bessel_y riccati_bessel_y proc~calculate_k_matrix calculate_k_matrix proc~calculate_k_matrix->proc~riccati_bessel_y program~scattering SCATTERING program~scattering->proc~calculate_k_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables dy_ highest_order_ ry_ Source Code riccati_bessel_y Variables Type Visibility Attributes Name Initial real(kind=dp), public, dimension(l_+1) :: dy_ integer(kind=int32), public :: highest_order_ real(kind=dp), public, dimension(l_+1) :: ry_ Source Code subroutine riccati_bessel_y ( l_ , x_ , y_ , yp_ ) !! calculates the Riccati-Bessel function of the second kind and its !! first derivative. Calls the rcty function from special_functions.f90 !------------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: l_ !! l - order of the Riccati-Bessel function of the second kind real ( dp ), intent ( in ) :: x_ !! x - argument of the Riccati-Bessel function of the second kind real ( dp ), intent ( inout ) :: y_ !! y_{l} (x) - Riccati-Bessel funciton of the second kind real ( dp ), intent ( inout ) :: yp_ !! y_{l}' (x) - derivative of the Riccati-Bessel funciton of the second kind !------------------------------------------------------------------------! integer ( int32 ) :: highest_order_ real ( dp ), dimension ( l_ + 1 ) :: ry_ , dy_ !------------------------------------------------------------------------! if ( l_ == 0 ) then call rcty ( l_ + 1 , x_ , highest_order_ , ry_ , dy_ ) else call rcty ( l_ , x_ , highest_order_ , ry_ , dy_ ) endif y_ = ry_ ( l_ + 1 ) yp_ = dy_ ( l_ + 1 ) !------------------------------------------------------------------------! if ( highest_order_ < l_ ) then !---------------------------------------------------------------------! call write_warning ( \"riccati_bessel_j: maximum order of Riccati-Bessel function:\" & // trim ( adjustl ( integer_to_character ( highest_order_ ))) // \"is smaller than \" // & \"requested order l = \" // trim ( adjustl ( integer_to_character ( l_ ))) ) !---------------------------------------------------------------------! y_ = ry_ ( highest_order_ ) yp_ = dy_ ( highest_order_ ) else y_ = ry_ ( l_ + 1 ) yp_ = dy_ ( l_ + 1 ) endif !------------------------------------------------------------------------! end subroutine riccati_bessel_y","tags":"","loc":"proc/riccati_bessel_y.html"},{"title":"spline – the SCATTERING code","text":"public  subroutine spline(N_, x_, y_, b_, c_, d_) determines b, c and d coefficients of the cubic spline function\ny(x) = y_i + b_i * dx + c_i * dx&#94;2 + d_i * dx&#94;3,\nwhere dx = x - x_i, and x_i <= x < x_i+1.\nThe algorithm is based on\nGerald, C., and Wheatley, P., \"Applied Numerical Analysis\", Addison-Wesley, 1994. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: N_ number of grid points real(kind=dp), intent(in) :: x_ (N_) grid points (ascending order) real(kind=dp), intent(in) :: y_ (N_) tabulated values real(kind=dp), intent(out) :: b_ (N_) arrays with coefficients of the spline function real(kind=dp), intent(out) :: c_ (N_) arrays with coefficients of the spline function real(kind=dp), intent(out) :: d_ (N_) arrays with coefficients of the spline function Calls proc~~spline~~CallsGraph proc~spline spline proc~integer_to_character integer_to_character proc~spline->proc~integer_to_character proc~write_error write_error proc~spline->proc~write_error proc~write_message write_message proc~write_error->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~spline~~CalledByGraph proc~spline spline proc~potential_interpolation potential_interpolation proc~potential_interpolation->proc~spline program~scattering SCATTERING program~scattering->proc~potential_interpolation Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables diff_x_ i_ j_ w_ Source Code spline Variables Type Visibility Attributes Name Initial real(kind=dp), public :: diff_x_ (N_-1) integer(kind=int32), public :: i_ integer(kind=int32), public :: j_ real(kind=dp), public :: w_ Source Code subroutine spline ( N_ , x_ , y_ , b_ , c_ , d_ ) !! determines b, c and d coefficients of the cubic spline function !! y(x) = y_i + b_i * dx + c_i * dx&#94;2 + d_i * dx&#94;3, !! where dx = x - x_i, and x_i <= x < x_i+1. !! The algorithm is based on !! Gerald, C., and Wheatley, P., \"Applied Numerical Analysis\", Addison-Wesley, 1994. !------------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: N_ !! number of grid points real ( dp ), intent ( in ) :: x_ ( N_ ) !! grid points (ascending order) real ( dp ), intent ( in ) :: y_ ( N_ ) !! tabulated values real ( dp ), intent ( out ) :: b_ ( N_ ), c_ ( N_ ), d_ ( N_ ) !! arrays with coefficients of the spline function !------------------------------------------------------------------------! integer ( int32 ) :: i_ , j_ real ( dp ) :: w_ real ( dp ) :: diff_x_ ( N_ - 1 ) !------------------------------------------------------------------------! ! check if the number of points is larger than 4 !------------------------------------------------------------------------! if ( N_ < 4 ) then call write_error ( \"spline function called with \" // & trim ( adjustl ( integer_to_character ( N_ ))) // \" points\" ) endif !------------------------------------------------------------------------! ! check if x is sorted in ascending order !------------------------------------------------------------------------! do i_ = 2 , N_ if ( x_ ( i_ ) <= x_ ( i_ - 1 )) then call write_error ( \"spline: x values are not in ascending order \" // & \" at index \" // trim ( adjustl ( integer_to_character ( i_ )))) endif end do !------------------------------------------------------------------------! diff_x_ = x_ ( 2 : N_ ) - x_ ( 1 : N_ - 1 ) !------------------------------------------------------------------------! b_ ( 2 : N_ - 1 ) = 2.0_dp * ( diff_x_ ( 1 : N_ - 2 ) + diff_x_ ( 2 : N_ - 1 )) b_ ( 1 ) = - diff_x_ ( 1 ) b_ ( N_ ) = - diff_x_ ( N_ - 1 ) c_ ( 2 : N_ - 1 ) = ( y_ ( 3 : N_ ) - y_ ( 2 : N_ - 1 ) ) / diff_x_ ( 2 : N_ - 1 ) & - ( y_ ( 2 : N_ - 1 ) - y_ ( 1 : N_ - 2 ) ) / diff_x_ ( 1 : N_ - 2 ) c_ ( 1 ) = c_ ( 3 ) / ( x_ ( 4 ) - x_ ( 2 )) - c_ ( 2 ) / ( x_ ( 3 ) - x_ ( 1 )) c_ ( N_ ) = c_ ( N_ - 1 ) / ( x_ ( N_ ) - x_ ( N_ - 2 )) - c_ ( N_ - 2 ) / ( x_ ( N_ - 1 ) - x_ ( N_ - 3 )) c_ ( 1 ) = c_ ( 1 ) / ( x_ ( 4 ) - x_ ( 1 )) * diff_x_ ( 1 ) ** 2 c_ ( N_ ) = - c_ ( N_ ) / ( x_ ( N_ ) - x_ ( N_ - 3 )) * diff_x_ ( N_ - 1 ) ** 2 do i_ = 2 , N_ w_ = diff_x_ ( i_ - 1 ) / b_ ( i_ - 1 ) b_ ( i_ ) = b_ ( i_ ) - w_ * diff_x_ ( i_ - 1 ) c_ ( i_ ) = c_ ( i_ ) - w_ * c_ ( i_ - 1 ) end do c_ ( N_ ) = c_ ( N_ ) / b_ ( N_ ) do j_ = 1 , N_ - 1 i_ = N_ - j_ c_ ( i_ ) = ( c_ ( i_ ) - diff_x_ ( i_ ) * c_ ( i_ + 1 )) / b_ ( i_ ) end do b_ ( 1 : N_ - 1 ) = ( y_ ( 2 : N_ ) - y_ ( 1 : N_ - 1 ) ) / diff_x_ ( 1 : N_ - 1 ) & - ( 2.0_dp * c_ ( 1 : N_ - 1 ) + c_ ( 2 : N_ ) ) * diff_x_ ( 1 : N_ - 1 ) d_ ( 1 : N_ - 1 ) = ( c_ ( 2 : N_ ) - c_ ( 1 : N_ - 1 ) ) / diff_x_ ( 1 : N_ - 1 ) c_ = c_ * 3.0_dp end subroutine spline","tags":"","loc":"proc/spline.html"},{"title":"potential_interpolation – the SCATTERING code","text":"public  subroutine potential_interpolation() intertpolates the necessary radial coupling terms using cubic\nspline functions. The coefficients are kept in bmat/cmat/dmat matrices Arguments None Calls proc~~potential_interpolation~~CallsGraph proc~potential_interpolation potential_interpolation proc~spline spline proc~potential_interpolation->proc~spline proc~integer_to_character integer_to_character proc~spline->proc~integer_to_character proc~write_error write_error proc~spline->proc~write_error proc~write_message write_message proc~write_error->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~potential_interpolation~~CalledByGraph proc~potential_interpolation potential_interpolation program~scattering SCATTERING program~scattering->proc~potential_interpolation Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables icoupl il ir Variables Type Visibility Attributes Name Initial integer(kind=int32), public :: icoupl integer(kind=int32), public :: il integer(kind=int32), public :: ir","tags":"","loc":"proc/potential_interpolation.html"},{"title":"potential_read – the SCATTERING code","text":"public  subroutine potential_read() reads the radial coupling terms from the external file.\nThe file is assumed to be formatted as follows:\nR, V_{l1,v1,j1,v1',j1'}(R) \nThe read radial coupling terms are kept in vmat/read_vmat3D Arguments None Calls proc~~potential_read~~CallsGraph proc~potential_read potential_read proc~file_io_status file_io_status proc~potential_read->proc~file_io_status proc~integer_to_character integer_to_character proc~potential_read->proc~integer_to_character proc~write_error write_error proc~potential_read->proc~write_error proc~float_to_character float_to_character proc~potential_read->proc~float_to_character proc~file_io_status->proc~integer_to_character proc~file_io_status->proc~write_error proc~write_message write_message proc~write_error->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~potential_read~~CalledByGraph proc~potential_read potential_read program~scattering SCATTERING program~scattering->proc~potential_read Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables err_message icol il io_status ir iskip_ l1 nrtmp Variables Type Visibility Attributes Name Initial character(len=200), public :: err_message integer(kind=int32), public :: icol integer(kind=int32), public :: il integer(kind=int32), public :: io_status integer(kind=int32), public :: ir integer(kind=int32), public :: iskip_ integer(kind=int32), public :: l1 integer(kind=int32), public :: nrtmp","tags":"","loc":"proc/potential_read.html"},{"title":"potential_reduction – the SCATTERING code","text":"public  subroutine potential_reduction() reducesof the read_vmat3D matrix to retain only the necessary coupling terms\nwhich are kept in reduced_*. The number of necessary coupling terms (ncoupl)\nis already determined in io_mod module.\nIf totalcol = ncoupl, the procedure is ignored Arguments None Calls proc~~potential_reduction~~CallsGraph proc~potential_reduction potential_reduction proc~write_message write_message proc~potential_reduction->proc~write_message proc~integer_to_character integer_to_character proc~potential_reduction->proc~integer_to_character Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~potential_reduction~~CalledByGraph proc~potential_reduction potential_reduction program~scattering SCATTERING program~scattering->proc~potential_reduction Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables icol icoupl il ir Variables Type Visibility Attributes Name Initial integer(kind=int32), public :: icol integer(kind=int32), public :: icoupl integer(kind=int32), public :: il integer(kind=int32), public :: ir","tags":"","loc":"proc/potential_reduction.html"},{"title":"allocate_1d – the SCATTERING code","text":"public interface allocate_1d Called by interface~~allocate_1d~~CalledByGraph interface~allocate_1d allocate_1d proc~read_input_file read_input_file proc~read_input_file->interface~allocate_1d proc~crosssection CROSSSECTION proc~crosssection->interface~allocate_1d program~scattering SCATTERING program~scattering->interface~allocate_1d program~scattering->proc~read_input_file program~scattering->proc~crosssection Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines allocate_1d_dp allocate_1d_int32 allocate_1d_sp Subroutines public pure module subroutine allocate_1d_dp(array_, size_) allocate a 1d array and fill it with 0s (double precision version) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), allocatable :: array_ (:) integer(kind=int32), intent(in) :: size_ public pure module subroutine allocate_1d_int32(array_, size_) allocate a 1d array and fill it with 0s (integer version) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), allocatable :: array_ (:) integer(kind=int32), intent(in) :: size_ public pure module subroutine allocate_1d_sp(array_, size_) allocate a 1d array and fill it with 0s (single precision version) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout), allocatable :: array_ (:) integer(kind=int32), intent(in) :: size_","tags":"","loc":"interface/allocate_1d.html"},{"title":"allocate_2d – the SCATTERING code","text":"public interface allocate_2d Called by interface~~allocate_2d~~CalledByGraph interface~allocate_2d allocate_2d proc~numerov numerov proc~numerov->interface~allocate_2d program~scattering SCATTERING program~scattering->interface~allocate_2d program~scattering->proc~numerov Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines allocate_2d_dp allocate_2d_int32 allocate_2d_sp Subroutines public pure module subroutine allocate_2d_dp(array_, size1_, size2_) allocate a 2d array and fill it with 0s (double precision version) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), allocatable :: array_ (:,:) integer(kind=int32), intent(in) :: size1_ integer(kind=int32), intent(in) :: size2_ public pure module subroutine allocate_2d_int32(array_, size1_, size2_) allocate a 2d array and fill it with 0s (integer version) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), allocatable :: array_ (:,:) integer(kind=int32), intent(in) :: size1_ integer(kind=int32), intent(in) :: size2_ public pure module subroutine allocate_2d_sp(array_, size1_, size2_) allocate a 2d array and fill it with 0s (single precision version) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout), allocatable :: array_ (:,:) integer(kind=int32), intent(in) :: size1_ integer(kind=int32), intent(in) :: size2_","tags":"","loc":"interface/allocate_2d.html"},{"title":"allocate_3d – the SCATTERING code","text":"public interface allocate_3d Called by interface~~allocate_3d~~CalledByGraph interface~allocate_3d allocate_3d proc~read_input_file read_input_file proc~read_input_file->interface~allocate_3d program~scattering SCATTERING program~scattering->proc~read_input_file Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines allocate_3d_dp allocate_3d_int32 allocate_3d_sp Subroutines public pure module subroutine allocate_3d_dp(array_, size1_, size2_, size3_) allocate a 3d array and fill it with 0s (double precision version) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), allocatable :: array_ (:,:,:) integer(kind=int32), intent(in) :: size1_ integer(kind=int32), intent(in) :: size2_ integer(kind=int32), intent(in) :: size3_ public pure module subroutine allocate_3d_int32(array_, size1_, size2_, size3_) allocate a 3d array and fill it with 0s (integer version) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), allocatable :: array_ (:,:,:) integer(kind=int32), intent(in) :: size1_ integer(kind=int32), intent(in) :: size2_ integer(kind=int32), intent(in) :: size3_ public pure module subroutine allocate_3d_sp(array_, size1_, size2_, size3_) allocate a 3d array and fill it with 0s (single precision version) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout), allocatable :: array_ (:,:,:) integer(kind=int32), intent(in) :: size1_ integer(kind=int32), intent(in) :: size2_ integer(kind=int32), intent(in) :: size3_","tags":"","loc":"interface/allocate_3d.html"},{"title":"append – the SCATTERING code","text":"public interface append Called by interface~~append~~CalledByGraph interface~append append program~scattering SCATTERING program~scattering->interface~append Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines append_dp append_int32 append_sp Subroutines public pure module subroutine append_dp(array_, element_) append element to an array (double precision version) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), allocatable :: array_ (:) real(kind=dp), intent(in) :: element_ public pure module subroutine append_int32(array_, element_) append element to an array (integer version) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), allocatable :: array_ (:) integer(kind=int32), intent(in) :: element_ public pure module subroutine append_sp(array_, element_) append element to an array (single precision version) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout), allocatable :: array_ (:) real(kind=sp), intent(in) :: element_","tags":"","loc":"interface/append.html"},{"title":"fill_symmetric_matrix – the SCATTERING code","text":"public interface fill_symmetric_matrix Called by interface~~fill_symmetric_matrix~~CalledByGraph interface~fill_symmetric_matrix fill_symmetric_matrix proc~calculate_s_matrix calculate_s_matrix proc~calculate_s_matrix->interface~fill_symmetric_matrix proc~calculate_log_der_matrix calculate_log_der_matrix proc~calculate_log_der_matrix->interface~fill_symmetric_matrix proc~numerov numerov proc~numerov->interface~fill_symmetric_matrix proc~numerov->proc~calculate_log_der_matrix proc~pes_contribution pes_contribution proc~numerov->proc~pes_contribution proc~cenitrfugal_matrix cenitrfugal_matrix proc~numerov->proc~cenitrfugal_matrix proc~pes_contribution->interface~fill_symmetric_matrix proc~cenitrfugal_matrix->interface~fill_symmetric_matrix program~scattering SCATTERING program~scattering->proc~calculate_s_matrix program~scattering->proc~numerov Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines fill_symmetric_matrix_dp fill_symmetric_matrix_int32 fill_symmetric_matrix_sp Subroutines public module subroutine fill_symmetric_matrix_dp(matrix_, upper_lower_) fill the upper/lower triangle of a symmetric matrix (double precision version) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: matrix_ (:,:) character(len=1), intent(in) :: upper_lower_ public module subroutine fill_symmetric_matrix_int32(matrix_, upper_lower_) fill the upper/lower triangle of a symmetric matrix (integer version) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: matrix_ (:,:) character(len=1), intent(in) :: upper_lower_ public module subroutine fill_symmetric_matrix_sp(matrix_, upper_lower_) fill the upper/lower triangle of a symmetric matrix (single precision version) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: matrix_ (:,:) character(len=1), intent(in) :: upper_lower_","tags":"","loc":"interface/fill_symmetric_matrix.html"},{"title":"invert_symmetric_matrix – the SCATTERING code","text":"public interface invert_symmetric_matrix Called by interface~~invert_symmetric_matrix~~CalledByGraph interface~invert_symmetric_matrix invert_symmetric_matrix proc~calculate_s_matrix calculate_s_matrix proc~calculate_s_matrix->interface~invert_symmetric_matrix proc~calculate_log_der_matrix calculate_log_der_matrix proc~calculate_log_der_matrix->interface~invert_symmetric_matrix proc~numerov numerov proc~numerov->interface~invert_symmetric_matrix proc~numerov->proc~calculate_log_der_matrix program~scattering SCATTERING program~scattering->proc~calculate_s_matrix program~scattering->proc~numerov Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines invert_symmetric_matrix_dp invert_symmetric_matrix_int32 invert_symmetric_matrix_sp Subroutines public module subroutine invert_symmetric_matrix_dp(matrix_) invert a symmetric matrix using DSYTRI method (double precision version) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: matrix_ (:,:) public module subroutine invert_symmetric_matrix_int32(matrix_) invert a symmetric matrix using DSYTRI method (integer version) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: matrix_ (:,:) public module subroutine invert_symmetric_matrix_sp(matrix_) invert a symmetric matrix using DSYTRI method (single precision version) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: matrix_ (:,:)","tags":"","loc":"interface/invert_symmetric_matrix.html"},{"title":"check_nonzero_coupling_matrix_elements – the SCATTERING code","text":"public  subroutine check_nonzero_coupling_matrix_elements(number_of_channels, channels_level_indices, channels_omega_values, number_of_nonzero_coupling_matrix_elements, number_of_nonzero_coupling_coefficients) checks the number of non-zero coupling matrix elements due to\nthe \\bar{\\Omega} = \\bar{\\Omega}' condition\n(number_of_nonzero_coupling_matrix_elements variable),\nand the total number of non-zero algebraic coefficients that enter\nEqs. (6.13)-(6.15) (number_of_nonzero_coupling_coefficients variable). Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: number_of_channels size of the basis integer(kind=int32), intent(in) :: channels_level_indices (number_of_channels) holds the indices pointing to the basis arrays integer(kind=int32), intent(in) :: channels_omega_values (number_of_channels) holds all values of \\bar{\\Omega} integer(kind=int32), intent(out) :: number_of_nonzero_coupling_matrix_elements number of non-zero terms in the sum () for each non-zero element of the coupling matrix integer(kind=int32), intent(out) :: number_of_nonzero_coupling_coefficients number of all non-zero algberaix coefficients in the whole coupling matrix Calls proc~~check_nonzero_coupling_matrix_elements~~CallsGraph proc~check_nonzero_coupling_matrix_elements check_nonzero_coupling_matrix_elements proc~triangle_inequality_holds triangle_inequality_holds proc~check_nonzero_coupling_matrix_elements->proc~triangle_inequality_holds proc~is_sum_even is_sum_even proc~check_nonzero_coupling_matrix_elements->proc~is_sum_even Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~check_nonzero_coupling_matrix_elements~~CalledByGraph proc~check_nonzero_coupling_matrix_elements check_nonzero_coupling_matrix_elements program~scattering SCATTERING program~scattering->proc~check_nonzero_coupling_matrix_elements Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables count_nonzero_coupling_coefficients count_nonzero_coupling_matrix_elements ii ij il j1ptmp j1tmp l1 nil omegaptmp omegatmp Source Code check_nonzero_coupling_matrix_elements Variables Type Visibility Attributes Name Initial integer(kind=int32), public :: count_nonzero_coupling_coefficients integer(kind=int32), public :: count_nonzero_coupling_matrix_elements integer(kind=int32), public :: ii integer(kind=int32), public :: ij integer(kind=int32), public :: il integer(kind=int32), public :: j1ptmp integer(kind=int32), public :: j1tmp integer(kind=int32), public :: l1 integer(kind=int32), public :: nil integer(kind=int32), public :: omegaptmp integer(kind=int32), public :: omegatmp Source Code subroutine check_nonzero_coupling_matrix_elements ( number_of_channels , & channels_level_indices , channels_omega_values , & number_of_nonzero_coupling_matrix_elements , & number_of_nonzero_coupling_coefficients ) !! checks the number of non-zero coupling matrix elements due to !! the \\bar{\\Omega} = \\bar{\\Omega}' condition !! (number_of_nonzero_coupling_matrix_elements variable), !! and the total number of non-zero algebraic coefficients that enter !! Eqs. (6.13)-(6.15) (number_of_nonzero_coupling_coefficients variable). !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: number_of_channels !! size of the basis integer ( int32 ), intent ( in ) :: channels_level_indices ( number_of_channels ) !! holds the indices pointing to the basis arrays integer ( int32 ), intent ( in ) :: channels_omega_values ( number_of_channels ) !! holds all values of \\bar{\\Omega} integer ( int32 ), intent ( out ) :: number_of_nonzero_coupling_matrix_elements !! number of non-zero terms in the sum () for each non-zero element of the coupling matrix integer ( int32 ), intent ( out ) :: number_of_nonzero_coupling_coefficients !! number of all non-zero algberaix coefficients in the whole coupling matrix !---------------------------------------------------------------------! integer ( int32 ) :: count_nonzero_coupling_matrix_elements , & count_nonzero_coupling_coefficients , nil , j1tmp , j1ptmp , omegatmp , & omegaptmp , l1 , ii , ij , il !---------------------------------------------------------------------! count_nonzero_coupling_coefficients = 0 count_nonzero_coupling_matrix_elements = 0 do ii = 1 , number_of_channels j1tmp = j1array ( channels_level_indices ( ii )) omegatmp = channels_omega_values ( ii ) do ij = 1 , ii j1ptmp = j1array ( channels_level_indices ( ij )) omegaptmp = channels_omega_values ( ij ) if ( omegatmp . ne . omegaptmp ) cycle count_nonzero_coupling_matrix_elements = & count_nonzero_coupling_matrix_elements + 1 do il = 1 , nterms l1 = l1tab ( il ) if ( triangle_inequality_holds ( j1tmp , j1ptmp , l1 ). eq . 0 ) cycle if ( is_sum_even ( j1tmp , j1ptmp , l1 ). eq . 0 ) cycle count_nonzero_coupling_coefficients = & count_nonzero_coupling_coefficients + 1 enddo enddo enddo !---------------------------------------------------------------------! number_of_nonzero_coupling_coefficients = count_nonzero_coupling_coefficients number_of_nonzero_coupling_matrix_elements = count_nonzero_coupling_matrix_elements !---------------------------------------------------------------------! end subroutine check_nonzero_coupling_matrix_elements","tags":"","loc":"proc/check_nonzero_coupling_matrix_elements.html"},{"title":"prepare_coupling_matrix_elements – the SCATTERING code","text":"public  subroutine prepare_coupling_matrix_elements(number_of_channels, channels_level_indices, channels_omega_values, number_of_nonzero_coupling_matrix_elements, number_of_nonzero_coupling_coefficients, nonzero_terms_per_element, nonzero_legendre_indices, nonzero_coupling_coefficients) -- nonzero_terms_per_element - keeps the number of\n   non-zero terms in the sum (Eq. (6.21)) for each non-zero matrix\n   element of the coupling matrix\n-- nonzero_legendre_indices - holds the proper\n   indices in the range (0, nterms) pointing to l1/l2/lltabs, which\n   correspond to the non-vanishing elements of the sum (Eq. (6.21))\n   for each non-zero  matrix element of the coupling matrix\n-- nonzero_coupling_coefficients --  holds values of non-zero Percival-Seaton coefficients Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: number_of_channels size of the basis integer(kind=int32), intent(in) :: channels_level_indices (number_of_channels) holds the indices pointing to the basis arrays integer(kind=int32), intent(in) :: channels_omega_values (number_of_channels) holds all values of \\bar{\\Omega} integer(kind=int32), intent(in) :: number_of_nonzero_coupling_matrix_elements number of non-zero terms in the sum () for each non-zero element of the coupling matrix integer(kind=int32), intent(in) :: number_of_nonzero_coupling_coefficients number of all non-zero algberaix coefficients in the whole coupling matrix integer(kind=int32), intent(inout) :: nonzero_terms_per_element (number_of_nonzero_coupling_matrix_elements) keeps the number of non-zero terms in the sum (Eq. (6.21)) for\neach non-zero element of the coupling matrix integer(kind=int32), intent(inout) :: nonzero_legendre_indices (number_of_nonzero_coupling_coefficients) holds proper indices pointing to l1tab, which\ncorrespond to the non-vanishing elements of the sum  (Eq. (6.21))\nfor each non-zero element of the coupling matrix real(kind=dp), intent(inout) :: nonzero_coupling_coefficients (number_of_nonzero_coupling_coefficients) holds the values of the non-zero algebraic coefficients Calls proc~~prepare_coupling_matrix_elements~~CallsGraph proc~prepare_coupling_matrix_elements prepare_coupling_matrix_elements proc~triangle_inequality_holds triangle_inequality_holds proc~prepare_coupling_matrix_elements->proc~triangle_inequality_holds fwig3jj fwig3jj proc~prepare_coupling_matrix_elements->fwig3jj proc~is_sum_even is_sum_even proc~prepare_coupling_matrix_elements->proc~is_sum_even Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~prepare_coupling_matrix_elements~~CalledByGraph proc~prepare_coupling_matrix_elements prepare_coupling_matrix_elements program~scattering SCATTERING program~scattering->proc~prepare_coupling_matrix_elements Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables count_nonzero_coupling_coefficients count_nonzero_coupling_matrix_elements ii ij il j1ptmp j1tmp l1 nonzero_legendre omegaptmp omegatmp pscoeff Source Code prepare_coupling_matrix_elements Variables Type Visibility Attributes Name Initial integer(kind=int32), public :: count_nonzero_coupling_coefficients integer(kind=int32), public :: count_nonzero_coupling_matrix_elements integer(kind=int32), public :: ii integer(kind=int32), public :: ij integer(kind=int32), public :: il integer(kind=int32), public :: j1ptmp integer(kind=int32), public :: j1tmp integer(kind=int32), public :: l1 integer(kind=int32), public :: nonzero_legendre integer(kind=int32), public :: omegaptmp integer(kind=int32), public :: omegatmp real(kind=dp), public :: pscoeff Source Code subroutine prepare_coupling_matrix_elements ( number_of_channels , & channels_level_indices , channels_omega_values , & number_of_nonzero_coupling_matrix_elements , & number_of_nonzero_coupling_coefficients , & nonzero_terms_per_element , nonzero_legendre_indices , & nonzero_coupling_coefficients ) !! prepares: !! -- nonzero_terms_per_element - keeps the number of !!    non-zero terms in the sum (Eq. (6.21)) for each non-zero matrix !!    element of the coupling matrix !! -- nonzero_legendre_indices - holds the proper !!    indices in the range (0, nterms) pointing to l1/l2/lltabs, which !!    correspond to the non-vanishing elements of the sum (Eq. (6.21)) !!    for each non-zero  matrix element of the coupling matrix !! -- nonzero_coupling_coefficients --  holds values of non-zero Percival-Seaton coefficients !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: number_of_channels !! size of the basis integer ( int32 ), intent ( in ) :: channels_level_indices ( number_of_channels ) !! holds the indices pointing to the basis arrays integer ( int32 ), intent ( in ) :: channels_omega_values ( number_of_channels ) !! holds all values of \\bar{\\Omega} integer ( int32 ), intent ( in ) :: number_of_nonzero_coupling_matrix_elements !! number of non-zero terms in the sum () for each non-zero element of the coupling matrix integer ( int32 ), intent ( in ) :: number_of_nonzero_coupling_coefficients !! number of all non-zero algberaix coefficients in the whole coupling matrix integer ( int32 ), intent ( inout ) :: & nonzero_terms_per_element ( number_of_nonzero_coupling_matrix_elements ) !! keeps the number of non-zero terms in the sum (Eq. (6.21)) for !! each non-zero element of the coupling matrix integer ( int32 ), intent ( inout ) :: & nonzero_legendre_indices ( number_of_nonzero_coupling_coefficients ) !! holds proper indices pointing to l1tab, which !! correspond to the non-vanishing elements of the sum  (Eq. (6.21)) !! for each non-zero element of the coupling matrix real ( dp ), intent ( inout ) :: & nonzero_coupling_coefficients ( number_of_nonzero_coupling_coefficients ) !! holds the values of the non-zero algebraic coefficients !---------------------------------------------------------------------! integer ( int32 ) :: count_nonzero_coupling_matrix_elements , & count_nonzero_coupling_coefficients , nonzero_legendre , j1tmp , & j1ptmp , omegatmp , omegaptmp , l1 , ii , ij , il real ( dp ) :: pscoeff !---------------------------------------------------------------------! nonzero_terms_per_element = 0 nonzero_legendre_indices = 0 nonzero_coupling_coefficients = 0 count_nonzero_coupling_coefficients = 0 count_nonzero_coupling_matrix_elements = 0 !---------------------------------------------------------------------! do ii = 1 , number_of_channels j1tmp = j1array ( channels_level_indices ( ii )) omegatmp = channels_omega_values ( ii ) do ij = 1 , ii j1ptmp = j1array ( channels_level_indices ( ij )) omegaptmp = channels_omega_values ( ij ) if ( omegatmp . ne . omegaptmp ) cycle !---------------------------------------------------------------! ! passed \\bar{\\Omega} = \\bar{\\Omega}' condition !---------------------------------------------------------------! count_nonzero_coupling_matrix_elements = & count_nonzero_coupling_matrix_elements + 1 !---------------------------------------------------------------! ! count non-zero terms in the sum over legendre polynomials ! for this element !---------------------------------------------------------------! nonzero_legendre = 0 do il = 1 , nterms l1 = l1tab ( il ) if ( triangle_inequality_holds ( j1tmp , j1ptmp , l1 ). eq . 0 ) cycle if ( is_sum_even ( j1tmp , j1ptmp , l1 ). eq . 0 ) cycle !------------------------------------------------------------! ! passed non-zero conditions !------------------------------------------------------------! count_nonzero_coupling_coefficients = & count_nonzero_coupling_coefficients + 1 !------------------------------------------------------------! ! calculate the Percival-Seaton coefficient !------------------------------------------------------------! pscoeff = dsqrt ( real (( 2 * j1tmp + 1 ) * ( 2 * j1ptmp + 1 ), dp ))& * fwig3jj ( 2 * j1tmp , 2 * j1ptmp , 2 * l1 , 0 , 0 , 0 ) & * fwig3jj ( 2 * j1tmp , 2 * j1ptmp , 2 * l1 , & 2 * omegatmp , - 2 * omegatmp , 0 ) & * ( - 1.0_dp ) ** ( omegatmp ) !------------------------------------------------------------! nonzero_coupling_coefficients ( & count_nonzero_coupling_coefficients ) = pscoeff nonzero_legendre_indices ( count_nonzero_coupling_coefficients )& = il nonzero_legendre = nonzero_legendre + 1 enddo nonzero_terms_per_element ( count_nonzero_coupling_matrix_elements )& = nonzero_legendre enddo enddo !---------------------------------------------------------------------! end subroutine prepare_coupling_matrix_elements","tags":"","loc":"proc/prepare_coupling_matrix_elements.html"},{"title":"print_coupling_matrix_elements_summary – the SCATTERING code","text":"public  subroutine print_coupling_matrix_elements_summary(number_of_channels, number_of_nonzero_coupling_matrix_elements, number_of_nonzero_coupling_coefficients) print a shor summary on the number of non-zero matrix elements\nof the coupling matrix Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: number_of_channels size of the basis integer(kind=int32), intent(in) :: number_of_nonzero_coupling_matrix_elements number of non-zero terms in the sum () for each non-zero element\nof the coupling matrix integer(kind=int32), intent(in) :: number_of_nonzero_coupling_coefficients number of all non-zero algberaix coefficients in the whole\ncoupling matrix Calls proc~~print_coupling_matrix_elements_summary~~CallsGraph proc~print_coupling_matrix_elements_summary print_coupling_matrix_elements_summary proc~write_message write_message proc~print_coupling_matrix_elements_summary->proc~write_message proc~integer_to_character integer_to_character proc~print_coupling_matrix_elements_summary->proc~integer_to_character Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~print_coupling_matrix_elements_summary~~CalledByGraph proc~print_coupling_matrix_elements_summary print_coupling_matrix_elements_summary program~scattering SCATTERING program~scattering->proc~print_coupling_matrix_elements_summary Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code print_coupling_matrix_elements_summary Source Code subroutine print_coupling_matrix_elements_summary ( number_of_channels , & number_of_nonzero_coupling_matrix_elements , & number_of_nonzero_coupling_coefficients ) !! print a shor summary on the number of non-zero matrix elements !! of the coupling matrix !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: number_of_channels !! size of the basis integer ( int32 ), intent ( in ) :: number_of_nonzero_coupling_matrix_elements !! number of non-zero terms in the sum () for each non-zero element !! of the coupling matrix integer ( int32 ), intent ( in ) :: number_of_nonzero_coupling_coefficients !! number of all non-zero algberaix coefficients in the whole !! coupling matrix !---------------------------------------------------------------------! call write_message ( repeat ( \"*\" , 90 )) call write_message ( repeat ( \" \" , 5 ) // \"Size of the coupling matrix: \" // & integer_to_character ( number_of_channels )) call write_message ( repeat ( \" \" , 5 ) // \"Number of non-zero elements \" // & \"of the potential matrix: \" // integer_to_character ( & number_of_nonzero_coupling_matrix_elements )) call write_message ( repeat ( \" \" , 5 ) // \"Number of non-zero elements \" // & \" of the coupling matrix: \" // integer_to_character ( & number_of_nonzero_coupling_coefficients )) call write_message ( repeat ( '*' , 90 )) !---------------------------------------------------------------------! end subroutine print_coupling_matrix_elements_summary","tags":"","loc":"proc/print_coupling_matrix_elements_summary.html"},{"title":"CROSSSECTION – the SCATTERING code","text":"public  subroutine CROSSSECTION(jj, nopen, number_of_channels, number_of_open_basis_levels, open_basis_levels, open_basis_wavevectors, srmatrix, simatrix, channels_level_indices, channels_l_values, xs_array) calculate the state-to-state cross-section Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: jj total angular momentum integer(kind=int32), intent(in) :: nopen number of open channels integer(kind=int32), intent(in) :: number_of_channels size of the basis integer(kind=int32), intent(in) :: number_of_open_basis_levels number of all possible state-to-state XS integer(kind=int32), intent(in) :: open_basis_levels (number_of_open_basis_levels) holds indices to the basis arrays which correspond to open channels real(kind=dp), intent(in) :: open_basis_wavevectors (number_of_open_basis_levels) holds wavenumbers k_{i} real(kind=dp), intent(in) :: srmatrix (nopen,nopen) real and imaginary parts of the S-matrix real(kind=dp), intent(in) :: simatrix (nopen,nopen) real and imaginary parts of the S-matrix integer(kind=int32), intent(in) :: channels_level_indices (number_of_channels) holds the indices pointing to the basis arrays integer(kind=int32), intent(in) :: channels_l_values (number_of_channels) holds all values of l real(kind=dp), intent(inout) :: xs_array (number_of_open_basis_levels*number_of_open_basis_levels) array holding all XSs Calls proc~~crosssection~~CallsGraph proc~crosssection CROSSSECTION interface~allocate_1d allocate_1d proc~crosssection->interface~allocate_1d proc~time_count_summary time_count_summary proc~crosssection->proc~time_count_summary proc~write_message write_message proc~time_count_summary->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~crosssection~~CalledByGraph proc~crosssection CROSSSECTION program~scattering SCATTERING program~scattering->proc~crosssection Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables ifin ii iinit il ilp ioccur1 ioccur2 j1lev j1plev jblockarr jfin jinit jpblockarr lptmp ltmp njoccur njpoccur teli telr telsq time_finish time_start v1lev v1plev waveinit xs_time xssum Variables Type Visibility Attributes Name Initial integer(kind=int32), public :: ifin integer(kind=int32), public :: ii integer(kind=int32), public :: iinit integer(kind=int32), public :: il integer(kind=int32), public :: ilp integer(kind=int32), public :: ioccur1 integer(kind=int32), public :: ioccur2 integer(kind=int32), public :: j1lev integer(kind=int32), public :: j1plev integer(kind=int32), public, allocatable :: jblockarr (:) integer(kind=int32), public :: jfin integer(kind=int32), public :: jinit integer(kind=int32), public, allocatable :: jpblockarr (:) integer(kind=int32), public :: lptmp integer(kind=int32), public :: ltmp integer(kind=int32), public :: njoccur integer(kind=int32), public :: njpoccur real(kind=dp), public :: teli real(kind=dp), public :: telr real(kind=dp), public :: telsq real(kind=dp), public :: time_finish real(kind=dp), public :: time_start integer(kind=int32), public :: v1lev integer(kind=int32), public :: v1plev real(kind=dp), public :: waveinit real(kind=dp), public :: xs_time real(kind=dp), public :: xssum","tags":"","loc":"proc/crosssection.html"},{"title":"check_dtol_otol – the SCATTERING code","text":"public  subroutine check_dtol_otol(maxXSdiag, maxXSoff, ncacdiag, ncacoff, terminate) check if the dtol/otol condition on partial XS is already fulfilled Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: maxXSdiag largest elastic and inelastic XS real(kind=dp), intent(in) :: maxXSoff largest elastic and inelastic XS integer(kind=int32), intent(inout) :: ncacdiag number of consecutive blocks for which dtol/otol condition is already\nfulfilled. Gets incremented within the subroutine integer(kind=int32), intent(inout) :: ncacoff number of consecutive blocks for which dtol/otol condition is already\nfulfilled. Gets incremented within the subroutine logical, intent(inout) :: terminate if .true. the dtol/otol condition is fulfilled;\nJ-tot loop is terminated Called by proc~~check_dtol_otol~~CalledByGraph proc~check_dtol_otol check_dtol_otol program~scattering SCATTERING program~scattering->proc~check_dtol_otol Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables diagcontr icount icount2 offcontr Source Code check_dtol_otol Variables Type Visibility Attributes Name Initial logical, public :: diagcontr integer(kind=int32), public :: icount integer(kind=int32), public :: icount2 logical, public :: offcontr Source Code subroutine check_dtol_otol ( maxXSdiag , maxXSoff , ncacdiag , ncacoff , terminate ) !! check if the dtol/otol condition on partial XS is already fulfilled !---------------------------------------------------------------------------! real ( dp ), intent ( in ) :: maxXSdiag , maxXSoff !! largest elastic and inelastic XS integer ( int32 ), intent ( inout ) :: ncacdiag , ncacoff !! number of consecutive blocks for which dtol/otol condition is already !! fulfilled. Gets incremented within the subroutine logical , intent ( inout ) :: terminate !! if .true. the dtol/otol condition is fulfilled; !! J-tot loop is terminated !---------------------------------------------------------------------------! integer ( int32 ) :: icount , icount2 logical :: diagcontr , offcontr !---------------------------------------------------------------------------! terminate = . false . !---------------------------------------------------------------------------! ! diagcontr and offcontr check if dtol and otol are fulfilled, respectively !---------------------------------------------------------------------------! diagcontr = . false . offcontr = . false . !---------------------------------------------------------------------------! if ( maxXSdiag . le . dtol ) diagcontr = . true . if ( maxXSoff . le . otol ) offcontr = . true . !---------------------------------------------------------------------------! if ( diagcontr ) then ncacdiag = ncacdiag + 1 else ncacdiag = 0 endif !------------------------------------------------------------------------------! if ( offcontr ) then ncacoff = ncacoff + 1 else ncacoff = 0 endif !------------------------------------------------------------------------------! ! Finish the calculations if both contributions are smaller than the limits:   ! !------------------------------------------------------------------------------! if (( ncacdiag . ge . ncac ). and .( ncacoff . ge . ncac )) terminate = . true . !------------------------------------------------------------------------------! end subroutine check_dtol_otol","tags":"","loc":"proc/check_dtol_otol.html"},{"title":"print_largest_partial_xs – the SCATTERING code","text":"public  subroutine print_largest_partial_xs(jj, maxXSdiag, maxXSoff, jinddiag, jindoff1, jindoff2, number_of_open_basis_levels, open_basis_levels) print the largest partial elastic and inelastic state-to-state XS\nin given J-block Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: jj total angular momentum real(kind=dp), intent(in) :: maxXSdiag the largest partial elastic state-to-state XS in this J-block real(kind=dp), intent(in) :: maxXSoff the largest partial inelastic state-to-state XS in this J-block integer(kind=int32), intent(in) :: jinddiag index pointing indirectly to quantum numbers associated with\nthe largest partial elastic state-to-state XS in this J-block integer(kind=int32), intent(in) :: jindoff1 indices pointing indirectly to quantum numbers associated with\nthe largest partial inelastic state-to-state XS in this J-block integer(kind=int32), intent(in) :: jindoff2 indices pointing indirectly to quantum numbers associated with\nthe largest partial inelastic state-to-state XS in this J-block integer(kind=int32), intent(in) :: number_of_open_basis_levels number of all possible state-to-state XS (size of open_basis_levels array) integer(kind=int32), intent(in) :: open_basis_levels (number_of_open_basis_levels) holds indices to the basis arrays which correspond to open channels Calls proc~~print_largest_partial_xs~~CallsGraph proc~print_largest_partial_xs print_largest_partial_xs proc~integer_to_character integer_to_character proc~print_largest_partial_xs->proc~integer_to_character proc~write_message write_message proc~print_largest_partial_xs->proc~write_message proc~float_to_character float_to_character proc~print_largest_partial_xs->proc~float_to_character Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~print_largest_partial_xs~~CalledByGraph proc~print_largest_partial_xs print_largest_partial_xs program~scattering SCATTERING program~scattering->proc~print_largest_partial_xs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables header_line line Source Code print_largest_partial_xs Variables Type Visibility Attributes Name Initial character(len=200), public :: header_line character(len=200), public :: line Source Code subroutine print_largest_partial_xs ( jj , maxXSdiag , maxXSoff , jinddiag , jindoff1 , & jindoff2 , number_of_open_basis_levels , open_basis_levels ) !! print the largest partial elastic and inelastic state-to-state XS !! in given J-block !---------------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: jj !! total angular momentum real ( dp ), intent ( in ) :: maxXSdiag !! the largest partial elastic state-to-state XS in this J-block real ( dp ), intent ( in ) :: maxXSoff !! the largest partial inelastic state-to-state XS in this J-block integer ( int32 ), intent ( in ) :: jinddiag !! index pointing indirectly to quantum numbers associated with !! the largest partial elastic state-to-state XS in this J-block integer ( int32 ), intent ( in ) :: jindoff1 , jindoff2 !! indices pointing indirectly to quantum numbers associated with !! the largest partial inelastic state-to-state XS in this J-block integer ( int32 ), intent ( in ) :: number_of_open_basis_levels !! number of all possible state-to-state XS (size of open_basis_levels array) integer ( int32 ), intent ( in ) :: open_basis_levels ( number_of_open_basis_levels ) !! holds indices to the basis arrays which correspond to open channels !---------------------------------------------------------------------------! character ( len = 200 ) :: header_line , line !---------------------------------------------------------------------------! if (( prntlvl . eq . 1 ). or .( prntlvl . eq . 2 )) then call write_message ( \"Largest partial elastic state-to-state for JTOT = \" // & trim ( adjustl ( integer_to_character ( jj ))) // \": \" // & trim ( adjustl ( float_to_character ( maxXSdiag )))) call write_message ( \"Largest partial inelastic state-to-state for JTOT = \" // & trim ( adjustl ( integer_to_character ( jj ))) // \": \" // & trim ( adjustl ( float_to_character ( maxXSoff )))) call write_message ( repeat ( \" \" , 43 ) // \"***\" ) else if ( prntlvl . ge . 3 ) then !------------------------------------------------------------------------! call write_message ( \"Largest partial elastic state-to-state for JTOT = \" // & integer_to_character ( jj ) ) write ( header_line , \"(2x,a4,2x,a4,2x,a2,2x,a4,2x,a4,16x,a2)\" ) \"v1_f\" , & \"j1_f\" , \"<-\" , \"v1_i\" , \"j1_i\" , \"XS\" call write_message ( header_line ) write ( line , \"(2X,I4,2X,I4,6X,I4,2X,I4,2X,E16.8)\" ) & v1array ( open_basis_levels ( jinddiag )), j1array ( open_basis_levels ( jinddiag )), & v1array ( open_basis_levels ( jinddiag )), j1array ( open_basis_levels ( jinddiag )), maxXSdiag call write_message ( line ) !------------------------------------------------------------------------! call write_message ( \"Largest partial inelastic state-to-state for JTOT = \" // & integer_to_character ( jj ) ) call write_message ( header_line ) write ( line , \"(2X,I4,2X,I4,6X,I4,2X,I4,2X,E16.8)\" ) & v1array ( open_basis_levels ( jindoff2 )), j1array ( open_basis_levels ( jindoff2 )), & v1array ( open_basis_levels ( jindoff1 )), j1array ( open_basis_levels ( jindoff1 )), maxXSoff call write_message ( line ) call write_message ( repeat ( \" \" , 43 ) // \"***\" ) !------------------------------------------------------------------------! endif end subroutine print_largest_partial_xs","tags":"","loc":"proc/print_largest_partial_xs.html"},{"title":"p_coeff – the SCATTERING code","text":"public  function p_coeff(jtot_, j_, l_, omega_) result(p_coeff_) calculates the P coefficients from Eq. (6.19) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: jtot_ total angular momentum integer(kind=int32), intent(in) :: j_ rotational quantum number integer(kind=int32), intent(in) :: l_ orbital angular momentum integer(kind=int32), intent(in) :: omega_ projection of j on the BF-Z axis Return Value real(kind=dp) result (...) Calls proc~~p_coeff~~CallsGraph proc~p_coeff p_coeff fwig3jj fwig3jj proc~p_coeff->fwig3jj Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~p_coeff~~CalledByGraph proc~p_coeff p_coeff proc~transform_summation transform_summation proc~transform_summation->proc~p_coeff proc~bf_to_sf_transformation bf_to_sf_transformation proc~bf_to_sf_transformation->proc~transform_summation program~scattering SCATTERING program~scattering->proc~bf_to_sf_transformation Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables delta_ Source Code p_coeff Variables Type Visibility Attributes Name Initial real(kind=dp), public :: delta_ Source Code function p_coeff ( jtot_ , j_ , l_ , omega_ ) result ( p_coeff_ ) !! calculates the P coefficients from Eq. (6.19) !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: jtot_ !! total angular momentum integer ( int32 ), intent ( in ) :: j_ !! rotational quantum number integer ( int32 ), intent ( in ) :: l_ !! orbital angular momentum integer ( int32 ), intent ( in ) :: omega_ !! projection of j on the BF-Z axis real ( dp ) :: p_coeff_ !! result (...) !---------------------------------------------------------------------! real ( dp ) :: delta_ !---------------------------------------------------------------------! delta_ = 0.d0 if ( omega_ == 0 ) delta_ = 1.0_dp p_coeff_ = ( - 1.0_dp ) ** ( jtot_ + omega_ ) * dsqrt ( 2.0_dp ) & * dsqrt ( real ( 2 * l_ + 1 , dp )) * fwig3jj ( 2 * j_ , 2 * jtot_ , 2 * l_ , & 2 * omega_ , - 2 * omega_ , 0 ) / dsqrt ( 1.0_dp + delta_ ) !---------------------------------------------------------------------! end function p_coeff","tags":"","loc":"proc/p_coeff.html"},{"title":"bf_to_sf_transformation – the SCATTERING code","text":"public  subroutine bf_to_sf_transformation(number_of_channels, jtot_, channels_level_indices, channels_omega_values, channels_l_values, bf_matrix, sf_matrix) takes an input matrix in the BF-frame and transforms it to\nthe SF-frame; calls transsum and pfunc Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: number_of_channels size of the basis integer(kind=int32), intent(in) :: jtot_ total angular momentum integer(kind=int32), intent(in) :: channels_level_indices (number_of_channels) holds the indices pointing to the basis arrays integer(kind=int32), intent(in) :: channels_omega_values (number_of_channels) holds all values of \\bar{\\Omega} integer(kind=int32), intent(in) :: channels_l_values (number_of_channels) holds all values of l real(kind=dp), intent(in) :: bf_matrix (number_of_channels,number_of_channels) matrix in the BF frame real(kind=dp), intent(inout) :: sf_matrix (number_of_channels,number_of_channels) (output) matrix in the SF frame Calls proc~~bf_to_sf_transformation~~CallsGraph proc~bf_to_sf_transformation bf_to_sf_transformation proc~transform_summation transform_summation proc~bf_to_sf_transformation->proc~transform_summation proc~p_coeff p_coeff proc~transform_summation->proc~p_coeff fwig3jj fwig3jj proc~p_coeff->fwig3jj Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~bf_to_sf_transformation~~CalledByGraph proc~bf_to_sf_transformation bf_to_sf_transformation program~scattering SCATTERING program~scattering->proc~bf_to_sf_transformation Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables coeff ii ij j1_ j1p_ l_ lp_ omega_ omegap_ sf_result v1_ v1p_ Source Code bf_to_sf_transformation Variables Type Visibility Attributes Name Initial real(kind=dp), public :: coeff integer(kind=int32), public :: ii integer(kind=int32), public :: ij integer(kind=int32), public :: j1_ integer(kind=int32), public :: j1p_ integer(kind=int32), public :: l_ integer(kind=int32), public :: lp_ integer(kind=int32), public :: omega_ integer(kind=int32), public :: omegap_ real(kind=dp), public :: sf_result integer(kind=int32), public :: v1_ integer(kind=int32), public :: v1p_ Source Code subroutine bf_to_sf_transformation ( number_of_channels , jtot_ , & channels_level_indices , channels_omega_values , channels_l_values , & bf_matrix , sf_matrix ) !! takes an input matrix in the BF-frame and transforms it to !! the SF-frame; calls transsum and pfunc !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: number_of_channels !! size of the basis integer ( int32 ), intent ( in ) :: jtot_ !! total angular momentum integer ( int32 ), intent ( in ) :: channels_level_indices ( number_of_channels ) !! holds the indices pointing to the basis arrays integer ( int32 ), intent ( in ) :: channels_omega_values ( number_of_channels ) !! holds all values of \\bar{\\Omega} integer ( int32 ), intent ( in ) :: channels_l_values ( number_of_channels ) !! holds all values of l real ( dp ), intent ( in ) :: bf_matrix ( number_of_channels , number_of_channels ) !! matrix in the BF frame real ( dp ), intent ( inout ) :: sf_matrix ( number_of_channels , number_of_channels ) !! (output) matrix in the SF frame !---------------------------------------------------------------------! integer ( int32 ) :: l_ , lp_ , omega_ , omegap_ , v1_ , j1_ , v1p_ , j1p_ , ii , ij real ( dp ) :: coeff , sf_result !---------------------------------------------------------------------! do ii = 1 , number_of_channels v1_ = v1array ( channels_level_indices ( ii )) j1_ = j1array ( channels_level_indices ( ii )) l_ = channels_l_values ( ii ) do ij = 1 , number_of_channels v1p_ = v1array ( channels_level_indices ( ij )) j1p_ = j1array ( channels_level_indices ( ij )) lp_ = channels_l_values ( ij ) call transform_summation ( number_of_channels , jtot_ , v1_ , j1_ , v1p_ , j1p_ , & l_ , lp_ , channels_level_indices , channels_omega_values , & bf_matrix , sf_result ) sf_matrix ( ii , ij ) = sf_result enddo enddo !---------------------------------------------------------------------! end subroutine bf_to_sf_transformation","tags":"","loc":"proc/bf_to_sf_transformation.html"},{"title":"calculate_k_matrix – the SCATTERING code","text":"public  subroutine calculate_k_matrix(number_of_channels, log_der_matrix, number_of_open_channels, channels_level_indices, channels_l_values, r_, k_matrix) implementation of Eq. 6.53 Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: number_of_channels y-matrix is of number_of_channels x number_of_channels size real(kind=dp), intent(in) :: log_der_matrix (number_of_channels,number_of_channels) asymptotic log-derivative matrix integer(kind=int32), intent(in) :: number_of_open_channels number of open channels integer(kind=int32), intent(in) :: channels_level_indices (number_of_channels) holds the indices pointing to the basis arrays integer(kind=int32), intent(in) :: channels_l_values (number_of_channels) holds all values of l real(kind=dp), intent(in) :: r_ Rmax real(kind=dp), intent(inout) :: k_matrix (number_of_open_channels,number_of_open_channels) K-matrix Calls proc~~calculate_k_matrix~~CallsGraph proc~calculate_k_matrix calculate_k_matrix proc~etotal ETOTAL proc~calculate_k_matrix->proc~etotal proc~modified_bessel_k_ratio modified_bessel_k_ratio proc~calculate_k_matrix->proc~modified_bessel_k_ratio proc~riccati_bessel_y riccati_bessel_y proc~calculate_k_matrix->proc~riccati_bessel_y dgesv dgesv proc~calculate_k_matrix->dgesv dgemm dgemm proc~calculate_k_matrix->dgemm proc~riccati_bessel_j riccati_bessel_j proc~calculate_k_matrix->proc~riccati_bessel_j proc~ikv ikv proc~modified_bessel_k_ratio->proc~ikv proc~write_warning write_warning proc~modified_bessel_k_ratio->proc~write_warning proc~integer_to_character integer_to_character proc~modified_bessel_k_ratio->proc~integer_to_character proc~riccati_bessel_y->proc~write_warning proc~riccati_bessel_y->proc~integer_to_character proc~rcty rcty proc~riccati_bessel_y->proc~rcty proc~rctj rctj proc~riccati_bessel_j->proc~rctj proc~riccati_bessel_j->proc~write_warning proc~riccati_bessel_j->proc~integer_to_character proc~msta1 msta1 proc~ikv->proc~msta1 proc~msta2 msta2 proc~ikv->proc~msta2 proc~rctj->proc~msta1 proc~rctj->proc~msta2 proc~write_message write_message proc~write_warning->proc~write_message proc~envj envj proc~msta1->proc~envj proc~msta2->proc~envj Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~calculate_k_matrix~~CalledByGraph proc~calculate_k_matrix calculate_k_matrix program~scattering SCATTERING program~scattering->proc~calculate_k_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables closed_channels_indices diag_j_matrix diag_jp_matrix diag_n_matrix diag_np_matrix iclosed ii index_closed index_open iopen iopen2 j_element_ jp_element_ n_element_ np_element_ open_channels_indices ratio status_ wavenumber x Source Code calculate_k_matrix Variables Type Visibility Attributes Name Initial integer(kind=int32), public :: closed_channels_indices (number_of_channels-number_of_open_channels) real(kind=dp), public :: diag_j_matrix (number_of_channels,number_of_open_channels) real(kind=dp), public :: diag_jp_matrix (number_of_channels,number_of_open_channels) real(kind=dp), public :: diag_n_matrix (number_of_channels,number_of_channels) real(kind=dp), public :: diag_np_matrix (number_of_channels,number_of_channels) integer(kind=int32), public :: iclosed integer(kind=int32), public :: ii integer(kind=int32), public :: index_closed integer(kind=int32), public :: index_open integer(kind=int32), public :: iopen integer(kind=int32), public :: iopen2 real(kind=dp), public :: j_element_ real(kind=dp), public :: jp_element_ real(kind=dp), public :: n_element_ real(kind=dp), public :: np_element_ integer(kind=int32), public :: open_channels_indices (number_of_open_channels) real(kind=dp), public :: ratio integer(kind=int32), public :: status_ real(kind=dp), public :: wavenumber real(kind=dp), public :: x Source Code subroutine calculate_k_matrix ( number_of_channels , log_der_matrix , & number_of_open_channels , channels_level_indices , channels_l_values , & r_ , k_matrix ) !! implementation of Eq. 6.53 !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: number_of_channels !! y-matrix is of number_of_channels x number_of_channels size real ( dp ), intent ( in ) :: log_der_matrix ( number_of_channels , number_of_channels ) !! asymptotic log-derivative matrix integer ( int32 ), intent ( in ) :: number_of_open_channels !! number of open channels integer ( int32 ), intent ( in ) :: channels_level_indices ( number_of_channels ) !! holds the indices pointing to the basis arrays integer ( int32 ), intent ( in ) :: channels_l_values ( number_of_channels ) !! holds all values of l real ( dp ), intent ( in ) :: r_ !! Rmax real ( dp ), intent ( inout ) :: k_matrix ( number_of_open_channels , number_of_open_channels ) !! K-matrix !---------------------------------------------------------------------! integer ( int32 ) :: index_open , index_closed , ii , iopen , iopen2 , & iclosed , status_ real ( dp ) :: wavenumber , x , j_element_ , jp_element_ , n_element_ , & np_element_ , ratio integer ( int32 ) :: open_channels_indices ( number_of_open_channels ) integer ( int32 ) :: closed_channels_indices ( number_of_channels - number_of_open_channels ) real ( dp ) :: diag_n_matrix ( number_of_channels , number_of_channels ), & diag_np_matrix ( number_of_channels , number_of_channels ), & diag_j_matrix ( number_of_channels , number_of_open_channels ), & diag_jp_matrix ( number_of_channels , number_of_open_channels ) !---------------------------------------------------------------------! ! diag_j_matrix   -  diagonal J matrix (Eqs. 6.37 & 6.39) ! diag_jp_matrix  -  diagonal J`matrix (derivative of J) ! diag_n_matrix   -  diagonal N matrix (Eqs. 6.30 & 6.40) ! diag_np_matrix  -  diagonal N`matrix (derivative of N) !---------------------------------------------------------------------! diag_j_matrix = 0 diag_jp_matrix = 0 diag_n_matrix = 0 diag_np_matrix = 0 !---------------------------------------------------------------------! index_open = 0 index_closed = 0 !---------------------------------------------------------------------! ! save indices to open and closed channels !---------------------------------------------------------------------! do ii = 1 , number_of_channels if ( elevel ( channels_level_indices ( ii )). le . ETOTAL ()) then index_open = index_open + 1 open_channels_indices ( index_open ) = ii else index_closed = index_closed + 1 closed_channels_indices ( index_closed ) = ii endif enddo !---------------------------------------------------------------------! ! Prepare J, J', N and N' matrices ! open channels: !---------------------------------------------------------------------! do iopen = 1 , number_of_open_channels wavenumber = dsqrt ( 2 * reducedmass * ( ETOTAL ()& - elevel ( channels_level_indices ( open_channels_indices ( iopen ))))) x = wavenumber * r_ call riccati_bessel_j ( channels_l_values ( open_channels_indices ( iopen )),& x , j_element_ , jp_element_ ) diag_j_matrix ( iopen , iopen ) = ( wavenumber ) ** ( - 0.5d0 ) * j_element_ diag_jp_matrix ( iopen , iopen ) = ( wavenumber ) ** ( 0.5d0 ) * jp_element_ call riccati_bessel_y ( channels_l_values ( open_channels_indices ( iopen )),& x , n_element_ , np_element_ ) diag_n_matrix ( iopen , iopen ) = ( wavenumber ) ** ( - 0.5d0 ) * n_element_ diag_np_matrix ( iopen , iopen ) = ( wavenumber ) ** ( 0.5d0 ) * np_element_ enddo !---------------------------------------------------------------------! ! Prepare J, J', N and N' matrices ! closed channels: !---------------------------------------------------------------------! do iclosed = 1 , number_of_channels - number_of_open_channels wavenumber = dsqrt ( dabs ( 2 * reducedmass * ( ETOTAL ()& - elevel ( channels_level_indices ( closed_channels_indices ( iclosed )))))) x = wavenumber * r_ call modified_bessel_k_ratio ( channels_l_values ( closed_channels_indices ( iclosed )), x , ratio ) !------------------------------------------------------------------! ! substitution for closed channels, (Eqs. 6.44 - 6.45) !------------------------------------------------------------------! diag_n_matrix ( number_of_open_channels + iclosed , number_of_open_channels + iclosed ) = 1.d0 diag_np_matrix ( number_of_open_channels + iclosed , number_of_open_channels + iclosed ) = ( wavenumber ) * ratio enddo !---------------------------------------------------------------------! call DGEMM ( 'N' , 'N' , number_of_channels , number_of_channels , & number_of_channels , 1.0d0 , log_der_matrix , number_of_channels , diag_n_matrix , & number_of_channels , - 1.d0 , diag_np_matrix , number_of_channels ) call DGEMM ( 'N' , 'N' , number_of_channels , number_of_open_channels , & number_of_channels , - 1.0d0 , log_der_matrix , number_of_channels , diag_j_matrix , & number_of_channels , 1.d0 , diag_jp_matrix , number_of_channels ) !---------------------------------------------------------------------! call DGESV ( number_of_channels , number_of_open_channels , diag_np_matrix , & number_of_channels , diag_j_matrix , diag_jp_matrix , number_of_channels , status_ ) !---------------------------------------------------------------------! do iopen = 1 , number_of_open_channels do iopen2 = 1 , number_of_open_channels k_matrix ( iopen , iopen2 ) = diag_jp_matrix ( iopen , iopen2 ) enddo enddo !---------------------------------------------------------------------! end subroutine calculate_k_matrix","tags":"","loc":"proc/calculate_k_matrix.html"},{"title":"calculate_s_matrix – the SCATTERING code","text":"public  subroutine calculate_s_matrix(number_of_open_channels, k_matrix, s_matrix_real, s_matrix_imag) implementation of Eq. 6.57 Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: number_of_open_channels number of open channels real(kind=dp), intent(in) :: k_matrix (number_of_open_channels,number_of_open_channels) K-matrix real(kind=dp), intent(inout) :: s_matrix_real (number_of_open_channels,number_of_open_channels) (output) real part of the S-matrix real(kind=dp), intent(inout) :: s_matrix_imag (number_of_open_channels,number_of_open_channels) (output) imaginary part of the S-matrix Calls proc~~calculate_s_matrix~~CallsGraph proc~calculate_s_matrix calculate_s_matrix dgemm dgemm proc~calculate_s_matrix->dgemm interface~invert_symmetric_matrix invert_symmetric_matrix proc~calculate_s_matrix->interface~invert_symmetric_matrix interface~fill_symmetric_matrix fill_symmetric_matrix proc~calculate_s_matrix->interface~fill_symmetric_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~calculate_s_matrix~~CalledByGraph proc~calculate_s_matrix calculate_s_matrix program~scattering SCATTERING program~scattering->proc~calculate_s_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables iopen iopen2 s_tmp_matrix Source Code calculate_s_matrix Variables Type Visibility Attributes Name Initial integer(kind=int32), public :: iopen integer(kind=int32), public :: iopen2 real(kind=dp), public :: s_tmp_matrix (number_of_open_channels,number_of_open_channels) Source Code subroutine calculate_s_matrix ( number_of_open_channels , k_matrix , & s_matrix_real , s_matrix_imag ) !! implementation of Eq. 6.57 !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: number_of_open_channels !! number of open channels real ( dp ), intent ( in ) :: k_matrix ( number_of_open_channels , number_of_open_channels ) !! K-matrix real ( dp ), intent ( inout ) :: s_matrix_real ( number_of_open_channels , number_of_open_channels ) !! (output) real part of the S-matrix real ( dp ), intent ( inout ) :: s_matrix_imag ( number_of_open_channels , number_of_open_channels ) !! (output) imaginary part of the S-matrix !---------------------------------------------------------------------! integer ( int32 ) :: iopen , iopen2 real ( dp ) :: s_tmp_matrix ( number_of_open_channels , number_of_open_channels ) !---------------------------------------------------------------------! s_matrix_real = 0 s_matrix_imag = 0 !---------------------------------------------------------------------! call DGEMM ( 'N' , 'N' , number_of_open_channels , number_of_open_channels , & number_of_open_channels , 0.5d0 , k_matrix , number_of_open_channels , & k_matrix , number_of_open_channels , 0.d0 , s_tmp_matrix , number_of_open_channels ) do iopen = 1 , number_of_open_channels s_tmp_matrix ( iopen , iopen ) = s_tmp_matrix ( iopen , iopen ) + 0.5d0 enddo call invert_symmetric_matrix ( s_tmp_matrix ) call fill_symmetric_matrix ( s_tmp_matrix , 'u' ) call DGEMM ( 'N' , 'N' , number_of_open_channels , number_of_open_channels , & number_of_open_channels , - 1.0d0 , s_tmp_matrix , number_of_open_channels ,& k_matrix , number_of_open_channels , 0.d0 , s_matrix_imag , number_of_open_channels ) do iopen = 1 , number_of_open_channels do iopen2 = 1 , number_of_open_channels s_matrix_real ( iopen , iopen2 ) = s_tmp_matrix ( iopen , iopen2 ) enddo s_matrix_real ( iopen , iopen ) = s_matrix_real ( iopen , iopen ) - 1.d0 enddo !------------------------------------------------------------------------! end subroutine calculate_s_matrix","tags":"","loc":"proc/calculate_s_matrix.html"},{"title":"transform_summation – the SCATTERING code","text":"public  subroutine transform_summation(number_of_channels, jtot_, v_, j_, vp_, jp_, l_, lp_, channels_level_indices, channels_omega_values, bf_matrix, sf_element) performs the summation in Eqs. (6.17) and (6.18) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: number_of_channels size of the basis integer(kind=int32), intent(in) :: jtot_ total angular momentum integer(kind=int32), intent(in) :: v_ vibrational and rotational quantum numbers integer(kind=int32), intent(in) :: j_ vibrational and rotational quantum numbers integer(kind=int32), intent(in) :: vp_ vibrational and rotational quantum numbers integer(kind=int32), intent(in) :: jp_ vibrational and rotational quantum numbers integer(kind=int32), intent(in) :: l_ orbital angular momenta integer(kind=int32), intent(in) :: lp_ orbital angular momenta integer(kind=int32), intent(in) :: channels_level_indices (number_of_channels) holds the indices pointing to the basis arrays integer(kind=int32), intent(in) :: channels_omega_values (number_of_channels) holds all values of \\bar{\\Omega} real(kind=dp), intent(in) :: bf_matrix (number_of_channels,number_of_channels) matrix in the BF frame real(kind=dp), intent(out) :: sf_element (output) matrix element in the SF frame Calls proc~~transform_summation~~CallsGraph proc~transform_summation transform_summation proc~p_coeff p_coeff proc~transform_summation->proc~p_coeff fwig3jj fwig3jj proc~p_coeff->fwig3jj Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~transform_summation~~CalledByGraph proc~transform_summation transform_summation proc~bf_to_sf_transformation bf_to_sf_transformation proc~bf_to_sf_transformation->proc~transform_summation program~scattering SCATTERING program~scattering->proc~bf_to_sf_transformation Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables coeff_inner coeff_outer ii ij j1ptmp j1tmp omptmp omtmp sum_inner sum_outer v1ptmp v1tmp Source Code transform_summation Variables Type Visibility Attributes Name Initial real(kind=dp), public :: coeff_inner real(kind=dp), public :: coeff_outer integer(kind=int32), public :: ii integer(kind=int32), public :: ij integer(kind=int32), public :: j1ptmp integer(kind=int32), public :: j1tmp integer(kind=int32), public :: omptmp integer(kind=int32), public :: omtmp real(kind=dp), public :: sum_inner real(kind=dp), public :: sum_outer integer(kind=int32), public :: v1ptmp integer(kind=int32), public :: v1tmp Source Code subroutine transform_summation ( number_of_channels , jtot_ , v_ , j_ , vp_ , & jp_ , l_ , lp_ , channels_level_indices , channels_omega_values , & bf_matrix , sf_element ) !! performs the summation in Eqs. (6.17) and (6.18) !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: number_of_channels !! size of the basis integer ( int32 ), intent ( in ) :: jtot_ !! total angular momentum integer ( int32 ), intent ( in ) :: v_ , j_ , vp_ , jp_ !! vibrational and rotational quantum numbers integer ( int32 ), intent ( in ) :: l_ , lp_ !! orbital angular momenta integer ( int32 ), intent ( in ) :: channels_level_indices ( number_of_channels ) !! holds the indices pointing to the basis arrays integer ( int32 ), intent ( in ) :: channels_omega_values ( number_of_channels ) !! holds all values of \\bar{\\Omega} real ( dp ), intent ( in ) :: bf_matrix ( number_of_channels , number_of_channels ) !! matrix in the BF frame real ( dp ), intent ( out ) :: sf_element !! (output) matrix element in the SF frame !---------------------------------------------------------------------! integer ( int32 ) :: ii , ij , omtmp , omptmp , v1tmp , j1tmp , v1ptmp , j1ptmp real ( dp ) :: coeff_outer , coeff_inner , sum_outer , sum_inner !---------------------------------------------------------------------! sum_outer = 0.0_dp do ii = 1 , number_of_channels if ( v1array ( channels_level_indices ( ii )) /= v_ . or . & j1array ( channels_level_indices ( ii )) /= j_ ) cycle coeff_outer = p_coeff ( jtot_ , j_ , l_ , channels_omega_values ( ii )) sum_inner = 0.0_dp do ij = 1 , number_of_channels if ( v1array ( channels_level_indices ( ij )) /= vp_ . or . & j1array ( channels_level_indices ( ij )) /= jp_ ) cycle coeff_inner = p_coeff ( jtot_ , jp_ , lp_ , channels_omega_values ( ij )) sum_inner = sum_inner + coeff_inner * bf_matrix ( ii , ij ) end do sum_outer = sum_outer + coeff_outer * sum_inner end do sf_element = sum_outer !---------------------------------------------------------------------! end subroutine transform_summation","tags":"","loc":"proc/transform_summation.html"},{"title":"unitarity_check – the SCATTERING code","text":"public  subroutine unitarity_check(number_of_open_channels, s_matrix_real, s_matrix_imag, totalcheck) checks the unitarity of the S-matrix (Eq. 6.15) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: number_of_open_channels number of open channels real(kind=dp), intent(in) :: s_matrix_real (number_of_open_channels,number_of_open_channels) real part of the S-matrix real(kind=dp), intent(in) :: s_matrix_imag (number_of_open_channels,number_of_open_channels) imaginary part of the S-matrix logical, intent(inout) :: totalcheck (output) if .true. unitary is fulfilled, .false. otherwise Calls proc~~unitarity_check~~CallsGraph proc~unitarity_check unitarity_check proc~write_message write_message proc~unitarity_check->proc~write_message proc~write_warning write_warning proc~unitarity_check->proc~write_warning proc~write_warning->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~unitarity_check~~CalledByGraph proc~unitarity_check unitarity_check program~scattering SCATTERING program~scattering->proc~unitarity_check Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables iopen iopen2 line_ unitary_tol unitarycheck unitarychecktmp Source Code unitarity_check Variables Type Visibility Attributes Name Initial integer(kind=int32), public :: iopen integer(kind=int32), public :: iopen2 character(len=200), public :: line_ real(kind=dp), public :: unitary_tol real(kind=dp), public :: unitarycheck (number_of_open_channels) real(kind=dp), public :: unitarychecktmp Source Code subroutine unitarity_check ( number_of_open_channels , s_matrix_real , & s_matrix_imag , totalcheck ) !! checks the unitarity of the S-matrix (Eq. 6.15) !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: number_of_open_channels !! number of open channels real ( dp ), intent ( in ) :: s_matrix_real ( number_of_open_channels , number_of_open_channels ) !! real part of the S-matrix real ( dp ), intent ( in ) :: s_matrix_imag ( number_of_open_channels , number_of_open_channels ) !! imaginary part of the S-matrix logical , intent ( inout ) :: totalcheck !! (output) if .true. unitary is fulfilled, .false. otherwise !---------------------------------------------------------------------! character ( len = 200 ) :: line_ integer ( int32 ) :: iopen , iopen2 real ( dp ) :: unitarychecktmp , unitary_tol real ( dp ) :: unitarycheck ( number_of_open_channels ) !---------------------------------------------------------------------! totalcheck = . true . unitary_tol = 1e-6_dp !---------------------------------------------------------------------! if ( prntlvl . ge . 4 ) then call write_message ( \"Check of the unitarity of the S-matrix:\" ) call write_message ( repeat ( \" \" , 34 ) // \"*** S-matrix elements: ***\" ) call write_message ( \"   ROW   COL\" // repeat ( \" \" , 15 ) // \"S**2\" // & repeat ( \" \" , 17 ) // \"RE (S)\" // repeat ( \" \" , 17 ) // \"IM (S)\" ) endif !---------------------------------------------------------------------! do iopen = 1 , number_of_open_channels unitarychecktmp = 0.0_dp do iopen2 = 1 , number_of_open_channels unitarychecktmp = unitarychecktmp + & s_matrix_real ( iopen , iopen2 ) ** 2. + s_matrix_imag ( iopen , iopen2 ) ** 2. !---------------------------------------------------------------! if ( prntlvl . ge . 4 ) then write ( line_ , \"(1X,I5,1X,I5,8X,E15.8,8X,E15.8,8X,E15.8)\" ) & iopen , iopen2 , s_matrix_real ( iopen , iopen2 ) ** 2. + s_matrix_imag ( iopen , iopen2 ) ** 2. , & s_matrix_real ( iopen , iopen2 ), s_matrix_imag ( iopen , iopen2 ) call write_message ( line_ ) endif !---------------------------------------------------------------! enddo unitarycheck ( iopen ) = unitarychecktmp enddo !---------------------------------------------------------------------! do iopen = 1 , number_of_open_channels if ( dabs ( unitarycheck ( iopen ) - 1.d0 ). gt . unitary_tol ) then call write_warning ( \"Unitary condition is not fulfilled for channel no.\" ) write ( line_ , \"(1X,I5,8X,E15.8)\" ) iopen , unitarycheck ( iopen ) call write_message ( trim ( adjustl ( line_ ))) call write_message ( \"Consider increasing the STEPS parameter\" ) totalcheck = . false . endif enddo if ( prntlvl . ge . 4 ) then call write_message ( repeat ( \" \" , 43 ) // \"***\" ) call write_message ( \"Check of the unitarity of the S-matrix:\" ) call write_message ( \"   ROW\" // repeat ( \" \" , 12 ) // \"sum(S**2)\" ) do iopen = 1 , number_of_open_channels write ( line_ , \"(1X,I5,8X,E15.8)\" ) iopen , unitarycheck ( iopen ) call write_message ( trim ( adjustl ( line_ ))) enddo call write_message ( repeat ( \" \" , 43 ) // \"***\" ) endif !---------------------------------------------------------------------! end subroutine unitarity_check","tags":"","loc":"proc/unitarity_check.html"},{"title":"RADTERMVALUE – the SCATTERING code","text":"public  subroutine RADTERMVALUE(rr, l1, v1, j1, v1p, j1p, v) returns the value of a specific radial coupling term at rr Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: rr intermolecular distance integer(kind=int32), intent(in) :: l1 Legendre expansion index integer(kind=int32), intent(in) :: v1 rovibrational quantum numbers integer(kind=int32), intent(in) :: j1 rovibrational quantum numbers integer(kind=int32), intent(in) :: v1p rovibrational quantum numbers integer(kind=int32), intent(in) :: j1p rovibrational quantum numbers real(kind=dp), intent(out) :: v value of the radial coupling coefficient Calls proc~~radtermvalue~~CallsGraph proc~radtermvalue RADTERMVALUE proc~integer_to_character integer_to_character proc~radtermvalue->proc~integer_to_character proc~ispline ispline proc~radtermvalue->proc~ispline proc~write_error write_error proc~radtermvalue->proc~write_error proc~float_to_character float_to_character proc~ispline->proc~float_to_character proc~write_warning write_warning proc~ispline->proc~write_warning proc~write_message write_message proc~write_error->proc~write_message proc~write_warning->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~radtermvalue~~CalledByGraph proc~radtermvalue RADTERMVALUE proc~pes_contribution pes_contribution proc~pes_contribution->proc~radtermvalue proc~numerov numerov proc~numerov->proc~pes_contribution program~scattering SCATTERING program~scattering->proc~numerov Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables icoupl il indl indl2 rrcurr Variables Type Visibility Attributes Name Initial integer(kind=int32), public :: icoupl integer(kind=int32), public :: il integer(kind=int32), public :: indl integer(kind=int32), public :: indl2 real(kind=dp), public :: rrcurr","tags":"","loc":"proc/radtermvalue.html"},{"title":"calculate_log_der_matrix – the SCATTERING code","text":"public  subroutine calculate_log_der_matrix(h, y_dim, tt_min, tt_n, tt_plus, r_n, r_plus, log_der_matrix) calculates the log-derivative matrix from Eq. (6.29)\ncalled by numerov and log_derivative at the end of the propagation Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: h step of the propagation integer(kind=int32), intent(in) :: y_dim dimension of the log-derivative matrix real(kind=dp), intent(in) :: tt_min (y_dim,y_dim) T-matrix at R_{max - 1} real(kind=dp), intent(in) :: tt_n (y_dim,y_dim) T-matrix at R_{max} real(kind=dp), intent(in) :: tt_plus (y_dim,y_dim) T-matrix at R_{max + 1} real(kind=dp), intent(in) :: r_n (y_dim,y_dim) R-matrix at R_{max} real(kind=dp), intent(in) :: r_plus (y_dim,y_dim) R-matrix at R_{max + 1} real(kind=dp), intent(inout) :: log_der_matrix (y_dim,y_dim) log-derivative matrix Calls proc~~calculate_log_der_matrix~~CallsGraph proc~calculate_log_der_matrix calculate_log_der_matrix interface~invert_symmetric_matrix invert_symmetric_matrix proc~calculate_log_der_matrix->interface~invert_symmetric_matrix dgemm dgemm proc~calculate_log_der_matrix->dgemm interface~fill_symmetric_matrix fill_symmetric_matrix proc~calculate_log_der_matrix->interface~fill_symmetric_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~calculate_log_der_matrix~~CalledByGraph proc~calculate_log_der_matrix calculate_log_der_matrix proc~numerov numerov proc~numerov->proc~calculate_log_der_matrix program~scattering SCATTERING program~scattering->proc~numerov Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables a ab abc b bra c d de def e f g i j Source Code calculate_log_der_matrix Variables Type Visibility Attributes Name Initial real(kind=dp), public :: a (y_dim,y_dim) real(kind=dp), public :: ab (y_dim,y_dim) real(kind=dp), public :: abc (y_dim,y_dim) real(kind=dp), public :: b (y_dim,y_dim) real(kind=dp), public :: bra (y_dim,y_dim) real(kind=dp), public :: c (y_dim,y_dim) real(kind=dp), public :: d (y_dim,y_dim) real(kind=dp), public :: de (y_dim,y_dim) real(kind=dp), public :: def (y_dim,y_dim) real(kind=dp), public :: e (y_dim,y_dim) real(kind=dp), public :: f (y_dim,y_dim) real(kind=dp), public :: g (y_dim,y_dim) integer(kind=int32), public :: i integer(kind=int32), public :: j Source Code subroutine calculate_log_der_matrix ( h , y_dim , tt_min , tt_n , tt_plus , r_n , r_plus , log_der_matrix ) !! calculates the log-derivative matrix from Eq. (6.29) !! called by numerov and log_derivative at the end of the propagation !---------------------------------------------------------------------! real ( dp ), intent ( in ) :: h !! step of the propagation integer ( int32 ), intent ( in ) :: y_dim !! dimension of the log-derivative matrix real ( dp ), intent ( in ) :: tt_min ( y_dim , y_dim ) !! T-matrix at R_{max - 1} real ( dp ), intent ( in ) :: tt_n ( y_dim , y_dim ) !! T-matrix at R_{max} real ( dp ), intent ( in ) :: tt_plus ( y_dim , y_dim ) !! T-matrix at R_{max + 1} real ( dp ), intent ( in ) :: r_n ( y_dim , y_dim ) !! R-matrix at R_{max} real ( dp ), intent ( in ) :: r_plus ( y_dim , y_dim ) !! R-matrix at R_{max + 1} real ( dp ), intent ( inout ) :: log_der_matrix ( y_dim , y_dim ) !! log-derivative matrix !---------------------------------------------------------------------! integer ( int32 ) :: i , j real ( dp ) :: a ( y_dim , y_dim ), b ( y_dim , y_dim ), c ( y_dim , y_dim ), & d ( y_dim , y_dim ), e ( y_dim , y_dim ), f ( y_dim , y_dim ), g ( y_dim , y_dim ), & ab ( y_dim , y_dim ), abc ( y_dim , y_dim ), de ( y_dim , y_dim ), & def ( y_dim , y_dim ), bra ( y_dim , y_dim ) !---------------------------------------------------------------------! log_der_matrix = 0 !---------------------------------------------------------------------! do i = 1 , y_dim do j = 1 , y_dim a ( i , j ) = - tt_plus ( i , j ) b ( i , j ) = - tt_plus ( i , j ) c ( i , j ) = r_plus ( i , j ) d ( i , j ) = - tt_min ( i , j ) e ( i , j ) = - tt_min ( i , j ) f ( i , j ) = r_n ( i , j ) g ( i , j ) = - tt_n ( i , j ) end do a ( i , i ) = 0.5 + a ( i , i ) b ( i , i ) = 1. + b ( i , i ) d ( i , i ) = 0.5 + d ( i , i ) e ( i , i ) = 1. + e ( i , i ) g ( i , i ) = 1. + g ( i , i ) end do !---------------------------------------------------------------------! call invert_symmetric_matrix ( b ) call fill_symmetric_matrix ( b , \"u\" ) call invert_symmetric_matrix ( e ) call fill_symmetric_matrix ( e , \"u\" ) call invert_symmetric_matrix ( f ) call fill_symmetric_matrix ( f , \"u\" ) !---------------------------------------------------------------------! CALL DGEMM ( 'N' , 'N' , y_dim , y_dim , y_dim , 1.0d0 ,& a , y_dim , b , y_dim , 0.d0 , ab , y_dim ) CALL DGEMM ( 'N' , 'N' , y_dim , y_dim , y_dim , 1.0d0 ,& ab , y_dim , c , y_dim , 0.d0 , abc , y_dim ) CALL DGEMM ( 'N' , 'N' , y_dim , y_dim , y_dim , 1.0d0 ,& d , y_dim , e , y_dim , 0.d0 , de , y_dim ) CALL DGEMM ( 'N' , 'N' , y_dim , y_dim , y_dim , 1.0d0 ,& de , y_dim , f , y_dim , 0.d0 , DEF , y_dim ) !----------------------------------------------------------------------! bra = abc - def !---------------------------------------------------------------------! CALL DGEMM ( 'N' , 'N' , y_dim , y_dim , y_dim , dble ( 1.d0 / h ), bra ,& y_dim , g , y_dim , 0.d0 , log_der_matrix , y_dim ) !---------------------------------------------------------------------! end subroutine calculate_log_der_matrix","tags":"","loc":"proc/calculate_log_der_matrix.html"},{"title":"cenitrfugal_matrix – the SCATTERING code","text":"public  subroutine cenitrfugal_matrix(number_of_channels, jj, channels_level_indices, channels_omega_values, centmatrix) calculates the (R* 2) centrifugal matrix from Eq. (6.19)\nonly called once at the beginning of the calculations Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: number_of_channels size of the basis integer(kind=int32), intent(in) :: jj total angular momentum integer(kind=int32), intent(in) :: channels_level_indices (number_of_channels) holds the indices pointing to the basis arrays integer(kind=int32), intent(in) :: channels_omega_values (number_of_channels) holds all values of \\bar{\\Omega} real(kind=dp), intent(out) :: centmatrix (number_of_channels,number_of_channels) (output) - (R* 2) centrifugal matrix Calls proc~~cenitrfugal_matrix~~CallsGraph proc~cenitrfugal_matrix cenitrfugal_matrix dfloat dfloat proc~cenitrfugal_matrix->dfloat interface~fill_symmetric_matrix fill_symmetric_matrix proc~cenitrfugal_matrix->interface~fill_symmetric_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~cenitrfugal_matrix~~CalledByGraph proc~cenitrfugal_matrix cenitrfugal_matrix proc~numerov numerov proc~numerov->proc~cenitrfugal_matrix program~scattering SCATTERING program~scattering->proc~numerov Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables centtmp delta1 delta2 ii ij j1ptmp j1tmp omegaptmp omegatmp v1ptmp v1tmp Variables Type Visibility Attributes Name Initial real(kind=dp), public :: centtmp real(kind=dp), public :: delta1 real(kind=dp), public :: delta2 integer(kind=int32), public :: ii integer(kind=int32), public :: ij integer(kind=int32), public :: j1ptmp integer(kind=int32), public :: j1tmp integer(kind=int32), public :: omegaptmp integer(kind=int32), public :: omegatmp integer(kind=int32), public :: v1ptmp integer(kind=int32), public :: v1tmp","tags":"","loc":"proc/cenitrfugal_matrix.html"},{"title":"numerov – the SCATTERING code","text":"public  subroutine numerov(channels_level_indices, channels_omega_values, number_of_nonzero_coupling_matrix_elements, number_of_nonzero_coupling_coefficients, nonzero_terms_per_element, nonzero_legendre_indices, nonzero_coupling_coefficients, nsteps, number_of_channels, jj, log_der_matrix) renormalized Numerov propagator Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: channels_level_indices (number_of_channels) holds the indices pointing to the basis arrays integer(kind=int32), intent(in) :: channels_omega_values (number_of_channels) holds all values of \\bar{\\Omega} integer(kind=int32), intent(in) :: number_of_nonzero_coupling_matrix_elements number of non-zero terms in the sum () for each non-zero element of the coupling matrix integer(kind=int32), intent(in) :: number_of_nonzero_coupling_coefficients number of all non-zero algberaix coefficients in the whole coupling matrix integer(kind=int32), intent(in) :: nonzero_terms_per_element (number_of_nonzero_coupling_matrix_elements) keeps the number of non-zero terms in the sum (Eq. (6.21)) for\neach non-zero element of W/V integer(kind=int32), intent(in) :: nonzero_legendre_indices (number_of_nonzero_coupling_coefficients) holds the proper indices pointing to l1/l2/lltabs, which\ncorrespond to the non-vanishing elements of the sum  (Eq. (6.21))\nfor each non-zero element of W/V real(kind=dp), intent(in) :: nonzero_coupling_coefficients (number_of_nonzero_coupling_coefficients) holds the values of the non-zero algebraic coefficients integer(kind=int32), intent(in) :: nsteps number of steps from rmin to rmax integer(kind=int32), intent(in) :: number_of_channels size of the basis integer(kind=int32), intent(in) :: jj total angular momentum real(kind=dp), intent(inout) :: log_der_matrix (:,:) resulting log-derivative matrix at RMAX Calls proc~~numerov~~CallsGraph proc~numerov numerov proc~etotal ETOTAL proc~numerov->proc~etotal proc~calculate_log_der_matrix calculate_log_der_matrix proc~numerov->proc~calculate_log_der_matrix proc~write_message write_message proc~numerov->proc~write_message proc~pes_contribution pes_contribution proc~numerov->proc~pes_contribution proc~cenitrfugal_matrix cenitrfugal_matrix proc~numerov->proc~cenitrfugal_matrix interface~allocate_2d allocate_2d proc~numerov->interface~allocate_2d interface~invert_symmetric_matrix invert_symmetric_matrix proc~numerov->interface~invert_symmetric_matrix interface~fill_symmetric_matrix fill_symmetric_matrix proc~numerov->interface~fill_symmetric_matrix proc~float_to_character float_to_character proc~numerov->proc~float_to_character proc~calculate_log_der_matrix->interface~invert_symmetric_matrix proc~calculate_log_der_matrix->interface~fill_symmetric_matrix dgemm dgemm proc~calculate_log_der_matrix->dgemm proc~pes_contribution->interface~fill_symmetric_matrix proc~radtermvalue RADTERMVALUE proc~pes_contribution->proc~radtermvalue proc~cenitrfugal_matrix->interface~fill_symmetric_matrix dfloat dfloat proc~cenitrfugal_matrix->dfloat proc~integer_to_character integer_to_character proc~radtermvalue->proc~integer_to_character proc~ispline ispline proc~radtermvalue->proc~ispline proc~write_error write_error proc~radtermvalue->proc~write_error proc~ispline->proc~float_to_character proc~write_warning write_warning proc~ispline->proc~write_warning proc~write_error->proc~write_message proc~write_warning->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~numerov~~CalledByGraph proc~numerov numerov program~scattering SCATTERING program~scattering->proc~numerov Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables cent_mat finish i ii ij r r_center r_plus r_temp rmatrix start step_numerov t_center t_mat t_minus t_plus u_left u_right umatrix v_mat v_tmp w_mat w_tmp Source Code numerov Variables Type Visibility Attributes Name Initial real(kind=dp), public, dimension(number_of_channels,number_of_channels) :: cent_mat real(kind=dp), public :: finish integer(kind=int32), public :: i integer(kind=int32), public :: ii integer(kind=int32), public :: ij real(kind=dp), public :: r real(kind=dp), public, allocatable, dimension(:,:) :: r_center real(kind=dp), public, allocatable, dimension(:,:) :: r_plus real(kind=dp), public, allocatable, dimension(:,:) :: r_temp real(kind=dp), public, allocatable, dimension(:,:) :: rmatrix real(kind=dp), public :: start real(kind=dp), public :: step_numerov real(kind=dp), public, allocatable, dimension(:,:) :: t_center real(kind=dp), public, dimension(number_of_channels,number_of_channels) :: t_mat real(kind=dp), public, allocatable, dimension(:,:) :: t_minus real(kind=dp), public, allocatable, dimension(:,:) :: t_plus real(kind=dp), public, dimension(number_of_channels,number_of_channels) :: u_left real(kind=dp), public, dimension(number_of_channels,number_of_channels) :: u_right real(kind=dp), public, allocatable, dimension(:,:) :: umatrix real(kind=dp), public, dimension(number_of_channels,number_of_channels) :: v_mat real(kind=dp), public, allocatable, dimension(:,:) :: v_tmp real(kind=dp), public, dimension(number_of_channels,number_of_channels) :: w_mat real(kind=dp), public, allocatable, dimension(:,:) :: w_tmp Source Code subroutine numerov ( channels_level_indices , channels_omega_values , & number_of_nonzero_coupling_matrix_elements , & number_of_nonzero_coupling_coefficients , nonzero_terms_per_element , & nonzero_legendre_indices , nonzero_coupling_coefficients , nsteps , & number_of_channels , jj , log_der_matrix ) !! renormalized Numerov propagator !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: number_of_channels !! size of the basis integer ( int32 ), intent ( in ) :: channels_level_indices ( number_of_channels ) !! holds the indices pointing to the basis arrays integer ( int32 ), intent ( in ) :: channels_omega_values ( number_of_channels ) !! holds all values of \\bar{\\Omega} integer ( int32 ), intent ( in ) :: number_of_nonzero_coupling_matrix_elements !! number of non-zero terms in the sum () for each non-zero element of the coupling matrix integer ( int32 ), intent ( in ) :: number_of_nonzero_coupling_coefficients !! number of all non-zero algberaix coefficients in the whole coupling matrix integer ( int32 ), intent ( in ) :: nonzero_terms_per_element ( number_of_nonzero_coupling_matrix_elements ) !! keeps the number of non-zero terms in the sum (Eq. (6.21)) for !! each non-zero element of W/V integer ( int32 ), intent ( in ) :: nonzero_legendre_indices ( number_of_nonzero_coupling_coefficients ) !! holds the proper indices pointing to l1/l2/lltabs, which !! correspond to the non-vanishing elements of the sum  (Eq. (6.21)) !! for each non-zero element of W/V real ( dp ), intent ( in ) :: nonzero_coupling_coefficients ( number_of_nonzero_coupling_coefficients ) !! holds the values of the non-zero algebraic coefficients integer ( int32 ), intent ( in ) :: nsteps !! number of steps from rmin to rmax integer ( int32 ), intent ( in ) :: jj !! total angular momentum real ( dp ), intent ( inout ) :: log_der_matrix (:,:) !! resulting log-derivative matrix at RMAX !---------------------------------------------------------------------! integer ( int32 ) :: i , ii , ij real ( dp ) :: start , finish , r , step_numerov real ( dp ), allocatable , dimension (:,:) :: umatrix , r_temp , rmatrix , & t_minus , t_center , t_plus , r_center , r_plus , w_tmp , v_tmp real ( dp ), dimension ( number_of_channels , number_of_channels ) :: & cent_mat , v_mat , w_mat , t_mat , u_left , u_right !---------------------------------------------------------------------! CALL CPU_TIME ( start ) !---------------------------------------------------------------------! ! Calculate the centrifugal term !---------------------------------------------------------------------! call cenitrfugal_matrix ( number_of_channels , jj , channels_level_indices , & channels_omega_values , cent_mat ) step_numerov = ( rmax - rmin ) / dble ( nsteps - 1 ) call allocate_2d ( R_temp , number_of_channels , number_of_channels ) !---------------------------------------------------------------------! ! Calculate the PES contribution at rmin !---------------------------------------------------------------------! call pes_contribution ( number_of_channels , jj , rmin , & channels_level_indices , channels_omega_values , & number_of_nonzero_coupling_matrix_elements , & number_of_nonzero_coupling_coefficients , & nonzero_terms_per_element , nonzero_legendre_indices , & nonzero_coupling_coefficients , v_mat ) !---------------------------------------------------------------------! ! Coupling matrix W at rmin !---------------------------------------------------------------------! w_mat = v_mat - ( 1. / rmin ** 2. ) * cent_mat !---------------------------------------------------------------------! ! T-matrix (Eq. 6.23) !---------------------------------------------------------------------! do ii = 1 , number_of_channels do ij = 1 , number_of_channels t_mat ( ii , ij ) = - (( step_numerov ** 2. ) / 1 2. ) * ( w_mat ( ii , ij )) enddo t_mat ( ii , ii ) = - (( step_numerov ** 2. ) / 1 2. ) * & ( 2 * reducedmass * ETOTAL ()) + t_mat ( ii , ii ) enddo !---------------------------------------------------------------------! ! U-matrix (Eq. 6.25) !---------------------------------------------------------------------! do ii = 1 , number_of_channels do ij = 1 , number_of_channels u_left ( ii , ij ) = - t_mat ( ii , ij ) end do u_left ( ii , ii ) = 1.d0 + u_left ( ii , ii ) end do call invert_symmetric_matrix ( u_left ) call fill_symmetric_matrix ( u_left , 'u' ) !---------------------------------------------------------------------! ! R-matrix at rmin + 1 = U-matrix at rmin !---------------------------------------------------------------------! do ii = 1 , number_of_channels do ij = 1 , number_of_channels r_temp ( ii , ij ) = 1 2.d0 * u_left ( ii , ij ) enddo r_temp ( ii , ii ) = r_temp ( ii , ii ) - 1 0.d0 enddo !---------------------------------------------------------------------! ! Continue the propagation to rmax !---------------------------------------------------------------------! do i = 2 , nsteps !------------------------------------------------------------------! ! Coupling matrix W at R !------------------------------------------------------------------! R = rmin + ( i - 1 ) * step_numerov call allocate_2d ( rmatrix , number_of_channels , number_of_channels ) call allocate_2d ( umatrix , number_of_channels , number_of_channels ) call pes_contribution ( number_of_channels , jj , R , & channels_level_indices , channels_omega_values , & number_of_nonzero_coupling_matrix_elements , & number_of_nonzero_coupling_coefficients , & nonzero_terms_per_element , nonzero_legendre_indices , & nonzero_coupling_coefficients , v_mat ) w_mat = v_mat - ( 1. / R ** 2. ) * cent_mat !------------------------------------------------------------------! ! T-matrix at R (6.18) !------------------------------------------------------------------! do ii = 1 , number_of_channels do ij = 1 , number_of_channels t_mat ( ii , ij ) = - (( step_numerov ** 2. ) / 1 2. ) * ( w_mat ( ii , ij )) enddo t_mat ( ii , ii ) = - (( step_numerov ** 2. ) / 1 2. ) * & ( 2 * reducedmass * ETOTAL ()) + t_mat ( ii , ii ) enddo !------------------------------------------------------------------! ! U-matrix at R (6.20) !------------------------------------------------------------------! do ii = 1 , number_of_channels do ij = 1 , number_of_channels u_left ( ii , ij ) = - t_mat ( ii , ij ) end do u_left ( ii , ii ) = 1.d0 + u_left ( ii , ii ) end do call invert_symmetric_matrix ( u_left ) call fill_symmetric_matrix ( u_left , 'u' ) do ii = 1 , number_of_channels do ij = 1 , number_of_channels umatrix ( ii , ij ) = 1 2.d0 * u_left ( ii , ij ) enddo umatrix ( ii , ii ) = umatrix ( ii , ii ) - 1 0.d0 enddo call invert_symmetric_matrix ( r_temp ) call fill_symmetric_matrix ( r_temp , 'u' ) !------------------------------------------------------------------! ! Prepare T at Rmax - 1 and R at Rmax !------------------------------------------------------------------! if ( i == nsteps - 1 ) then call allocate_2d ( v_tmp , number_of_channels , number_of_channels ) call allocate_2d ( w_tmp , number_of_channels , number_of_channels ) call allocate_2d ( t_minus , number_of_channels , number_of_channels ) call pes_contribution ( number_of_channels , jj , r , & channels_level_indices , channels_omega_values , & number_of_nonzero_coupling_matrix_elements , & number_of_nonzero_coupling_coefficients , & nonzero_terms_per_element , nonzero_legendre_indices , & nonzero_coupling_coefficients , v_tmp ) w_tmp = v_tmp - ( 1. / R ** 2. ) * cent_mat do ii = 1 , number_of_channels do ij = 1 , number_of_channels t_minus ( ii , ij ) = - (( step_numerov ** 2. ) / 1 2. ) * & ( w_tmp ( ii , ij )) enddo t_minus ( ii , ii ) = - (( step_numerov ** 2. ) / 1 2. ) * & ( 2 * reducedmass * ETOTAL ()) + t_minus ( ii , ii ) enddo call allocate_2d ( r_center , number_of_channels , number_of_channels ) r_center = umatrix - r_temp !---------------------------------------------------------------! ! Prepare T at Rmax and R max + 1, and R at Rmax + 1 !---------------------------------------------------------------! else if ( i == nsteps ) then call allocate_2d ( v_tmp , number_of_channels , number_of_channels ) call allocate_2d ( w_tmp , number_of_channels , number_of_channels ) call allocate_2d ( t_center , number_of_channels , number_of_channels ) call pes_contribution ( number_of_channels , jj , r , & channels_level_indices , channels_omega_values , & number_of_nonzero_coupling_matrix_elements , & number_of_nonzero_coupling_coefficients , & nonzero_terms_per_element , nonzero_legendre_indices , & nonzero_coupling_coefficients , v_tmp ) w_tmp = v_tmp - ( 1. / R ** 2. ) * cent_mat do ii = 1 , number_of_channels do ij = 1 , number_of_channels t_center ( ii , ij ) = - (( step_numerov ** 2. ) / 1 2. ) * & ( w_tmp ( ii , ij )) enddo t_center ( ii , ii ) = - (( step_numerov ** 2. ) / 1 2. ) * & ( 2 * reducedmass * ETOTAL ()) + t_center ( ii , ii ) enddo call allocate_2d ( r_plus , number_of_channels , number_of_channels ) r_plus = umatrix - r_temp r = rmax + step_numerov call allocate_2d ( v_tmp , number_of_channels , number_of_channels ) call allocate_2d ( t_plus , number_of_channels , number_of_channels ) call allocate_2d ( w_tmp , number_of_channels , number_of_channels ) call pes_contribution ( number_of_channels , jj , r , & channels_level_indices , channels_omega_values , & number_of_nonzero_coupling_matrix_elements , & number_of_nonzero_coupling_coefficients , & nonzero_terms_per_element , nonzero_legendre_indices , & nonzero_coupling_coefficients , v_tmp ) w_tmp = v_tmp - ( 1. / R ** 2. ) * cent_mat do ii = 1 , number_of_channels do ij = 1 , number_of_channels t_plus ( ii , ij ) = - (( step_numerov ** 2. ) / 1 2. ) * & ( w_tmp ( ii , ij )) enddo t_plus ( ii , ii ) = - (( step_numerov ** 2. ) / 1 2. ) * & ( 2 * reducedmass * ETOTAL ()) + t_plus ( ii , ii ) enddo end if !------------------------------------------------------------------! ! R-matrix at R_{n+1} (Eq. 6.28) !------------------------------------------------------------------! rmatrix = umatrix - r_temp call allocate_2d ( r_temp , number_of_channels , number_of_channels ) !------------------------------------------------------------------! ! Move R_{n+1} to R_{n} !------------------------------------------------------------------! r_temp = rmatrix end do CALL CPU_TIME ( finish ) !---------------------------------------------------------------------! ! Eq. (6.29) !---------------------------------------------------------------------! call calculate_log_der_matrix ( step_numerov , number_of_channels , & t_minus , t_center , t_plus , r_center , r_plus , log_der_matrix ) !---------------------------------------------------------------------! if ( prntlvl . ge . 2 ) then call write_message ( \"Numerov propagator took \" // & trim ( adjustl ( float_to_character ( finish - start , \"(E14.8)\" ))) // & \" seconds\" ) endif !---------------------------------------------------------------------! end subroutine numerov","tags":"","loc":"proc/numerov.html"},{"title":"pes_contribution – the SCATTERING code","text":"public  subroutine pes_contribution(number_of_channels, jj, r, channels_level_indices, channels_omega_values, number_of_nonzero_coupling_matrix_elements, number_of_nonzero_coupling_coefficients, nonzero_terms_per_element, nonzero_legendre_indices, nonzero_coupling_coefficients, vmatrix) calculates the contribution from the PES in (X) at given R Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: number_of_channels size of the basis integer(kind=int32), intent(in) :: jj total angular momentum real(kind=dp), intent(in) :: r intermolecular distance integer(kind=int32), intent(in) :: channels_level_indices (number_of_channels) holds the indices pointing to the basis arrays integer(kind=int32), intent(in) :: channels_omega_values (number_of_channels) holds all values of \\bar{\\Omega} integer(kind=int32), intent(in) :: number_of_nonzero_coupling_matrix_elements number of non-zero terms in the sum () for each non-zero element of the coupling matrix integer(kind=int32), intent(in) :: number_of_nonzero_coupling_coefficients number of all non-zero algberaix coefficients in the whole coupling matrix integer(kind=int32), intent(in) :: nonzero_terms_per_element (number_of_nonzero_coupling_matrix_elements) keeps the number of non-zero terms in the sum (Eq. (6.21)) for\neach non-zero element of W/V integer(kind=int32), intent(in) :: nonzero_legendre_indices (number_of_nonzero_coupling_coefficients) holds the proper indices pointing to l1/l2/lltabs, which\ncorrespond to the non-vanishing elements of the sum  (Eq. (6.21))\nfor each non-zero element of W/V real(kind=dp), intent(in) :: nonzero_coupling_coefficients (number_of_nonzero_coupling_coefficients) holds the values of the non-zero algebraic coefficients real(kind=dp), intent(out) :: vmatrix (number_of_channels,number_of_channels) (output) - the PES contribution to the coupling matrix Calls proc~~pes_contribution~~CallsGraph proc~pes_contribution pes_contribution proc~radtermvalue RADTERMVALUE proc~pes_contribution->proc~radtermvalue interface~fill_symmetric_matrix fill_symmetric_matrix proc~pes_contribution->interface~fill_symmetric_matrix proc~integer_to_character integer_to_character proc~radtermvalue->proc~integer_to_character proc~ispline ispline proc~radtermvalue->proc~ispline proc~write_error write_error proc~radtermvalue->proc~write_error proc~float_to_character float_to_character proc~ispline->proc~float_to_character proc~write_warning write_warning proc~ispline->proc~write_warning proc~write_message write_message proc~write_error->proc~write_message proc~write_warning->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~pes_contribution~~CalledByGraph proc~pes_contribution pes_contribution proc~numerov numerov proc~numerov->proc~pes_contribution program~scattering SCATTERING program~scattering->proc~numerov Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables erot ii ij il indvl inonzero_coupling_matrix_elements j1ptmp j1tmp l1 nonzerolam omegaptmp omegatmp pscoeff sumtemp v v1ptmp v1tmp Source Code pes_contribution Variables Type Visibility Attributes Name Initial real(kind=dp), public :: erot integer(kind=int32), public :: ii integer(kind=int32), public :: ij integer(kind=int32), public :: il integer(kind=int32), public :: indvl integer(kind=int32), public :: inonzero_coupling_matrix_elements integer(kind=int32), public :: j1ptmp integer(kind=int32), public :: j1tmp integer(kind=int32), public :: l1 integer(kind=int32), public :: nonzerolam integer(kind=int32), public :: omegaptmp integer(kind=int32), public :: omegatmp real(kind=dp), public :: pscoeff real(kind=dp), public :: sumtemp real(kind=dp), public :: v integer(kind=int32), public :: v1ptmp integer(kind=int32), public :: v1tmp Source Code subroutine pes_contribution ( number_of_channels , jj , r , & channels_level_indices , channels_omega_values , & number_of_nonzero_coupling_matrix_elements , & number_of_nonzero_coupling_coefficients , & nonzero_terms_per_element , nonzero_legendre_indices , & nonzero_coupling_coefficients , vmatrix ) !! calculates the contribution from the PES in (X) at given R !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: number_of_channels !! size of the basis integer ( int32 ), intent ( in ) :: jj !! total angular momentum real ( dp ), intent ( in ) :: r !! intermolecular distance integer ( int32 ), intent ( in ) :: channels_level_indices ( number_of_channels ) !! holds the indices pointing to the basis arrays integer ( int32 ), intent ( in ) :: channels_omega_values ( number_of_channels ) !! holds all values of \\bar{\\Omega} integer ( int32 ), intent ( in ) :: number_of_nonzero_coupling_matrix_elements !! number of non-zero terms in the sum () for each non-zero element of the coupling matrix integer ( int32 ), intent ( in ) :: number_of_nonzero_coupling_coefficients !! number of all non-zero algberaix coefficients in the whole coupling matrix integer ( int32 ), intent ( in ) :: nonzero_terms_per_element ( number_of_nonzero_coupling_matrix_elements ) !! keeps the number of non-zero terms in the sum (Eq. (6.21)) for !! each non-zero element of W/V integer ( int32 ), intent ( in ) :: nonzero_legendre_indices ( number_of_nonzero_coupling_coefficients ) !! holds the proper indices pointing to l1/l2/lltabs, which !! correspond to the non-vanishing elements of the sum  (Eq. (6.21)) !! for each non-zero element of W/V real ( dp ), intent ( in ) :: nonzero_coupling_coefficients ( number_of_nonzero_coupling_coefficients ) !! holds the values of the non-zero algebraic coefficients real ( dp ), intent ( out ) :: vmatrix ( number_of_channels , number_of_channels ) !! (output) - the PES contribution to the coupling matrix !---------------------------------------------------------------------! integer ( int32 ) :: indvl , inonzero_coupling_matrix_elements , omegatmp , omegaptmp , l1 , & nonzerolam , v1tmp , j1tmp , v1ptmp , j1ptmp , ii , ij , il real ( dp ) :: erot , sumtemp , pscoeff , v !---------------------------------------------------------------------! vmatrix = 0 indvl = 0 inonzero_coupling_matrix_elements = 0 !---------------------------------------------------------------------! do ii = 1 , number_of_channels v1tmp = v1array ( channels_level_indices ( ii )) j1tmp = j1array ( channels_level_indices ( ii )) omegatmp = channels_omega_values ( ii ) erot = elevel ( channels_level_indices ( ii )) do ij = 1 , ii v1ptmp = v1array ( channels_level_indices ( ij )) j1ptmp = j1array ( channels_level_indices ( ij )) omegaptmp = channels_omega_values ( ij ) if ( omegatmp . ne . omegaptmp ) cycle inonzero_coupling_matrix_elements = inonzero_coupling_matrix_elements + 1 nonzerolam = nonzero_terms_per_element ( inonzero_coupling_matrix_elements ) sumtemp = 0.d0 do il = 1 , nonzerolam indvl = indvl + 1 l1 = l1tab ( nonzero_legendre_indices ( indvl )) pscoeff = nonzero_coupling_coefficients ( indvl ) call RADTERMVALUE ( r , l1 , v1tmp , j1tmp , v1ptmp , j1ptmp , v ) sumtemp = sumtemp + pscoeff * v enddo vmatrix ( ii , ij ) = - 2 * reducedmass * sumtemp enddo vmatrix ( ii , ii ) = vmatrix ( ii , ii ) - ( 2 * reducedmass * erot ) enddo !---------------------------------------------------------------------! call fill_symmetric_matrix ( vmatrix , 'u' ) !---------------------------------------------------------------------! end subroutine pes_contribution","tags":"","loc":"proc/pes_contribution.html"},{"title":"float_to_character – the SCATTERING code","text":"public  function float_to_character(f, format_string) result(res) Converts a floating-point number to a character string. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: f input floating-point number character(len=*), intent(in), optional :: format_string Optional format string. Return Value character(len=64) Output character string. Called by proc~~float_to_character~~CalledByGraph proc~float_to_character float_to_character proc~ispline ispline proc~ispline->proc~float_to_character proc~print_largest_partial_xs print_largest_partial_xs proc~print_largest_partial_xs->proc~float_to_character program~scattering SCATTERING program~scattering->proc~float_to_character program~scattering->proc~print_largest_partial_xs proc~numerov numerov program~scattering->proc~numerov proc~potential_read potential_read program~scattering->proc~potential_read proc~read_input_file read_input_file program~scattering->proc~read_input_file proc~numerov->proc~float_to_character proc~pes_contribution pes_contribution proc~numerov->proc~pes_contribution proc~input_summary input_summary proc~input_summary->proc~float_to_character proc~potential_read->proc~float_to_character proc~radtermvalue RADTERMVALUE proc~radtermvalue->proc~ispline proc~read_input_file->proc~input_summary proc~pes_contribution->proc~radtermvalue Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code float_to_character Source Code function float_to_character ( f , format_string ) result ( res ) !! Converts a floating-point number to a character string. !---------------------------------------------------------------------! real ( dp ), intent ( in ) :: f !! input floating-point number character ( len =* ), intent ( in ), optional :: format_string !! Optional format string. character ( len = 64 ) :: res !! Output character string. !---------------------------------------------------------------------! character ( len = 32 ) :: default_format , user_format !---------------------------------------------------------------------! ! Default format: 6 decimal places !---------------------------------------------------------------------! default_format = '(F0.6)' !---------------------------------------------------------------------! if ( present ( format_string )) then user_format = trim ( format_string ) else user_format = default_format endif !---------------------------------------------------------------------! write ( res , user_format ) f res = adjustl ( res ) !---------------------------------------------------------------------! end function float_to_character","tags":"","loc":"proc/float_to_character.html"},{"title":"integer_to_character – the SCATTERING code","text":"public  function integer_to_character(i) result(res) transfers integer to a character Arguments Type Intent Optional Attributes Name integer, intent(in) :: i input integer Return Value character(len=32) output character Called by proc~~integer_to_character~~CalledByGraph proc~integer_to_character integer_to_character proc~input_check input_check proc~input_check->proc~integer_to_character proc~modified_bessel_k_ratio modified_bessel_k_ratio proc~modified_bessel_k_ratio->proc~integer_to_character proc~riccati_bessel_y riccati_bessel_y proc~riccati_bessel_y->proc~integer_to_character proc~potential_reduction potential_reduction proc~potential_reduction->proc~integer_to_character proc~print_coupling_matrix_elements_summary print_coupling_matrix_elements_summary proc~print_coupling_matrix_elements_summary->proc~integer_to_character proc~print_largest_partial_xs print_largest_partial_xs proc~print_largest_partial_xs->proc~integer_to_character program~scattering SCATTERING program~scattering->proc~integer_to_character program~scattering->proc~potential_reduction program~scattering->proc~print_coupling_matrix_elements_summary program~scattering->proc~print_largest_partial_xs proc~file_io_status file_io_status program~scattering->proc~file_io_status proc~potential_read potential_read program~scattering->proc~potential_read proc~read_input_file read_input_file program~scattering->proc~read_input_file proc~calculate_k_matrix calculate_k_matrix program~scattering->proc~calculate_k_matrix proc~potential_interpolation potential_interpolation program~scattering->proc~potential_interpolation proc~numerov numerov program~scattering->proc~numerov proc~input_summary input_summary proc~input_summary->proc~integer_to_character proc~riccati_bessel_j riccati_bessel_j proc~riccati_bessel_j->proc~integer_to_character proc~file_io_status->proc~integer_to_character proc~spline spline proc~spline->proc~integer_to_character proc~potential_read->proc~integer_to_character proc~potential_read->proc~file_io_status proc~radtermvalue RADTERMVALUE proc~radtermvalue->proc~integer_to_character proc~read_input_file->proc~input_check proc~read_input_file->proc~input_summary proc~read_input_file->proc~file_io_status proc~calculate_k_matrix->proc~modified_bessel_k_ratio proc~calculate_k_matrix->proc~riccati_bessel_y proc~calculate_k_matrix->proc~riccati_bessel_j proc~pes_contribution pes_contribution proc~pes_contribution->proc~radtermvalue proc~potential_interpolation->proc~spline proc~numerov->proc~pes_contribution Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code integer_to_character Source Code function integer_to_character ( i ) result ( res ) !! transfers integer to a character !---------------------------------------------------------------------! integer , intent ( in ) :: i !! input integer character ( len = 32 ) :: res !! output character !---------------------------------------------------------------------! write ( res , '(i0)' ) i res = adjustl ( res ) !---------------------------------------------------------------------! end function integer_to_character","tags":"","loc":"proc/integer_to_character.html"},{"title":"to_lowercase – the SCATTERING code","text":"public  function to_lowercase(str) result(low_str) forces lowercase on given string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str input string Return Value character(len=len) output (lowercase) string Contents Source Code to_lowercase Source Code function to_lowercase ( str ) result ( low_str ) !! forces lowercase on given string !---------------------------------------------------------------------! character ( len =* ), intent ( in ) :: str !! input string character ( len = len ( str )) :: low_str !! output (lowercase) string !---------------------------------------------------------------------! integer ( int32 ) :: i !---------------------------------------------------------------------! do i = 1 , len ( str ) low_str ( i : i ) = char_to_lowercase ( str ( i : i )) enddo !---------------------------------------------------------------------! end function to_lowercase","tags":"","loc":"proc/to_lowercase.html"},{"title":"alloc_status – the SCATTERING code","text":"public  subroutine alloc_status(istat_, message_, op_, unit_) check the status after allocation Arguments Type Intent Optional Attributes Name integer(kind=int32) :: istat_ result of stat=istat in (de)allocate character(len=*), intent(in) :: message_ a message to be written character(len=1), intent(in) :: op_ 'a' for allocation, 'd' for deallocation integer(kind=int32), intent(in), optional :: unit_ optional, unit where the message will be written Calls proc~~alloc_status~~CallsGraph proc~alloc_status alloc_status proc~write_error write_error proc~alloc_status->proc~write_error proc~write_message write_message proc~write_error->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code alloc_status Source Code subroutine alloc_status ( istat_ , message_ , op_ , unit_ ) !! check the status after allocation !---------------------------------------------------------------------! integer ( int32 ) :: istat_ !! result of stat=istat in (de)allocate character ( len = * ), intent ( in ) :: message_ !! a message to be written character ( len = 1 ), intent ( in ) :: op_ !! 'a' for allocation, 'd' for deallocation integer ( int32 ), optional , intent ( in ) :: unit_ !! optional, unit where the message will be written !---------------------------------------------------------------------! character ( len = :), allocatable :: add_prefix_ !---------------------------------------------------------------------! add_prefix_ = '' if ( istat_ /= 0 ) then select case ( op_ ) case ( 'a' ) add_prefix_ = 'memory allocation: ' // trim ( message_ ) case ( 'd' ) add_prefix_ = 'memory deallocation: ' // trim ( message_ ) case default call write_error & ( 'Incorrect op_ argument in alloc_status subroutine (' & // trim ( op_ ) // ')' ) end select call write_error ( add_prefix_ , unit_ ) endif !---------------------------------------------------------------------! end subroutine alloc_status","tags":"","loc":"proc/alloc_status.html"},{"title":"file_io_status – the SCATTERING code","text":"public  subroutine file_io_status(istat_, iomsg_, channel_, op_, unit_) check the status during various io operations on files Arguments Type Intent Optional Attributes Name integer(kind=int32) :: istat_ result of iostat in open/read/write/close character(len=*), intent(in) :: iomsg_ result of iomsg in open/read/write/close integer(kind=int32), intent(in) :: channel_ name of the file character(len=1), intent(in) :: op_ 'o' for opening of the file, 'r' for reading, 'w' for writing,\n'c' for closing integer(kind=int32), intent(in), optional :: unit_ optional, unit where the message will be written Calls proc~~file_io_status~~CallsGraph proc~file_io_status file_io_status proc~integer_to_character integer_to_character proc~file_io_status->proc~integer_to_character proc~write_error write_error proc~file_io_status->proc~write_error proc~write_message write_message proc~write_error->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~file_io_status~~CalledByGraph proc~file_io_status file_io_status proc~read_input_file read_input_file proc~read_input_file->proc~file_io_status proc~potential_read potential_read proc~potential_read->proc~file_io_status program~scattering SCATTERING program~scattering->proc~file_io_status program~scattering->proc~read_input_file program~scattering->proc~potential_read Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code file_io_status Source Code subroutine file_io_status ( istat_ , iomsg_ , channel_ , op_ , unit_ ) !! check the status during various io operations on files !---------------------------------------------------------------------! integer ( int32 ) :: istat_ !! result of iostat in open/read/write/close character ( len = * ), intent ( in ) :: iomsg_ !! result of iomsg in open/read/write/close integer ( int32 ), intent ( in ) :: channel_ !! name of the file character ( len = 1 ), intent ( in ) :: op_ !! 'o' for opening of the file, 'r' for reading, 'w' for writing, !! 'c' for closing integer ( int32 ), optional , intent ( in ) :: unit_ !! optional, unit where the message will be written !---------------------------------------------------------------------! character ( len = :), allocatable :: add_prefix_ !---------------------------------------------------------------------! add_prefix_ = '' if ( istat_ /= 0 ) then select case ( op_ ) case ( 'o' ) add_prefix_ = 'opening file on channel: ' // & integer_to_character ( channel_ ) case ( 'r' ) add_prefix_ = 'reading file on channel: ' // & integer_to_character ( channel_ ) case ( 'w' ) add_prefix_ = 'writing to file on channel: ' // & integer_to_character ( channel_ ) case ( 'c' ) add_prefix_ = 'closing file on channel: ' // & integer_to_character ( channel_ ) case default call write_error & ( 'Incorrect op_ argument in file_io_status subroutine (' & // trim ( op_ ) // ')' ) end select call write_error ( trim ( add_prefix_ ) // \" with message: \" // iomsg_ , unit_ ) endif !---------------------------------------------------------------------! end subroutine file_io_status","tags":"","loc":"proc/file_io_status.html"},{"title":"time_count_summary – the SCATTERING code","text":"public  subroutine time_count_summary(start_, stop_, time_, message_) print the message about the time it took to complete a single task Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: start_ initial time real(kind=dp), intent(in) :: stop_ final time real(kind=dp), intent(out) :: time_ stop_ - start_ character(len=*), intent(in), optional :: message_ (optional) a message to print instead of a default\n\"Completed in ... s\" Calls proc~~time_count_summary~~CallsGraph proc~time_count_summary time_count_summary proc~write_message write_message proc~time_count_summary->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~time_count_summary~~CalledByGraph proc~time_count_summary time_count_summary proc~crosssection CROSSSECTION proc~crosssection->proc~time_count_summary program~scattering SCATTERING program~scattering->proc~time_count_summary program~scattering->proc~crosssection Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code time_count_summary Source Code subroutine time_count_summary ( start_ , stop_ , time_ , message_ ) !! print the message about the time it took to complete a single task !---------------------------------------------------------------------! real ( dp ), intent ( in ) :: start_ !! initial time real ( dp ), intent ( in ) :: stop_ !! final time real ( dp ), intent ( out ) :: time_ !! stop_ - start_ character ( len = * ), optional , intent ( in ) :: message_ !! (optional) a message to print instead of a default !! \"Completed in ... s\" !---------------------------------------------------------------------! character ( len = 12 ) :: default_message = 'Completed in' character ( len = 100 ) :: time_msg !---------------------------------------------------------------------! time_ = stop_ - start_ if ( present ( message_ )) then write ( time_msg , fmt = '(a,x,a,es11.4,x,a)' ) & '--' , trim ( message_ ), time_ , 's' else write ( time_msg , fmt = '(a,x,a,es11.4,x,a)' ) & '--' , default_message , time_ , 's' endif call write_message ( time_msg ) !---------------------------------------------------------------------! end subroutine time_count_summary","tags":"","loc":"proc/time_count_summary.html"},{"title":"write_error – the SCATTERING code","text":"public  subroutine write_error(message_, unit_) writes an error message on a chosen unit Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message_ a message to be written integer(kind=int32), intent(in), optional :: unit_ optional, unit where the message will be written Calls proc~~write_error~~CallsGraph proc~write_error write_error proc~write_message write_message proc~write_error->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~write_error~~CalledByGraph proc~write_error write_error proc~wavenumberekin WAVENUMBEREKIN proc~wavenumberekin->proc~write_error proc~set_channels_level_indices_channels_omega_values set_channels_level_indices_channels_omega_values proc~set_channels_level_indices_channels_omega_values->proc~write_error proc~input_check input_check proc~input_check->proc~write_error proc~file_io_status file_io_status proc~file_io_status->proc~write_error proc~potential_read potential_read proc~potential_read->proc~write_error proc~potential_read->proc~file_io_status proc~spline spline proc~spline->proc~write_error proc~radtermvalue RADTERMVALUE proc~radtermvalue->proc~write_error proc~alloc_status alloc_status proc~alloc_status->proc~write_error proc~write_header write_header proc~write_header->proc~write_error proc~set_channels_l_values set_channels_l_values proc~set_channels_l_values->proc~write_error proc~set_number_of_channels set_number_of_channels proc~set_number_of_channels->proc~write_error proc~potential_interpolation potential_interpolation proc~potential_interpolation->proc~spline program~scattering SCATTERING program~scattering->proc~set_channels_level_indices_channels_omega_values program~scattering->proc~file_io_status program~scattering->proc~potential_read program~scattering->proc~write_header program~scattering->proc~set_channels_l_values program~scattering->proc~set_number_of_channels program~scattering->proc~potential_interpolation proc~read_input_file read_input_file program~scattering->proc~read_input_file proc~numerov numerov program~scattering->proc~numerov proc~input_summary input_summary proc~input_summary->proc~wavenumberekin proc~pes_contribution pes_contribution proc~pes_contribution->proc~radtermvalue proc~read_input_file->proc~input_check proc~read_input_file->proc~file_io_status proc~read_input_file->proc~input_summary proc~numerov->proc~pes_contribution Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_error Source Code subroutine write_error ( message_ , unit_ ) !! writes an error message on a chosen unit !---------------------------------------------------------------------! character ( len = * ), intent ( in ) :: message_ !! a message to be written integer ( int32 ), optional , intent ( in ) :: unit_ !! optional, unit where the message will be written !---------------------------------------------------------------------! call write_message ( 'Error: ' // trim ( message_ ), unit_ ) stop !---------------------------------------------------------------------! end subroutine write_error","tags":"","loc":"proc/write_error.html"},{"title":"write_header – the SCATTERING code","text":"public  subroutine write_header(header_type, opt_integer_) writes headers on screen Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: header_type specifies the type of the header: 'main', 'input_read',\n'input_check', 'input_summary', 'initialization', 'check_norm',\n'save_basis', 'save_pes', 'radial_terms', 'save_radial_terms',\n'reconstruction' integer(kind=int32), intent(in), optional :: opt_integer_ optional integer used in case \"block\" to pass jtot value Calls proc~~write_header~~CallsGraph proc~write_header write_header proc~write_message write_message proc~write_header->proc~write_message proc~write_error write_error proc~write_header->proc~write_error interface~incorrect_value incorrect_value proc~write_header->interface~incorrect_value proc~write_error->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~write_header~~CalledByGraph proc~write_header write_header program~scattering SCATTERING program~scattering->proc~write_header Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_header Source Code subroutine write_header ( header_type , opt_integer_ ) !! writes headers on screen character ( len = * ), intent ( in ) :: header_type !! specifies the type of the header: 'main', 'input_read', !! 'input_check', 'input_summary', 'initialization', 'check_norm', !! 'save_basis', 'save_pes', 'radial_terms', 'save_radial_terms', !! 'reconstruction' integer ( int32 ), optional , intent ( in ) :: opt_integer_ !! optional integer used in case \"block\" to pass jtot value !---------------------------------------------------------------------! character ( len = 100 ) :: header_star , header_str character ( len = 10 ) :: tmp_str_ integer ( int32 ) :: len_str_ !---------------------------------------------------------------------! select case ( trim ( header_type )) case ( 'main' ) write ( header_star , fmt = \"(a90)\" ) repeat ( \"*\" , 90 ) call write_message ( header_star ) call write_message ( header_star ) write ( header_str , fmt = '(a,25x,a43,20x,a)' ) & '*' , 'BIGOS quantum scattering package, vs. 0.00.' , '*' call write_message ( header_str ) write ( header_str , fmt = '(a,36x,a19,33x,a)' ) & '*' , 'the SCATTERING code' , '*' call write_message ( header_str ) write ( header_str , fmt = '(a,29x,a31,28x,a)' ) & '*' , 'adjusted for H2-He calculations' , '*' call write_message ( header_str ) write ( header_str , fmt = '(a,37x,a17,34x,a)' ) & '*' , 'by Hubert Jozwiak' , '*' call write_message ( header_str ) write ( header_str , fmt = '(a,40x,a11,37x,a)' ) & '*' , '20/12/2023 ' , '*' call write_message ( header_str ) call write_message ( header_star ) case ( 'block' ) call write_message ( repeat ( '*' , 90 )) if ( present ( opt_integer_ )) then write ( tmp_str_ , \"(i10)\" ) opt_integer_ len_str_ = len_trim ( tmp_str_ ) write ( * , '(\"*\", A, \"JTOT = \", A, A, \"*\")' ) & repeat ( ' ' , 40 - len_str_ ), tmp_str_ , repeat ( ' ' , 41 ) call write_message ( repeat ( '*' , 90 )) else call write_error ( \"**** JTOT value not provided in \" // & \"write_header_block ****\" ) endif case default call incorrect_value ( 'header_type (write_header)' , header_type ) end select !---------------------------------------------------------------------! end subroutine write_header","tags":"","loc":"proc/write_header.html"},{"title":"write_message – the SCATTERING code","text":"public  subroutine write_message(message_, unit_) writes a message on a chosen unit Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message_ a message to be written integer(kind=int32), intent(in), optional :: unit_ optional, unit where the message will be written Called by proc~~write_message~~CalledByGraph proc~write_message write_message proc~potential_reduction potential_reduction proc~potential_reduction->proc~write_message proc~print_coupling_matrix_elements_summary print_coupling_matrix_elements_summary proc~print_coupling_matrix_elements_summary->proc~write_message proc~numerov numerov proc~numerov->proc~write_message proc~pes_contribution pes_contribution proc~numerov->proc~pes_contribution proc~print_largest_partial_xs print_largest_partial_xs proc~print_largest_partial_xs->proc~write_message proc~input_check input_check proc~input_check->proc~write_message proc~write_error write_error proc~input_check->proc~write_error proc~print_bf_channels print_bf_channels proc~print_bf_channels->proc~write_message program~scattering SCATTERING program~scattering->proc~write_message program~scattering->proc~potential_reduction program~scattering->proc~print_coupling_matrix_elements_summary program~scattering->proc~numerov program~scattering->proc~print_largest_partial_xs program~scattering->proc~print_bf_channels proc~time_count_summary time_count_summary program~scattering->proc~time_count_summary proc~unitarity_check unitarity_check program~scattering->proc~unitarity_check proc~write_header write_header program~scattering->proc~write_header proc~set_channels_level_indices_channels_omega_values set_channels_level_indices_channels_omega_values program~scattering->proc~set_channels_level_indices_channels_omega_values proc~crosssection CROSSSECTION program~scattering->proc~crosssection proc~read_input_file read_input_file program~scattering->proc~read_input_file proc~potential_read potential_read program~scattering->proc~potential_read proc~file_io_status file_io_status program~scattering->proc~file_io_status proc~set_channels_l_values set_channels_l_values program~scattering->proc~set_channels_l_values proc~set_number_of_channels set_number_of_channels program~scattering->proc~set_number_of_channels proc~calculate_k_matrix calculate_k_matrix program~scattering->proc~calculate_k_matrix proc~potential_interpolation potential_interpolation program~scattering->proc~potential_interpolation proc~write_error->proc~write_message proc~input_summary input_summary proc~input_summary->proc~write_message proc~wavenumberekin WAVENUMBEREKIN proc~input_summary->proc~wavenumberekin proc~write_warning write_warning proc~write_warning->proc~write_message proc~time_count_summary->proc~write_message proc~unitarity_check->proc~write_message proc~unitarity_check->proc~write_warning proc~write_header->proc~write_message proc~write_header->proc~write_error proc~wavenumberekin->proc~write_error proc~set_channels_level_indices_channels_omega_values->proc~write_error proc~ispline ispline proc~ispline->proc~write_warning proc~modified_bessel_k_ratio modified_bessel_k_ratio proc~modified_bessel_k_ratio->proc~write_warning proc~riccati_bessel_y riccati_bessel_y proc~riccati_bessel_y->proc~write_warning proc~crosssection->proc~time_count_summary proc~read_input_file->proc~input_check proc~read_input_file->proc~input_summary proc~read_input_file->proc~file_io_status proc~potential_read->proc~write_error proc~potential_read->proc~file_io_status proc~file_io_status->proc~write_error proc~spline spline proc~spline->proc~write_error proc~radtermvalue RADTERMVALUE proc~radtermvalue->proc~write_error proc~radtermvalue->proc~ispline proc~alloc_status alloc_status proc~alloc_status->proc~write_error proc~set_channels_l_values->proc~write_error proc~set_number_of_channels->proc~write_error proc~riccati_bessel_j riccati_bessel_j proc~riccati_bessel_j->proc~write_warning proc~calculate_k_matrix->proc~modified_bessel_k_ratio proc~calculate_k_matrix->proc~riccati_bessel_y proc~calculate_k_matrix->proc~riccati_bessel_j proc~pes_contribution->proc~radtermvalue proc~potential_interpolation->proc~spline Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_message Source Code subroutine write_message ( message_ , unit_ ) !! writes a message on a chosen unit !---------------------------------------------------------------------! character ( len = * ), intent ( in ) :: message_ !! a message to be written integer ( int32 ), optional , intent ( in ) :: unit_ !! optional, unit where the message will be written !---------------------------------------------------------------------! if ( present ( unit_ )) then write ( unit_ , '(a)' ) trim ( message_ ) else write ( output_unit , '(a)' ) trim ( message_ ) endif !---------------------------------------------------------------------! end subroutine write_message","tags":"","loc":"proc/write_message.html"},{"title":"write_warning – the SCATTERING code","text":"public  subroutine write_warning(message_, unit_) writes a warning message on a chosen unit Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message_ a message to be written integer(kind=int32), intent(in), optional :: unit_ optional, unit where the message will be written Calls proc~~write_warning~~CallsGraph proc~write_warning write_warning proc~write_message write_message proc~write_warning->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~write_warning~~CalledByGraph proc~write_warning write_warning proc~ispline ispline proc~ispline->proc~write_warning proc~modified_bessel_k_ratio modified_bessel_k_ratio proc~modified_bessel_k_ratio->proc~write_warning proc~riccati_bessel_y riccati_bessel_y proc~riccati_bessel_y->proc~write_warning proc~unitarity_check unitarity_check proc~unitarity_check->proc~write_warning proc~riccati_bessel_j riccati_bessel_j proc~riccati_bessel_j->proc~write_warning proc~radtermvalue RADTERMVALUE proc~radtermvalue->proc~ispline proc~calculate_k_matrix calculate_k_matrix proc~calculate_k_matrix->proc~modified_bessel_k_ratio proc~calculate_k_matrix->proc~riccati_bessel_y proc~calculate_k_matrix->proc~riccati_bessel_j program~scattering SCATTERING program~scattering->proc~unitarity_check program~scattering->proc~calculate_k_matrix proc~numerov numerov program~scattering->proc~numerov proc~pes_contribution pes_contribution proc~pes_contribution->proc~radtermvalue proc~numerov->proc~pes_contribution Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_warning Source Code subroutine write_warning ( message_ , unit_ ) !! writes a warning message on a chosen unit !---------------------------------------------------------------------! character ( len = * ), intent ( in ) :: message_ !! a message to be written integer ( int32 ), optional , intent ( in ) :: unit_ !! optional, unit where the message will be written !---------------------------------------------------------------------! call write_message ( 'Warning: ' // trim ( message_ ), unit_ ) !---------------------------------------------------------------------! end subroutine write_warning","tags":"","loc":"proc/write_warning.html"},{"title":"incorrect_value – the SCATTERING code","text":"public interface incorrect_value interface for the following message: incorrect value encountered:\n  variable_name = variable_value Called by interface~~incorrect_value~~CalledByGraph interface~incorrect_value incorrect_value proc~input_check input_check proc~input_check->interface~incorrect_value proc~write_header write_header proc~write_header->interface~incorrect_value proc~read_input_file read_input_file proc~read_input_file->proc~input_check program~scattering SCATTERING program~scattering->proc~write_header program~scattering->proc~read_input_file Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures incorrect_value_ch incorrect_value_int32 incorrect_value_sp incorrect_value_dp Module Procedures private  subroutine incorrect_value_ch(name_, value_, unit_) incorrect value encountered:\n  variable_name = variable_value Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name_ name of the variable character(len=*), intent(in) :: value_ value of the variable integer(kind=int32), intent(in), optional :: unit_ optional, unit where the message will be written private  subroutine incorrect_value_int32(name_, value_, unit_) incorrect value encountered:\n  variable_name = variable_value Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name_ name of the variable integer(kind=int32), intent(in) :: value_ value of the variable integer(kind=int32), intent(in), optional :: unit_ optional, unit where the message will be written private  subroutine incorrect_value_sp(name_, value_, unit_) incorrect value encountered:\n  variable_name = variable_value Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name_ name of the variable real(kind=sp), intent(in) :: value_ value of the variable integer(kind=int32), intent(in), optional :: unit_ optional, unit where the message will be written private  subroutine incorrect_value_dp(name_, value_, unit_) incorrect value encountered:\n  variable_name = variable_value Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name_ name of the variable real(kind=dp), intent(in) :: value_ value of the variable integer(kind=int32), intent(in), optional :: unit_ optional, unit where the message will be written","tags":"","loc":"interface/incorrect_value.html"},{"title":"print_bf_channels – the SCATTERING code","text":"public  subroutine print_bf_channels(number_of_channels, jtot_, nparity, channels_level_indices, channels_omega_values) prints BF quantum numbers on screen Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: number_of_channels number of channels in the block integer(kind=int32), intent(in) :: jtot_ total angular momentum integer(kind=int32), intent(in) :: nparity parity exponent of the block (0 if p = +1, 1 if p = -1) integer(kind=int32), intent(inout) :: channels_level_indices (number_of_channels) holds the indices pointing to the basis arrays integer(kind=int32), intent(inout) :: channels_omega_values (number_of_channels) holds all values of \\bar{\\Omega} Calls proc~~print_bf_channels~~CallsGraph proc~print_bf_channels print_bf_channels proc~write_message write_message proc~print_bf_channels->proc~write_message proc~etotal ETOTAL proc~print_bf_channels->proc~etotal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~print_bf_channels~~CalledByGraph proc~print_bf_channels print_bf_channels program~scattering SCATTERING program~scattering->proc~print_bf_channels Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables erot isize_ itmp j1tmp line_ omegatmp v1tmp wavenumber Source Code print_bf_channels Variables Type Visibility Attributes Name Initial real(kind=dp), public :: erot integer(kind=int32), public :: isize_ integer(kind=int32), public :: itmp integer(kind=int32), public :: j1tmp character(len=200), public :: line_ integer(kind=int32), public :: omegatmp integer(kind=int32), public :: v1tmp real(kind=dp), public :: wavenumber Source Code subroutine print_bf_channels ( number_of_channels , jtot_ , nparity , channels_level_indices , channels_omega_values ) !! prints BF quantum numbers on screen !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: number_of_channels !! number of channels in the block integer ( int32 ), intent ( in ) :: jtot_ !! total angular momentum integer ( int32 ), intent ( in ) :: nparity !! parity exponent of the block (0 if p = +1, 1 if p = -1) integer ( int32 ), intent ( inout ) :: channels_level_indices ( number_of_channels ) !! holds the indices pointing to the basis arrays integer ( int32 ), intent ( inout ) :: channels_omega_values ( number_of_channels ) !! holds all values of \\bar{\\Omega} !---------------------------------------------------------------------! character ( len = 200 ) :: line_ integer ( int32 ) :: isize_ , itmp , v1tmp , j1tmp , omegatmp real ( dp ) :: erot , wavenumber !---------------------------------------------------------------------! call write_message ( \"  v1      j1     omega      p\" // repeat ( \" \" , 11 ) // & \"E_j\" // repeat ( \" \" , 16 ) // \"wv\" ) !---------------------------------------------------------------------! do isize_ = 1 , number_of_channels v1tmp = v1array ( channels_level_indices ( isize_ )) j1tmp = j1array ( channels_level_indices ( isize_ )) omegatmp = channels_omega_values ( isize_ ) erot = elevel ( channels_level_indices ( isize_ )) itmp = ( - 1 ) ** nparity if (( ETOTAL () - erot ) <= 0.0_dp ) then write ( line_ , \"(I4,4X,I4,6X,I4,5X,I2,2X,F12.4,4X,'--------------')\" ) & v1tmp , j1tmp , omegatmp , itmp * ( - 1 ) ** jtot_ , erot * hartreetocm call write_message ( line_ ) else wavenumber = dsqrt ( 2 * reducedmass * ( ETOTAL () - erot )) write ( line_ , \"(I4,4X,I4,6X,I4,5X,I2,2X,F12.4,4X,F14.8)\" ) & v1tmp , j1tmp , omegatmp , itmp * ( - 1 ) ** jtot_ , erot * hartreetocm , & wavenumber / bohrtoangstrom call write_message ( line_ ) endif enddo !---------------------------------------------------------------------! end subroutine print_bf_channels","tags":"","loc":"proc/print_bf_channels.html"},{"title":"set_channels_l_values – the SCATTERING code","text":"public  subroutine set_channels_l_values(number_of_channels, jtot_, nparity, channels_l_values) Prepares the channels_l_values array which holds values of orbital angular momentum\n(l), an SF-frame quantum number. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: number_of_channels number of channels in the block integer(kind=int32), intent(in) :: jtot_ total angular momentum integer(kind=int32), intent(in) :: nparity parity exponent of the block (0 if p = +1, 1 if p = -1) integer(kind=int32), intent(inout) :: channels_l_values (number_of_channels) holds all values of l Calls proc~~set_channels_l_values~~CallsGraph proc~set_channels_l_values set_channels_l_values proc~write_error write_error proc~set_channels_l_values->proc~write_error proc~write_message write_message proc~write_error->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~set_channels_l_values~~CalledByGraph proc~set_channels_l_values set_channels_l_values program~scattering SCATTERING program~scattering->proc~set_channels_l_values Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables ij il isize_ lmax lmin ltmp Source Code set_channels_l_values Variables Type Visibility Attributes Name Initial integer, public :: ij integer, public :: il integer, public :: isize_ integer, public :: lmax integer, public :: lmin integer, public :: ltmp Source Code subroutine set_channels_l_values ( number_of_channels , jtot_ , nparity , channels_l_values ) !! Prepares the channels_l_values array which holds values of orbital angular momentum !! (l), an SF-frame quantum number. !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: number_of_channels !! number of channels in the block integer ( int32 ), intent ( in ) :: jtot_ !! total angular momentum integer ( int32 ), intent ( in ) :: nparity !! parity exponent of the block (0 if p = +1, 1 if p = -1) integer ( int32 ), intent ( inout ) :: channels_l_values ( number_of_channels ) !! holds all values of l !---------------------------------------------------------------------! integer :: lmin , lmax , ltmp integer :: ij , il , isize_ !---------------------------------------------------------------------! isize_ = 0 do ij = 1 , nlevel lmin = abs ( jtot_ - j1array ( ij )) lmax = jtot_ + j1array ( ij ) do il = lmin , lmax ltmp = il if ( mod ( ltmp + j1array ( ij ) + jtot_ , 2 ) == nparity ) then if ( isize_ >= number_of_channels ) then call write_error ( \"Array index isize_ out of bounds of \" // & \"channels_l_values in set_channels_l_values.\" ) end if channels_l_values ( isize_ + 1 ) = ltmp isize_ = isize_ + 1 endif enddo enddo !---------------------------------------------------------------------! end subroutine set_channels_l_values","tags":"","loc":"proc/set_channels_l_values.html"},{"title":"set_channels_level_indices_channels_omega_values – the SCATTERING code","text":"public  subroutine set_channels_level_indices_channels_omega_values(number_of_channels, jtot_, nparity, channels_level_indices, channels_omega_values) Prepares the channels_level_indices array which holds indices that refer to the\nbasis arrays: v1level/j1level/elevel, and channels_omega_values which holds values\nof \\bar{\\Omega} Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: number_of_channels number of channels in the block integer(kind=int32), intent(in) :: jtot_ total angular momentum integer(kind=int32), intent(in) :: nparity parity exponent of the block (0 if p = +1, 1 if p = -1) integer(kind=int32), intent(inout) :: channels_level_indices (number_of_channels) holds the indices pointing to the basis arrays integer(kind=int32), intent(inout) :: channels_omega_values (number_of_channels) holds all values of \\bar{\\Omega} Calls proc~~set_channels_level_indices_channels_omega_values~~CallsGraph proc~set_channels_level_indices_channels_omega_values set_channels_level_indices_channels_omega_values proc~write_error write_error proc~set_channels_level_indices_channels_omega_values->proc~write_error proc~write_message write_message proc~write_error->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~set_channels_level_indices_channels_omega_values~~CalledByGraph proc~set_channels_level_indices_channels_omega_values set_channels_level_indices_channels_omega_values program~scattering SCATTERING program~scattering->proc~set_channels_level_indices_channels_omega_values Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables ij iomega isize_ omegamax omegatmp Source Code set_channels_level_indices_channels_omega_values Variables Type Visibility Attributes Name Initial integer(kind=int32), public :: ij integer(kind=int32), public :: iomega integer(kind=int32), public :: isize_ integer(kind=int32), public :: omegamax integer(kind=int32), public :: omegatmp Source Code subroutine set_channels_level_indices_channels_omega_values ( number_of_channels , jtot_ , nparity , channels_level_indices , & channels_omega_values ) !! Prepares the channels_level_indices array which holds indices that refer to the !! basis arrays: v1level/j1level/elevel, and channels_omega_values which holds values !! of \\bar{\\Omega} !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: number_of_channels !! number of channels in the block integer ( int32 ), intent ( in ) :: jtot_ !! total angular momentum integer ( int32 ), intent ( in ) :: nparity !! parity exponent of the block (0 if p = +1, 1 if p = -1) integer ( int32 ), intent ( inout ) :: channels_level_indices ( number_of_channels ) !! holds the indices pointing to the basis arrays integer ( int32 ), intent ( inout ) :: channels_omega_values ( number_of_channels ) !! holds all values of \\bar{\\Omega} !---------------------------------------------------------------------! integer ( int32 ) :: isize_ , omegatmp , omegamax , ij , iomega !---------------------------------------------------------------------! isize_ = 0 !---------------------------------------------------------------------! do ij = 1 , nlevel omegamax = min ( j1array ( ij ), jtot_ ) if ( nparity . eq . 0 ) then do iomega = 1 , omegamax + 1 if ( isize_ >= number_of_channels ) then call write_error ( \"Array index isize_ out of bounds of \" // & \"channels_l_values in set_channels_level_indices_channels_omega_values.\" ) end if omegatmp = iomega - 1 channels_omega_values ( isize_ + 1 ) = omegatmp channels_level_indices ( isize_ + 1 ) = ij isize_ = isize_ + 1 enddo else do iomega = 1 , omegamax if ( isize_ >= number_of_channels ) then call write_error ( \"Array index isize_ out of bounds of \" // & \"channels_l_values in set_channels_level_indices_channels_omega_values.\" ) end if omegatmp = iomega channels_omega_values ( isize_ + 1 ) = omegatmp channels_level_indices ( isize_ + 1 ) = ij isize_ = isize_ + 1 enddo endif enddo !---------------------------------------------------------------------! end subroutine set_channels_level_indices_channels_omega_values","tags":"","loc":"proc/set_channels_level_indices_channels_omega_values.html"},{"title":"set_number_of_channels – the SCATTERING code","text":"public  subroutine set_number_of_channels(jtot_, size_BF_even, size_BF_odd) determine the number of scattering channels in each parity block \nfor given JTOT; check both BF and SF frames Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: jtot_ total angular momentum integer(kind=int32), intent(inout) :: size_BF_even number of channels in p = 1 block integer(kind=int32), intent(inout) :: size_BF_odd number of channels in p = -1 block Calls proc~~set_number_of_channels~~CallsGraph proc~set_number_of_channels set_number_of_channels proc~write_error write_error proc~set_number_of_channels->proc~write_error proc~write_message write_message proc~write_error->proc~write_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~set_number_of_channels~~CalledByGraph proc~set_number_of_channels set_number_of_channels program~scattering SCATTERING program~scattering->proc~set_number_of_channels Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables ii j1tmp l_len len_even len_odd lmax lmin omegamax size_SF_even size_SF_odd Source Code set_number_of_channels Variables Type Visibility Attributes Name Initial integer(kind=int32), public :: ii integer(kind=int32), public :: j1tmp integer(kind=int32), public :: l_len integer(kind=int32), public :: len_even integer(kind=int32), public :: len_odd integer(kind=int32), public :: lmax integer(kind=int32), public :: lmin integer(kind=int32), public :: omegamax integer(kind=int32), public :: size_SF_even integer(kind=int32), public :: size_SF_odd Source Code subroutine set_number_of_channels ( jtot_ , size_BF_even , size_BF_odd ) !! determine the number of scattering channels in each parity block !! for given JTOT; check both BF and SF frames !---------------------------------------------------------------------! !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: jtot_ !! total angular momentum integer ( int32 ), intent ( inout ) :: size_BF_even !! number of channels in p = 1 block integer ( int32 ), intent ( inout ) :: size_BF_odd !! number of channels in p = -1 block !---------------------------------------------------------------------! integer ( int32 ) :: ii , j1tmp , omegamax , lmin , lmax , l_len , len_even , & len_odd , size_SF_even , size_SF_odd !---------------------------------------------------------------------! ! BF frame !---------------------------------------------------------------------! size_BF_even = 0 size_BF_odd = 0 do ii = 1 , nlevel j1tmp = j1array ( ii ) omegamax = min ( j1tmp , jtot_ ) size_BF_even = size_BF_even + omegamax + 1 size_BF_odd = size_BF_odd + omegamax enddo !---------------------------------------------------------------------! ! SF frame !---------------------------------------------------------------------! size_SF_even = 0 size_SF_odd = 0 do ii = 1 , nlevel j1tmp = j1array ( ii ) lmin = abs ( jtot_ - j1tmp ) lmax = jtot_ + j1tmp l_len = lmax - lmin + 1 len_even = int (( l_len + 1 ) / 2 ) len_odd = int (( l_len - 1 ) / 2 ) size_SF_even = size_SF_even + len_even size_SF_odd = size_SF_odd + len_odd enddo !---------------------------------------------------------------------! ! Check if the results are the same !---------------------------------------------------------------------! if ( size_BF_even . ne . size_SF_even ) then call write_error ( \"Different number of channels in even block \" // & \"(BF/SF); check set_number_of_channels\" ) endif !---------------------------------------------------------------------! if ( size_BF_odd . ne . size_SF_odd ) then call write_error ( \"Different number of channels in odd block \" // & \"(BF/SF); check set_number_of_channels\" ) endif !---------------------------------------------------------------------! end subroutine set_number_of_channels","tags":"","loc":"proc/set_number_of_channels.html"},{"title":"set_number_of_open_channels_wavmax – the SCATTERING code","text":"public  subroutine set_number_of_open_channels_wavmax(number_of_channels, channels_level_indices, channels_omega_values, number_of_open_channels, wavmax) Calculates the number of energetically open channels (number_of_open_channels) and\nthe largest wave number (wavmax) in the block. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: number_of_channels number of channels in the block integer(kind=int32), intent(in) :: channels_level_indices (number_of_channels) holds the indices pointing to the basis arrays integer(kind=int32), intent(in) :: channels_omega_values (number_of_channels) holds all values of \\bar{\\Omega} integer(kind=int32), intent(inout) :: number_of_open_channels number of open channels real(kind=dp), intent(inout) :: wavmax the largest wave number (wavmax) in the block Calls proc~~set_number_of_open_channels_wavmax~~CallsGraph proc~set_number_of_open_channels_wavmax set_number_of_open_channels_wavmax proc~etotal ETOTAL proc~set_number_of_open_channels_wavmax->proc~etotal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~set_number_of_open_channels_wavmax~~CalledByGraph proc~set_number_of_open_channels_wavmax set_number_of_open_channels_wavmax program~scattering SCATTERING program~scattering->proc~set_number_of_open_channels_wavmax Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables isize_ wavenumber Source Code set_number_of_open_channels_wavmax Variables Type Visibility Attributes Name Initial integer(kind=int32), public :: isize_ real(kind=dp), public :: wavenumber Source Code subroutine set_number_of_open_channels_wavmax ( number_of_channels , & channels_level_indices , channels_omega_values , & number_of_open_channels , wavmax ) !! Calculates the number of energetically open channels (number_of_open_channels) and !! the largest wave number (wavmax) in the block. !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: number_of_channels !! number of channels in the block integer ( int32 ), intent ( in ) :: channels_level_indices ( number_of_channels ) !! holds the indices pointing to the basis arrays integer ( int32 ), intent ( in ) :: channels_omega_values ( number_of_channels ) !! holds all values of \\bar{\\Omega} integer ( int32 ), intent ( inout ) :: number_of_open_channels !! number of open channels real ( dp ), intent ( inout ) :: wavmax !! the largest wave number (wavmax) in the block !---------------------------------------------------------------------! integer ( int32 ) :: isize_ real ( dp ) :: wavenumber !---------------------------------------------------------------------! number_of_open_channels = 0 wavmax = 0.0_dp !---------------------------------------------------------------------! do isize_ = 1 , number_of_channels if (( ETOTAL () - elevel ( channels_level_indices ( isize_ ))) > 0.0_dp ) then number_of_open_channels = number_of_open_channels + 1 wavenumber = dsqrt ( 2 * reducedmass * ( ETOTAL () - elevel ( channels_level_indices ( isize_ )))) wavmax = max ( wavmax , wavenumber ) endif enddo !---------------------------------------------------------------------! end subroutine set_number_of_open_channels_wavmax","tags":"","loc":"proc/set_number_of_open_channels_wavmax.html"},{"title":"special_functions_mod – the SCATTERING code","text":"This module holds rctj, rcty, envj, msta1, msta2, ikv, gamma from\n special_functions library, donwloaded from:\n https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html\n  Author: Original FORTRAN77 version by Shanjie Zhang, Jianming Jin.\nFORTRAN90 version by John Burkardt. Reference: Shanjie Zhang, Jianming Jin,\nComputation of Special Functions,\nWiley, 1996,\nISBN: 0-471-11963-6,\nLC: QA351.C45. --------------------------------------------------------------------------! Used by module~~special_functions_mod~~UsedByGraph module~special_functions_mod special_functions_mod module~math_functions_mod math_functions_mod module~math_functions_mod->module~special_functions_mod module~potential POTENTIAL module~potential->module~math_functions_mod module~propagators PROPAGATORS module~propagators->module~math_functions_mod module~propagators->module~potential module~boundary_conditions_mod boundary_conditions_mod module~boundary_conditions_mod->module~math_functions_mod module~pes_coupling_matrix PES_COUPLING_MATRIX module~pes_coupling_matrix->module~math_functions_mod program~scattering SCATTERING program~scattering->module~potential program~scattering->module~propagators program~scattering->module~boundary_conditions_mod program~scattering->module~pes_coupling_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Functions envj msta1 msta2 Subroutines gamma ikv rctj rcty Functions public  function envj (n, x) utility function used by MSTA1 and MSTA2. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: x Return Value real(kind=8) public  function msta1 (x, mp) determines a backward recurrence starting point for Jn(x). Arguments Type Intent Optional Attributes Name real(kind=8) :: x integer(kind=4) :: mp Return Value integer(kind=4) public  function msta2 (x, n, mp) determines a backward recurrence starting point for Jn(x). Arguments Type Intent Optional Attributes Name real(kind=8) :: x integer(kind=4) :: n integer(kind=4) :: mp Return Value integer(kind=4) Subroutines public  subroutine gamma (x, ga) evaluates the Gamma function. Arguments Type Intent Optional Attributes Name real(kind=8) :: x real(kind=8) :: ga public  subroutine ikv (v, x, vm, bi, di, bk, dk) computes modified Bessel function Iv(x) and Kv(x) and their derivatives. Arguments Type Intent Optional Attributes Name real(kind=8) :: v real(kind=8) :: x real(kind=8) :: vm real(kind=8) :: bi (0:*) real(kind=8) :: di (0:*) real(kind=8) :: bk (0:*) real(kind=8) :: dk (0:*) public  subroutine rctj (n, x, nm, rj, dj) computes Riccati-Bessel function of the first kind, and derivatives. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: x integer(kind=4) :: nm real(kind=8) :: rj (0:n) real(kind=8) :: dj (0:n) public  subroutine rcty (n, x, nm, ry, dy) computes Riccati-Bessel function of the second kind, and derivatives. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: x integer(kind=4) :: nm real(kind=8) :: ry (0:n) real(kind=8) :: dy (0:n)","tags":"","loc":"module/special_functions_mod.html"},{"title":"io_mod – the SCATTERING code","text":"this module provides following functions and subroutines:\n1. input_file - reads the input file prepared by the user\n2. input_check - checks the variables supplied in the input file\n3. input_summary - summary of the input variables\n5. etotal (function) - returns the total energy of the system\n6. wavenumberekin (function) - returns the wavenumber (in 1/A&#94;{2})\n7. units_conversion - converts all physical quantities to atomic units\n8. count_available_xs (function) - counts energetically accessible\n   levels in the basis\n9. jaccess (function) - returns jopen and waveopen - arrays needed for\n   calculations of the state-to-state XS Uses utility_functions_mod array_operations_mod iso_fortran_env module~~io_mod~~UsesGraph module~io_mod io_mod module~utility_functions_mod utility_functions_mod module~io_mod->module~utility_functions_mod iso_fortran_env iso_fortran_env module~io_mod->iso_fortran_env module~array_operations_mod array_operations_mod module~io_mod->module~array_operations_mod module~utility_functions_mod->iso_fortran_env module~array_operations_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~io_mod~~UsedByGraph module~io_mod io_mod module~potential POTENTIAL module~potential->module~io_mod module~channels_mod channels_mod module~channels_mod->module~io_mod module~boundary_conditions_mod boundary_conditions_mod module~boundary_conditions_mod->module~io_mod module~pes_coupling_matrix PES_COUPLING_MATRIX module~pes_coupling_matrix->module~io_mod program~scattering SCATTERING program~scattering->module~io_mod program~scattering->module~potential program~scattering->module~channels_mod program~scattering->module~boundary_conditions_mod program~scattering->module~pes_coupling_matrix module~propagators PROPAGATORS program~scattering->module~propagators module~statetostatexs statetostateXS program~scattering->module~statetostatexs module~propagators->module~io_mod module~propagators->module~potential module~statetostatexs->module~io_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables amutoau b bmat bmat3D bohrtoangstrom c cmat cmat3D d dmat dmat3D dr dtol elevel energy hartreetocm ietoterel initial ipart iunits j1array j1pes j1ppes jtotmax jtotmin jtotstep l1tab l2tab label lltab n_skip_lines ncac ncoupl nlevel nmodlevels nr nterms otol partialfile pes_file_exists pi potentialfile prntlvl read_vmat3D reduced_j1pes reduced_j1ppes reduced_v1pes reduced_v1ppes reducedmass rmat rmax rmin saveeigenvectors smatrixfile steps totalcol v1array v1pes v1ppes vdepth vmat vmat3D Functions ETOTAL WAVENUMBEREKIN count_open_basis_levels Subroutines input_check input_summary read_input_file save_open_basis_levels units_conversion Variables Type Visibility Attributes Name Initial real(kind=dp), public, parameter :: amutoau = 1822.8884862d0 real(kind=dp), public, allocatable :: b (:) real(kind=dp), public, allocatable :: bmat (:,:) real(kind=dp), public, allocatable :: bmat3D (:,:,:) real(kind=dp), public, parameter :: bohrtoangstrom = 0.5291772109d0 real(kind=dp), public, allocatable :: c (:) real(kind=dp), public, allocatable :: cmat (:,:) real(kind=dp), public, allocatable :: cmat3D (:,:,:) real(kind=dp), public, allocatable :: d (:) real(kind=dp), public, allocatable :: dmat (:,:) real(kind=dp), public, allocatable :: dmat3D (:,:,:) real(kind=dp), public :: dr real(kind=dp), public :: dtol real(kind=dp), public, allocatable :: elevel (:) real(kind=dp), public :: energy real(kind=dp), public, parameter :: hartreetocm = 219474.631363d0 integer(kind=int32), public :: ietoterel integer(kind=int32), public :: initial integer(kind=int32), public :: ipart integer(kind=int32), public :: iunits integer(kind=int32), public, allocatable :: j1array (:) integer(kind=int32), public, allocatable :: j1pes (:) integer(kind=int32), public, allocatable :: j1ppes (:) integer(kind=int32), public :: jtotmax integer(kind=int32), public :: jtotmin integer(kind=int32), public :: jtotstep integer(kind=int32), public, allocatable :: l1tab (:) integer(kind=int32), public, allocatable :: l2tab (:) character(len=80), public :: label integer(kind=int32), public, allocatable :: lltab (:) integer(kind=int32), public :: n_skip_lines integer(kind=int32), public :: ncac integer(kind=int32), public :: ncoupl integer(kind=int32), public :: nlevel integer(kind=int32), public :: nmodlevels integer(kind=int32), public :: nr integer(kind=int32), public :: nterms real(kind=dp), public :: otol character(len=80), public :: partialfile logical, public :: pes_file_exists real(kind=dp), public, parameter :: pi = dacos(-1.d0) character(len=80), public :: potentialfile integer(kind=int32), public :: prntlvl real(kind=dp), public, allocatable :: read_vmat3D (:,:,:) integer(kind=int32), public, allocatable :: reduced_j1pes (:) integer(kind=int32), public, allocatable :: reduced_j1ppes (:) integer(kind=int32), public, allocatable :: reduced_v1pes (:) integer(kind=int32), public, allocatable :: reduced_v1ppes (:) real(kind=dp), public :: reducedmass real(kind=dp), public, allocatable :: rmat (:) real(kind=dp), public :: rmax real(kind=dp), public :: rmin integer(kind=int32), public :: saveeigenvectors character(len=80), public :: smatrixfile integer(kind=int32), public :: steps integer(kind=int32), public :: totalcol integer(kind=int32), public, allocatable :: v1array (:) integer(kind=int32), public, allocatable :: v1pes (:) integer(kind=int32), public, allocatable :: v1ppes (:) real(kind=dp), public :: vdepth real(kind=dp), public, allocatable :: vmat (:,:) real(kind=dp), public, allocatable :: vmat3D (:,:,:) Functions public  function ETOTAL () result(etot_) returns the total energy Arguments None Return Value real(kind=dp) public  function WAVENUMBEREKIN () result(k_) returns the wavenumber (in 1/A&#94;{2}) Arguments None Return Value real(kind=dp) public  function count_open_basis_levels () result(open_) counts the energetically accessible levels in the basis Arguments None Return Value integer(kind=int32) Subroutines public  subroutine input_check (nmlistind) checks if the supplied input parameters are correct Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: nmlistind nmlistind = 1: namelist INPUT\nnmlistind = 2: namelist BASIS\nnmlistind = 3: namelist POTENTIAL public  subroutine input_summary () summarize the input parameters for the current run Arguments None public  subroutine read_input_file () reads the input file prepared by the user using NAMELIST feature\nthe code uses 3 namelists: input, basis and potential Arguments None public  subroutine save_open_basis_levels (number_of_open_basis_levels, open_basis_levels, open_basis_wavevectors) saves indices to open levels in the basis and corresponding\nwavenumbers Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: number_of_open_basis_levels number of energetically accessible levels in the basis integer(kind=int32), intent(inout) :: open_basis_levels (number_of_open_basis_levels) array holding indices to energetically accessible levels in the basis real(kind=dp), intent(inout) :: open_basis_wavevectors (number_of_open_basis_levels) array holding wavevectors calculated w.r.t energetically accessible levels in the basis public  subroutine units_conversion () converts all physical quantities to atomic units Arguments None","tags":"","loc":"module/io_mod.html"},{"title":"math_functions_mod – the SCATTERING code","text":"this module holds 3 types of functions:\n-- geometric functions: triangle_inequality_holds and is_sum_even\n-- bessel functions: groups functions: riccati_bessel_j, bessely and modified_bessel_k_ratio\n   that call special functions from special_functions.f90 library\n-- interpolation procedures: spline and ispline functions for interpolating data\n-- additional functions: rctj, rcty, envj, msta1, msta2, ikv, gamma from\n   special_functions library Uses utility_functions_mod special_functions_mod iso_fortran_env module~~math_functions_mod~~UsesGraph module~math_functions_mod math_functions_mod module~utility_functions_mod utility_functions_mod module~math_functions_mod->module~utility_functions_mod module~special_functions_mod special_functions_mod module~math_functions_mod->module~special_functions_mod iso_fortran_env iso_fortran_env module~math_functions_mod->iso_fortran_env module~utility_functions_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~math_functions_mod~~UsedByGraph module~math_functions_mod math_functions_mod module~potential POTENTIAL module~potential->module~math_functions_mod module~propagators PROPAGATORS module~propagators->module~math_functions_mod module~propagators->module~potential module~boundary_conditions_mod boundary_conditions_mod module~boundary_conditions_mod->module~math_functions_mod module~pes_coupling_matrix PES_COUPLING_MATRIX module~pes_coupling_matrix->module~math_functions_mod program~scattering SCATTERING program~scattering->module~potential program~scattering->module~propagators program~scattering->module~boundary_conditions_mod program~scattering->module~pes_coupling_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Functions is_sum_even ispline triangle_inequality_holds Subroutines modified_bessel_k_ratio riccati_bessel_j riccati_bessel_y spline Functions public  function is_sum_even (x, y, z) result(sum_even) checks if the sum of 3 integers is an even integer Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x variables to check if the sum is even integer(kind=int32), intent(in) :: y variables to check if the sum is even integer(kind=int32), intent(in) :: z variables to check if the sum is even Return Value integer(kind=int32) (out) result: 1 = true, 0 = false public  function ispline (u_, N_, x_, y_, b_, c_, d_) result(spl_result) returns interpolated value at guven u_ point\nnumber of points and ascending order of x is not checked since\nispline is called after \"spline\" where these checks are done Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: u_ point at which the tabulated value is interpolated integer(kind=int32), intent(in) :: N_ number of grid points real(kind=dp), intent(in) :: x_ (N_) grid points real(kind=dp), intent(in) :: y_ (N_) tabulated values real(kind=dp), intent(in) :: b_ (N_) arrays with coefficients of the spline function real(kind=dp), intent(in) :: c_ (N_) arrays with coefficients of the spline function real(kind=dp), intent(in) :: d_ (N_) arrays with coefficients of the spline function Return Value real(kind=dp) interpolated value at u_ public  function triangle_inequality_holds (x, y, z) result(triang) check if the triangle inequality for 3 variables hols Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x variables to check the triangle inequality integer(kind=int32), intent(in) :: y variables to check the triangle inequality integer(kind=int32), intent(in) :: z variables to check the triangle inequality Return Value integer(kind=int32) (out) result: 1 = true, 0 = false Subroutines public  subroutine modified_bessel_k_ratio (l_, x_, ratio_) calculates the ratio of the modified Bessel function of the second\nkind K_{l_ + 1/2}(x) and its first derivative (Eq. ...)\nUses ikv function from special_functions.f90 Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: l_ l - order of the function (without the 1/2 factor!) real(kind=dp), intent(in) :: x_ x - argument of the function real(kind=dp), intent(inout) :: ratio_ ratio of the modified Bessel function of the second kind to its derivative public  subroutine riccati_bessel_j (l_, x_, j_, jp_) calculates the Riccati-Bessel function of the first kind and its\nfirst derivative. Calls the rctj function from special_functions.f90 Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: l_ l - order of the Riccati-Bessel function of the first kind real(kind=dp), intent(in) :: x_ x - argument of the Riccati-Bessel function of the first kind real(kind=dp), intent(inout) :: j_ j_{l} (x) - Riccati-Bessel funciton of the first kind real(kind=dp), intent(inout) :: jp_ j_{l}' (x) - derivative of the Riccati-Bessel funciton of the first kind public  subroutine riccati_bessel_y (l_, x_, y_, yp_) calculates the Riccati-Bessel function of the second kind and its\nfirst derivative. Calls the rcty function from special_functions.f90 Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: l_ l - order of the Riccati-Bessel function of the second kind real(kind=dp), intent(in) :: x_ x - argument of the Riccati-Bessel function of the second kind real(kind=dp), intent(inout) :: y_ y_{l} (x) - Riccati-Bessel funciton of the second kind real(kind=dp), intent(inout) :: yp_ y_{l}' (x) - derivative of the Riccati-Bessel funciton of the second kind public  subroutine spline (N_, x_, y_, b_, c_, d_) determines b, c and d coefficients of the cubic spline function\ny(x) = y_i + b_i * dx + c_i * dx&#94;2 + d_i * dx&#94;3,\nwhere dx = x - x_i, and x_i <= x < x_i+1.\nThe algorithm is based on\nGerald, C., and Wheatley, P., \"Applied Numerical Analysis\", Addison-Wesley, 1994. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: N_ number of grid points real(kind=dp), intent(in) :: x_ (N_) grid points (ascending order) real(kind=dp), intent(in) :: y_ (N_) tabulated values real(kind=dp), intent(out) :: b_ (N_) arrays with coefficients of the spline function real(kind=dp), intent(out) :: c_ (N_) arrays with coefficients of the spline function real(kind=dp), intent(out) :: d_ (N_) arrays with coefficients of the spline function","tags":"","loc":"module/math_functions_mod.html"},{"title":"POTENTIAL – the SCATTERING code","text":"this module provides functions for reading and interpolating radial coupling\n coefficients of the PES:\n 1. potential_read: reads radial coupling terms from external file\n 2. potential_reduction: reduces the number of radial terms that couple\n    different rovibrational levels to a smaller number of terms that\n    describe the couplings between the levels provided in the basis\n 3. potential_interpolation: cubic spline interpolation of the coupling terms\n--------------------------------------------------------------------------! Uses utility_functions_mod math_functions_mod io_mod iso_fortran_env module~~potential~~UsesGraph module~potential POTENTIAL module~utility_functions_mod utility_functions_mod module~potential->module~utility_functions_mod iso_fortran_env iso_fortran_env module~potential->iso_fortran_env module~math_functions_mod math_functions_mod module~potential->module~math_functions_mod module~io_mod io_mod module~potential->module~io_mod module~utility_functions_mod->iso_fortran_env module~math_functions_mod->module~utility_functions_mod module~math_functions_mod->iso_fortran_env module~special_functions_mod special_functions_mod module~math_functions_mod->module~special_functions_mod module~io_mod->module~utility_functions_mod module~io_mod->iso_fortran_env module~array_operations_mod array_operations_mod module~io_mod->module~array_operations_mod module~array_operations_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~potential~~UsedByGraph module~potential POTENTIAL module~propagators PROPAGATORS module~propagators->module~potential program~scattering SCATTERING program~scattering->module~potential program~scattering->module~propagators Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines potential_interpolation potential_read potential_reduction Subroutines public  subroutine potential_interpolation () intertpolates the necessary radial coupling terms using cubic\nspline functions. The coefficients are kept in bmat/cmat/dmat matrices Arguments None public  subroutine potential_read () reads the radial coupling terms from the external file.\nThe file is assumed to be formatted as follows:\nR, V_{l1,v1,j1,v1',j1'}(R) \nThe read radial coupling terms are kept in vmat/read_vmat3D Arguments None public  subroutine potential_reduction () reducesof the read_vmat3D matrix to retain only the necessary coupling terms\nwhich are kept in reduced_*. The number of necessary coupling terms (ncoupl)\nis already determined in io_mod module.\nIf totalcol = ncoupl, the procedure is ignored Arguments None","tags":"","loc":"module/potential.html"},{"title":"array_operations_mod – the SCATTERING code","text":"this module provides supplementary functions and subroutines to handle\nmatrix allocation, invertion, appending etc. Uses iso_fortran_env module~~array_operations_mod~~UsesGraph module~array_operations_mod array_operations_mod iso_fortran_env iso_fortran_env module~array_operations_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: array_operations_allocate_submod array_operations_append_submod array_operations_fill_symmetric_matrix_submod array_operations_invert_symmetric_matrix_submod module~~array_operations_mod~~UsedByGraph module~array_operations_mod array_operations_mod module~io_mod io_mod module~io_mod->module~array_operations_mod module~array_operations_invert_symmetric_matrix_submod array_operations_invert_symmetric_matrix_submod module~array_operations_invert_symmetric_matrix_submod->module~array_operations_mod module~boundary_conditions_mod boundary_conditions_mod module~boundary_conditions_mod->module~array_operations_mod module~boundary_conditions_mod->module~io_mod program~scattering SCATTERING program~scattering->module~array_operations_mod program~scattering->module~io_mod program~scattering->module~boundary_conditions_mod module~propagators PROPAGATORS program~scattering->module~propagators module~potential POTENTIAL program~scattering->module~potential module~channels_mod channels_mod program~scattering->module~channels_mod module~statetostatexs statetostateXS program~scattering->module~statetostatexs module~pes_coupling_matrix PES_COUPLING_MATRIX program~scattering->module~pes_coupling_matrix module~array_operations_allocate_submod array_operations_allocate_submod module~array_operations_allocate_submod->module~array_operations_mod module~array_operations_fill_symmetric_matrix_submod array_operations_fill_symmetric_matrix_submod module~array_operations_fill_symmetric_matrix_submod->module~array_operations_mod module~propagators->module~array_operations_mod module~propagators->module~io_mod module~propagators->module~potential module~array_operations_append_submod array_operations_append_submod module~array_operations_append_submod->module~array_operations_mod module~potential->module~io_mod module~channels_mod->module~io_mod module~statetostatexs->module~io_mod module~pes_coupling_matrix->module~io_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces allocate_1d allocate_2d allocate_3d append fill_symmetric_matrix invert_symmetric_matrix Interfaces public        interface allocate_1d public pure module subroutine allocate_1d_dp(array_, size_) allocate a 1d array and fill it with 0s (double precision version) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), allocatable :: array_ (:) integer(kind=int32), intent(in) :: size_ public pure module subroutine allocate_1d_int32(array_, size_) allocate a 1d array and fill it with 0s (integer version) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), allocatable :: array_ (:) integer(kind=int32), intent(in) :: size_ public pure module subroutine allocate_1d_sp(array_, size_) allocate a 1d array and fill it with 0s (single precision version) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout), allocatable :: array_ (:) integer(kind=int32), intent(in) :: size_ public        interface allocate_2d public pure module subroutine allocate_2d_dp(array_, size1_, size2_) allocate a 2d array and fill it with 0s (double precision version) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), allocatable :: array_ (:,:) integer(kind=int32), intent(in) :: size1_ integer(kind=int32), intent(in) :: size2_ public pure module subroutine allocate_2d_int32(array_, size1_, size2_) allocate a 2d array and fill it with 0s (integer version) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), allocatable :: array_ (:,:) integer(kind=int32), intent(in) :: size1_ integer(kind=int32), intent(in) :: size2_ public pure module subroutine allocate_2d_sp(array_, size1_, size2_) allocate a 2d array and fill it with 0s (single precision version) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout), allocatable :: array_ (:,:) integer(kind=int32), intent(in) :: size1_ integer(kind=int32), intent(in) :: size2_ public        interface allocate_3d public pure module subroutine allocate_3d_dp(array_, size1_, size2_, size3_) allocate a 3d array and fill it with 0s (double precision version) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), allocatable :: array_ (:,:,:) integer(kind=int32), intent(in) :: size1_ integer(kind=int32), intent(in) :: size2_ integer(kind=int32), intent(in) :: size3_ public pure module subroutine allocate_3d_int32(array_, size1_, size2_, size3_) allocate a 3d array and fill it with 0s (integer version) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), allocatable :: array_ (:,:,:) integer(kind=int32), intent(in) :: size1_ integer(kind=int32), intent(in) :: size2_ integer(kind=int32), intent(in) :: size3_ public pure module subroutine allocate_3d_sp(array_, size1_, size2_, size3_) allocate a 3d array and fill it with 0s (single precision version) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout), allocatable :: array_ (:,:,:) integer(kind=int32), intent(in) :: size1_ integer(kind=int32), intent(in) :: size2_ integer(kind=int32), intent(in) :: size3_ public        interface append public pure module subroutine append_dp(array_, element_) append element to an array (double precision version) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), allocatable :: array_ (:) real(kind=dp), intent(in) :: element_ public pure module subroutine append_int32(array_, element_) append element to an array (integer version) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), allocatable :: array_ (:) integer(kind=int32), intent(in) :: element_ public pure module subroutine append_sp(array_, element_) append element to an array (single precision version) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout), allocatable :: array_ (:) real(kind=sp), intent(in) :: element_ public        interface fill_symmetric_matrix public module subroutine fill_symmetric_matrix_dp(matrix_, upper_lower_) fill the upper/lower triangle of a symmetric matrix (double precision version) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: matrix_ (:,:) character(len=1), intent(in) :: upper_lower_ public module subroutine fill_symmetric_matrix_int32(matrix_, upper_lower_) fill the upper/lower triangle of a symmetric matrix (integer version) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: matrix_ (:,:) character(len=1), intent(in) :: upper_lower_ public module subroutine fill_symmetric_matrix_sp(matrix_, upper_lower_) fill the upper/lower triangle of a symmetric matrix (single precision version) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: matrix_ (:,:) character(len=1), intent(in) :: upper_lower_ public        interface invert_symmetric_matrix public module subroutine invert_symmetric_matrix_dp(matrix_) invert a symmetric matrix using DSYTRI method (double precision version) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: matrix_ (:,:) public module subroutine invert_symmetric_matrix_int32(matrix_) invert a symmetric matrix using DSYTRI method (integer version) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: matrix_ (:,:) public module subroutine invert_symmetric_matrix_sp(matrix_) invert a symmetric matrix using DSYTRI method (single precision version) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: matrix_ (:,:)","tags":"","loc":"module/array_operations_mod.html"},{"title":"PES_COUPLING_MATRIX – the SCATTERING code","text":"this module provides functions calculating the algebraic coefficients\nentering the coupling matrix (Eq. ...) Uses math_functions_mod io_mod iso_fortran_env fwigxjpf utility_functions_mod module~~pes_coupling_matrix~~UsesGraph module~pes_coupling_matrix PES_COUPLING_MATRIX fwigxjpf fwigxjpf module~pes_coupling_matrix->fwigxjpf iso_fortran_env iso_fortran_env module~pes_coupling_matrix->iso_fortran_env module~io_mod io_mod module~pes_coupling_matrix->module~io_mod module~utility_functions_mod utility_functions_mod module~pes_coupling_matrix->module~utility_functions_mod module~math_functions_mod math_functions_mod module~pes_coupling_matrix->module~math_functions_mod module~io_mod->iso_fortran_env module~io_mod->module~utility_functions_mod module~array_operations_mod array_operations_mod module~io_mod->module~array_operations_mod module~utility_functions_mod->iso_fortran_env module~math_functions_mod->iso_fortran_env module~math_functions_mod->module~utility_functions_mod module~special_functions_mod special_functions_mod module~math_functions_mod->module~special_functions_mod module~array_operations_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~pes_coupling_matrix~~UsedByGraph module~pes_coupling_matrix PES_COUPLING_MATRIX program~scattering SCATTERING program~scattering->module~pes_coupling_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines check_nonzero_coupling_matrix_elements prepare_coupling_matrix_elements print_coupling_matrix_elements_summary Subroutines public  subroutine check_nonzero_coupling_matrix_elements (number_of_channels, channels_level_indices, channels_omega_values, number_of_nonzero_coupling_matrix_elements, number_of_nonzero_coupling_coefficients) checks the number of non-zero coupling matrix elements due to\nthe \\bar{\\Omega} = \\bar{\\Omega}' condition\n(number_of_nonzero_coupling_matrix_elements variable),\nand the total number of non-zero algebraic coefficients that enter\nEqs. (6.13)-(6.15) (number_of_nonzero_coupling_coefficients variable). Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: number_of_channels size of the basis integer(kind=int32), intent(in) :: channels_level_indices (number_of_channels) holds the indices pointing to the basis arrays integer(kind=int32), intent(in) :: channels_omega_values (number_of_channels) holds all values of \\bar{\\Omega} integer(kind=int32), intent(out) :: number_of_nonzero_coupling_matrix_elements number of non-zero terms in the sum () for each non-zero element of the coupling matrix integer(kind=int32), intent(out) :: number_of_nonzero_coupling_coefficients number of all non-zero algberaix coefficients in the whole coupling matrix public  subroutine prepare_coupling_matrix_elements (number_of_channels, channels_level_indices, channels_omega_values, number_of_nonzero_coupling_matrix_elements, number_of_nonzero_coupling_coefficients, nonzero_terms_per_element, nonzero_legendre_indices, nonzero_coupling_coefficients) -- nonzero_terms_per_element - keeps the number of\n   non-zero terms in the sum (Eq. (6.21)) for each non-zero matrix\n   element of the coupling matrix\n-- nonzero_legendre_indices - holds the proper\n   indices in the range (0, nterms) pointing to l1/l2/lltabs, which\n   correspond to the non-vanishing elements of the sum (Eq. (6.21))\n   for each non-zero  matrix element of the coupling matrix\n-- nonzero_coupling_coefficients --  holds values of non-zero Percival-Seaton coefficients Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: number_of_channels size of the basis integer(kind=int32), intent(in) :: channels_level_indices (number_of_channels) holds the indices pointing to the basis arrays integer(kind=int32), intent(in) :: channels_omega_values (number_of_channels) holds all values of \\bar{\\Omega} integer(kind=int32), intent(in) :: number_of_nonzero_coupling_matrix_elements number of non-zero terms in the sum () for each non-zero element of the coupling matrix integer(kind=int32), intent(in) :: number_of_nonzero_coupling_coefficients number of all non-zero algberaix coefficients in the whole coupling matrix integer(kind=int32), intent(inout) :: nonzero_terms_per_element (number_of_nonzero_coupling_matrix_elements) keeps the number of non-zero terms in the sum (Eq. (6.21)) for\neach non-zero element of the coupling matrix integer(kind=int32), intent(inout) :: nonzero_legendre_indices (number_of_nonzero_coupling_coefficients) holds proper indices pointing to l1tab, which\ncorrespond to the non-vanishing elements of the sum  (Eq. (6.21))\nfor each non-zero element of the coupling matrix real(kind=dp), intent(inout) :: nonzero_coupling_coefficients (number_of_nonzero_coupling_coefficients) holds the values of the non-zero algebraic coefficients public  subroutine print_coupling_matrix_elements_summary (number_of_channels, number_of_nonzero_coupling_matrix_elements, number_of_nonzero_coupling_coefficients) print a shor summary on the number of non-zero matrix elements\nof the coupling matrix Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: number_of_channels size of the basis integer(kind=int32), intent(in) :: number_of_nonzero_coupling_matrix_elements number of non-zero terms in the sum () for each non-zero element\nof the coupling matrix integer(kind=int32), intent(in) :: number_of_nonzero_coupling_coefficients number of all non-zero algberaix coefficients in the whole\ncoupling matrix","tags":"","loc":"module/pes_coupling_matrix.html"},{"title":"statetostateXS – the SCATTERING code","text":"This modules contains the subroutine that calculates the state-to-state XS Uses utility_functions_mod io_mod iso_fortran_env module~~statetostatexs~~UsesGraph module~statetostatexs statetostateXS module~utility_functions_mod utility_functions_mod module~statetostatexs->module~utility_functions_mod iso_fortran_env iso_fortran_env module~statetostatexs->iso_fortran_env module~io_mod io_mod module~statetostatexs->module~io_mod module~utility_functions_mod->iso_fortran_env module~io_mod->module~utility_functions_mod module~io_mod->iso_fortran_env module~array_operations_mod array_operations_mod module~io_mod->module~array_operations_mod module~array_operations_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~statetostatexs~~UsedByGraph module~statetostatexs statetostateXS program~scattering SCATTERING program~scattering->module~statetostatexs Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines CROSSSECTION check_dtol_otol print_largest_partial_xs Subroutines public  subroutine CROSSSECTION (jj, nopen, number_of_channels, number_of_open_basis_levels, open_basis_levels, open_basis_wavevectors, srmatrix, simatrix, channels_level_indices, channels_l_values, xs_array) calculate the state-to-state cross-section Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: jj total angular momentum integer(kind=int32), intent(in) :: nopen number of open channels integer(kind=int32), intent(in) :: number_of_channels size of the basis integer(kind=int32), intent(in) :: number_of_open_basis_levels number of all possible state-to-state XS integer(kind=int32), intent(in) :: open_basis_levels (number_of_open_basis_levels) holds indices to the basis arrays which correspond to open channels real(kind=dp), intent(in) :: open_basis_wavevectors (number_of_open_basis_levels) holds wavenumbers k_{i} real(kind=dp), intent(in) :: srmatrix (nopen,nopen) real and imaginary parts of the S-matrix real(kind=dp), intent(in) :: simatrix (nopen,nopen) real and imaginary parts of the S-matrix integer(kind=int32), intent(in) :: channels_level_indices (number_of_channels) holds the indices pointing to the basis arrays integer(kind=int32), intent(in) :: channels_l_values (number_of_channels) holds all values of l real(kind=dp), intent(inout) :: xs_array (number_of_open_basis_levels*number_of_open_basis_levels) array holding all XSs public  subroutine check_dtol_otol (maxXSdiag, maxXSoff, ncacdiag, ncacoff, terminate) check if the dtol/otol condition on partial XS is already fulfilled Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: maxXSdiag largest elastic and inelastic XS real(kind=dp), intent(in) :: maxXSoff largest elastic and inelastic XS integer(kind=int32), intent(inout) :: ncacdiag number of consecutive blocks for which dtol/otol condition is already\nfulfilled. Gets incremented within the subroutine integer(kind=int32), intent(inout) :: ncacoff number of consecutive blocks for which dtol/otol condition is already\nfulfilled. Gets incremented within the subroutine logical, intent(inout) :: terminate if .true. the dtol/otol condition is fulfilled;\nJ-tot loop is terminated public  subroutine print_largest_partial_xs (jj, maxXSdiag, maxXSoff, jinddiag, jindoff1, jindoff2, number_of_open_basis_levels, open_basis_levels) print the largest partial elastic and inelastic state-to-state XS\nin given J-block Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: jj total angular momentum real(kind=dp), intent(in) :: maxXSdiag the largest partial elastic state-to-state XS in this J-block real(kind=dp), intent(in) :: maxXSoff the largest partial inelastic state-to-state XS in this J-block integer(kind=int32), intent(in) :: jinddiag index pointing indirectly to quantum numbers associated with\nthe largest partial elastic state-to-state XS in this J-block integer(kind=int32), intent(in) :: jindoff1 indices pointing indirectly to quantum numbers associated with\nthe largest partial inelastic state-to-state XS in this J-block integer(kind=int32), intent(in) :: jindoff2 indices pointing indirectly to quantum numbers associated with\nthe largest partial inelastic state-to-state XS in this J-block integer(kind=int32), intent(in) :: number_of_open_basis_levels number of all possible state-to-state XS (size of open_basis_levels array) integer(kind=int32), intent(in) :: open_basis_levels (number_of_open_basis_levels) holds indices to the basis arrays which correspond to open channels","tags":"","loc":"module/statetostatexs.html"},{"title":"boundary_conditions_mod – the SCATTERING code","text":"This module contains subroutines that transform the asymptotic\nlog-derivative matrix into the scattering S-matrix:\n1. pfunc      - calculates the P coefficients from Eq. (6.19)\n2. transsum   - calculates the sum over \\bar{\\Omega} in Eq. (6.17-6.18)\n3. bftosfmat  - transforms a given BF-matrix to the SF frame of rerence\n4. calculate_k_matrix - transforms log-derivative matrix into reactance matrix kmattosmat - transfroms reactance matrix into scattering S-matrix Uses math_functions_mod io_mod iso_fortran_env fwigxjpf utility_functions_mod array_operations_mod module~~boundary_conditions_mod~~UsesGraph module~boundary_conditions_mod boundary_conditions_mod fwigxjpf fwigxjpf module~boundary_conditions_mod->fwigxjpf iso_fortran_env iso_fortran_env module~boundary_conditions_mod->iso_fortran_env module~io_mod io_mod module~boundary_conditions_mod->module~io_mod module~utility_functions_mod utility_functions_mod module~boundary_conditions_mod->module~utility_functions_mod module~math_functions_mod math_functions_mod module~boundary_conditions_mod->module~math_functions_mod module~array_operations_mod array_operations_mod module~boundary_conditions_mod->module~array_operations_mod module~io_mod->iso_fortran_env module~io_mod->module~utility_functions_mod module~io_mod->module~array_operations_mod module~utility_functions_mod->iso_fortran_env module~math_functions_mod->iso_fortran_env module~math_functions_mod->module~utility_functions_mod module~special_functions_mod special_functions_mod module~math_functions_mod->module~special_functions_mod module~array_operations_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~boundary_conditions_mod~~UsedByGraph module~boundary_conditions_mod boundary_conditions_mod program~scattering SCATTERING program~scattering->module~boundary_conditions_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Functions p_coeff Subroutines bf_to_sf_transformation calculate_k_matrix calculate_s_matrix transform_summation unitarity_check Functions public  function p_coeff (jtot_, j_, l_, omega_) result(p_coeff_) calculates the P coefficients from Eq. (6.19) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: jtot_ total angular momentum integer(kind=int32), intent(in) :: j_ rotational quantum number integer(kind=int32), intent(in) :: l_ orbital angular momentum integer(kind=int32), intent(in) :: omega_ projection of j on the BF-Z axis Return Value real(kind=dp) result (...) Subroutines public  subroutine bf_to_sf_transformation (number_of_channels, jtot_, channels_level_indices, channels_omega_values, channels_l_values, bf_matrix, sf_matrix) takes an input matrix in the BF-frame and transforms it to\nthe SF-frame; calls transsum and pfunc Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: number_of_channels size of the basis integer(kind=int32), intent(in) :: jtot_ total angular momentum integer(kind=int32), intent(in) :: channels_level_indices (number_of_channels) holds the indices pointing to the basis arrays integer(kind=int32), intent(in) :: channels_omega_values (number_of_channels) holds all values of \\bar{\\Omega} integer(kind=int32), intent(in) :: channels_l_values (number_of_channels) holds all values of l real(kind=dp), intent(in) :: bf_matrix (number_of_channels,number_of_channels) matrix in the BF frame real(kind=dp), intent(inout) :: sf_matrix (number_of_channels,number_of_channels) (output) matrix in the SF frame public  subroutine calculate_k_matrix (number_of_channels, log_der_matrix, number_of_open_channels, channels_level_indices, channels_l_values, r_, k_matrix) implementation of Eq. 6.53 Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: number_of_channels y-matrix is of number_of_channels x number_of_channels size real(kind=dp), intent(in) :: log_der_matrix (number_of_channels,number_of_channels) asymptotic log-derivative matrix integer(kind=int32), intent(in) :: number_of_open_channels number of open channels integer(kind=int32), intent(in) :: channels_level_indices (number_of_channels) holds the indices pointing to the basis arrays integer(kind=int32), intent(in) :: channels_l_values (number_of_channels) holds all values of l real(kind=dp), intent(in) :: r_ Rmax real(kind=dp), intent(inout) :: k_matrix (number_of_open_channels,number_of_open_channels) K-matrix public  subroutine calculate_s_matrix (number_of_open_channels, k_matrix, s_matrix_real, s_matrix_imag) implementation of Eq. 6.57 Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: number_of_open_channels number of open channels real(kind=dp), intent(in) :: k_matrix (number_of_open_channels,number_of_open_channels) K-matrix real(kind=dp), intent(inout) :: s_matrix_real (number_of_open_channels,number_of_open_channels) (output) real part of the S-matrix real(kind=dp), intent(inout) :: s_matrix_imag (number_of_open_channels,number_of_open_channels) (output) imaginary part of the S-matrix public  subroutine transform_summation (number_of_channels, jtot_, v_, j_, vp_, jp_, l_, lp_, channels_level_indices, channels_omega_values, bf_matrix, sf_element) performs the summation in Eqs. (6.17) and (6.18) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: number_of_channels size of the basis integer(kind=int32), intent(in) :: jtot_ total angular momentum integer(kind=int32), intent(in) :: v_ vibrational and rotational quantum numbers integer(kind=int32), intent(in) :: j_ vibrational and rotational quantum numbers integer(kind=int32), intent(in) :: vp_ vibrational and rotational quantum numbers integer(kind=int32), intent(in) :: jp_ vibrational and rotational quantum numbers integer(kind=int32), intent(in) :: l_ orbital angular momenta integer(kind=int32), intent(in) :: lp_ orbital angular momenta integer(kind=int32), intent(in) :: channels_level_indices (number_of_channels) holds the indices pointing to the basis arrays integer(kind=int32), intent(in) :: channels_omega_values (number_of_channels) holds all values of \\bar{\\Omega} real(kind=dp), intent(in) :: bf_matrix (number_of_channels,number_of_channels) matrix in the BF frame real(kind=dp), intent(out) :: sf_element (output) matrix element in the SF frame public  subroutine unitarity_check (number_of_open_channels, s_matrix_real, s_matrix_imag, totalcheck) checks the unitarity of the S-matrix (Eq. 6.15) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: number_of_open_channels number of open channels real(kind=dp), intent(in) :: s_matrix_real (number_of_open_channels,number_of_open_channels) real part of the S-matrix real(kind=dp), intent(in) :: s_matrix_imag (number_of_open_channels,number_of_open_channels) imaginary part of the S-matrix logical, intent(inout) :: totalcheck (output) if .true. unitary is fulfilled, .false. otherwise","tags":"","loc":"module/boundary_conditions_mod.html"},{"title":"PROPAGATORS – the SCATTERING code","text":"this modules contains the subroutines used by the propagator:\n1. cenitrfugal_matrix - prepares the centrifugal term (Eq. (6.19))\n2. pes_contribution   - prepares the interaction energy term (Eq. (6.21))\n3. radtermvalue - returns the value of a radial coupling term at given R\n4. calculate_log_der_matrix - calculates the log-derivative matrix (Eq. 6.29)\n5. pes_diagonalization - diagonalizes the coupling matrix from rmin to rmax\n6. numerov - renormalized Numerov's algorithm Uses math_functions_mod POTENTIAL io_mod iso_fortran_env array_operations_mod module~~propagators~~UsesGraph module~propagators PROPAGATORS module~potential POTENTIAL module~propagators->module~potential iso_fortran_env iso_fortran_env module~propagators->iso_fortran_env module~io_mod io_mod module~propagators->module~io_mod module~array_operations_mod array_operations_mod module~propagators->module~array_operations_mod module~math_functions_mod math_functions_mod module~propagators->module~math_functions_mod module~potential->iso_fortran_env module~potential->module~io_mod module~potential->module~math_functions_mod module~utility_functions_mod utility_functions_mod module~potential->module~utility_functions_mod module~io_mod->iso_fortran_env module~io_mod->module~array_operations_mod module~io_mod->module~utility_functions_mod module~array_operations_mod->iso_fortran_env module~math_functions_mod->iso_fortran_env module~math_functions_mod->module~utility_functions_mod module~special_functions_mod special_functions_mod module~math_functions_mod->module~special_functions_mod module~utility_functions_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~propagators~~UsedByGraph module~propagators PROPAGATORS program~scattering SCATTERING program~scattering->module~propagators Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines RADTERMVALUE calculate_log_der_matrix cenitrfugal_matrix numerov pes_contribution Subroutines public  subroutine RADTERMVALUE (rr, l1, v1, j1, v1p, j1p, v) returns the value of a specific radial coupling term at rr Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: rr intermolecular distance integer(kind=int32), intent(in) :: l1 Legendre expansion index integer(kind=int32), intent(in) :: v1 rovibrational quantum numbers integer(kind=int32), intent(in) :: j1 rovibrational quantum numbers integer(kind=int32), intent(in) :: v1p rovibrational quantum numbers integer(kind=int32), intent(in) :: j1p rovibrational quantum numbers real(kind=dp), intent(out) :: v value of the radial coupling coefficient public  subroutine calculate_log_der_matrix (h, y_dim, tt_min, tt_n, tt_plus, r_n, r_plus, log_der_matrix) calculates the log-derivative matrix from Eq. (6.29)\ncalled by numerov and log_derivative at the end of the propagation Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: h step of the propagation integer(kind=int32), intent(in) :: y_dim dimension of the log-derivative matrix real(kind=dp), intent(in) :: tt_min (y_dim,y_dim) T-matrix at R_{max - 1} real(kind=dp), intent(in) :: tt_n (y_dim,y_dim) T-matrix at R_{max} real(kind=dp), intent(in) :: tt_plus (y_dim,y_dim) T-matrix at R_{max + 1} real(kind=dp), intent(in) :: r_n (y_dim,y_dim) R-matrix at R_{max} real(kind=dp), intent(in) :: r_plus (y_dim,y_dim) R-matrix at R_{max + 1} real(kind=dp), intent(inout) :: log_der_matrix (y_dim,y_dim) log-derivative matrix public  subroutine cenitrfugal_matrix (number_of_channels, jj, channels_level_indices, channels_omega_values, centmatrix) calculates the (R* 2) centrifugal matrix from Eq. (6.19)\nonly called once at the beginning of the calculations Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: number_of_channels size of the basis integer(kind=int32), intent(in) :: jj total angular momentum integer(kind=int32), intent(in) :: channels_level_indices (number_of_channels) holds the indices pointing to the basis arrays integer(kind=int32), intent(in) :: channels_omega_values (number_of_channels) holds all values of \\bar{\\Omega} real(kind=dp), intent(out) :: centmatrix (number_of_channels,number_of_channels) (output) - (R* 2) centrifugal matrix public  subroutine numerov (channels_level_indices, channels_omega_values, number_of_nonzero_coupling_matrix_elements, number_of_nonzero_coupling_coefficients, nonzero_terms_per_element, nonzero_legendre_indices, nonzero_coupling_coefficients, nsteps, number_of_channels, jj, log_der_matrix) renormalized Numerov propagator Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: channels_level_indices (number_of_channels) holds the indices pointing to the basis arrays integer(kind=int32), intent(in) :: channels_omega_values (number_of_channels) holds all values of \\bar{\\Omega} integer(kind=int32), intent(in) :: number_of_nonzero_coupling_matrix_elements number of non-zero terms in the sum () for each non-zero element of the coupling matrix integer(kind=int32), intent(in) :: number_of_nonzero_coupling_coefficients number of all non-zero algberaix coefficients in the whole coupling matrix integer(kind=int32), intent(in) :: nonzero_terms_per_element (number_of_nonzero_coupling_matrix_elements) keeps the number of non-zero terms in the sum (Eq. (6.21)) for\neach non-zero element of W/V integer(kind=int32), intent(in) :: nonzero_legendre_indices (number_of_nonzero_coupling_coefficients) holds the proper indices pointing to l1/l2/lltabs, which\ncorrespond to the non-vanishing elements of the sum  (Eq. (6.21))\nfor each non-zero element of W/V real(kind=dp), intent(in) :: nonzero_coupling_coefficients (number_of_nonzero_coupling_coefficients) holds the values of the non-zero algebraic coefficients integer(kind=int32), intent(in) :: nsteps number of steps from rmin to rmax integer(kind=int32), intent(in) :: number_of_channels size of the basis integer(kind=int32), intent(in) :: jj total angular momentum real(kind=dp), intent(inout) :: log_der_matrix (:,:) resulting log-derivative matrix at RMAX public  subroutine pes_contribution (number_of_channels, jj, r, channels_level_indices, channels_omega_values, number_of_nonzero_coupling_matrix_elements, number_of_nonzero_coupling_coefficients, nonzero_terms_per_element, nonzero_legendre_indices, nonzero_coupling_coefficients, vmatrix) calculates the contribution from the PES in (X) at given R Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: number_of_channels size of the basis integer(kind=int32), intent(in) :: jj total angular momentum real(kind=dp), intent(in) :: r intermolecular distance integer(kind=int32), intent(in) :: channels_level_indices (number_of_channels) holds the indices pointing to the basis arrays integer(kind=int32), intent(in) :: channels_omega_values (number_of_channels) holds all values of \\bar{\\Omega} integer(kind=int32), intent(in) :: number_of_nonzero_coupling_matrix_elements number of non-zero terms in the sum () for each non-zero element of the coupling matrix integer(kind=int32), intent(in) :: number_of_nonzero_coupling_coefficients number of all non-zero algberaix coefficients in the whole coupling matrix integer(kind=int32), intent(in) :: nonzero_terms_per_element (number_of_nonzero_coupling_matrix_elements) keeps the number of non-zero terms in the sum (Eq. (6.21)) for\neach non-zero element of W/V integer(kind=int32), intent(in) :: nonzero_legendre_indices (number_of_nonzero_coupling_coefficients) holds the proper indices pointing to l1/l2/lltabs, which\ncorrespond to the non-vanishing elements of the sum  (Eq. (6.21))\nfor each non-zero element of W/V real(kind=dp), intent(in) :: nonzero_coupling_coefficients (number_of_nonzero_coupling_coefficients) holds the values of the non-zero algebraic coefficients real(kind=dp), intent(out) :: vmatrix (number_of_channels,number_of_channels) (output) - the PES contribution to the coupling matrix","tags":"","loc":"module/propagators.html"},{"title":"utility_functions_mod – the SCATTERING code","text":"utility_functions_mod contains functions which handle writing \nmessages/errors/warnings on screen, formatting headers, summary of the \ncalculations and a few other supporting functions. Uses iso_fortran_env module~~utility_functions_mod~~UsesGraph module~utility_functions_mod utility_functions_mod iso_fortran_env iso_fortran_env module~utility_functions_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~utility_functions_mod~~UsedByGraph module~utility_functions_mod utility_functions_mod module~io_mod io_mod module~io_mod->module~utility_functions_mod module~potential POTENTIAL module~potential->module~utility_functions_mod module~potential->module~io_mod module~math_functions_mod math_functions_mod module~potential->module~math_functions_mod module~channels_mod channels_mod module~channels_mod->module~utility_functions_mod module~channels_mod->module~io_mod module~boundary_conditions_mod boundary_conditions_mod module~boundary_conditions_mod->module~utility_functions_mod module~boundary_conditions_mod->module~io_mod module~boundary_conditions_mod->module~math_functions_mod module~pes_coupling_matrix PES_COUPLING_MATRIX module~pes_coupling_matrix->module~utility_functions_mod module~pes_coupling_matrix->module~io_mod module~pes_coupling_matrix->module~math_functions_mod module~array_operations_fill_symmetric_matrix_submod array_operations_fill_symmetric_matrix_submod module~array_operations_fill_symmetric_matrix_submod->module~utility_functions_mod program~scattering SCATTERING program~scattering->module~utility_functions_mod program~scattering->module~io_mod program~scattering->module~potential program~scattering->module~channels_mod program~scattering->module~boundary_conditions_mod program~scattering->module~pes_coupling_matrix module~statetostatexs statetostateXS program~scattering->module~statetostatexs module~propagators PROPAGATORS program~scattering->module~propagators module~statetostatexs->module~utility_functions_mod module~statetostatexs->module~io_mod module~math_functions_mod->module~utility_functions_mod module~propagators->module~io_mod module~propagators->module~potential module~propagators->module~math_functions_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces incorrect_value Functions float_to_character integer_to_character to_lowercase Subroutines alloc_status file_io_status time_count_summary write_error write_header write_message write_warning Interfaces public        interface incorrect_value interface for the following message: incorrect value encountered:\n  variable_name = variable_value private  subroutine incorrect_value_ch(name_, value_, unit_) incorrect value encountered:\n  variable_name = variable_value Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name_ name of the variable character(len=*), intent(in) :: value_ value of the variable integer(kind=int32), intent(in), optional :: unit_ optional, unit where the message will be written private  subroutine incorrect_value_int32(name_, value_, unit_) incorrect value encountered:\n  variable_name = variable_value Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name_ name of the variable integer(kind=int32), intent(in) :: value_ value of the variable integer(kind=int32), intent(in), optional :: unit_ optional, unit where the message will be written private  subroutine incorrect_value_sp(name_, value_, unit_) incorrect value encountered:\n  variable_name = variable_value Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name_ name of the variable real(kind=sp), intent(in) :: value_ value of the variable integer(kind=int32), intent(in), optional :: unit_ optional, unit where the message will be written private  subroutine incorrect_value_dp(name_, value_, unit_) incorrect value encountered:\n  variable_name = variable_value Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name_ name of the variable real(kind=dp), intent(in) :: value_ value of the variable integer(kind=int32), intent(in), optional :: unit_ optional, unit where the message will be written Functions public  function float_to_character (f, format_string) result(res) Converts a floating-point number to a character string. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: f input floating-point number character(len=*), intent(in), optional :: format_string Optional format string. Return Value character(len=64) Output character string. public  function integer_to_character (i) result(res) transfers integer to a character Arguments Type Intent Optional Attributes Name integer, intent(in) :: i input integer Return Value character(len=32) output character public  function to_lowercase (str) result(low_str) forces lowercase on given string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str input string Return Value character(len=len) output (lowercase) string Subroutines public  subroutine alloc_status (istat_, message_, op_, unit_) check the status after allocation Arguments Type Intent Optional Attributes Name integer(kind=int32) :: istat_ result of stat=istat in (de)allocate character(len=*), intent(in) :: message_ a message to be written character(len=1), intent(in) :: op_ 'a' for allocation, 'd' for deallocation integer(kind=int32), intent(in), optional :: unit_ optional, unit where the message will be written public  subroutine file_io_status (istat_, iomsg_, channel_, op_, unit_) check the status during various io operations on files Arguments Type Intent Optional Attributes Name integer(kind=int32) :: istat_ result of iostat in open/read/write/close character(len=*), intent(in) :: iomsg_ result of iomsg in open/read/write/close integer(kind=int32), intent(in) :: channel_ name of the file character(len=1), intent(in) :: op_ 'o' for opening of the file, 'r' for reading, 'w' for writing,\n'c' for closing integer(kind=int32), intent(in), optional :: unit_ optional, unit where the message will be written public  subroutine time_count_summary (start_, stop_, time_, message_) print the message about the time it took to complete a single task Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: start_ initial time real(kind=dp), intent(in) :: stop_ final time real(kind=dp), intent(out) :: time_ stop_ - start_ character(len=*), intent(in), optional :: message_ (optional) a message to print instead of a default\n\"Completed in ... s\" public  subroutine write_error (message_, unit_) writes an error message on a chosen unit Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message_ a message to be written integer(kind=int32), intent(in), optional :: unit_ optional, unit where the message will be written public  subroutine write_header (header_type, opt_integer_) writes headers on screen Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: header_type specifies the type of the header: 'main', 'input_read',\n'input_check', 'input_summary', 'initialization', 'check_norm',\n'save_basis', 'save_pes', 'radial_terms', 'save_radial_terms',\n'reconstruction' integer(kind=int32), intent(in), optional :: opt_integer_ optional integer used in case \"block\" to pass jtot value public  subroutine write_message (message_, unit_) writes a message on a chosen unit Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message_ a message to be written integer(kind=int32), intent(in), optional :: unit_ optional, unit where the message will be written public  subroutine write_warning (message_, unit_) writes a warning message on a chosen unit Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message_ a message to be written integer(kind=int32), intent(in), optional :: unit_ optional, unit where the message will be written","tags":"","loc":"module/utility_functions_mod.html"},{"title":"channels_mod – the SCATTERING code","text":"Uses utility_functions_mod io_mod iso_fortran_env module~~channels_mod~~UsesGraph module~channels_mod channels_mod module~utility_functions_mod utility_functions_mod module~channels_mod->module~utility_functions_mod iso_fortran_env iso_fortran_env module~channels_mod->iso_fortran_env module~io_mod io_mod module~channels_mod->module~io_mod module~utility_functions_mod->iso_fortran_env module~io_mod->module~utility_functions_mod module~io_mod->iso_fortran_env module~array_operations_mod array_operations_mod module~io_mod->module~array_operations_mod module~array_operations_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~channels_mod~~UsedByGraph module~channels_mod channels_mod program~scattering SCATTERING program~scattering->module~channels_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines print_bf_channels set_channels_l_values set_channels_level_indices_channels_omega_values set_number_of_channels set_number_of_open_channels_wavmax Subroutines public  subroutine print_bf_channels (number_of_channels, jtot_, nparity, channels_level_indices, channels_omega_values) prints BF quantum numbers on screen Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: number_of_channels number of channels in the block integer(kind=int32), intent(in) :: jtot_ total angular momentum integer(kind=int32), intent(in) :: nparity parity exponent of the block (0 if p = +1, 1 if p = -1) integer(kind=int32), intent(inout) :: channels_level_indices (number_of_channels) holds the indices pointing to the basis arrays integer(kind=int32), intent(inout) :: channels_omega_values (number_of_channels) holds all values of \\bar{\\Omega} public  subroutine set_channels_l_values (number_of_channels, jtot_, nparity, channels_l_values) Prepares the channels_l_values array which holds values of orbital angular momentum\n(l), an SF-frame quantum number. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: number_of_channels number of channels in the block integer(kind=int32), intent(in) :: jtot_ total angular momentum integer(kind=int32), intent(in) :: nparity parity exponent of the block (0 if p = +1, 1 if p = -1) integer(kind=int32), intent(inout) :: channels_l_values (number_of_channels) holds all values of l public  subroutine set_channels_level_indices_channels_omega_values (number_of_channels, jtot_, nparity, channels_level_indices, channels_omega_values) Prepares the channels_level_indices array which holds indices that refer to the\nbasis arrays: v1level/j1level/elevel, and channels_omega_values which holds values\nof \\bar{\\Omega} Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: number_of_channels number of channels in the block integer(kind=int32), intent(in) :: jtot_ total angular momentum integer(kind=int32), intent(in) :: nparity parity exponent of the block (0 if p = +1, 1 if p = -1) integer(kind=int32), intent(inout) :: channels_level_indices (number_of_channels) holds the indices pointing to the basis arrays integer(kind=int32), intent(inout) :: channels_omega_values (number_of_channels) holds all values of \\bar{\\Omega} public  subroutine set_number_of_channels (jtot_, size_BF_even, size_BF_odd) determine the number of scattering channels in each parity block \nfor given JTOT; check both BF and SF frames Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: jtot_ total angular momentum integer(kind=int32), intent(inout) :: size_BF_even number of channels in p = 1 block integer(kind=int32), intent(inout) :: size_BF_odd number of channels in p = -1 block public  subroutine set_number_of_open_channels_wavmax (number_of_channels, channels_level_indices, channels_omega_values, number_of_open_channels, wavmax) Calculates the number of energetically open channels (number_of_open_channels) and\nthe largest wave number (wavmax) in the block. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: number_of_channels number of channels in the block integer(kind=int32), intent(in) :: channels_level_indices (number_of_channels) holds the indices pointing to the basis arrays integer(kind=int32), intent(in) :: channels_omega_values (number_of_channels) holds all values of \\bar{\\Omega} integer(kind=int32), intent(inout) :: number_of_open_channels number of open channels real(kind=dp), intent(inout) :: wavmax the largest wave number (wavmax) in the block","tags":"","loc":"module/channels_mod.html"},{"title":"array_operations_invert_symmetric_matrix_submod – the SCATTERING code","text":"a submodule for append subroutines Uses Ancestors: array_operations_mod module~~array_operations_invert_symmetric_matrix_submod~~UsesGraph module~array_operations_invert_symmetric_matrix_submod array_operations_invert_symmetric_matrix_submod module~array_operations_mod array_operations_mod module~array_operations_invert_symmetric_matrix_submod->module~array_operations_mod iso_fortran_env iso_fortran_env module~array_operations_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"module/array_operations_invert_symmetric_matrix_submod.html"},{"title":"array_operations_append_submod – the SCATTERING code","text":"a submodule for append subroutines Uses Ancestors: array_operations_mod module~~array_operations_append_submod~~UsesGraph module~array_operations_append_submod array_operations_append_submod module~array_operations_mod array_operations_mod module~array_operations_append_submod->module~array_operations_mod iso_fortran_env iso_fortran_env module~array_operations_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"module/array_operations_append_submod.html"},{"title":"array_operations_fill_symmetric_matrix_submod – the SCATTERING code","text":"a submodule for append subroutines Uses utility_functions_mod Ancestors: array_operations_mod module~~array_operations_fill_symmetric_matrix_submod~~UsesGraph module~array_operations_fill_symmetric_matrix_submod array_operations_fill_symmetric_matrix_submod module~utility_functions_mod utility_functions_mod module~array_operations_fill_symmetric_matrix_submod->module~utility_functions_mod module~array_operations_mod array_operations_mod module~array_operations_fill_symmetric_matrix_submod->module~array_operations_mod iso_fortran_env iso_fortran_env module~utility_functions_mod->iso_fortran_env module~array_operations_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"module/array_operations_fill_symmetric_matrix_submod.html"},{"title":"array_operations_allocate_submod – the SCATTERING code","text":"a submodule for allocate subroutines Uses Ancestors: array_operations_mod module~~array_operations_allocate_submod~~UsesGraph module~array_operations_allocate_submod array_operations_allocate_submod module~array_operations_mod array_operations_mod module~array_operations_allocate_submod->module~array_operations_mod iso_fortran_env iso_fortran_env module~array_operations_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"module/array_operations_allocate_submod.html"},{"title":"SCATTERING – the SCATTERING code","text":"Uses POTENTIAL PES_COUPLING_MATRIX io_mod iso_fortran_env boundary_conditions_mod PROPAGATORS utility_functions_mod statetostateXS channels_mod array_operations_mod program~~scattering~~UsesGraph program~scattering SCATTERING module~potential POTENTIAL program~scattering->module~potential iso_fortran_env iso_fortran_env program~scattering->iso_fortran_env module~boundary_conditions_mod boundary_conditions_mod program~scattering->module~boundary_conditions_mod module~pes_coupling_matrix PES_COUPLING_MATRIX program~scattering->module~pes_coupling_matrix module~io_mod io_mod program~scattering->module~io_mod module~channels_mod channels_mod program~scattering->module~channels_mod module~propagators PROPAGATORS program~scattering->module~propagators module~utility_functions_mod utility_functions_mod program~scattering->module~utility_functions_mod module~statetostatexs statetostateXS program~scattering->module~statetostatexs module~array_operations_mod array_operations_mod program~scattering->module~array_operations_mod module~potential->iso_fortran_env module~potential->module~io_mod module~potential->module~utility_functions_mod module~math_functions_mod math_functions_mod module~potential->module~math_functions_mod module~boundary_conditions_mod->iso_fortran_env module~boundary_conditions_mod->module~io_mod module~boundary_conditions_mod->module~utility_functions_mod module~boundary_conditions_mod->module~array_operations_mod module~boundary_conditions_mod->module~math_functions_mod fwigxjpf fwigxjpf module~boundary_conditions_mod->fwigxjpf module~pes_coupling_matrix->iso_fortran_env module~pes_coupling_matrix->module~io_mod module~pes_coupling_matrix->module~utility_functions_mod module~pes_coupling_matrix->module~math_functions_mod module~pes_coupling_matrix->fwigxjpf module~io_mod->iso_fortran_env module~io_mod->module~utility_functions_mod module~io_mod->module~array_operations_mod module~channels_mod->iso_fortran_env module~channels_mod->module~io_mod module~channels_mod->module~utility_functions_mod module~propagators->module~potential module~propagators->iso_fortran_env module~propagators->module~io_mod module~propagators->module~array_operations_mod module~propagators->module~math_functions_mod module~utility_functions_mod->iso_fortran_env module~statetostatexs->iso_fortran_env module~statetostatexs->module~io_mod module~statetostatexs->module~utility_functions_mod module~array_operations_mod->iso_fortran_env module~math_functions_mod->iso_fortran_env module~math_functions_mod->module~utility_functions_mod module~special_functions_mod special_functions_mod module~math_functions_mod->module~special_functions_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Calls program~~scattering~~CallsGraph program~scattering SCATTERING fwig_table_init fwig_table_init program~scattering->fwig_table_init proc~calculate_k_matrix calculate_k_matrix program~scattering->proc~calculate_k_matrix proc~count_open_basis_levels count_open_basis_levels program~scattering->proc~count_open_basis_levels proc~set_channels_level_indices_channels_omega_values set_channels_level_indices_channels_omega_values program~scattering->proc~set_channels_level_indices_channels_omega_values interface~allocate_1d allocate_1d program~scattering->interface~allocate_1d proc~save_open_basis_levels save_open_basis_levels program~scattering->proc~save_open_basis_levels proc~potential_reduction potential_reduction program~scattering->proc~potential_reduction proc~bf_to_sf_transformation bf_to_sf_transformation program~scattering->proc~bf_to_sf_transformation proc~crosssection CROSSSECTION program~scattering->proc~crosssection proc~print_largest_partial_xs print_largest_partial_xs program~scattering->proc~print_largest_partial_xs proc~check_dtol_otol check_dtol_otol program~scattering->proc~check_dtol_otol fwig_table_free fwig_table_free program~scattering->fwig_table_free proc~read_input_file read_input_file program~scattering->proc~read_input_file proc~time_count_summary time_count_summary program~scattering->proc~time_count_summary proc~set_number_of_channels set_number_of_channels program~scattering->proc~set_number_of_channels interface~allocate_2d allocate_2d program~scattering->interface~allocate_2d proc~print_bf_channels print_bf_channels program~scattering->proc~print_bf_channels fwig_temp_init fwig_temp_init program~scattering->fwig_temp_init proc~set_number_of_open_channels_wavmax set_number_of_open_channels_wavmax program~scattering->proc~set_number_of_open_channels_wavmax proc~check_nonzero_coupling_matrix_elements check_nonzero_coupling_matrix_elements program~scattering->proc~check_nonzero_coupling_matrix_elements proc~print_coupling_matrix_elements_summary print_coupling_matrix_elements_summary program~scattering->proc~print_coupling_matrix_elements_summary proc~numerov numerov program~scattering->proc~numerov interface~append append program~scattering->interface~append fwig_temp_free fwig_temp_free program~scattering->fwig_temp_free proc~set_channels_l_values set_channels_l_values program~scattering->proc~set_channels_l_values proc~write_header write_header program~scattering->proc~write_header proc~file_io_status file_io_status program~scattering->proc~file_io_status proc~units_conversion units_conversion program~scattering->proc~units_conversion proc~potential_read potential_read program~scattering->proc~potential_read proc~write_message write_message program~scattering->proc~write_message proc~potential_interpolation potential_interpolation program~scattering->proc~potential_interpolation proc~prepare_coupling_matrix_elements prepare_coupling_matrix_elements program~scattering->proc~prepare_coupling_matrix_elements proc~calculate_s_matrix calculate_s_matrix program~scattering->proc~calculate_s_matrix proc~etotal ETOTAL program~scattering->proc~etotal proc~integer_to_character integer_to_character program~scattering->proc~integer_to_character proc~float_to_character float_to_character program~scattering->proc~float_to_character proc~unitarity_check unitarity_check program~scattering->proc~unitarity_check proc~calculate_k_matrix->proc~etotal proc~riccati_bessel_y riccati_bessel_y proc~calculate_k_matrix->proc~riccati_bessel_y proc~riccati_bessel_j riccati_bessel_j proc~calculate_k_matrix->proc~riccati_bessel_j dgesv dgesv proc~calculate_k_matrix->dgesv dgemm dgemm proc~calculate_k_matrix->dgemm proc~modified_bessel_k_ratio modified_bessel_k_ratio proc~calculate_k_matrix->proc~modified_bessel_k_ratio proc~count_open_basis_levels->proc~etotal proc~write_error write_error proc~set_channels_level_indices_channels_omega_values->proc~write_error proc~save_open_basis_levels->proc~etotal proc~potential_reduction->proc~write_message proc~potential_reduction->proc~integer_to_character proc~transform_summation transform_summation proc~bf_to_sf_transformation->proc~transform_summation proc~crosssection->interface~allocate_1d proc~crosssection->proc~time_count_summary proc~print_largest_partial_xs->proc~write_message proc~print_largest_partial_xs->proc~integer_to_character proc~print_largest_partial_xs->proc~float_to_character proc~read_input_file->interface~allocate_1d proc~read_input_file->proc~file_io_status proc~input_check input_check proc~read_input_file->proc~input_check interface~allocate_3d allocate_3d proc~read_input_file->interface~allocate_3d proc~input_summary input_summary proc~read_input_file->proc~input_summary proc~time_count_summary->proc~write_message proc~set_number_of_channels->proc~write_error proc~print_bf_channels->proc~write_message proc~print_bf_channels->proc~etotal proc~set_number_of_open_channels_wavmax->proc~etotal proc~is_sum_even is_sum_even proc~check_nonzero_coupling_matrix_elements->proc~is_sum_even proc~triangle_inequality_holds triangle_inequality_holds proc~check_nonzero_coupling_matrix_elements->proc~triangle_inequality_holds proc~print_coupling_matrix_elements_summary->proc~write_message proc~print_coupling_matrix_elements_summary->proc~integer_to_character proc~numerov->interface~allocate_2d proc~numerov->proc~write_message proc~numerov->proc~etotal proc~numerov->proc~float_to_character proc~pes_contribution pes_contribution proc~numerov->proc~pes_contribution interface~invert_symmetric_matrix invert_symmetric_matrix proc~numerov->interface~invert_symmetric_matrix proc~calculate_log_der_matrix calculate_log_der_matrix proc~numerov->proc~calculate_log_der_matrix proc~cenitrfugal_matrix cenitrfugal_matrix proc~numerov->proc~cenitrfugal_matrix interface~fill_symmetric_matrix fill_symmetric_matrix proc~numerov->interface~fill_symmetric_matrix proc~set_channels_l_values->proc~write_error proc~write_header->proc~write_message interface~incorrect_value incorrect_value proc~write_header->interface~incorrect_value proc~write_header->proc~write_error proc~file_io_status->proc~integer_to_character proc~file_io_status->proc~write_error proc~potential_read->proc~file_io_status proc~potential_read->proc~integer_to_character proc~potential_read->proc~float_to_character proc~potential_read->proc~write_error proc~spline spline proc~potential_interpolation->proc~spline fwig3jj fwig3jj proc~prepare_coupling_matrix_elements->fwig3jj proc~prepare_coupling_matrix_elements->proc~is_sum_even proc~prepare_coupling_matrix_elements->proc~triangle_inequality_holds proc~calculate_s_matrix->interface~invert_symmetric_matrix proc~calculate_s_matrix->dgemm proc~calculate_s_matrix->interface~fill_symmetric_matrix proc~unitarity_check->proc~write_message proc~write_warning write_warning proc~unitarity_check->proc~write_warning proc~riccati_bessel_y->proc~integer_to_character proc~riccati_bessel_y->proc~write_warning proc~rcty rcty proc~riccati_bessel_y->proc~rcty proc~spline->proc~integer_to_character proc~spline->proc~write_error proc~pes_contribution->interface~fill_symmetric_matrix proc~radtermvalue RADTERMVALUE proc~pes_contribution->proc~radtermvalue proc~write_warning->proc~write_message proc~riccati_bessel_j->proc~integer_to_character proc~riccati_bessel_j->proc~write_warning proc~rctj rctj proc~riccati_bessel_j->proc~rctj proc~input_check->proc~write_message proc~input_check->proc~integer_to_character proc~input_check->interface~incorrect_value proc~input_check->proc~write_error proc~calculate_log_der_matrix->interface~invert_symmetric_matrix proc~calculate_log_der_matrix->dgemm proc~calculate_log_der_matrix->interface~fill_symmetric_matrix proc~cenitrfugal_matrix->interface~fill_symmetric_matrix dfloat dfloat proc~cenitrfugal_matrix->dfloat proc~modified_bessel_k_ratio->proc~integer_to_character proc~modified_bessel_k_ratio->proc~write_warning proc~ikv ikv proc~modified_bessel_k_ratio->proc~ikv proc~p_coeff p_coeff proc~transform_summation->proc~p_coeff proc~write_error->proc~write_message proc~input_summary->proc~write_message proc~input_summary->proc~etotal proc~input_summary->proc~integer_to_character proc~input_summary->proc~float_to_character proc~wavenumberekin WAVENUMBEREKIN proc~input_summary->proc~wavenumberekin proc~msta1 msta1 proc~rctj->proc~msta1 proc~msta2 msta2 proc~rctj->proc~msta2 proc~ikv->proc~msta1 proc~ikv->proc~msta2 proc~p_coeff->fwig3jj proc~wavenumberekin->proc~etotal proc~wavenumberekin->proc~write_error proc~radtermvalue->proc~integer_to_character proc~radtermvalue->proc~write_error proc~ispline ispline proc~radtermvalue->proc~ispline proc~envj envj proc~msta1->proc~envj proc~msta2->proc~envj proc~ispline->proc~float_to_character proc~ispline->proc~write_warning Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables BF_log_der_matrix SF_log_der_matrix channels_l_values channels_level_indices channels_omega_values err_message iblock icheck icount icount2 ij ilevel io_status iomega iopen iopen2 isize_ isize_2 jinddiag jindoff1 jindoff2 jtot_ k_matrix len_even len_odd lmat_len lmax lmin ltmp maxXSdiag maxXSoff ncacdiag ncacoff nonzero_coupling_coefficients nonzero_legendre_indices nonzero_terms_per_element nsteps number_of_channels number_of_nonzero_coupling_coefficients number_of_nonzero_coupling_matrix_elements number_of_open_basis_levels number_of_open_channels omegamax open_basis_levels open_basis_wavevectors parity_index parity_indextmp partial_line s_matrix_imag s_matrix_real size_even size_odd smatcheckarr terminate time_coupling time_coupling_start time_coupling_stop time_init time_init_stop time_jtot time_jtot_start time_jtot_stop time_parity time_parity_start time_parity_stop time_total time_total_start time_total_stop unitarity_block_check wavmax wavvdepth wv xs_block xs_jtot xs_line xs_total Source Code SCATTERING Variables Type Attributes Name Initial real(kind=dp), allocatable :: BF_log_der_matrix (:,:) real(kind=dp), allocatable :: SF_log_der_matrix (:,:) integer, allocatable :: channels_l_values (:) integer, allocatable :: channels_level_indices (:) integer, allocatable :: channels_omega_values (:) character(len=200) :: err_message integer(kind=int32) :: iblock integer(kind=int32) :: icheck integer(kind=int32) :: icount integer(kind=int32) :: icount2 integer(kind=int32) :: ij integer(kind=int32) :: ilevel integer(kind=int32) :: io_status integer(kind=int32) :: iomega integer(kind=int32) :: iopen integer(kind=int32) :: iopen2 integer(kind=int32) :: isize_ integer(kind=int32) :: isize_2 integer(kind=int32) :: jinddiag integer(kind=int32) :: jindoff1 integer(kind=int32) :: jindoff2 integer(kind=int32) :: jtot_ real(kind=dp), allocatable :: k_matrix (:,:) integer(kind=int32) :: len_even integer(kind=int32) :: len_odd integer(kind=int32) :: lmat_len integer(kind=int32) :: lmax integer(kind=int32) :: lmin integer(kind=int32) :: ltmp real(kind=dp) :: maxXSdiag real(kind=dp) :: maxXSoff integer(kind=int32) :: ncacdiag integer(kind=int32) :: ncacoff real(kind=dp), allocatable :: nonzero_coupling_coefficients (:) integer, allocatable :: nonzero_legendre_indices (:) integer, allocatable :: nonzero_terms_per_element (:) integer(kind=int32) :: nsteps integer(kind=int32) :: number_of_channels integer(kind=int32) :: number_of_nonzero_coupling_coefficients integer(kind=int32) :: number_of_nonzero_coupling_matrix_elements integer(kind=int32) :: number_of_open_basis_levels integer(kind=int32) :: number_of_open_channels integer(kind=int32) :: omegamax integer, allocatable :: open_basis_levels (:) real(kind=dp), allocatable :: open_basis_wavevectors (:) integer(kind=int32) :: parity_index integer(kind=int32) :: parity_indextmp character(len=200) :: partial_line real(kind=dp), allocatable :: s_matrix_imag (:,:) real(kind=dp), allocatable :: s_matrix_real (:,:) integer(kind=int32) :: size_even integer(kind=int32) :: size_odd integer, allocatable :: smatcheckarr (:) logical :: terminate real(kind=dp) :: time_coupling real(kind=dp) :: time_coupling_start real(kind=dp) :: time_coupling_stop real(kind=dp) :: time_init real(kind=dp) :: time_init_stop real(kind=dp) :: time_jtot real(kind=dp) :: time_jtot_start real(kind=dp) :: time_jtot_stop real(kind=dp) :: time_parity real(kind=dp) :: time_parity_start real(kind=dp) :: time_parity_stop real(kind=dp) :: time_total real(kind=dp) :: time_total_start real(kind=dp) :: time_total_stop logical :: unitarity_block_check real(kind=dp) :: wavmax real(kind=dp) :: wavvdepth real(kind=dp), allocatable :: wv (:) real(kind=dp), allocatable :: xs_block (:) real(kind=dp), allocatable :: xs_jtot (:) character(len=200) :: xs_line real(kind=dp), allocatable :: xs_total (:) Source Code program SCATTERING use , intrinsic :: iso_fortran_env , only : int32 , sp => real32 , dp => real64 use io_mod use POTENTIAL use channels_mod use PES_COUPLING_MATRIX use PROPAGATORS use boundary_conditions_mod use statetostateXS use utility_functions_mod , only : write_header , file_io_status , write_message , & float_to_character , integer_to_character , time_count_summary use array_operations_mod , only : append !---------------------------------------------------------------------------! implicit none !---------------------------------------------------------------------------! character ( len = 200 ) :: err_message , partial_line , xs_line integer ( int32 ) :: number_of_nonzero_coupling_matrix_elements , & number_of_nonzero_coupling_coefficients , number_of_channels , size_even , & size_odd , number_of_open_basis_levels , iblock , jtot_ , parity_index , & parity_indextmp , nsteps , number_of_open_channels , ncacdiag , ncacoff , & omegamax , lmin , lmax , ltmp , lmat_len , len_even , len_odd , jinddiag , & jindoff1 , jindoff2 , ij , ilevel , iomega , iopen , iopen2 , isize_ , isize_2 , & icheck , icount , icount2 , io_status real ( dp ) :: wavmax , wavvdepth , maxXSdiag , maxXSoff , time_total_start , & time_total_stop , time_total , time_init_stop , time_init , time_jtot_start , & time_jtot_stop , time_jtot , time_parity_start , time_parity_stop , & time_parity , time_coupling_start , time_coupling_stop , time_coupling logical :: unitarity_block_check , terminate integer , allocatable :: channels_level_indices (:), channels_omega_values (:),& channels_l_values (:), open_basis_levels (:), nonzero_terms_per_element (:),& nonzero_legendre_indices (:), smatcheckarr (:) real ( dp ), allocatable :: wv (:), open_basis_wavevectors (:), & nonzero_coupling_coefficients (:), xs_total (:), xs_block (:), xs_jtot (:) real ( dp ), allocatable :: BF_log_der_matrix (:,:), SF_log_der_matrix (:,:), & k_matrix (:,:), s_matrix_real (:,:), s_matrix_imag (:,:) !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! ! Initizalization: start the time count !---------------------------------------------------------------------------! call cpu_time ( time_total_start ) !---------------------------------------------------------------------------! ! Initialize fwigxjpf library !---------------------------------------------------------------------------! call fwig_table_init ( 2 * 100 , 9 ) call fwig_temp_init ( 2 * 100 ) !---------------------------------------------------------------------------! ! Print the header !---------------------------------------------------------------------------! call write_header ( \"main\" ) !---------------------------------------------------------------------------! ! Read the input file !---------------------------------------------------------------------------! call read_input_file !---------------------------------------------------------------------------! ! S-matrix file: write input parameters and basis levels !---------------------------------------------------------------------------! open ( 11 , file = trim ( smatrixfile ), form = 'unformatted' , iostat = io_status , & iomsg = err_message ) call file_io_status ( io_status , err_message , 11 , \"o\" ) !---------------------------------------------------------------------------! write ( 11 ) label , 2 , nlevel , reducedmass write ( 11 ) ( v1array ( ilevel ), j1array ( ilevel ), ilevel = 1 , nlevel ) write ( 11 ) ( elevel ( ilevel ), ilevel = 1 , nlevel ) write ( 11 ) initial , energy !---------------------------------------------------------------------------! ! Prepare the file with the partial XS !---------------------------------------------------------------------------! if ( parity_index == 1 ) then open ( 12 , file = trim ( partialfile ), form = 'formatted' , status = 'unknown' , & iostat = io_status , iomsg = err_message ) call file_io_status ( io_status , err_message , 12 , \"o\" ) !------------------------------------------------------------------------! call write_message ( \"  jtot  iblock  v1_f  j1_f  <-  v1_i  j1_i'\" // & repeat ( \" \" , 14 ) // \"K.E.\" // repeat ( \" \" , 16 ) // \"XS\" , unit_ = 12 ) !------------------------------------------------------------------------! endif !---------------------------------------------------------------------------! ! Convert units: starting now, everything is in atomic units !---------------------------------------------------------------------------! call units_conversion !---------------------------------------------------------------------------! ! Read the radial terms of the potential from external file !---------------------------------------------------------------------------! call potential_read !---------------------------------------------------------------------------! ! Reduce matrix elements that are not needed !---------------------------------------------------------------------------! call potential_reduction !---------------------------------------------------------------------------! ! Interpolate radial terms !---------------------------------------------------------------------------! call potential_interpolation !---------------------------------------------------------------------------! ! Search for energetically accessible levels and prepare the arrays that are ! needed in the calculations of the state-to-state XS !---------------------------------------------------------------------------! number_of_open_basis_levels = count_open_basis_levels () call allocate_1d ( open_basis_levels , number_of_open_basis_levels ) call allocate_1d ( open_basis_wavevectors , number_of_open_basis_levels ) call save_open_basis_levels ( number_of_open_basis_levels , open_basis_levels , & open_basis_wavevectors ) !---------------------------------------------------------------------------! ! xs array summed over all blocks !---------------------------------------------------------------------------! call allocate_1d ( xs_total , & number_of_open_basis_levels * number_of_open_basis_levels ) !---------------------------------------------------------------------------! ! xs array a single JTOT value !---------------------------------------------------------------------------! call allocate_1d ( xs_jtot , & number_of_open_basis_levels * number_of_open_basis_levels ) !---------------------------------------------------------------------------! ! xs array a single parity block !---------------------------------------------------------------------------! call allocate_1d ( xs_block , & number_of_open_basis_levels * number_of_open_basis_levels ) !---------------------------------------------------------------------------! ! Initialization is finished !---------------------------------------------------------------------------! call cpu_time ( time_init_stop ) if ( prntlvl . ge . 2 ) call time_count_summary ( time_total_start , time_init_stop , & time_init , \"Initialization completed in \" ) !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! ! Prepare J-blocks !---------------------------------------------------------------------------! ! If JTOTMAX=-1 is called, iterate until convergence is achieved: ! this is managed by ncacdiag and ncacoff !---------------------------------------------------------------------------! ncacdiag = 0 ncacoff = 0 iblock = 0 terminate = . false . !---------------------------------------------------------------------------! ! Loop over total angular momentum !---------------------------------------------------------------------------! call write_message ( repeat ( \"*\" , 90 )) call write_message ( repeat ( \" \" , 28 ) // \"*** Loop over JTOT: ***\" ) !---------------------------------------------------------------------------! do jtot_ = jtotmin , jtotmax , jtotstep !------------------------------------------------------------------------! call write_header ( \"block\" , opt_integer_ = jtot_ ) !------------------------------------------------------------------------! call cpu_time ( time_jtot_start ) !------------------------------------------------------------------------! xs_jtot = 0 call set_number_of_channels ( jtot_ , size_even , size_odd ) !------------------------------------------------------------------------! do parity_index = 0 , 1 !---------------------------------------------------------------------! call cpu_time ( time_parity_start ) !---------------------------------------------------------------------! select case ( parity_index ) case ( 0 ) number_of_channels = size_even case ( 1 ) number_of_channels = size_odd end select !---------------------------------------------------------------------! if ( number_of_channels == 0 ) cycle !---------------------------------------------------------------------! ! Summary of the current block !---------------------------------------------------------------------! iblock = iblock + 1 if ( prntlvl . ge . 1 ) then call write_message ( \"Block number: \" // integer_to_character ( iblock )) call write_message ( \"jtot: \" // & trim ( adjustl ( integer_to_character ( jtot_ ))) // \" parity: \" // & trim ( adjustl ( integer_to_character (( - 1 ) ** parity_index ) ))) call write_message ( \"Number of scattering channels: \" // & integer_to_character ( number_of_channels )) endif !---------------------------------------------------------------------! ! Prepare of the basis for each J/p block: ! channels_omega_values holds all values of omega (BF_) ! channels_l_values holds all values of l (SF_) ! channels_level_indices holds the indices which refer to the basis arrays: !   --   v1level/j1level/elevel !---------------------------------------------------------------------! call allocate_1d ( channels_omega_values , number_of_channels ) call allocate_1d ( channels_l_values , number_of_channels ) call allocate_1d ( channels_level_indices , number_of_channels ) !---------------------------------------------------------------------! ! Prepare channels_omega_values, channels_level_indices and channels_l_values !---------------------------------------------------------------------! call set_channels_level_indices_channels_omega_values ( & number_of_channels , jtot_ , parity_index , channels_level_indices , & channels_omega_values ) call set_channels_l_values ( number_of_channels , jtot_ , parity_index , & channels_l_values ) !---------------------------------------------------------------------! ! Print the BF quantum numbers on screen !---------------------------------------------------------------------! if ( prntlvl . ge . 1 ) call print_bf_channels ( number_of_channels , jtot_ , & parity_index , channels_level_indices , channels_omega_values ) !---------------------------------------------------------------------! ! Determine the number of open (energetically accessible) channels ! and the largest wavevector in the block !---------------------------------------------------------------------! call set_number_of_open_channels_wavmax ( number_of_channels , & channels_level_indices , channels_omega_values , & number_of_open_channels , wavmax ) !---------------------------------------------------------------------! ! If there are no open channels, skip this block !---------------------------------------------------------------------! if ( number_of_open_channels == 0 ) then call write_message ( repeat ( '-' , 90 )) call write_message ( \"No open channels for block no.\" // & integer_to_character ( iblock ) ) call write_message ( repeat ( '-' , 90 )) cycle endif !---------------------------------------------------------------------! ! Determine the number of steps on the intermolecular (R) grid ! This is done either directly (if dr > 0) ! or through the number of steps per half de Broglie wavelength !---------------------------------------------------------------------! wavvdepth = dsqrt ( 2 * reducedmass * vdepth ) if ( dr <= 0 ) then nsteps = nint (( Rmax - Rmin ) / PI * (( wavmax + wavvdepth ) * steps )) else nsteps = nint (( Rmax - Rmin ) / dr ) + 1 endif !---------------------------------------------------------------------! ! Prepare the coupling matrix !---------------------------------------------------------------------! call cpu_time ( time_coupling_start ) call check_nonzero_coupling_matrix_elements ( number_of_channels , & channels_level_indices , channels_omega_values , & number_of_nonzero_coupling_matrix_elements , & number_of_nonzero_coupling_coefficients ) call allocate_1d ( nonzero_terms_per_element , number_of_nonzero_coupling_matrix_elements ) call allocate_1d ( nonzero_coupling_coefficients , number_of_nonzero_coupling_coefficients ) call allocate_1d ( nonzero_legendre_indices , number_of_nonzero_coupling_coefficients ) call prepare_coupling_matrix_elements ( number_of_channels , & channels_level_indices , channels_omega_values , & number_of_nonzero_coupling_matrix_elements , & number_of_nonzero_coupling_coefficients , nonzero_terms_per_element ,& nonzero_legendre_indices , nonzero_coupling_coefficients ) if ( prntlvl . ge . 2 ) call print_coupling_matrix_elements_summary ( & number_of_channels , number_of_nonzero_coupling_matrix_elements , & number_of_nonzero_coupling_coefficients ) call cpu_time ( time_coupling_stop ) if ( prntlvl . ge . 2 ) call write_message ( \"Calculations of the coupling \" // & \"matrix took \" // trim ( adjustl ( float_to_character ( & time_coupling_stop - time_coupling_start , \"(E14.8)\" ))) // \" seconds\" ) !---------------------------------------------------------------------! ! Prepare the log-derivative matrix (Eqs. 6.29 and 6.43) ! and the K-matrix (Eq. 6.53) !---------------------------------------------------------------------! call allocate_2d ( BF_log_der_matrix , number_of_channels , number_of_channels ) call allocate_2d ( SF_log_der_matrix , number_of_channels , number_of_channels ) call allocate_2d ( k_matrix , number_of_open_channels , number_of_open_channels ) !---------------------------------------------------------------------! ! Call the propagator: !---------------------------------------------------------------------! call numerov ( channels_level_indices , channels_omega_values , & number_of_nonzero_coupling_matrix_elements , & number_of_nonzero_coupling_coefficients , nonzero_terms_per_element ,& nonzero_legendre_indices , nonzero_coupling_coefficients , nsteps , & number_of_channels , jtot_ , BF_log_der_matrix ) call write_message ( \"Coupled equations were solved from \" // & trim ( adjustl ( float_to_character ( Rmin , \"(F10.4)\" ))) // \" a.u. to \" // & trim ( adjustl ( float_to_character ( Rmax , \"(F10.4)\" ))) // \" a.u. in \" // & trim ( adjustl ( integer_to_character ( nsteps ))) // \" steps (dr = \" // & trim ( adjustl ( float_to_character (( rmax - rmin ) / dble ( nsteps - 1 ), & \"(E14.8)\" ))) // \" a.u.)\" ) !---------------------------------------------------------------------! ! Transform the log-derivative matrix to the SF frame !---------------------------------------------------------------------! call bf_to_sf_transformation ( number_of_channels , jtot_ , & channels_level_indices , channels_omega_values , channels_l_values , & BF_log_der_matrix , SF_log_der_matrix ) !---------------------------------------------------------------------! ! Get the K-matrix from log-derivative matrix (Eq. 6.53) !---------------------------------------------------------------------! call calculate_k_matrix ( number_of_channels , SF_log_der_matrix , & number_of_open_channels , channels_level_indices , channels_l_values ,& rmax , k_matrix ) !---------------------------------------------------------------------! ! Get the S-matrix from the K-matrix (Eq. 6.57) !---------------------------------------------------------------------! call allocate_2d ( s_matrix_real , number_of_open_channels , number_of_open_channels ) call allocate_2d ( s_matrix_imag , number_of_open_channels , number_of_open_channels ) call calculate_s_matrix ( number_of_open_channels , k_matrix , s_matrix_real , s_matrix_imag ) !---------------------------------------------------------------------! ! Array of wavevectors (necessary for the XS calculations) !---------------------------------------------------------------------! call allocate_1d ( wv , number_of_open_channels ) do iopen = 1 , number_of_open_channels wv ( iopen ) = dsqrt (( 2 * reducedmass * & ( ETOTAL () - elevel ( channels_level_indices ( iopen ))))) / bohrtoangstrom enddo !---------------------------------------------------------------------! ! S-matrix is written to the binary S-matrix file !---------------------------------------------------------------------! write ( 11 ) jtot_ , parity_index , number_of_open_channels write ( 11 ) ( channels_level_indices ( iopen ), channels_l_values ( iopen ),& wv ( iopen ), iopen = 1 , number_of_open_channels ) write ( 11 ) (( s_matrix_real ( iopen , iopen2 ), iopen2 = 1 , iopen ),& iopen = 1 , number_of_open_channels ) write ( 11 ) (( s_matrix_imag ( iopen , iopen2 ), iopen2 = 1 , iopen ),& iopen = 1 , number_of_open_channels ) !---------------------------------------------------------------------! ! Check if the S-matrices are unitary !---------------------------------------------------------------------! call unitarity_check ( number_of_open_channels , s_matrix_real , s_matrix_imag , unitarity_block_check ) !---------------------------------------------------------------------! ! If the unitary is not fulfilled, keep the information about this block !---------------------------------------------------------------------! if (. not .( unitarity_block_check )) then call append ( smatcheckarr , jtot_ ) endif !---------------------------------------------------------------------! ! Calculate all available cross-sections !---------------------------------------------------------------------! call CROSSSECTION ( jtot_ , number_of_open_channels , number_of_channels , & number_of_open_basis_levels , open_basis_levels , & open_basis_wavevectors , s_matrix_real , s_matrix_imag , channels_level_indices , & channels_l_values , xs_block ) !---------------------------------------------------------------------! ! Print the results from this parity block to the partial XS file ! and add the calculated partial XS to the xs_jtot array !---------------------------------------------------------------------! do icount = 1 , number_of_open_basis_levels do icount2 = 1 , number_of_open_basis_levels if ( parity_index == 1 ) then write ( partial_line , & \"(I6,2X,I6,2X,I4,2X,I4,6X,I4,2X,I4,2X,E16.8,2X,E16.8)\" ) & jtot_ , iblock , v1array ( open_basis_levels ( icount2 )), & j1array ( open_basis_levels ( icount2 )), & v1array ( open_basis_levels ( icount )), & j1array ( open_basis_levels ( icount )), & ( etotal () - elevel ( open_basis_levels ( icount ))) * hartreetocm , & xs_block (( icount - 1 ) * number_of_open_basis_levels + icount2 ) call write_message ( partial_line , unit_ = 12 ) endif xs_jtot (( icount - 1 ) * number_of_open_basis_levels + icount2 ) = & xs_jtot (( icount - 1 ) * number_of_open_basis_levels + icount2 ) & + xs_block (( icount - 1 ) * number_of_open_basis_levels + icount2 ) enddo enddo !---------------------------------------------------------------------! ! Check the time after each parity block: !---------------------------------------------------------------------! call cpu_time ( time_parity_stop ) if ( prntlvl . ge . 2 ) call time_count_summary ( time_parity_start , & time_parity_stop , time_parity , \"Parity block completed in \" ) !---------------------------------------------------------------------! ! ... end of the loop over parity !---------------------------------------------------------------------! call write_message ( repeat ( \" \" , 43 ) // \"***\" ) enddo !------------------------------------------------------------------------! ! Add the cross-sections from this Jtot block: !------------------------------------------------------------------------! do icount = 1 , number_of_open_basis_levels do icount2 = 1 , number_of_open_basis_levels xs_total (( icount - 1 ) * number_of_open_basis_levels + icount2 ) = & xs_total (( icount - 1 ) * number_of_open_basis_levels + icount2 ) & + xs_jtot (( icount - 1 ) * number_of_open_basis_levels + icount2 ) enddo enddo !------------------------------------------------------------------------! ! Determine the largest partial elastic/inelastic XS in this Jtot block: !------------------------------------------------------------------------! jinddiag = 0 jindoff1 = 0 jindoff2 = 0 maxXSdiag = 0.0_dp maxXSoff = 0.0_dp do icount = 1 , number_of_open_basis_levels do icount2 = 1 , number_of_open_basis_levels if ( open_basis_levels ( icount2 ) == open_basis_levels ( icount )) then if (( xs_jtot (( icount - 1 ) * number_of_open_basis_levels + icount2 )). gt . maxXSdiag ) then maxXSdiag = xs_jtot (( icount - 1 ) * number_of_open_basis_levels + icount2 ) jinddiag = icount endif else if (( xs_jtot (( icount - 1 ) * number_of_open_basis_levels + icount2 )). gt . maxXSoff ) then maxXSoff = xs_jtot (( icount - 1 ) * number_of_open_basis_levels + icount2 ) jindoff1 = icount jindoff2 = icount2 endif endif enddo enddo !-----------------------------------------------------------------------! call print_largest_partial_xs ( jtot_ , maxXSdiag , maxXSoff , jinddiag , & jindoff1 , jindoff2 , number_of_open_basis_levels , open_basis_levels ) !-----------------------------------------------------------------------! if ( jtotmax == 999999 ) then call check_dtol_otol ( maxXSdiag , maxXSoff , ncacdiag , ncacoff , terminate ) endif !------------------------------------------------------------------------! ! Check the time after each JTOT block: !------------------------------------------------------------------------! call cpu_time ( time_jtot_stop ) !------------------------------------------------------------------------! ! Print all the XS after current JTOT block !------------------------------------------------------------------------! if ( prntlvl . ge . 3 ) then call write_message ( \"Cross sections for J: \" // & trim ( adjustl ( integer_to_character ( jtot_ ))) // \" and energy: \" // & trim ( adjustl ( float_to_character ( ETOTAL () * hartreetocm , \"(F10.4)\" ))) & // \" cm-1\" ) call write_message ( \"  v1_f  j1_f  <-  v1_i  j1_i\" // repeat ( \" \" , 14 ) & // \"K.E.\" // repeat ( \" \" , 16 ) // \"XS\" ) do icount = 1 , number_of_open_basis_levels do icount2 = 1 , number_of_open_basis_levels write ( xs_line , \"(2X,I4,2X,I4,6X,I4,2X,I4,2X,E16.8,2X,E16.8)\" ) & v1array ( open_basis_levels ( icount2 )), & j1array ( open_basis_levels ( icount2 )), & v1array ( open_basis_levels ( icount )), & j1array ( open_basis_levels ( icount )), & ( etotal () - elevel ( open_basis_levels ( icount ))) * hartreetocm , & xs_total (( icount - 1 ) * number_of_open_basis_levels + icount2 ) call write_message ( xs_line ) enddo enddo endif !------------------------------------------------------------------------! if ( prntlvl . ge . 2 ) call time_count_summary ( time_jtot_start , & time_jtot_stop , time_jtot , \"JTOT block completed in \" ) !------------------------------------------------------------------------! ! terminate the loop if dtol/otol condition is satisfied !------------------------------------------------------------------------! if ( terminate ) exit enddo call write_message ( repeat ( '*' , 90 )) call write_message ( repeat ( \" \" , 31 ) // \"Loop over JTOT finished\" ) call write_message ( repeat ( '*' , 90 )) call write_message ( \"*\" // repeat ( \" \" , 40 ) // \"SUMMARY\" // repeat ( \" \" , 41 ) & // \"*\" ) call write_message ( repeat ( '*' , 90 )) !---------------------------------------------------------------------------! ! if for some JTOTs the S-matrix did not fulfill the unitary check, ! these are listed here !---------------------------------------------------------------------------! if ( allocated ( smatcheckarr )) then print * call write_message ( repeat ( \"-\" , 90 )) call write_message ( repeat ( \" \" , 37 ) // \"*** WARNING ***\" ) call write_message ( repeat ( \"-\" , 90 )) call write_message ( \"Check unitarity of the S-matrix in the following \" // & \"JTOT blocks:\" ) do icheck = 1 , size ( smatcheckarr ) call write_message ( \"JTOT:\" // repeat ( \" \" , 8 ) // integer_to_character ( & smatcheckarr ( icheck ))) enddo call write_message ( repeat ( \"-\" , 90 )) print * endif !---------------------------------------------------------------------------! ! Print all the calculated XS !---------------------------------------------------------------------------! call write_message ( \"Final state-to-state XS\" ) call write_message ( \"  v1_f  j1_f  <-  v1_i  j1_i\" // repeat ( \" \" , 14 ) // & \"K.E.\" // repeat ( \" \" , 16 ) // \"XS\" ) do icount = 1 , number_of_open_basis_levels do icount2 = 1 , number_of_open_basis_levels write ( xs_line , \"(2X,I4,2X,I4,6X,I4,2X,I4,2X,E16.8,2X,E16.8)\" ) & v1array ( open_basis_levels ( icount2 )), & j1array ( open_basis_levels ( icount2 )), & v1array ( open_basis_levels ( icount )), & j1array ( open_basis_levels ( icount )), & ( etotal () - elevel ( open_basis_levels ( icount ))) * hartreetocm , & xs_total (( icount - 1 ) * number_of_open_basis_levels + icount2 ) call write_message ( xs_line ) enddo enddo !---------------------------------------------------------------------------! call fwig_temp_free (); call fwig_table_free (); !---------------------------------------------------------------------------! ! Stop the time count !---------------------------------------------------------------------------! call cpu_time ( time_total_stop ) call time_count_summary ( time_total_start , time_total_stop , time_total , & \"Total CPU time: \" ) close ( 11 ) close ( 12 ) !---------------------------------------------------------------------------! end program SCATTERING","tags":"","loc":"program/scattering.html"},{"title":"special_functions_mod.f90 – the SCATTERING code","text":"Files dependent on this one sourcefile~~special_functions_mod.f90~~AfferentGraph sourcefile~special_functions_mod.f90 special_functions_mod.f90 sourcefile~math_functions_mod.f90 math_functions_mod.f90 sourcefile~math_functions_mod.f90->sourcefile~special_functions_mod.f90 sourcefile~pes_read_mod.f90 pes_read_mod.f90 sourcefile~pes_read_mod.f90->sourcefile~math_functions_mod.f90 sourcefile~coupling_matrix_mod.f90 coupling_matrix_mod.f90 sourcefile~coupling_matrix_mod.f90->sourcefile~math_functions_mod.f90 sourcefile~propagator_mod.f90 propagator_mod.f90 sourcefile~propagator_mod.f90->sourcefile~math_functions_mod.f90 sourcefile~propagator_mod.f90->sourcefile~pes_read_mod.f90 sourcefile~boundary_conditions_mod.f90 boundary_conditions_mod.f90 sourcefile~boundary_conditions_mod.f90->sourcefile~math_functions_mod.f90 sourcefile~scattering.f90 scattering.f90 sourcefile~scattering.f90->sourcefile~pes_read_mod.f90 sourcefile~scattering.f90->sourcefile~coupling_matrix_mod.f90 sourcefile~scattering.f90->sourcefile~propagator_mod.f90 sourcefile~scattering.f90->sourcefile~boundary_conditions_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules special_functions_mod Source Code special_functions_mod.f90 Source Code module special_functions_mod !! This module holds rctj, rcty, envj, msta1, msta2, ikv, gamma from !! special_functions library, donwloaded from: !! https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html !!  Author: !! !!    Original FORTRAN77 version by Shanjie Zhang, Jianming Jin. !!    FORTRAN90 version by John Burkardt. !! !!  Reference: !! !!    Shanjie Zhang, Jianming Jin, !!    Computation of Special Functions, !!    Wiley, 1996, !!    ISBN: 0-471-11963-6, !!    LC: QA351.C45. !!--------------------------------------------------------------------------! implicit none !--------------------------------------------------------------------------! contains !--------------------------------------------------------------------------! subroutine rctj ( n , x , nm , rj , dj ) !------------------------------------------------------------------------! !! computes Riccati-Bessel function of the first kind, and derivatives. !------------------------------------------------------------------------! !  Licensing: ! !    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, !    they give permission to incorporate this routine into a user program !    provided that the copyright is acknowledged. ! !  Modified: ! !    18 July 2012 ! !  Author: ! !    Shanjie Zhang,Jianming Jin ! !  Reference: ! !    Shanjie Zhang,Jianming Jin, !    Computation of Special Functions, !    Wiley,1996, !    ISBN: 0-471-11963-6, !    LC: QA351.C45. ! !  Parameters: ! !    Input,integer(kind = 4) N,the order of jn(x). ! !    Input,real(kind = 8) X,the argument. ! !    Output,integer(kind = 4) NM,the highest order computed. ! !    Output,real(kind = 8) RJ(0:N),the values of x jn(x). ! !    Output,real(kind = 8) DJ(0:N),the values of [x jn(x)]'. !------------------------------------------------------------------------! implicit none integer ( kind = 4 ) n real ( kind = 8 ) cs real ( kind = 8 ) dj ( 0 : n ) real ( kind = 8 ) f real ( kind = 8 ) f0 real ( kind = 8 ) f1 integer ( kind = 4 ) k integer ( kind = 4 ) m ! ---------------------------------------------------------------------- ! commented because the functions are now in the same module !\t\t  integer(kind = 4) msta1 !\t\t  integer(kind = 4) msta2 ! ---------------------------------------------------------------------- integer ( kind = 4 ) nm real ( kind = 8 ) rj ( 0 : n ) real ( kind = 8 ) rj0 real ( kind = 8 ) rj1 real ( kind = 8 ) x nm = n if ( abs ( x ) < 1.0D-100 ) then do k = 0 , n rj ( k ) = 0.0D+00 dj ( k ) = 0.0D+00 end do dj ( 0 ) = 1.0D+00 return end if rj ( 0 ) = sin ( x ) rj ( 1 ) = rj ( 0 ) / x - cos ( x ) rj0 = rj ( 0 ) rj1 = rj ( 1 ) if ( 2 <= n ) then m = msta1 ( x , 200 ) if ( m < n ) then nm = m else m = msta2 ( x , n , 15 ) end if f0 = 0.0D+00 f1 = 1.0D-100 do k = m , 0 , - 1 f = ( 2.0D+00 * k + 3.0D+00 ) * f1 / x - f0 if ( k <= nm ) then rj ( k ) = f end if f0 = f1 f1 = f end do if ( abs ( rj1 ) < abs ( rj0 )) then cs = rj0 / f else cs = rj1 / f0 end if do k = 0 , nm rj ( k ) = cs * rj ( k ) end do end if dj ( 0 ) = cos ( x ) do k = 1 , nm dj ( k ) = - k * rj ( k ) / x + rj ( k - 1 ) end do return end !------------------------------------------------------------------------! subroutine rcty ( n , x , nm , ry , dy ) !------------------------------------------------------------------------! !! computes Riccati-Bessel function of the second kind, and derivatives. !------------------------------------------------------------------------! ! !  Licensing: ! !    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, !    they give permission to incorporate this routine into a user program !    provided that the copyright is acknowledged. ! !  Modified: ! !    18 July 2012 ! !  Author: ! !    Shanjie Zhang,Jianming Jin ! !  Reference: ! !    Shanjie Zhang,Jianming Jin, !    Computation of Special Functions, !    Wiley,1996, !    ISBN: 0-471-11963-6, !    LC: QA351.C45. ! !  Parameters: ! !    Input,integer(kind = 4) N,the order of yn(x). ! !    Input,real(kind = 8) X,the argument. ! !    Output,integer(kind = 4) NM,the highest order computed. ! !    Output,real(kind = 8) RY(0:N),the values of x yn(x). ! !    Output,real(kind = 8) DY(0:N),the values of [x yn(x)]'. !------------------------------------------------------------------------! implicit none integer ( kind = 4 ) n real ( kind = 8 ) dy ( 0 : n ) integer ( kind = 4 ) k integer ( kind = 4 ) nm real ( kind = 8 ) rf0 real ( kind = 8 ) rf1 real ( kind = 8 ) rf2 real ( kind = 8 ) ry ( 0 : n ) real ( kind = 8 ) x nm = n if ( x < 1.0D-60 ) then do k = 0 , n ry ( k ) = - 1.0D+300 dy ( k ) = 1.0D+300 end do ry ( 0 ) = - 1.0D+00 dy ( 0 ) = 0.0D+00 return end if ry ( 0 ) = - cos ( x ) ry ( 1 ) = ry ( 0 ) / x - sin ( x ) rf0 = ry ( 0 ) rf1 = ry ( 1 ) do k = 2 , n rf2 = ( 2.0D+00 * k - 1.0D+00 ) * rf1 / x - rf0 if ( 1.0D+300 < abs ( rf2 )) then exit end if ry ( k ) = rf2 rf0 = rf1 rf1 = rf2 end do nm = k - 1 dy ( 0 ) = sin ( x ) do k = 1 , nm dy ( k ) = - k * ry ( k ) / x + ry ( k - 1 ) end do return end !------------------------------------------------------------------------! subroutine gamma ( x , ga ) !------------------------------------------------------------------------! !! evaluates the Gamma function. !------------------------------------------------------------------------! !  Licensing: ! !    The original FORTRAN77 version of this routine is copyrighted by !    Shanjie Zhang and Jianming Jin.  However, they give permission to !    incorporate this routine into a user program that the copyright !    is acknowledged. ! !  Modified: ! !    08 September 2007 ! !  Author: ! !    Original FORTRAN77 version by Shanjie Zhang, Jianming Jin. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    Shanjie Zhang, Jianming Jin, !    Computation of Special Functions, !    Wiley, 1996, !    ISBN: 0-471-11963-6, !    LC: QA351.C45 ! !  Parameters: ! !    Input, real ( kind = 8 ) X, the argument. !    X must not be 0, or any negative integer. ! !    Output, real ( kind = 8 ) GA, the value of the Gamma function. !------------------------------------------------------------------------! implicit none real ( kind = 8 ), dimension ( 26 ) :: g = ( / & 1.0D+00 , & 0.5772156649015329D+00 , & - 0.6558780715202538D+00 , & - 0.420026350340952D-01 , & 0.1665386113822915D+00 , & - 0.421977345555443D-01 , & - 0.96219715278770D-02 , & 0.72189432466630D-02 , & - 0.11651675918591D-02 , & - 0.2152416741149D-03 , & 0.1280502823882D-03 , & - 0.201348547807D-04 , & - 0.12504934821D-05 , & 0.11330272320D-05 , & - 0.2056338417D-06 , & 0.61160950D-08 , & 0.50020075D-08 , & - 0.11812746D-08 , & 0.1043427D-09 , & 0.77823D-11 , & - 0.36968D-11 , & 0.51D-12 , & - 0.206D-13 , & - 0.54D-14 , & 0.14D-14 , & 0.1D-15 / ) real ( kind = 8 ) ga real ( kind = 8 ) gr integer ( kind = 4 ) k integer ( kind = 4 ) m integer ( kind = 4 ) m1 real ( kind = 8 ), parameter :: pi = 3.141592653589793D+00 real ( kind = 8 ) r real ( kind = 8 ) x real ( kind = 8 ) z if ( x == aint ( x ) ) then if ( 0.0D+00 < x ) then ga = 1.0D+00 m1 = int ( x ) - 1 do k = 2 , m1 ga = ga * k end do else ga = 1.0D+300 end if else if ( 1.0D+00 < abs ( x ) ) then z = abs ( x ) m = int ( z ) r = 1.0D+00 do k = 1 , m r = r * ( z - real ( k , kind = 8 ) ) end do z = z - real ( m , kind = 8 ) else z = x end if gr = g ( 26 ) do k = 25 , 1 , - 1 gr = gr * z + g ( k ) end do ga = 1.0D+00 / ( gr * z ) if ( 1.0D+00 < abs ( x ) ) then ga = ga * r if ( x < 0.0D+00 ) then ga = - pi / ( x * ga * sin ( pi * x ) ) end if end if end if return end !------------------------------------------------------------------------! subroutine ikv ( v , x , vm , bi , di , bk , dk ) !------------------------------------------------------------------------! !! computes modified Bessel function Iv(x) and Kv(x) and their derivatives. !------------------------------------------------------------------------! !  Licensing: ! !    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, !    they give permission to incorporate this routine into a user program !    provided that the copyright is acknowledged. ! !  Modified: ! !    17 July 2012 ! !  Author: ! !    Shanjie Zhang, Jianming Jin ! !  Reference: ! !    Shanjie Zhang, Jianming Jin, !    Computation of Special Functions, !    Wiley, 1996, !    ISBN: 0-471-11963-6, !    LC: QA351.C45. ! !  Parameters: ! !    Input, real ( kind = 8 ) V, the order of Iv(x) and Kv(x). !    V = N + V0. ! !    Input, real ( kind = 8 ) X, the argument. ! !    Output, real ( kind = 8 ) VM, the highest order computed. ! !    Output, real ( kind = 8 ) BI(0:N), DI(0:N), BK(0:N), DK(0:N), the !    values of In+v0(x), In+v0'(x), Kn+v0(x), Kn+v0'(x). !------------------------------------------------------------------------! implicit none real ( kind = 8 ) a1 real ( kind = 8 ) a2 real ( kind = 8 ) bi ( 0 : * ) real ( kind = 8 ) bi0 real ( kind = 8 ) bk ( 0 : * ) real ( kind = 8 ) bk0 real ( kind = 8 ) bk1 real ( kind = 8 ) bk2 real ( kind = 8 ) ca real ( kind = 8 ) cb real ( kind = 8 ) cs real ( kind = 8 ) ct real ( kind = 8 ) di ( 0 : * ) real ( kind = 8 ) dk ( 0 : * ) real ( kind = 8 ) f real ( kind = 8 ) f1 real ( kind = 8 ) f2 real ( kind = 8 ) gan real ( kind = 8 ) gap integer ( kind = 4 ) k integer ( kind = 4 ) k0 integer ( kind = 4 ) m ! ---------------------------------------------------------------------- ! commented because the functions are now in the same module !\t\t  integer(kind = 4) msta1 !\t\t  integer(kind = 4) msta2 ! ---------------------------------------------------------------------- integer ( kind = 4 ) n real ( kind = 8 ) pi real ( kind = 8 ) piv real ( kind = 8 ) r real ( kind = 8 ) r1 real ( kind = 8 ) r2 real ( kind = 8 ) sum real ( kind = 8 ) v real ( kind = 8 ) v0 real ( kind = 8 ) v0n real ( kind = 8 ) v0p real ( kind = 8 ) vm real ( kind = 8 ) vt real ( kind = 8 ) w0 real ( kind = 8 ) wa real ( kind = 8 ) ww real ( kind = 8 ) x real ( kind = 8 ) x2 pi = 3.141592653589793D+00 x2 = x * x n = int ( v ) v0 = v - n if ( n == 0 ) then n = 1 end if if ( x < 1.0D-100 ) then do k = 0 , n bi ( k ) = 0.0D+00 di ( k ) = 0.0D+00 bk ( k ) = - 1.0D+300 dk ( k ) = 1.0D+300 end do if ( v == 0.0D+00 ) then bi ( 0 ) = 1.0D+00 di ( 1 ) = 0.5D+00 end if vm = v return end if piv = pi * v0 vt = 4.0D+00 * v0 * v0 if ( v0 == 0.0D+00 ) then a1 = 1.0D+00 else v0p = 1.0D+00 + v0 call gamma ( v0p , gap ) a1 = ( 0.5D+00 * x ) ** v0 / gap end if if ( x < 3 5.0D+00 ) then k0 = 14 else if ( x < 5 0.0D+00 ) then k0 = 10 else k0 = 8 end if if ( x <= 1 8.0D+00 ) then bi0 = 1.0D+00 r = 1.0D+00 do k = 1 , 30 r = 0.25D+00 * r * x2 / ( k * ( k + v0 ) ) bi0 = bi0 + r if ( abs ( r / bi0 ) < 1.0D-15 ) then exit end if end do bi0 = bi0 * a1 else ca = exp ( x ) / sqrt ( 2.0D+00 * pi * x ) sum = 1.0D+00 r = 1.0D+00 do k = 1 , k0 r = - 0.125D+00 * r * ( vt - ( 2.0D+00 * k - 1.0D+00 ) ** 2 ) / ( k * x ) sum = sum + r end do bi0 = ca * sum end if m = msta1 ( x , 200 ) if ( m < n ) then n = m else m = msta2 ( x , n , 15 ) end if f2 = 0.0D+00 f1 = 1.0D-100 do k = m , 0 , - 1 f = 2.0D+00 * ( v0 + k + 1.0D+00 ) / x * f1 + f2 if ( k <= n ) then bi ( k ) = f end if f2 = f1 f1 = f end do cs = bi0 / f do k = 0 , n bi ( k ) = cs * bi ( k ) end do di ( 0 ) = v0 / x * bi ( 0 ) + bi ( 1 ) do k = 1 , n di ( k ) = - ( k + v0 ) / x * bi ( k ) + bi ( k - 1 ) end do if ( x <= 9.0D+00 ) then if ( v0 == 0.0D+00 ) then ct = - log ( 0.5D+00 * x ) - 0.5772156649015329D+00 cs = 0.0D+00 w0 = 0.0D+00 r = 1.0D+00 do k = 1 , 50 w0 = w0 + 1.0D+00 / k r = 0.25D+00 * r / ( k * k ) * x2 cs = cs + r * ( w0 + ct ) wa = abs ( cs ) if ( abs ( ( wa - ww ) / wa ) < 1.0D-15 ) then exit end if ww = wa end do bk0 = ct + cs else v0n = 1.0D+00 - v0 call gamma ( v0n , gan ) a2 = 1.0D+00 / ( gan * ( 0.5D+00 * x ) ** v0 ) a1 = ( 0.5D+00 * x ) ** v0 / gap sum = a2 - a1 r1 = 1.0D+00 r2 = 1.0D+00 do k = 1 , 120 r1 = 0.25D+00 * r1 * x2 / ( k * ( k - v0 ) ) r2 = 0.25D+00 * r2 * x2 / ( k * ( k + v0 ) ) sum = sum + a2 * r1 - a1 * r2 wa = abs ( sum ) if ( abs ( ( wa - ww ) / wa ) < 1.0D-15 ) then exit end if ww = wa end do bk0 = 0.5D+00 * pi * sum / sin ( piv ) end if else cb = exp ( - x ) * sqrt ( 0.5D+00 * pi / x ) sum = 1.0D+00 r = 1.0D+00 do k = 1 , k0 r = 0.125D+00 * r * ( vt - ( 2.0D+00 * k - 1.0D+00 ) ** 2 ) / ( k * x ) sum = sum + r end do bk0 = cb * sum end if bk1 = ( 1.0D+00 / x - bi ( 1 ) * bk0 ) / bi ( 0 ) bk ( 0 ) = bk0 bk ( 1 ) = bk1 do k = 2 , n bk2 = 2.0D+00 * ( v0 + k - 1.0D+00 ) / x * bk1 + bk0 bk ( k ) = bk2 bk0 = bk1 bk1 = bk2 end do dk ( 0 ) = v0 / x * bk ( 0 ) - bk ( 1 ) do k = 1 , n dk ( k ) = - ( k + v0 ) / x * bk ( k ) - bk ( k - 1 ) end do vm = n + v0 return end !------------------------------------------------------------------------! function envj ( n , x ) !------------------------------------------------------------------------! !! utility function used by MSTA1 and MSTA2. !------------------------------------------------------------------------! !  Discussion: ! !    ENVJ estimates -log(Jn(x)) from the estimate !    Jn(x) approx 1/sqrt(2*pi*n) *(e*x/(2*n))&#94;n ! !  Licensing: ! !    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, !    they give permission to incorporate this routine into a user program !    provided that the copyright is acknowledged. ! !  Modified: ! !    14 January 2016 ! !  Author: ! !    Shanjie Zhang,Jianming Jin !    Modifications suggested by Vincent Lafage,11 January 2016. ! !  Reference: ! !    Shanjie Zhang,Jianming Jin, !    Computation of Special Functions, !    Wiley,1996, !    ISBN: 0-471-11963-6, !    LC: QA351.C45. ! !  Parameters: ! !    Input,integer(kind = 4) N,the order of the Bessel function. ! !    Input,real(kind = 8) X,the absolute value of the argument. ! !    Output,real(kind = 8) ENVJ,the value. !------------------------------------------------------------------------! implicit none real ( kind = 8 ) envj real ( kind = 8 ) logten integer ( kind = 4 ) n real ( kind = 8 ) n_r8 real ( kind = 8 ) r8_gamma_log real ( kind = 8 ) x ! !  Original code ! if (. true .) then envj = 0.5D+00 * log10 ( 6.28D+00 * n ) & - n * log10 ( 1.36D+00 * x / n ) ! !  Modification suggested by Vincent Lafage. ! else n_r8 = real ( n , kind = 8 ) logten = log ( 1 0.0D+00 ) envj = r8_gamma_log ( n_r8 + 1.0D+00 ) / logten - n_r8 * log10 ( x ) end if return end !------------------------------------------------------------------------! function msta1 ( x , mp ) !------------------------------------------------------------------------! !! determines a backward recurrence starting point for Jn(x). !------------------------------------------------------------------------! !  Discussion: ! !    This procedure determines the starting point for backward !    recurrence such that the magnitude of !    Jn(x) at that point is about 10&#94;(-MP). ! !  Licensing: ! !    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, !    they give permission to incorporate this routine into a user program !    provided that the copyright is acknowledged. ! !  Modified: ! !    08 July 2012 ! !  Author: ! !    Shanjie Zhang,Jianming Jin ! !  Reference: ! !    Shanjie Zhang,Jianming Jin, !    Computation of Special Functions, !    Wiley,1996, !    ISBN: 0-471-11963-6, !    LC: QA351.C45. ! !  Parameters: ! !    Input,real(kind = 8) X,the argument. ! !    Input,integer(kind = 4) MP,the negative logarithm of the !    desired magnitude. ! !    Output,integer(kind = 4) MSTA1,the starting point. !------------------------------------------------------------------------! implicit none real ( kind = 8 ) a0 !---------------------------------------------------------------------- ! commented because the envj is in the same module !\t\t  real(kind = 8) envj !----------------------------------------------------------------------- real ( kind = 8 ) f real ( kind = 8 ) f0 real ( kind = 8 ) f1 integer ( kind = 4 ) it integer ( kind = 4 ) mp integer ( kind = 4 ) msta1 integer ( kind = 4 ) n0 integer ( kind = 4 ) n1 integer ( kind = 4 ) nn real ( kind = 8 ) x a0 = abs ( x ) n0 = int ( 1.1D+00 * a0 ) + 1 f0 = envj ( n0 , a0 ) - mp n1 = n0 + 5 f1 = envj ( n1 , a0 ) - mp do it = 1 , 20 nn = n1 - ( n1 - n0 ) / ( 1.0D+00 - f0 / f1 ) f = envj ( nn , a0 ) - mp if ( abs ( nn - n1 ) < 1 ) then exit end if n0 = n1 f0 = f1 n1 = nn f1 = f end do msta1 = nn return end !------------------------------------------------------------------------! function msta2 ( x , n , mp ) !------------------------------------------------------------------------! !! determines a backward recurrence starting point for Jn(x). !------------------------------------------------------------------------! !  Discussion: ! !    This procedure determines the starting point for a backward !    recurrence such that all Jn(x) has MP significant digits. ! !    Jianming Jin supplied a modification to this code on 12 January 2016. ! !  Licensing: ! !    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, !    they give permission to incorporate this routine into a user program !    provided that the copyright is acknowledged. ! !  Modified: ! !    14 January 2016 ! !  Author: ! !    Shanjie Zhang,Jianming Jin ! !  Reference: ! !    Shanjie Zhang,Jianming Jin, !    Computation of Special Functions, !    Wiley,1996, !    ISBN: 0-471-11963-6, !    LC: QA351.C45. ! !  Parameters: ! !    Input,real(kind = 8) X,the argument of Jn(x). ! !    Input,integer(kind = 4) N,the order of Jn(x). ! !    Input,integer(kind = 4) MP,the number of significant digits. ! !    Output,integer(kind = 4) MSTA2,the starting point. !------------------------------------------------------------------------! implicit none real ( kind = 8 ) a0 real ( kind = 8 ) ejn !---------------------------------------------------------------------- ! commented because the envj is in the same module !\t\t  real(kind = 8) envj !---------------------------------------------------------------------- real ( kind = 8 ) f real ( kind = 8 ) f0 real ( kind = 8 ) f1 real ( kind = 8 ) hmp integer ( kind = 4 ) it integer ( kind = 4 ) mp integer ( kind = 4 ) msta2 integer ( kind = 4 ) n integer ( kind = 4 ) n0 integer ( kind = 4 ) n1 integer ( kind = 4 ) nn real ( kind = 8 ) obj real ( kind = 8 ) x a0 = abs ( x ) hmp = 0.5D+00 * mp ejn = envj ( n , a0 ) if ( ejn <= hmp ) then obj = mp ! !  Original code: ! !   n0 = int(1.1D+00 * a0) ! !  Updated code: ! n0 = int ( 1.1D+00 * a0 ) + 1 else obj = hmp + ejn n0 = n end if f0 = envj ( n0 , a0 ) - obj n1 = n0 + 5 f1 = envj ( n1 , a0 ) - obj do it = 1 , 20 nn = n1 - ( n1 - n0 ) / ( 1.0D+00 - f0 / f1 ) f = envj ( nn , a0 ) - obj if ( abs ( nn - n1 ) < 1 ) then exit end if n0 = n1 f0 = f1 n1 = nn f1 = f end do msta2 = nn + 10 return end !------------------------------------------------------------------------! end module special_functions_mod","tags":"","loc":"sourcefile/special_functions_mod.f90.html"},{"title":"input_reader_mod.f90 – the SCATTERING code","text":"This file depends on sourcefile~~input_reader_mod.f90~~EfferentGraph sourcefile~input_reader_mod.f90 input_reader_mod.f90 sourcefile~utility_functions_mod.f90 utility_functions_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~array_operations_mod.f90 array_operations_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~array_operations_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~input_reader_mod.f90~~AfferentGraph sourcefile~input_reader_mod.f90 input_reader_mod.f90 sourcefile~pes_read_mod.f90 pes_read_mod.f90 sourcefile~pes_read_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~coupling_matrix_mod.f90 coupling_matrix_mod.f90 sourcefile~coupling_matrix_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~sts_xs_mod.f90 sts_xs_mod.f90 sourcefile~sts_xs_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~scattering.f90 scattering.f90 sourcefile~scattering.f90->sourcefile~input_reader_mod.f90 sourcefile~scattering.f90->sourcefile~pes_read_mod.f90 sourcefile~scattering.f90->sourcefile~coupling_matrix_mod.f90 sourcefile~scattering.f90->sourcefile~sts_xs_mod.f90 sourcefile~boundary_conditions_mod.f90 boundary_conditions_mod.f90 sourcefile~scattering.f90->sourcefile~boundary_conditions_mod.f90 sourcefile~channels_mod.f90 channels_mod.f90 sourcefile~scattering.f90->sourcefile~channels_mod.f90 sourcefile~propagator_mod.f90 propagator_mod.f90 sourcefile~scattering.f90->sourcefile~propagator_mod.f90 sourcefile~boundary_conditions_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~channels_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~propagator_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~propagator_mod.f90->sourcefile~pes_read_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules io_mod Source Code input_reader_mod.f90 Source Code module io_mod !! this module provides following functions and subroutines: !! 1. input_file - reads the input file prepared by the user !! 2. input_check - checks the variables supplied in the input file !! 3. input_summary - summary of the input variables !! 5. etotal (function) - returns the total energy of the system !! 6. wavenumberekin (function) - returns the wavenumber (in 1/A&#94;{2}) !! 7. units_conversion - converts all physical quantities to atomic units !! 8. count_available_xs (function) - counts energetically accessible !!    levels in the basis !! 9. jaccess (function) - returns jopen and waveopen - arrays needed for !!    calculations of the state-to-state XS !---------------------------------------------------------------------------! use , intrinsic :: iso_fortran_env , only : int32 , sp => real32 , dp => real64 use utility_functions_mod , only : file_io_status , write_error , write_message ,& incorrect_value , integer_to_character , float_to_character use array_operations_mod , only : allocate_1d , allocate_2d , allocate_3d !------------------------------------------------------------------------------! implicit none !------------------------------------------------------------------------------! character ( len = 80 ) :: label , potentialfile , smatrixfile , partialfile integer ( int32 ) :: ietoterel , jtotmin , jtotmax , jtotstep , & steps , ncac , initial , nlevel , nr , nterms , ncoupl , totalcol ,& n_skip_lines , iunits , ipart , prntlvl , saveeigenvectors , nmodlevels real ( dp ) :: reducedmass , energy , rmin , rmax , dr , vdepth , dtol , otol real ( dp ), parameter :: amutoau = 182 2.8884862d0 real ( dp ), parameter :: bohrtoangstrom = 0.5291772109d0 real ( dp ), parameter :: hartreetocm = 21947 4.631363d0 real ( dp ), parameter :: pi = dacos ( - 1.d0 ) integer ( int32 ), allocatable :: v1array (:), j1array (:), l1tab (:), l2tab (:), & lltab (:), v1pes (:), j1pes (:), v1ppes (:), j1ppes (:), reduced_v1pes (:), & reduced_j1pes (:), reduced_v1ppes (:), reduced_j1ppes (:) real ( dp ), allocatable :: elevel (:), rmat (:), b (:), c (:), d (:), vmat (:,:), & bmat (:,:), cmat (:,:), dmat (:,:), read_vmat3D (:,:,:), vmat3D (:,:,:), & bmat3D (:,:,:), cmat3D (:,:,:), dmat3D (:,:,:) logical :: pes_file_exists !------------------------------------------------------------------------------! contains subroutine read_input_file !! reads the input file prepared by the user using NAMELIST feature !! the code uses 3 namelists: input, basis and potential !------------------------------------------------------------------------! character ( len = 200 ) :: err_message integer ( int32 ) :: ilevel , iilevel , icoupl , icol , il , io_status !------------------------------------------------------------------------! namelist / INPUT / label , reducedmass , ietoterel , energy , & jtotmin , jtotmax , jtotstep , rmin , rmax , dr , steps , vdepth , & ncac , dtol , otol , nlevel , initial , nr , nterms , totalcol , & n_skip_lines , iunits , potentialfile , smatrixfile , ipart , partialfile , & prntlvl namelist / BASIS / v1array , j1array , elevel namelist / POTENTIAL / l1tab , l2tab , lltab , v1pes , j1pes , v1ppes , j1ppes !------------------------------------------------------------------------------! ! Pre-declaration of variables                                                 ! !------------------------------------------------------------------------------! ! The most important variables (if they are not specified, the code stops):    ! !------------------------------------------------------------------------------! reducedmass = - 1.0_dp energy = - 1.0_dp rmin = - 1.0_dp rmax = - 1.0_dp nlevel = - 1 initial = - 1 nr = - 1 nterms = - 1 !------------------------------------------------------------------------------! ! Additional variables (the code runs with the pre-declared values):           ! !------------------------------------------------------------------------------! ietoterel = 0 jtotmin = 0 jtotmax = - 1 jtotstep = 1 dr = - 1.0_dp steps = 10 vdepth = 0.0_dp ncac = 1 dtol = 0.1_dp otol = 0.1_dp totalcol = 1 n_skip_lines = 0 iunits = 0 potentialfile = 'RadialTerms.dat' smatrixfile = 'SmatrixFile.dat' ipart = 0 partialfile = 'PartialFile.dat' prntlvl = 2 !------------------------------------------------------------------------------! open ( unit = 5 , action = 'read' , form = 'formatted' , access = 'sequential' , & status = 'old' , iostat = io_status , iomsg = err_message ) call file_io_status ( io_status , err_message , 5 , 'o' ) !------------------------------------------------------------------------------! ! Read the input namelist:                                                     ! !------------------------------------------------------------------------------! read ( unit = 5 , nml = INPUT , iostat = io_status , iomsg = err_message ) call file_io_status ( io_status , err_message , 5 , 'r' ) !------------------------------------------------------------------------------! ! Check if the variables from input namelist are supplied correctly:           ! !------------------------------------------------------------------------------! call input_check ( 1 ) if ( jtotmax . eq . - 1 ) jtotmax = 999999 call allocate_1d ( v1array , nlevel ) call allocate_1d ( j1array , nlevel ) call allocate_1d ( elevel , nlevel ) call allocate_1d ( l1tab , nterms ) call allocate_1d ( v1pes , totalcol ) call allocate_1d ( v1ppes , totalcol ) call allocate_1d ( j1pes , totalcol ) call allocate_1d ( j1ppes , totalcol ) !------------------------------------------------------------------------------! ! Read the basis namelist & check if the values were supplied correctly:       ! !------------------------------------------------------------------------------! read ( unit = 5 , nml = BASIS , iostat = io_status , iomsg = err_message ) call file_io_status ( io_status , err_message , 5 , 'r' ) call input_check ( 2 ) !------------------------------------------------------------------------------! ! If itype = 2/4 the code reads all the totalcol coupling terms, but some of   ! ! them will not be used in the calculations. Here, the code prepares           ! ! the arrays of ncoupl size, that will hold only the necessary terms           ! !------------------------------------------------------------------------------! ncoupl = nlevel * ( nlevel + 1 ) / 2 call allocate_1d ( reduced_j1pes , ncoupl ) call allocate_1d ( reduced_j1ppes , ncoupl ) call allocate_1d ( reduced_v1pes , ncoupl ) call allocate_1d ( reduced_v1ppes , ncoupl ) icoupl = 0 do ilevel = 1 , nlevel do iilevel = ilevel , nlevel icoupl = icoupl + 1 reduced_v1pes ( icoupl ) = v1array ( ilevel ) reduced_j1pes ( icoupl ) = j1array ( ilevel ) reduced_v1ppes ( icoupl ) = v1array ( iilevel ) reduced_j1ppes ( icoupl ) = j1array ( iilevel ) enddo enddo !------------------------------------------------------------------------------! ! Read the potential namelist & check if the values were supplied correctly:   ! !------------------------------------------------------------------------------! read ( unit = 5 , nml = POTENTIAL , iostat = io_status , iomsg = err_message ) call file_io_status ( io_status , err_message , 5 , 'r' ) call input_check ( 3 ) close ( 5 ) !------------------------------------------------------------------------------! ! Prepare the arrays that are needed for interpolation of the coupling terms:  ! !------------------------------------------------------------------------------! call allocate_1d ( rmat , nr ) call allocate_1d ( b , nr ) call allocate_1d ( c , nr ) call allocate_1d ( d , nr ) call allocate_3d ( read_vmat3D , nr , nterms , totalcol ) call allocate_3d ( vmat3D , nr , nterms , ncoupl ) call allocate_3d ( bmat3D , nr , nterms , ncoupl ) call allocate_3d ( cmat3D , nr , nterms , ncoupl ) call allocate_3d ( dmat3D , nr , nterms , ncoupl ) !------------------------------------------------------------------------------! ! Summarize the input parameters:                                              ! !------------------------------------------------------------------------------! call input_summary end subroutine read_input_file !------------------------------------------------------------------------------! subroutine input_check ( nmlistind ) !! checks if the supplied input parameters are correct !------------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: nmlistind !! nmlistind = 1: namelist INPUT !! nmlistind = 2: namelist BASIS !! nmlistind = 3: namelist POTENTIAL !------------------------------------------------------------------------! integer ( int32 ) :: ilevel , il , icol !------------------------------------------------------------------------! if ( nmlistind . eq . 1 ) then !------------------------------------------------------------------------! ! Namelist input: !------------------------------------------------------------------------! if ( reducedmass . lt . 0 ) then call incorrect_value ( \"reducedmass\" , reducedmass , 5 ) endif if (( ietoterel . ne . 0 ). and .( ietoterel . ne . 1 )) then call incorrect_value ( \"ietoterel\" , ietoterel , 5 ) endif if ( energy . lt . 0 ) then call incorrect_value ( \"energy\" , energy , 5 ) endif if ( rmin . le . 0 ) then call incorrect_value ( \"rmin\" , rmin , 5 ) endif if ( rmax . le . 0 ) then call incorrect_value ( \"rmax\" , rmax , 5 ) endif if ( rmax . lt . rmin ) then call incorrect_value ( \"rmax/rmin\" , rmax / rmin , 5 ) endif if ( steps . le . 0.d0 ) then call incorrect_value ( \"steps\" , steps , 5 ) endif if ( vdepth . lt . 0.d0 ) then call incorrect_value ( \"vdepth\" , vdepth , 5 ) endif if ( jtotmin . lt . 0 ) then call incorrect_value ( \"jtotmin\" , jtotmin , 5 ) endif if ( jtotmax . lt . 0 ) then if ( ncac . lt . 0 ) then call write_message ( \"JTOTMAX < 0:\" ) call incorrect_value ( \"ncac\" , ncac , 5 ) endif if ( dtol . lt . 0 ) then call write_message ( \"JTOTMAX < 0:\" ) call incorrect_value ( \"dtol\" , dtol , 5 ) endif if ( otol . lt . 0 ) then call write_message ( \"JTOTMAX < 0:\" ) call incorrect_value ( \"otol\" , otol , 5 ) endif else if ( jtotmax . lt . jtotmin ) then call write_message ( \"jtotmax is smaller than jtotmin\" ) call incorrect_value ( \"jtotmax/jtotmin\" , & real ( jtotmax / jtotmin , dp ), 5 ) endif endif if ( nlevel . le . 0 ) then call incorrect_value ( \"nlevel\" , nlevel , 5 ) endif if ( ietoterel . eq . 1 ) then if ( initial . le . 0 ) then call write_message ( \"ietoterel = 1:\" ) call incorrect_value ( \"initial\" , initial , 5 ) endif if ( initial . gt . nlevel ) then call write_message ( \"ietoterel = 1:\" ) call write_message ( \"nlevel = \" // integer_to_character ( nlevel )) call incorrect_value ( \"initial > nlevel\" , initial , 5 ) endif endif if ( nr . le . 0 ) then call incorrect_value ( \"nr\" , nr , 5 ) endif if ( nterms . le . 0 ) then call incorrect_value ( \"nterms\" , nterms , 5 ) endif if ( totalcol . le . 0 ) then call incorrect_value ( \"totalcol\" , totalcol , 5 ) endif if ( n_skip_lines . lt . 0 ) then call incorrect_value ( \"n_skip_lines\" , n_skip_lines , 5 ) endif if (( iunits . ne . 0 ). and .( iunits . ne . 1 )) then call incorrect_value ( \"iunits\" , iunits , 5 ) endif inquire ( file = potentialfile , exist = pes_file_exists ) if ( pes_file_exists . eqv .. false .) then call write_error ( trim ( adjustl ( potentialfile )) // \" does not exist\" ) endif if (( ipart . ne . 0 ). and .( ipart . ne . 1 )) then call incorrect_value ( \"ipart\" , ipart , 5 ) endif if ( prntlvl . lt . 0 ) then call incorrect_value ( \"prntlvl\" , prntlvl , 5 ) endif !------------------------------------------------------------------------! else if ( nmlistind . eq . 2 ) then !------------------------------------------------------------------------! ! Namelist basis: !------------------------------------------------------------------------! do ilevel = 1 , nlevel if ( v1array ( ilevel ). lt . 0 ) then call incorrect_value ( \"v1array(\" // integer_to_character ( ilevel ) // \")\" , v1array ( ilevel ), 5 ) endif if ( j1array ( ilevel ). lt . 0 ) then call incorrect_value ( \"j1array(\" // integer_to_character ( ilevel ) // \")\" , j1array ( ilevel ), 5 ) endif if ( elevel ( ilevel ). lt . 0.0_dp ) then call incorrect_value ( \"elevel(\" // integer_to_character ( ilevel ) // \")\" , elevel ( ilevel ), 5 ) endif enddo !------------------------------------------------------------------------! else if ( nmlistind . eq . 3 ) then !------------------------------------------------------------------------! ! Namelist potential: !------------------------------------------------------------------------! do il = 1 , nterms if ( l1tab ( il ). lt . 0 ) then call incorrect_value ( \"l1tab(\" // integer_to_character ( il ) // \")\" , l1tab ( il ), 5 ) endif enddo do icol = 1 , totalcol if ( v1pes ( icol ). lt . 0 ) then call incorrect_value ( \"v1pes(\" // integer_to_character ( icol ) // \")\" , v1pes ( icol ), 5 ) endif if ( j1pes ( icol ). lt . 0 ) then call incorrect_value ( \"j1pes(\" // integer_to_character ( icol ) // \")\" , j1pes ( icol ), 5 ) endif if ( v1ppes ( icol ). lt . 0 ) then call incorrect_value ( \"vp1pes(\" // integer_to_character ( icol ) // \")\" , v1ppes ( icol ), 5 ) endif if ( j1ppes ( icol ). lt . 0 ) then call incorrect_value ( \"j1ppes(\" // integer_to_character ( icol ) // \")\" , j1ppes ( icol ), 5 ) endif enddo endif !------------------------------------------------------------------------! end subroutine input_check !------------------------------------------------------------------------------! subroutine input_summary !! summarize the input parameters for the current run !------------------------------------------------------------------------! integer ( int32 ) :: ilevel !------------------------------------------------------------------------! call write_message ( \"User-supplied label: \" // label ) call write_message ( \"Reduced mass: \" // & trim ( adjustl ( float_to_character ( reducedmass , \"(F10.4)\" ))) // \" a.m.u.\" ) call write_message ( \"*** Energy levels in the basis set: ***\" ) call write_message ( \"   v       j            Energy (cm&#94;{-1})\" ) do ilevel = 1 , nlevel write ( * , \"(I4,4X,I4,16X,F12.4)\" ) v1array ( ilevel ), j1array ( ilevel ), elevel ( ilevel ) enddo write ( * , \"(44X,A3)\" ) \"***\" if ( jtotmax . ne . 999999 ) then call write_message ( \"The equations will be solved \" // & \"for total angular momentum J from \" // & trim ( adjustl ( integer_to_character ( jtotmin ))) // \" to \" & // trim ( adjustl ( integer_to_character ( jtotmax ))) // \" with step \" // & trim ( adjustl ( integer_to_character ( jtotstep )))) else call write_message ( \"The loop over JTOT will be performed from \" // & trim ( adjustl ( integer_to_character ( jtotmin ))) // \" with step \" // & trim ( adjustl ( integer_to_character ( jtotstep ))) // \" until \" // & trim ( adjustl ( integer_to_character ( ncac ))) // & \" consecutive JTOT-blocks contribute less than \" // & trim ( adjustl ( float_to_character ( dtol , \"(E10.4)\" ))) // & \" A&#94;2 to the elastic XS and less than \" // & trim ( adjustl ( float_to_character ( otol , \"(E10.4)\" ))) // & \" A&#94;2 to the inelastic XS\" ) endif if ( ietoterel . eq . 0 ) then call write_message ( \"The calculations will be performed for the total energy equal to \" & // trim ( adjustl ( float_to_character ( ETOTAL (), \"(F10.4)\" ))) // \" cm-1\" ) else if ( ietoterel . eq . 1 ) then call write_message ( \"Relative kinetic energy of the colliding system: \" // & trim ( adjustl ( float_to_character ( energy , \"(F10.4)\" ))) // \" cm-1\" ) call write_message ( \"and the corresponding wavenumber: \" // & trim ( adjustl ( float_to_character ( WAVENUMBEREKIN (), \"(F10.4)\" ))) // & \" 1/Ang\" ) call write_message ( \"The kinetic energy is calculated with respect to the\" // & \" v = \" // trim ( adjustl ( integer_to_character ( v1array ( initial )))) // & \" j = \" // trim ( adjustl ( integer_to_character ( j1array ( initial )))) // & \" level in the basis set with the rotational energy \" // & trim ( adjustl ( float_to_character ( elevel ( initial ), \"(F10.4)\" ))) & // \" cm-1.\" ) call write_message ( \"This gives the total energy equal to \" // & trim ( adjustl ( float_to_character ( ETOTAL (), \"(F10.4)\" ))) // \" cm-1\" ) endif if ( ipart . eq . 1 ) then call write_message ( \"Partial cross sections will be saved into \" // partialfile ) endif call write_message ( \"S-matrix elements will be saved into \" // smatrixfile ) !------------------------------------------------------------------------! end subroutine input_summary !------------------------------------------------------------------------------! function ETOTAL () result ( etot_ ) !! returns the total energy !------------------------------------------------------------------------! real ( dp ) :: etot_ !------------------------------------------------------------------------! if ( ietoterel . eq . 0 ) then etot_ = energy else if ( ietoterel . eq . 1 ) then etot_ = energy + elevel ( initial ) endif !------------------------------------------------------------------------! end function !------------------------------------------------------------------------------! function WAVENUMBEREKIN () result ( k_ ) !! returns the wavenumber (in 1/A&#94;{2}) !------------------------------------------------------------------------! real ( dp ) :: k_ !------------------------------------------------------------------------! if ( ietoterel . eq . 1 ) then k_ = dsqrt ( 2 * reducedmass * amutoau * & ( ETOTAL () - elevel ( initial )) / hartreetocm ) / bohrtoangstrom else call write_error ( \"Wavenumberekin called when ietoterel = 0\" ) endif !------------------------------------------------------------------------! end function !------------------------------------------------------------------------------! subroutine units_conversion !! converts all physical quantities to atomic units !---------------------------------------------------------------------! integer ( int32 ) :: ilevel !---------------------------------------------------------------------! reducedmass = reducedmass * amutoau energy = energy / hartreetocm vdepth = vdepth / hartreetocm !---------------------------------------------------------------------! do ilevel = 1 , nlevel elevel ( ilevel ) = elevel ( ilevel ) / hartreetocm enddo !---------------------------------------------------------------------! end subroutine units_conversion !------------------------------------------------------------------------------! function count_open_basis_levels () result ( open_ ) !! counts the energetically accessible levels in the basis !---------------------------------------------------------------------! integer ( int32 ) :: open_ , ilevel !---------------------------------------------------------------------! open_ = 0 do ilevel = 1 , nlevel if ( ETOTAL () - elevel ( ilevel ). ge . 0 ) then open_ = open_ + 1 endif enddo !---------------------------------------------------------------------! end function count_open_basis_levels !------------------------------------------------------------------------------! subroutine save_open_basis_levels ( number_of_open_basis_levels , & open_basis_levels , open_basis_wavevectors ) !! saves indices to open levels in the basis and corresponding !! wavenumbers !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: number_of_open_basis_levels !! number of energetically accessible levels in the basis integer ( int32 ), intent ( inout ) :: open_basis_levels ( number_of_open_basis_levels ) !! array holding indices to energetically accessible levels in the basis real ( dp ), intent ( inout ) :: open_basis_wavevectors ( number_of_open_basis_levels ) !! array holding wavevectors calculated w.r.t energetically accessible levels in the basis !---------------------------------------------------------------------! integer ( int32 ) :: count_ , ilevel !---------------------------------------------------------------------! count_ = 0 do ilevel = 1 , nlevel if ( ETOTAL () - elevel ( ilevel ) >= 0 ) then count_ = count_ + 1 open_basis_levels ( count_ ) = ilevel open_basis_wavevectors ( count_ ) = dsqrt (( 2 * reducedmass & * ( ETOTAL () - elevel ( ilevel )))) / bohrtoangstrom endif enddo !---------------------------------------------------------------------! end subroutine save_open_basis_levels !------------------------------------------------------------------------------! end module io_mod","tags":"","loc":"sourcefile/input_reader_mod.f90.html"},{"title":"math_functions_mod.f90 – the SCATTERING code","text":"This file depends on sourcefile~~math_functions_mod.f90~~EfferentGraph sourcefile~math_functions_mod.f90 math_functions_mod.f90 sourcefile~utility_functions_mod.f90 utility_functions_mod.f90 sourcefile~math_functions_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~special_functions_mod.f90 special_functions_mod.f90 sourcefile~math_functions_mod.f90->sourcefile~special_functions_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~math_functions_mod.f90~~AfferentGraph sourcefile~math_functions_mod.f90 math_functions_mod.f90 sourcefile~pes_read_mod.f90 pes_read_mod.f90 sourcefile~pes_read_mod.f90->sourcefile~math_functions_mod.f90 sourcefile~coupling_matrix_mod.f90 coupling_matrix_mod.f90 sourcefile~coupling_matrix_mod.f90->sourcefile~math_functions_mod.f90 sourcefile~propagator_mod.f90 propagator_mod.f90 sourcefile~propagator_mod.f90->sourcefile~math_functions_mod.f90 sourcefile~propagator_mod.f90->sourcefile~pes_read_mod.f90 sourcefile~boundary_conditions_mod.f90 boundary_conditions_mod.f90 sourcefile~boundary_conditions_mod.f90->sourcefile~math_functions_mod.f90 sourcefile~scattering.f90 scattering.f90 sourcefile~scattering.f90->sourcefile~pes_read_mod.f90 sourcefile~scattering.f90->sourcefile~coupling_matrix_mod.f90 sourcefile~scattering.f90->sourcefile~propagator_mod.f90 sourcefile~scattering.f90->sourcefile~boundary_conditions_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules math_functions_mod Source Code math_functions_mod.f90 Source Code module math_functions_mod !! this module holds 3 types of functions: !! -- geometric functions: triangle_inequality_holds and is_sum_even !! -- bessel functions: groups functions: riccati_bessel_j, bessely and modified_bessel_k_ratio !!    that call special functions from special_functions.f90 library !! -- interpolation procedures: spline and ispline functions for interpolating data !! -- additional functions: rctj, rcty, envj, msta1, msta2, ikv, gamma from !!    special_functions library !---------------------------------------------------------------------------! use , intrinsic :: iso_fortran_env , only : int32 , sp => real32 , dp => real64 use utility_functions_mod , only : write_error , write_warning , & integer_to_character , float_to_character , time_count_summary use special_functions_mod , only : rctj , rcty , envj , msta1 , msta2 , ikv , gamma !---------------------------------------------------------------------------! implicit none contains !---------------------------------------------------------------------------! !                           Geometric functions !---------------------------------------------------------------------------! function triangle_inequality_holds ( x , y , z ) result ( triang ) !! check if the triangle inequality for 3 variables hols !------------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: x , y , z !! variables to check the triangle inequality integer ( int32 ) :: triang !! (out) result: 1 = true, 0 = false !------------------------------------------------------------------------! triang = 0 if ( x + y >= z . and . x + z >= y . and . y + z >= x ) then triang = 1 endif !------------------------------------------------------------------------! end function triangle_inequality_holds !---------------------------------------------------------------------------! function is_sum_even ( x , y , z ) result ( sum_even ) !! checks if the sum of 3 integers is an even integer !------------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: x , y , z !! variables to check if the sum is even integer ( int32 ) :: sum_even !! (out) result: 1 = true, 0 = false !------------------------------------------------------------------------! sum_even = merge ( 1 , 0 , modulo ( x + y + z , 2 ) == 0 ) !------------------------------------------------------------------------! end function is_sum_even !---------------------------------------------------------------------------! !                             Bessel functions ! these functions handle calling to specific subroutines from ! special_functions.f90 library !---------------------------------------------------------------------------! subroutine riccati_bessel_j ( l_ , x_ , j_ , jp_ ) !! calculates the Riccati-Bessel function of the first kind and its !! first derivative. Calls the rctj function from special_functions.f90 !------------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: l_ !! l - order of the Riccati-Bessel function of the first kind real ( dp ), intent ( in ) :: x_ !! x - argument of the Riccati-Bessel function of the first kind real ( dp ), intent ( inout ) :: j_ !! j_{l} (x) - Riccati-Bessel funciton of the first kind real ( dp ), intent ( inout ) :: jp_ !! j_{l}' (x) - derivative of the Riccati-Bessel funciton of the first kind !------------------------------------------------------------------------! integer ( int32 ) :: highest_order_ real ( dp ), dimension ( l_ + 1 ) :: rj_ , dj_ !------------------------------------------------------------------------! if ( l_ == 0 ) then call rctj ( l_ + 1 , x_ , highest_order_ , rj_ , dj_ ) else call rctj ( l_ , x_ , highest_order_ , rj_ , dj_ ) endif if ( highest_order_ < l_ ) then !---------------------------------------------------------------------! call write_warning ( \"riccati_bessel_j: maximum order of Riccati-Bessel function:\" & // trim ( adjustl ( integer_to_character ( highest_order_ ))) // \"is smaller than \" // & \"requested order l = \" // trim ( adjustl ( integer_to_character ( l_ ))) ) !---------------------------------------------------------------------! j_ = rj_ ( highest_order_ ) jp_ = dj_ ( highest_order_ ) else j_ = rj_ ( l_ + 1 ) jp_ = dj_ ( l_ + 1 ) endif !------------------------------------------------------------------------! end subroutine riccati_bessel_j !---------------------------------------------------------------------------! subroutine riccati_bessel_y ( l_ , x_ , y_ , yp_ ) !! calculates the Riccati-Bessel function of the second kind and its !! first derivative. Calls the rcty function from special_functions.f90 !------------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: l_ !! l - order of the Riccati-Bessel function of the second kind real ( dp ), intent ( in ) :: x_ !! x - argument of the Riccati-Bessel function of the second kind real ( dp ), intent ( inout ) :: y_ !! y_{l} (x) - Riccati-Bessel funciton of the second kind real ( dp ), intent ( inout ) :: yp_ !! y_{l}' (x) - derivative of the Riccati-Bessel funciton of the second kind !------------------------------------------------------------------------! integer ( int32 ) :: highest_order_ real ( dp ), dimension ( l_ + 1 ) :: ry_ , dy_ !------------------------------------------------------------------------! if ( l_ == 0 ) then call rcty ( l_ + 1 , x_ , highest_order_ , ry_ , dy_ ) else call rcty ( l_ , x_ , highest_order_ , ry_ , dy_ ) endif y_ = ry_ ( l_ + 1 ) yp_ = dy_ ( l_ + 1 ) !------------------------------------------------------------------------! if ( highest_order_ < l_ ) then !---------------------------------------------------------------------! call write_warning ( \"riccati_bessel_j: maximum order of Riccati-Bessel function:\" & // trim ( adjustl ( integer_to_character ( highest_order_ ))) // \"is smaller than \" // & \"requested order l = \" // trim ( adjustl ( integer_to_character ( l_ ))) ) !---------------------------------------------------------------------! y_ = ry_ ( highest_order_ ) yp_ = dy_ ( highest_order_ ) else y_ = ry_ ( l_ + 1 ) yp_ = dy_ ( l_ + 1 ) endif !------------------------------------------------------------------------! end subroutine riccati_bessel_y !---------------------------------------------------------------------------! subroutine modified_bessel_k_ratio ( l_ , x_ , ratio_ ) !! calculates the ratio of the modified Bessel function of the second !! kind K_{l_ + 1/2}(x) and its first derivative (Eq. ...) !! Uses ikv function from special_functions.f90 !------------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: l_ !! l - order of the function (without the 1/2 factor!) real ( dp ), intent ( in ) :: x_ !! x - argument of the function real ( dp ), intent ( inout ) :: ratio_ !! ratio of the modified Bessel function of the second kind to its derivative !------------------------------------------------------------------------! integer ( int32 ) :: highest_order_ real ( dp ) :: order_ , highest_order_real_ real ( dp ), dimension ( l_ + 1 ) :: bi_arr_ , di_arr_ , bk_arr_ , dk_arr_ !------------------------------------------------------------------------! order_ = real ( l_ , dp ) + 0.5_dp call ikv ( order_ , x_ , highest_order_real_ , bi_arr_ , di_arr_ , bk_arr_ , dk_arr_ ) highest_order_ = nint ( highest_order_real_ - 0.5_dp ) !------------------------------------------------------------------------! if ( highest_order_ < l_ ) then !---------------------------------------------------------------------! call write_warning ( \"modified_bessel_k_ratio: maximum order of modified Bessel function:\" & // trim ( adjustl ( integer_to_character ( highest_order_ ))) // \"is smaller than \" // & \"requested order l = \" // trim ( adjustl ( integer_to_character ( l_ ))) ) !---------------------------------------------------------------------! ratio_ = dk_arr_ ( highest_order_ ) / bk_arr_ ( highest_order_ ) else ratio_ = dk_arr_ ( l_ + 1 ) / bk_arr_ ( l_ + 1 ) endif !------------------------------------------------------------------------! end subroutine modified_bessel_k_ratio !---------------------------------------------------------------------------! !                          Interpolation procedures !---------------------------------------------------------------------------! subroutine spline ( N_ , x_ , y_ , b_ , c_ , d_ ) !! determines b, c and d coefficients of the cubic spline function !! y(x) = y_i + b_i * dx + c_i * dx&#94;2 + d_i * dx&#94;3, !! where dx = x - x_i, and x_i <= x < x_i+1. !! The algorithm is based on !! Gerald, C., and Wheatley, P., \"Applied Numerical Analysis\", Addison-Wesley, 1994. !------------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: N_ !! number of grid points real ( dp ), intent ( in ) :: x_ ( N_ ) !! grid points (ascending order) real ( dp ), intent ( in ) :: y_ ( N_ ) !! tabulated values real ( dp ), intent ( out ) :: b_ ( N_ ), c_ ( N_ ), d_ ( N_ ) !! arrays with coefficients of the spline function !------------------------------------------------------------------------! integer ( int32 ) :: i_ , j_ real ( dp ) :: w_ real ( dp ) :: diff_x_ ( N_ - 1 ) !------------------------------------------------------------------------! ! check if the number of points is larger than 4 !------------------------------------------------------------------------! if ( N_ < 4 ) then call write_error ( \"spline function called with \" // & trim ( adjustl ( integer_to_character ( N_ ))) // \" points\" ) endif !------------------------------------------------------------------------! ! check if x is sorted in ascending order !------------------------------------------------------------------------! do i_ = 2 , N_ if ( x_ ( i_ ) <= x_ ( i_ - 1 )) then call write_error ( \"spline: x values are not in ascending order \" // & \" at index \" // trim ( adjustl ( integer_to_character ( i_ )))) endif end do !------------------------------------------------------------------------! diff_x_ = x_ ( 2 : N_ ) - x_ ( 1 : N_ - 1 ) !------------------------------------------------------------------------! b_ ( 2 : N_ - 1 ) = 2.0_dp * ( diff_x_ ( 1 : N_ - 2 ) + diff_x_ ( 2 : N_ - 1 )) b_ ( 1 ) = - diff_x_ ( 1 ) b_ ( N_ ) = - diff_x_ ( N_ - 1 ) c_ ( 2 : N_ - 1 ) = ( y_ ( 3 : N_ ) - y_ ( 2 : N_ - 1 ) ) / diff_x_ ( 2 : N_ - 1 ) & - ( y_ ( 2 : N_ - 1 ) - y_ ( 1 : N_ - 2 ) ) / diff_x_ ( 1 : N_ - 2 ) c_ ( 1 ) = c_ ( 3 ) / ( x_ ( 4 ) - x_ ( 2 )) - c_ ( 2 ) / ( x_ ( 3 ) - x_ ( 1 )) c_ ( N_ ) = c_ ( N_ - 1 ) / ( x_ ( N_ ) - x_ ( N_ - 2 )) - c_ ( N_ - 2 ) / ( x_ ( N_ - 1 ) - x_ ( N_ - 3 )) c_ ( 1 ) = c_ ( 1 ) / ( x_ ( 4 ) - x_ ( 1 )) * diff_x_ ( 1 ) ** 2 c_ ( N_ ) = - c_ ( N_ ) / ( x_ ( N_ ) - x_ ( N_ - 3 )) * diff_x_ ( N_ - 1 ) ** 2 do i_ = 2 , N_ w_ = diff_x_ ( i_ - 1 ) / b_ ( i_ - 1 ) b_ ( i_ ) = b_ ( i_ ) - w_ * diff_x_ ( i_ - 1 ) c_ ( i_ ) = c_ ( i_ ) - w_ * c_ ( i_ - 1 ) end do c_ ( N_ ) = c_ ( N_ ) / b_ ( N_ ) do j_ = 1 , N_ - 1 i_ = N_ - j_ c_ ( i_ ) = ( c_ ( i_ ) - diff_x_ ( i_ ) * c_ ( i_ + 1 )) / b_ ( i_ ) end do b_ ( 1 : N_ - 1 ) = ( y_ ( 2 : N_ ) - y_ ( 1 : N_ - 1 ) ) / diff_x_ ( 1 : N_ - 1 ) & - ( 2.0_dp * c_ ( 1 : N_ - 1 ) + c_ ( 2 : N_ ) ) * diff_x_ ( 1 : N_ - 1 ) d_ ( 1 : N_ - 1 ) = ( c_ ( 2 : N_ ) - c_ ( 1 : N_ - 1 ) ) / diff_x_ ( 1 : N_ - 1 ) c_ = c_ * 3.0_dp end subroutine spline !---------------------------------------------------------------------------! function ispline ( u_ , N_ , x_ , y_ , b_ , c_ , d_ ) result ( spl_result ) !! returns interpolated value at guven u_ point !! number of points and ascending order of x is not checked since !! ispline is called after \"spline\" where these checks are done !------------------------------------------------------------------------! real ( dp ), intent ( in ) :: u_ !! point at which the tabulated value is interpolated integer ( int32 ), intent ( in ) :: N_ !! number of grid points real ( dp ), intent ( in ) :: x_ ( N_ ) !! grid points real ( dp ), intent ( in ) :: y_ ( N_ ) !! tabulated values real ( dp ), intent ( in ) :: b_ ( N_ ), c_ ( N_ ), d_ ( N_ ) !! arrays with coefficients of the spline function real ( dp ) :: spl_result !! interpolated value at u_ !------------------------------------------------------------------------! integer ( int32 ) :: k_ , l_ , mid_ real ( dp ) :: dx_ !------------------------------------------------------------------------! if ( u_ > x_ ( N_ )) then call write_warning ( \"ispline: point u_ = \" // & trim ( adjustl ( float_to_character ( u_ ))) // \" exceeds the original \" & // \"grid: x(N) = \" // trim ( adjustl ( float_to_character ( x_ ( N_ ))))) spl_result = y_ ( N_ ) else if ( u_ < x_ ( 1 ) ) then call write_warning ( \"ispline: point u_ = \" // & trim ( adjustl ( float_to_character ( u_ ))) // \" exceeds the original \" & // \"grid: x(1) = \" // trim ( adjustl ( float_to_character ( x_ ( 1 ))))) spl_result = y_ ( 1 ) else !---------------------------------------------------------------------! l_ = 1 k_ = N_ + 1 do while ( k_ > l_ + 1 ) mid_ = nint ( ( l_ + k_ ) / 2.0_dp ) if ( x_ ( mid_ ) > u_ ) then k_ = mid_ else l_ = mid_ endif end do dx_ = u_ - x_ ( l_ ) spl_result = y_ ( l_ ) + dx_ * ( b_ ( l_ ) + dx_ * ( c_ ( l_ ) + d_ ( l_ ) * dx_ )) !---------------------------------------------------------------------! endif !------------------------------------------------------------------------! end function ispline !------------------------------------------------------------------------------! end module math_functions_mod","tags":"","loc":"sourcefile/math_functions_mod.f90.html"},{"title":"pes_read_mod.f90 – the SCATTERING code","text":"This file depends on sourcefile~~pes_read_mod.f90~~EfferentGraph sourcefile~pes_read_mod.f90 pes_read_mod.f90 sourcefile~input_reader_mod.f90 input_reader_mod.f90 sourcefile~pes_read_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~utility_functions_mod.f90 utility_functions_mod.f90 sourcefile~pes_read_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~math_functions_mod.f90 math_functions_mod.f90 sourcefile~pes_read_mod.f90->sourcefile~math_functions_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~array_operations_mod.f90 array_operations_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~array_operations_mod.f90 sourcefile~math_functions_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~special_functions_mod.f90 special_functions_mod.f90 sourcefile~math_functions_mod.f90->sourcefile~special_functions_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~pes_read_mod.f90~~AfferentGraph sourcefile~pes_read_mod.f90 pes_read_mod.f90 sourcefile~scattering.f90 scattering.f90 sourcefile~scattering.f90->sourcefile~pes_read_mod.f90 sourcefile~propagator_mod.f90 propagator_mod.f90 sourcefile~scattering.f90->sourcefile~propagator_mod.f90 sourcefile~propagator_mod.f90->sourcefile~pes_read_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules POTENTIAL Source Code pes_read_mod.f90 Source Code module POTENTIAL !! this module provides functions for reading and interpolating radial coupling !! coefficients of the PES: !! 1. potential_read: reads radial coupling terms from external file !! 2. potential_reduction: reduces the number of radial terms that couple !!    different rovibrational levels to a smaller number of terms that !!    describe the couplings between the levels provided in the basis !! 3. potential_interpolation: cubic spline interpolation of the coupling terms !!--------------------------------------------------------------------------! use , intrinsic :: iso_fortran_env , only : int32 , sp => real32 , dp => real64 use io_mod use utility_functions_mod , only : file_io_status , write_error , write_message ,& time_count_summary use math_functions_mod , only : spline implicit none contains !---------------------------------------------------------------------------! subroutine potential_read !! reads the radial coupling terms from the external file. !! The file is assumed to be formatted as follows: !! R, V_{l1,v1,j1,v1',j1'}(R) !! The read radial coupling terms are kept in vmat/read_vmat3D !---------------------------------------------------------------------! character ( len = 200 ) :: err_message integer ( int32 ) :: nrtmp , l1 , iskip_ , il , ir , icol , io_status !---------------------------------------------------------------------! open ( 8 , file = trim ( potentialfile ), form = 'formatted' , status = 'old' , & iostat = io_status , iomsg = err_message ) call file_io_status ( io_status , err_message , 5 , 'o' ) !---------------------------------------------------------------------! ! Skip the informative lines at the beginning !---------------------------------------------------------------------! do iskip_ = 1 , n_skip_lines read ( 8 , * ) enddo do il = 1 , nterms !------------------------------------------------------------------! ! Check if current value of l1 is in line with l1tab !------------------------------------------------------------------! read ( 8 , * ) l1 if ( l1 . ne . l1tab ( il )) then close ( 8 ) close ( 11 ) if ( ipart . eq . 1 ) close ( 12 ) call write_error ( \"potential_read: l1 = \" // integer_to_character ( l1 ) // & \" differs from expected balue in l1tab (\" // integer_to_character ( il ) // & \") = \" // integer_to_character ( l1tab ( il ))) endif do ir = 1 , nr read ( 8 , * ) rmat ( ir ), ( read_vmat3D ( ir , il , icol ),& icol = 1 , totalcol ) enddo enddo close ( 8 , iostat = io_status , iomsg = err_message ) call file_io_status ( io_status , err_message , 5 , 'c' ) !---------------------------------------------------------------------! ! Check if supplied radial terms cover a sufficient range of R !---------------------------------------------------------------------! if ( rmin . lt . rmat ( 1 )) then close ( 11 ) if ( ipart . eq . 1 ) close ( 12 ) call write_error ( \"rmin value provided by the user (\" // & float_to_character ( rmin , \"(F10.4)\" ) // \") is smaller than \" // & \"rmin supplied in \" // trim ( adjustl ( potentialfile )) // \" ( \" // & float_to_character ( rmat ( 1 ), \"(F10.4)\" ) // \")\" ) else if ( rmax . gt . rmat ( nr )) then close ( 11 ) if ( ipart . eq . 1 ) close ( 12 ) call write_error ( \"rmax value provided by the user (\" // & float_to_character ( rmax , \"(F10.4)\" ) // \") is larger than \" // & \"rmax supplied in \" // trim ( adjustl ( potentialfile )) // \" ( \" // & float_to_character ( rmat ( nr ), \"(F10.4)\" ) // \")\" ) endif !---------------------------------------------------------------------! end subroutine !------------------------------------------------------------------------------! subroutine potential_reduction !! reducesof the read_vmat3D matrix to retain only the necessary coupling terms !! which are kept in reduced_*. The number of necessary coupling terms (ncoupl) !! is already determined in io_mod module. !! If totalcol = ncoupl, the procedure is ignored !---------------------------------------------------------------------! integer ( int32 ) :: il , icoupl , ir , icol !---------------------------------------------------------------------! ! Print the original set of quantum numbers !---------------------------------------------------------------------! if ( prntlvl . ge . 2 ) then call write_message ( \"*** Reducing the number of the radial coupling terms... ***\" ) if ( prntlvl . ge . 3 ) then call write_message ( \"Original set of quantum numbers:\" ) call write_message ( \"       v1  j1  v1`  j1`\" ) do icol = 1 , totalcol write ( * , \"(5X,2(2X,I2),2(2X,I2))\" ) v1pes ( icol ), j1pes ( icol ), & v1ppes ( icol ), j1ppes ( icol ) enddo endif endif !---------------------------------------------------------------------! ! Pick only the necessary terms: !---------------------------------------------------------------------! do il = 1 , nterms do ir = 1 , nr do icoupl = 1 , ncoupl do icol = 1 , totalcol if (( reduced_j1pes ( icoupl ) == j1pes ( icol )). and .& ( reduced_j1ppes ( icoupl ) == j1ppes ( icol )). and .& ( reduced_v1pes ( icoupl ) == v1pes ( icol )). and .& ( reduced_v1ppes ( icoupl ) == v1ppes ( icol ))) then vmat3D ( ir , il , icoupl ) = read_vmat3D ( ir , il , icol ) endif enddo enddo enddo enddo !---------------------------------------------------------------------! ! Print the reduced set of quantum numbers !---------------------------------------------------------------------! if ( prntlvl . ge . 2 ) then if ( prntlvl . ge . 3 ) then call write_message ( \"Reduced set of quantum numbers:\" ) call write_message ( \"       v1  j1  v1`  j1`\" ) do icoupl = 1 , ncoupl write ( * , \"(5X,2(2X,I2),2(2X,I2))\" ) reduced_v1pes ( icoupl ), & reduced_j1pes ( icoupl ), reduced_v1ppes ( icoupl ), reduced_j1ppes ( icoupl ) enddo endif call write_message ( \"*** Reduced \" // & trim ( adjustl ( integer_to_character ( totalcol ))) // & \" radial terms to \" // & trim ( adjustl ( integer_to_character ( ncoupl ))) // \" ***\" ) endif !---------------------------------------------------------------------! ! The original matrix is no longer needed !---------------------------------------------------------------------! deallocate ( read_vmat3D ) !---------------------------------------------------------------------! end subroutine !------------------------------------------------------------------------------! subroutine potential_interpolation !! intertpolates the necessary radial coupling terms using cubic !! spline functions. The coefficients are kept in bmat/cmat/dmat matrices !---------------------------------------------------------------------! integer ( int32 ) :: il , icoupl , ir !---------------------------------------------------------------------! do il = 1 , nterms do icoupl = 1 , ncoupl call SPLINE ( nr , rmat , vmat3D (:, il , icoupl ), b , c , d ) do ir = 1 , nr bmat3D ( ir , il , icoupl ) = b ( ir ) cmat3D ( ir , il , icoupl ) = c ( ir ) dmat3D ( ir , il , icoupl ) = d ( ir ) enddo enddo enddo !---------------------------------------------------------------------! end subroutine !------------------------------------------------------------------------------! end module POTENTIAL","tags":"","loc":"sourcefile/pes_read_mod.f90.html"},{"title":"array_operations_mod.f90 – the SCATTERING code","text":"Files dependent on this one sourcefile~~array_operations_mod.f90~~AfferentGraph sourcefile~array_operations_mod.f90 array_operations_mod.f90 sourcefile~input_reader_mod.f90 input_reader_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~array_operations_mod.f90 sourcefile~scattering.f90 scattering.f90 sourcefile~scattering.f90->sourcefile~array_operations_mod.f90 sourcefile~scattering.f90->sourcefile~input_reader_mod.f90 sourcefile~boundary_conditions_mod.f90 boundary_conditions_mod.f90 sourcefile~scattering.f90->sourcefile~boundary_conditions_mod.f90 sourcefile~propagator_mod.f90 propagator_mod.f90 sourcefile~scattering.f90->sourcefile~propagator_mod.f90 sourcefile~pes_read_mod.f90 pes_read_mod.f90 sourcefile~scattering.f90->sourcefile~pes_read_mod.f90 sourcefile~coupling_matrix_mod.f90 coupling_matrix_mod.f90 sourcefile~scattering.f90->sourcefile~coupling_matrix_mod.f90 sourcefile~sts_xs_mod.f90 sts_xs_mod.f90 sourcefile~scattering.f90->sourcefile~sts_xs_mod.f90 sourcefile~channels_mod.f90 channels_mod.f90 sourcefile~scattering.f90->sourcefile~channels_mod.f90 sourcefile~array_operations_append_submod.f90 array_operations_append_submod.f90 sourcefile~array_operations_append_submod.f90->sourcefile~array_operations_mod.f90 sourcefile~boundary_conditions_mod.f90->sourcefile~array_operations_mod.f90 sourcefile~boundary_conditions_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~array_operations_invert_symmetric_matrix_submod.f90 array_operations_invert_symmetric_matrix_submod.f90 sourcefile~array_operations_invert_symmetric_matrix_submod.f90->sourcefile~array_operations_mod.f90 sourcefile~propagator_mod.f90->sourcefile~array_operations_mod.f90 sourcefile~propagator_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~propagator_mod.f90->sourcefile~pes_read_mod.f90 sourcefile~array_operations_fill_symmetric_matrix_submod.f90 array_operations_fill_symmetric_matrix_submod.f90 sourcefile~array_operations_fill_symmetric_matrix_submod.f90->sourcefile~array_operations_mod.f90 sourcefile~array_operations_allocate_submod.f90 array_operations_allocate_submod.f90 sourcefile~array_operations_allocate_submod.f90->sourcefile~array_operations_mod.f90 sourcefile~pes_read_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~coupling_matrix_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~sts_xs_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~channels_mod.f90->sourcefile~input_reader_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules array_operations_mod Source Code array_operations_mod.f90 Source Code module array_operations_mod !! this module provides supplementary functions and subroutines to handle !! matrix allocation, invertion, appending etc. !---------------------------------------------------------------------------! use , intrinsic :: iso_fortran_env , only : int32 , sp => real32 , dp => real64 implicit none !---------------------------------------------------------------------------! interface allocate_1d pure module subroutine allocate_1d_int32 ( array_ , size_ ) !! allocate a 1d array and fill it with 0s (integer version) integer ( int32 ), intent ( inout ), allocatable :: array_ (:) integer ( int32 ), intent ( in ) :: size_ end subroutine allocate_1d_int32 pure module subroutine allocate_1d_sp ( array_ , size_ ) !! allocate a 1d array and fill it with 0s (single precision version) real ( sp ), intent ( inout ), allocatable :: array_ (:) integer ( int32 ), intent ( in ) :: size_ end subroutine allocate_1d_sp pure module subroutine allocate_1d_dp ( array_ , size_ ) !! allocate a 1d array and fill it with 0s (double precision version) real ( dp ), intent ( inout ), allocatable :: array_ (:) integer ( int32 ), intent ( in ) :: size_ end subroutine allocate_1d_dp end interface !---------------------------------------------------------------------------! interface allocate_2d pure module subroutine allocate_2d_int32 ( array_ , size1_ , size2_ ) !! allocate a 2d array and fill it with 0s (integer version) integer ( int32 ), intent ( inout ), allocatable :: array_ (:,:) integer ( int32 ), intent ( in ) :: size1_ , size2_ end subroutine allocate_2d_int32 pure module subroutine allocate_2d_sp ( array_ , size1_ , size2_ ) !! allocate a 2d array and fill it with 0s (single precision version) real ( sp ), intent ( inout ), allocatable :: array_ (:,:) integer ( int32 ), intent ( in ) :: size1_ , size2_ end subroutine allocate_2d_sp pure module subroutine allocate_2d_dp ( array_ , size1_ , size2_ ) !! allocate a 2d array and fill it with 0s (double precision version) real ( dp ), intent ( inout ), allocatable :: array_ (:,:) integer ( int32 ), intent ( in ) :: size1_ , size2_ end subroutine allocate_2d_dp end interface !---------------------------------------------------------------------------! interface allocate_3d pure module subroutine allocate_3d_int32 ( array_ , size1_ , size2_ , size3_ ) !! allocate a 3d array and fill it with 0s (integer version) integer ( int32 ), intent ( inout ), allocatable :: array_ (:,:,:) integer ( int32 ), intent ( in ) :: size1_ , size2_ , size3_ end subroutine allocate_3d_int32 pure module subroutine allocate_3d_sp ( array_ , size1_ , size2_ , size3_ ) !! allocate a 3d array and fill it with 0s (single precision version) real ( sp ), intent ( inout ), allocatable :: array_ (:,:,:) integer ( int32 ), intent ( in ) :: size1_ , size2_ , size3_ end subroutine allocate_3d_sp pure module subroutine allocate_3d_dp ( array_ , size1_ , size2_ , size3_ ) !! allocate a 3d array and fill it with 0s (double precision version) real ( dp ), intent ( inout ), allocatable :: array_ (:,:,:) integer ( int32 ), intent ( in ) :: size1_ , size2_ , size3_ end subroutine allocate_3d_dp end interface !---------------------------------------------------------------------------! interface append pure module subroutine append_int32 ( array_ , element_ ) !! append element to an array (integer version) integer ( int32 ), intent ( inout ), allocatable :: array_ (:) integer ( int32 ), intent ( in ) :: element_ end subroutine append_int32 pure module subroutine append_sp ( array_ , element_ ) !! append element to an array (single precision version) real ( sp ), intent ( inout ), allocatable :: array_ (:) real ( sp ), intent ( in ) :: element_ end subroutine append_sp pure module subroutine append_dp ( array_ , element_ ) !! append element to an array (double precision version) real ( dp ), intent ( inout ), allocatable :: array_ (:) real ( dp ), intent ( in ) :: element_ end subroutine append_dp end interface !---------------------------------------------------------------------------! !   interface print_square_matrix !      module subroutine print_square_matrix_int32(matrix_, tol_) !         !! print elements of the square matrix with given tolerance (integer version) !         integer(int32), intent(in)     :: matrix_(:,:) !         real(dp), optional, intent(in) :: tol_ !      end subroutine print_square_matrix_int32 !      module subroutine print_square_matrix_sp(matrix_, tol_) !         !! print elements of the square matrix with given tolerance (single precision version) !         real(sp), intent(in)           :: matrix_(:,:) !         real(dp), optional, intent(in) :: tol_ !      end subroutine print_square_matrix_sp !      module subroutine print_square_matrix_dp(matrix_, tol_) !         !! print elements of the square matrix with given tolerance (double precision version) !         real(dp), intent(in)           :: matrix_(:,:) !         real(dp), optional, intent(in) :: tol_ !      end subroutine print_square_matrix_dp !   end interface !---------------------------------------------------------------------------! interface invert_symmetric_matrix module subroutine invert_symmetric_matrix_int32 ( matrix_ ) !! invert a symmetric matrix using DSYTRI method (integer version) integer ( int32 ), intent ( inout ) :: matrix_ (:,:) end subroutine invert_symmetric_matrix_int32 module subroutine invert_symmetric_matrix_sp ( matrix_ ) !! invert a symmetric matrix using DSYTRI method (single precision version) real ( sp ), intent ( inout ) :: matrix_ (:,:) end subroutine invert_symmetric_matrix_sp module subroutine invert_symmetric_matrix_dp ( matrix_ ) !! invert a symmetric matrix using DSYTRI method (double precision version) real ( dp ), intent ( inout ) :: matrix_ (:,:) end subroutine invert_symmetric_matrix_dp end interface !---------------------------------------------------------------------------! interface fill_symmetric_matrix module subroutine fill_symmetric_matrix_int32 ( matrix_ , upper_lower_ ) !! fill the upper/lower triangle of a symmetric matrix (integer version) integer ( int32 ), intent ( inout ) :: matrix_ (:,:) character ( len = 1 ), intent ( in ) :: upper_lower_ end subroutine fill_symmetric_matrix_int32 module subroutine fill_symmetric_matrix_sp ( matrix_ , upper_lower_ ) !! fill the upper/lower triangle of a symmetric matrix (single precision version) real ( sp ), intent ( inout ) :: matrix_ (:,:) character ( len = 1 ), intent ( in ) :: upper_lower_ end subroutine fill_symmetric_matrix_sp module subroutine fill_symmetric_matrix_dp ( matrix_ , upper_lower_ ) !! fill the upper/lower triangle of a symmetric matrix (double precision version) real ( dp ), intent ( inout ) :: matrix_ (:,:) character ( len = 1 ), intent ( in ) :: upper_lower_ end subroutine fill_symmetric_matrix_dp end interface !---------------------------------------------------------------------------! end module array_operations_mod","tags":"","loc":"sourcefile/array_operations_mod.f90.html"},{"title":"array_operations_invert_symmetric_matrix_submod.f90 – the SCATTERING code","text":"This file depends on sourcefile~~array_operations_invert_symmetric_matrix_submod.f90~~EfferentGraph sourcefile~array_operations_invert_symmetric_matrix_submod.f90 array_operations_invert_symmetric_matrix_submod.f90 sourcefile~array_operations_mod.f90 array_operations_mod.f90 sourcefile~array_operations_invert_symmetric_matrix_submod.f90->sourcefile~array_operations_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules array_operations_invert_symmetric_matrix_submod Source Code array_operations_invert_symmetric_matrix_submod.f90 Source Code submodule ( array_operations_mod ) array_operations_invert_symmetric_matrix_submod !! a submodule for append subroutines implicit none contains module subroutine invert_symmetric_matrix_int32 ( matrix_ ) !! invert a symmetric matrix using DSYTRI method (integer version) integer ( int32 ), intent ( inout ) :: matrix_ (:,:) !---------------------------------------------------------------------! write ( * , * ) \"Integer version of Lapack inversion procedures does not exist\" write ( * , * ) \"Convert the integer arrays to real\" stop !---------------------------------------------------------------------! end subroutine invert_symmetric_matrix_int32 module subroutine invert_symmetric_matrix_sp ( matrix_ ) !! invert a symmetric matrix using SSYTRI method (single precision version) real ( sp ), intent ( inout ) :: matrix_ (:,:) !---------------------------------------------------------------------! integer ( int32 ) :: size_1_ , size_2_ , size_ , lwork_ , nb_ , ok_ , ILAENV integer ( int32 ), allocatable :: pivot_ (:) real ( sp ), allocatable :: work_ (:) !---------------------------------------------------------------------! size_1_ = size ( matrix_ , dim = 1 ) size_2_ = size ( matrix_ , dim = 2 ) if ( size_1_ . eq . size_2_ ) then size_ = size_1_ else print * , \"Error in invert_symmetric_matrix_dp: size in dim = 1 (\" , size_1_ ,& \") is different than in dim = 2 (\" , size_2_ , \")\" print * , \"Adapt this subroutine to rectangle matrices\" stop endif !---------------------------------------------------------------------! if ( allocated ( pivot_ )) deallocate ( pivot_ ) allocate ( pivot_ ( size_ )) !---------------------------------------------------------------------! nb_ = ILAENV ( 1 , 'SSYTRF' , 'L' , size_ , - 1 , - 1 , - 1 ) lwork_ = nb_ * size_ if ( allocated ( work_ )) deallocate ( work_ ) allocate ( work_ ( lwork_ )) work_ = 0 !---------------------------------------------------------------------! call SSYTRF ( 'L' , size_ , matrix_ , size_ , pivot_ , work_ , lwork_ , ok_ ) if ( ok_ /= 0 ) then write ( * , * ) \"DSYTRF failed with status:\" , ok_ stop endif !---------------------------------------------------------------------! call SSYTRI ( 'L' , size_ , matrix_ , size_ , pivot_ , work_ , ok_ ) if ( ok_ /= 0 ) then write ( * , * ) \"DSYTRI failed with status:\" , ok_ stop endif !---------------------------------------------------------------------! end subroutine invert_symmetric_matrix_sp module subroutine invert_symmetric_matrix_dp ( matrix_ ) !! invert a symmetric matrix using DSYTRI method (double precision version) real ( dp ), intent ( inout ) :: matrix_ (:,:) !---------------------------------------------------------------------! integer ( int32 ) :: size_1_ , size_2_ , size_ , lwork_ , nb_ , ok_ , ILAENV integer ( int32 ), allocatable :: pivot_ (:) real ( dp ), allocatable :: work_ (:) !---------------------------------------------------------------------! size_1_ = size ( matrix_ , dim = 1 ) size_2_ = size ( matrix_ , dim = 2 ) if ( size_1_ . eq . size_2_ ) then size_ = size_1_ else print * , \"Error in invert_symmetric_matrix_dp: size in dim = 1 (\" , size_1_ ,& \") is different than in dim = 2 (\" , size_2_ , \")\" print * , \"Adapt this subroutine to rectangle matrices\" stop endif !---------------------------------------------------------------------! if ( allocated ( pivot_ )) deallocate ( pivot_ ) allocate ( pivot_ ( size_ )) !---------------------------------------------------------------------! nb_ = ILAENV ( 1 , 'DSYTRF' , 'L' , size_ , - 1 , - 1 , - 1 ) lwork_ = nb_ * size_ if ( allocated ( work_ )) deallocate ( work_ ) allocate ( work_ ( lwork_ )) work_ = 0 !---------------------------------------------------------------------! call DSYTRF ( 'L' , size_ , matrix_ , size_ , pivot_ , work_ , lwork_ , ok_ ) if ( ok_ /= 0 ) then write ( * , * ) \"DSYTRF failed with status:\" , ok_ stop endif !---------------------------------------------------------------------! call DSYTRI ( 'L' , size_ , matrix_ , size_ , pivot_ , work_ , ok_ ) if ( ok_ /= 0 ) then write ( * , * ) \"DSYTRI failed with status:\" , ok_ stop endif !---------------------------------------------------------------------! end subroutine invert_symmetric_matrix_dp end submodule array_operations_invert_symmetric_matrix_submod","tags":"","loc":"sourcefile/array_operations_invert_symmetric_matrix_submod.f90.html"},{"title":"array_operations_append_submod.f90 – the SCATTERING code","text":"This file depends on sourcefile~~array_operations_append_submod.f90~~EfferentGraph sourcefile~array_operations_append_submod.f90 array_operations_append_submod.f90 sourcefile~array_operations_mod.f90 array_operations_mod.f90 sourcefile~array_operations_append_submod.f90->sourcefile~array_operations_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules array_operations_append_submod Source Code array_operations_append_submod.f90 Source Code submodule ( array_operations_mod ) array_operations_append_submod !! a submodule for append subroutines implicit none contains pure module subroutine append_int32 ( array_ , element_ ) !! append element to an array (intger version) integer ( int32 ), allocatable , intent ( inout ) :: array_ (:) integer ( int32 ), intent ( in ) :: element_ !---------------------------------------------------------------------! integer ( int32 ), allocatable :: tmp_array_ (:) !---------------------------------------------------------------------! if ( allocated ( array_ )) then allocate ( tmp_array_ ( size ( array_ ) + 1 )) tmp_array_ (: size ( array_ )) = array_ (:) tmp_array_ ( size ( array_ ) + 1 ) = element_ deallocate ( array_ ) allocate ( array_ ( size ( tmp_array_ ))) call move_alloc ( tmp_array_ , array_ ) else allocate ( array_ ( 1 )) array_ ( 1 ) = element_ endif end subroutine append_int32 pure module subroutine append_sp ( array_ , element_ ) !! append element to an array (single precision version) real ( sp ), allocatable , intent ( inout ) :: array_ (:) real ( sp ), intent ( in ) :: element_ !---------------------------------------------------------------------! real ( sp ), allocatable :: tmp_array_ (:) !---------------------------------------------------------------------! if ( allocated ( array_ )) then allocate ( tmp_array_ ( size ( array_ ) + 1 )) tmp_array_ (: size ( array_ )) = array_ (:) tmp_array_ ( size ( array_ ) + 1 ) = element_ deallocate ( array_ ) allocate ( array_ ( size ( tmp_array_ ))) call move_alloc ( tmp_array_ , array_ ) else allocate ( array_ ( 1 )) array_ ( 1 ) = element_ endif end subroutine append_sp pure module subroutine append_dp ( array_ , element_ ) !! append element to an array (double precision version) real ( dp ), allocatable , intent ( inout ) :: array_ (:) real ( dp ), intent ( in ) :: element_ !---------------------------------------------------------------------! real ( dp ), allocatable :: tmp_array_ (:) !---------------------------------------------------------------------! if ( allocated ( array_ )) then allocate ( tmp_array_ ( size ( array_ ) + 1 )) tmp_array_ (: size ( array_ )) = array_ (:) tmp_array_ ( size ( array_ ) + 1 ) = element_ deallocate ( array_ ) allocate ( array_ ( size ( tmp_array_ ))) call move_alloc ( tmp_array_ , array_ ) else allocate ( array_ ( 1 )) array_ ( 1 ) = element_ endif end subroutine append_dp end submodule array_operations_append_submod","tags":"","loc":"sourcefile/array_operations_append_submod.f90.html"},{"title":"coupling_matrix_mod.f90 – the SCATTERING code","text":"This file depends on sourcefile~~coupling_matrix_mod.f90~~EfferentGraph sourcefile~coupling_matrix_mod.f90 coupling_matrix_mod.f90 sourcefile~utility_functions_mod.f90 utility_functions_mod.f90 sourcefile~coupling_matrix_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~input_reader_mod.f90 input_reader_mod.f90 sourcefile~coupling_matrix_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~math_functions_mod.f90 math_functions_mod.f90 sourcefile~coupling_matrix_mod.f90->sourcefile~math_functions_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~array_operations_mod.f90 array_operations_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~array_operations_mod.f90 sourcefile~math_functions_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~special_functions_mod.f90 special_functions_mod.f90 sourcefile~math_functions_mod.f90->sourcefile~special_functions_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~coupling_matrix_mod.f90~~AfferentGraph sourcefile~coupling_matrix_mod.f90 coupling_matrix_mod.f90 sourcefile~scattering.f90 scattering.f90 sourcefile~scattering.f90->sourcefile~coupling_matrix_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules PES_COUPLING_MATRIX Source Code coupling_matrix_mod.f90 Source Code module PES_COUPLING_MATRIX !! this module provides functions calculating the algebraic coefficients !! entering the coupling matrix (Eq. ...) !---------------------------------------------------------------------------! use , intrinsic :: iso_fortran_env , only : int32 , sp => real32 , dp => real64 use utility_functions_mod , only : write_error , write_message , integer_to_character use fwigxjpf , only : fwig3jj use io_mod use math_functions_mod , only : triangle_inequality_holds , is_sum_even implicit none contains !------------------------------------------------------------------------------! subroutine check_nonzero_coupling_matrix_elements ( number_of_channels , & channels_level_indices , channels_omega_values , & number_of_nonzero_coupling_matrix_elements , & number_of_nonzero_coupling_coefficients ) !! checks the number of non-zero coupling matrix elements due to !! the \\bar{\\Omega} = \\bar{\\Omega}' condition !! (number_of_nonzero_coupling_matrix_elements variable), !! and the total number of non-zero algebraic coefficients that enter !! Eqs. (6.13)-(6.15) (number_of_nonzero_coupling_coefficients variable). !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: number_of_channels !! size of the basis integer ( int32 ), intent ( in ) :: channels_level_indices ( number_of_channels ) !! holds the indices pointing to the basis arrays integer ( int32 ), intent ( in ) :: channels_omega_values ( number_of_channels ) !! holds all values of \\bar{\\Omega} integer ( int32 ), intent ( out ) :: number_of_nonzero_coupling_matrix_elements !! number of non-zero terms in the sum () for each non-zero element of the coupling matrix integer ( int32 ), intent ( out ) :: number_of_nonzero_coupling_coefficients !! number of all non-zero algberaix coefficients in the whole coupling matrix !---------------------------------------------------------------------! integer ( int32 ) :: count_nonzero_coupling_matrix_elements , & count_nonzero_coupling_coefficients , nil , j1tmp , j1ptmp , omegatmp , & omegaptmp , l1 , ii , ij , il !---------------------------------------------------------------------! count_nonzero_coupling_coefficients = 0 count_nonzero_coupling_matrix_elements = 0 do ii = 1 , number_of_channels j1tmp = j1array ( channels_level_indices ( ii )) omegatmp = channels_omega_values ( ii ) do ij = 1 , ii j1ptmp = j1array ( channels_level_indices ( ij )) omegaptmp = channels_omega_values ( ij ) if ( omegatmp . ne . omegaptmp ) cycle count_nonzero_coupling_matrix_elements = & count_nonzero_coupling_matrix_elements + 1 do il = 1 , nterms l1 = l1tab ( il ) if ( triangle_inequality_holds ( j1tmp , j1ptmp , l1 ). eq . 0 ) cycle if ( is_sum_even ( j1tmp , j1ptmp , l1 ). eq . 0 ) cycle count_nonzero_coupling_coefficients = & count_nonzero_coupling_coefficients + 1 enddo enddo enddo !---------------------------------------------------------------------! number_of_nonzero_coupling_coefficients = count_nonzero_coupling_coefficients number_of_nonzero_coupling_matrix_elements = count_nonzero_coupling_matrix_elements !---------------------------------------------------------------------! end subroutine check_nonzero_coupling_matrix_elements !------------------------------------------------------------------------------! subroutine prepare_coupling_matrix_elements ( number_of_channels , & channels_level_indices , channels_omega_values , & number_of_nonzero_coupling_matrix_elements , & number_of_nonzero_coupling_coefficients , & nonzero_terms_per_element , nonzero_legendre_indices , & nonzero_coupling_coefficients ) !! prepares: !! -- nonzero_terms_per_element - keeps the number of !!    non-zero terms in the sum (Eq. (6.21)) for each non-zero matrix !!    element of the coupling matrix !! -- nonzero_legendre_indices - holds the proper !!    indices in the range (0, nterms) pointing to l1/l2/lltabs, which !!    correspond to the non-vanishing elements of the sum (Eq. (6.21)) !!    for each non-zero  matrix element of the coupling matrix !! -- nonzero_coupling_coefficients --  holds values of non-zero Percival-Seaton coefficients !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: number_of_channels !! size of the basis integer ( int32 ), intent ( in ) :: channels_level_indices ( number_of_channels ) !! holds the indices pointing to the basis arrays integer ( int32 ), intent ( in ) :: channels_omega_values ( number_of_channels ) !! holds all values of \\bar{\\Omega} integer ( int32 ), intent ( in ) :: number_of_nonzero_coupling_matrix_elements !! number of non-zero terms in the sum () for each non-zero element of the coupling matrix integer ( int32 ), intent ( in ) :: number_of_nonzero_coupling_coefficients !! number of all non-zero algberaix coefficients in the whole coupling matrix integer ( int32 ), intent ( inout ) :: & nonzero_terms_per_element ( number_of_nonzero_coupling_matrix_elements ) !! keeps the number of non-zero terms in the sum (Eq. (6.21)) for !! each non-zero element of the coupling matrix integer ( int32 ), intent ( inout ) :: & nonzero_legendre_indices ( number_of_nonzero_coupling_coefficients ) !! holds proper indices pointing to l1tab, which !! correspond to the non-vanishing elements of the sum  (Eq. (6.21)) !! for each non-zero element of the coupling matrix real ( dp ), intent ( inout ) :: & nonzero_coupling_coefficients ( number_of_nonzero_coupling_coefficients ) !! holds the values of the non-zero algebraic coefficients !---------------------------------------------------------------------! integer ( int32 ) :: count_nonzero_coupling_matrix_elements , & count_nonzero_coupling_coefficients , nonzero_legendre , j1tmp , & j1ptmp , omegatmp , omegaptmp , l1 , ii , ij , il real ( dp ) :: pscoeff !---------------------------------------------------------------------! nonzero_terms_per_element = 0 nonzero_legendre_indices = 0 nonzero_coupling_coefficients = 0 count_nonzero_coupling_coefficients = 0 count_nonzero_coupling_matrix_elements = 0 !---------------------------------------------------------------------! do ii = 1 , number_of_channels j1tmp = j1array ( channels_level_indices ( ii )) omegatmp = channels_omega_values ( ii ) do ij = 1 , ii j1ptmp = j1array ( channels_level_indices ( ij )) omegaptmp = channels_omega_values ( ij ) if ( omegatmp . ne . omegaptmp ) cycle !---------------------------------------------------------------! ! passed \\bar{\\Omega} = \\bar{\\Omega}' condition !---------------------------------------------------------------! count_nonzero_coupling_matrix_elements = & count_nonzero_coupling_matrix_elements + 1 !---------------------------------------------------------------! ! count non-zero terms in the sum over legendre polynomials ! for this element !---------------------------------------------------------------! nonzero_legendre = 0 do il = 1 , nterms l1 = l1tab ( il ) if ( triangle_inequality_holds ( j1tmp , j1ptmp , l1 ). eq . 0 ) cycle if ( is_sum_even ( j1tmp , j1ptmp , l1 ). eq . 0 ) cycle !------------------------------------------------------------! ! passed non-zero conditions !------------------------------------------------------------! count_nonzero_coupling_coefficients = & count_nonzero_coupling_coefficients + 1 !------------------------------------------------------------! ! calculate the Percival-Seaton coefficient !------------------------------------------------------------! pscoeff = dsqrt ( real (( 2 * j1tmp + 1 ) * ( 2 * j1ptmp + 1 ), dp ))& * fwig3jj ( 2 * j1tmp , 2 * j1ptmp , 2 * l1 , 0 , 0 , 0 ) & * fwig3jj ( 2 * j1tmp , 2 * j1ptmp , 2 * l1 , & 2 * omegatmp , - 2 * omegatmp , 0 ) & * ( - 1.0_dp ) ** ( omegatmp ) !------------------------------------------------------------! nonzero_coupling_coefficients ( & count_nonzero_coupling_coefficients ) = pscoeff nonzero_legendre_indices ( count_nonzero_coupling_coefficients )& = il nonzero_legendre = nonzero_legendre + 1 enddo nonzero_terms_per_element ( count_nonzero_coupling_matrix_elements )& = nonzero_legendre enddo enddo !---------------------------------------------------------------------! end subroutine prepare_coupling_matrix_elements !------------------------------------------------------------------------------! !------------------------------------------------------------------------------! subroutine print_coupling_matrix_elements_summary ( number_of_channels , & number_of_nonzero_coupling_matrix_elements , & number_of_nonzero_coupling_coefficients ) !! print a shor summary on the number of non-zero matrix elements !! of the coupling matrix !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: number_of_channels !! size of the basis integer ( int32 ), intent ( in ) :: number_of_nonzero_coupling_matrix_elements !! number of non-zero terms in the sum () for each non-zero element !! of the coupling matrix integer ( int32 ), intent ( in ) :: number_of_nonzero_coupling_coefficients !! number of all non-zero algberaix coefficients in the whole !! coupling matrix !---------------------------------------------------------------------! call write_message ( repeat ( \"*\" , 90 )) call write_message ( repeat ( \" \" , 5 ) // \"Size of the coupling matrix: \" // & integer_to_character ( number_of_channels )) call write_message ( repeat ( \" \" , 5 ) // \"Number of non-zero elements \" // & \"of the potential matrix: \" // integer_to_character ( & number_of_nonzero_coupling_matrix_elements )) call write_message ( repeat ( \" \" , 5 ) // \"Number of non-zero elements \" // & \" of the coupling matrix: \" // integer_to_character ( & number_of_nonzero_coupling_coefficients )) call write_message ( repeat ( '*' , 90 )) !---------------------------------------------------------------------! end subroutine print_coupling_matrix_elements_summary !------------------------------------------------------------------------------! !------------------------------------------------------------------------------! end module PES_COUPLING_MATRIX","tags":"","loc":"sourcefile/coupling_matrix_mod.f90.html"},{"title":"sts_xs_mod.f90 – the SCATTERING code","text":"This file depends on sourcefile~~sts_xs_mod.f90~~EfferentGraph sourcefile~sts_xs_mod.f90 sts_xs_mod.f90 sourcefile~input_reader_mod.f90 input_reader_mod.f90 sourcefile~sts_xs_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~utility_functions_mod.f90 utility_functions_mod.f90 sourcefile~sts_xs_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~array_operations_mod.f90 array_operations_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~array_operations_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~sts_xs_mod.f90~~AfferentGraph sourcefile~sts_xs_mod.f90 sts_xs_mod.f90 sourcefile~scattering.f90 scattering.f90 sourcefile~scattering.f90->sourcefile~sts_xs_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules statetostateXS Source Code sts_xs_mod.f90 Source Code module statetostateXS !! This modules contains the subroutine that calculates the state-to-state XS !---------------------------------------------------------------------------! use , intrinsic :: iso_fortran_env , only : int32 , sp => real32 , dp => real64 use io_mod use utility_functions_mod , only : write_message , time_count_summary implicit none contains !---------------------------------------------------------------------------! subroutine CROSSSECTION ( jj , nopen , number_of_channels , & number_of_open_basis_levels , open_basis_levels , & open_basis_wavevectors , srmatrix , simatrix , channels_level_indices , & channels_l_values , xs_array ) !! calculate the state-to-state cross-section !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: jj !! total angular momentum integer ( int32 ), intent ( in ) :: nopen !! number of open channels integer ( int32 ), intent ( in ) :: number_of_channels !! size of the basis integer ( int32 ), intent ( in ) :: number_of_open_basis_levels !! number of all possible state-to-state XS integer ( int32 ), intent ( in ) :: open_basis_levels ( number_of_open_basis_levels ) !! holds indices to the basis arrays which correspond to open channels real ( dp ), intent ( in ) :: open_basis_wavevectors ( number_of_open_basis_levels ) !! holds wavenumbers k_{i} real ( dp ), intent ( in ) :: srmatrix ( nopen , nopen ), simatrix ( nopen , nopen ) !! real and imaginary parts of the S-matrix integer ( int32 ), intent ( in ) :: channels_level_indices ( number_of_channels ) !! holds the indices pointing to the basis arrays integer ( int32 ), intent ( in ) :: channels_l_values ( number_of_channels ) !! holds all values of l real ( dp ), intent ( inout ) :: xs_array ( number_of_open_basis_levels * number_of_open_basis_levels ) !! array holding all XSs !---------------------------------------------------------------------! integer ( int32 ) :: jinit , jfin , njoccur , njpoccur , v1lev , j1lev , & v1plev , j1plev , ltmp , lptmp , iinit , ifin , ioccur1 , ioccur2 , ii , & il , ilp real ( dp ) :: waveinit , xssum , telr , teli , telsq , time_start , time_finish , xs_time integer ( int32 ), allocatable :: jblockarr (:), jpblockarr (:) !---------------------------------------------------------------------! call CPU_TIME ( time_start ) xs_array = 0 !---------------------------------------------------------------------! do iinit = 1 , number_of_open_basis_levels jinit = open_basis_levels ( iinit ) v1lev = v1array ( jinit ) j1lev = j1array ( jinit ) waveinit = open_basis_wavevectors ( iinit ) do ifin = 1 , number_of_open_basis_levels jfin = open_basis_levels ( ifin ) v1plev = v1array ( jfin ) j1plev = j1array ( jfin ) njoccur = 0 njpoccur = 0 do ii = 1 , number_of_channels if (( j1array ( channels_level_indices ( ii )). eq . j1lev )& . and .( v1array ( channels_level_indices ( ii )). eq . v1lev )) then njoccur = njoccur + 1 endif if ( j1array ( channels_level_indices ( ii )). eq . j1plev & . and .( v1array ( channels_level_indices ( ii )). eq . v1plev )) then njpoccur = njpoccur + 1 endif enddo call allocate_1d ( jblockarr , njoccur ) call allocate_1d ( jpblockarr , njpoccur ) ioccur1 = 0 ioccur2 = 0 do ii = 1 , number_of_channels if (( j1array ( channels_level_indices ( ii )). eq . j1lev )& . and .( v1array ( channels_level_indices ( ii )). eq . v1lev )) then ioccur1 = ioccur1 + 1 jblockarr ( ioccur1 ) = ii endif if ( j1array ( channels_level_indices ( ii )). eq . j1plev & . and .( v1array ( channels_level_indices ( ii )). eq . v1plev )) then ioccur2 = ioccur2 + 1 jpblockarr ( ioccur2 ) = ii endif enddo xssum = 0.d0 do il = 1 , njoccur ltmp = channels_l_values ( jblockarr ( il )) do ilp = 1 , njpoccur lptmp = channels_l_values ( jpblockarr ( ilp )) if (( j1lev . eq . j1plev ). and .( v1lev . eq . v1plev )) then if ( ltmp . eq . lptmp ) then telr = 1.d0 - srmatrix ( jblockarr ( il ),& jpblockarr ( ilp )) teli = - simatrix ( jblockarr ( il ), jpblockarr ( ilp )) telsq = telr ** 2.d0 + teli ** 2.d0 xssum = xssum + telsq else telr = - srmatrix ( jblockarr ( il ), jpblockarr ( ilp )) teli = - simatrix ( jblockarr ( il ), jpblockarr ( ilp )) telsq = telr ** 2.d0 + teli ** 2.d0 xssum = xssum + telsq endif else telr = - srmatrix ( jblockarr ( il ), jpblockarr ( ilp )) teli = - simatrix ( jblockarr ( il ), jpblockarr ( ilp )) telsq = telr ** 2.d0 + teli ** 2.d0 xssum = xssum + telsq endif enddo enddo xssum = xssum * ( 2.d0 * jj + 1.d0 ) xs_array (( iinit - 1 ) * number_of_open_basis_levels + ifin ) = xssum * pi / & (( 2.d0 * j1lev + 1.d0 ) * waveinit ** 2.d0 ) enddo enddo !---------------------------------------------------------------------! CALL CPU_TIME ( time_finish ) if ( prntlvl . ge . 2 ) call time_count_summary ( time_start , time_finish , & xs_time , \"Cross-sections calculations completed in \" ) end !------------------------------------------------------------------------------! !------------------------------------------------------------------------------! subroutine print_largest_partial_xs ( jj , maxXSdiag , maxXSoff , jinddiag , jindoff1 , & jindoff2 , number_of_open_basis_levels , open_basis_levels ) !! print the largest partial elastic and inelastic state-to-state XS !! in given J-block !---------------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: jj !! total angular momentum real ( dp ), intent ( in ) :: maxXSdiag !! the largest partial elastic state-to-state XS in this J-block real ( dp ), intent ( in ) :: maxXSoff !! the largest partial inelastic state-to-state XS in this J-block integer ( int32 ), intent ( in ) :: jinddiag !! index pointing indirectly to quantum numbers associated with !! the largest partial elastic state-to-state XS in this J-block integer ( int32 ), intent ( in ) :: jindoff1 , jindoff2 !! indices pointing indirectly to quantum numbers associated with !! the largest partial inelastic state-to-state XS in this J-block integer ( int32 ), intent ( in ) :: number_of_open_basis_levels !! number of all possible state-to-state XS (size of open_basis_levels array) integer ( int32 ), intent ( in ) :: open_basis_levels ( number_of_open_basis_levels ) !! holds indices to the basis arrays which correspond to open channels !---------------------------------------------------------------------------! character ( len = 200 ) :: header_line , line !---------------------------------------------------------------------------! if (( prntlvl . eq . 1 ). or .( prntlvl . eq . 2 )) then call write_message ( \"Largest partial elastic state-to-state for JTOT = \" // & trim ( adjustl ( integer_to_character ( jj ))) // \": \" // & trim ( adjustl ( float_to_character ( maxXSdiag )))) call write_message ( \"Largest partial inelastic state-to-state for JTOT = \" // & trim ( adjustl ( integer_to_character ( jj ))) // \": \" // & trim ( adjustl ( float_to_character ( maxXSoff )))) call write_message ( repeat ( \" \" , 43 ) // \"***\" ) else if ( prntlvl . ge . 3 ) then !------------------------------------------------------------------------! call write_message ( \"Largest partial elastic state-to-state for JTOT = \" // & integer_to_character ( jj ) ) write ( header_line , \"(2x,a4,2x,a4,2x,a2,2x,a4,2x,a4,16x,a2)\" ) \"v1_f\" , & \"j1_f\" , \"<-\" , \"v1_i\" , \"j1_i\" , \"XS\" call write_message ( header_line ) write ( line , \"(2X,I4,2X,I4,6X,I4,2X,I4,2X,E16.8)\" ) & v1array ( open_basis_levels ( jinddiag )), j1array ( open_basis_levels ( jinddiag )), & v1array ( open_basis_levels ( jinddiag )), j1array ( open_basis_levels ( jinddiag )), maxXSdiag call write_message ( line ) !------------------------------------------------------------------------! call write_message ( \"Largest partial inelastic state-to-state for JTOT = \" // & integer_to_character ( jj ) ) call write_message ( header_line ) write ( line , \"(2X,I4,2X,I4,6X,I4,2X,I4,2X,E16.8)\" ) & v1array ( open_basis_levels ( jindoff2 )), j1array ( open_basis_levels ( jindoff2 )), & v1array ( open_basis_levels ( jindoff1 )), j1array ( open_basis_levels ( jindoff1 )), maxXSoff call write_message ( line ) call write_message ( repeat ( \" \" , 43 ) // \"***\" ) !------------------------------------------------------------------------! endif end subroutine print_largest_partial_xs !------------------------------------------------------------------------------! !------------------------------------------------------------------------------! subroutine check_dtol_otol ( maxXSdiag , maxXSoff , ncacdiag , ncacoff , terminate ) !! check if the dtol/otol condition on partial XS is already fulfilled !---------------------------------------------------------------------------! real ( dp ), intent ( in ) :: maxXSdiag , maxXSoff !! largest elastic and inelastic XS integer ( int32 ), intent ( inout ) :: ncacdiag , ncacoff !! number of consecutive blocks for which dtol/otol condition is already !! fulfilled. Gets incremented within the subroutine logical , intent ( inout ) :: terminate !! if .true. the dtol/otol condition is fulfilled; !! J-tot loop is terminated !---------------------------------------------------------------------------! integer ( int32 ) :: icount , icount2 logical :: diagcontr , offcontr !---------------------------------------------------------------------------! terminate = . false . !---------------------------------------------------------------------------! ! diagcontr and offcontr check if dtol and otol are fulfilled, respectively !---------------------------------------------------------------------------! diagcontr = . false . offcontr = . false . !---------------------------------------------------------------------------! if ( maxXSdiag . le . dtol ) diagcontr = . true . if ( maxXSoff . le . otol ) offcontr = . true . !---------------------------------------------------------------------------! if ( diagcontr ) then ncacdiag = ncacdiag + 1 else ncacdiag = 0 endif !------------------------------------------------------------------------------! if ( offcontr ) then ncacoff = ncacoff + 1 else ncacoff = 0 endif !------------------------------------------------------------------------------! ! Finish the calculations if both contributions are smaller than the limits:   ! !------------------------------------------------------------------------------! if (( ncacdiag . ge . ncac ). and .( ncacoff . ge . ncac )) terminate = . true . !------------------------------------------------------------------------------! end subroutine check_dtol_otol !------------------------------------------------------------------------------! !------------------------------------------------------------------------------! end module statetostateXS","tags":"","loc":"sourcefile/sts_xs_mod.f90.html"},{"title":"scattering.f90 – the SCATTERING code","text":"This file depends on sourcefile~~scattering.f90~~EfferentGraph sourcefile~scattering.f90 scattering.f90 sourcefile~pes_read_mod.f90 pes_read_mod.f90 sourcefile~scattering.f90->sourcefile~pes_read_mod.f90 sourcefile~coupling_matrix_mod.f90 coupling_matrix_mod.f90 sourcefile~scattering.f90->sourcefile~coupling_matrix_mod.f90 sourcefile~sts_xs_mod.f90 sts_xs_mod.f90 sourcefile~scattering.f90->sourcefile~sts_xs_mod.f90 sourcefile~input_reader_mod.f90 input_reader_mod.f90 sourcefile~scattering.f90->sourcefile~input_reader_mod.f90 sourcefile~boundary_conditions_mod.f90 boundary_conditions_mod.f90 sourcefile~scattering.f90->sourcefile~boundary_conditions_mod.f90 sourcefile~channels_mod.f90 channels_mod.f90 sourcefile~scattering.f90->sourcefile~channels_mod.f90 sourcefile~propagator_mod.f90 propagator_mod.f90 sourcefile~scattering.f90->sourcefile~propagator_mod.f90 sourcefile~utility_functions_mod.f90 utility_functions_mod.f90 sourcefile~scattering.f90->sourcefile~utility_functions_mod.f90 sourcefile~array_operations_mod.f90 array_operations_mod.f90 sourcefile~scattering.f90->sourcefile~array_operations_mod.f90 sourcefile~pes_read_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~pes_read_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~math_functions_mod.f90 math_functions_mod.f90 sourcefile~pes_read_mod.f90->sourcefile~math_functions_mod.f90 sourcefile~coupling_matrix_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~coupling_matrix_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~coupling_matrix_mod.f90->sourcefile~math_functions_mod.f90 sourcefile~sts_xs_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~sts_xs_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~array_operations_mod.f90 sourcefile~boundary_conditions_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~boundary_conditions_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~boundary_conditions_mod.f90->sourcefile~array_operations_mod.f90 sourcefile~boundary_conditions_mod.f90->sourcefile~math_functions_mod.f90 sourcefile~channels_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~channels_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~propagator_mod.f90->sourcefile~pes_read_mod.f90 sourcefile~propagator_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~propagator_mod.f90->sourcefile~array_operations_mod.f90 sourcefile~propagator_mod.f90->sourcefile~math_functions_mod.f90 sourcefile~math_functions_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~special_functions_mod.f90 special_functions_mod.f90 sourcefile~math_functions_mod.f90->sourcefile~special_functions_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Programs SCATTERING Source Code scattering.f90 Source Code program SCATTERING use , intrinsic :: iso_fortran_env , only : int32 , sp => real32 , dp => real64 use io_mod use POTENTIAL use channels_mod use PES_COUPLING_MATRIX use PROPAGATORS use boundary_conditions_mod use statetostateXS use utility_functions_mod , only : write_header , file_io_status , write_message , & float_to_character , integer_to_character , time_count_summary use array_operations_mod , only : append !---------------------------------------------------------------------------! implicit none !---------------------------------------------------------------------------! character ( len = 200 ) :: err_message , partial_line , xs_line integer ( int32 ) :: number_of_nonzero_coupling_matrix_elements , & number_of_nonzero_coupling_coefficients , number_of_channels , size_even , & size_odd , number_of_open_basis_levels , iblock , jtot_ , parity_index , & parity_indextmp , nsteps , number_of_open_channels , ncacdiag , ncacoff , & omegamax , lmin , lmax , ltmp , lmat_len , len_even , len_odd , jinddiag , & jindoff1 , jindoff2 , ij , ilevel , iomega , iopen , iopen2 , isize_ , isize_2 , & icheck , icount , icount2 , io_status real ( dp ) :: wavmax , wavvdepth , maxXSdiag , maxXSoff , time_total_start , & time_total_stop , time_total , time_init_stop , time_init , time_jtot_start , & time_jtot_stop , time_jtot , time_parity_start , time_parity_stop , & time_parity , time_coupling_start , time_coupling_stop , time_coupling logical :: unitarity_block_check , terminate integer , allocatable :: channels_level_indices (:), channels_omega_values (:),& channels_l_values (:), open_basis_levels (:), nonzero_terms_per_element (:),& nonzero_legendre_indices (:), smatcheckarr (:) real ( dp ), allocatable :: wv (:), open_basis_wavevectors (:), & nonzero_coupling_coefficients (:), xs_total (:), xs_block (:), xs_jtot (:) real ( dp ), allocatable :: BF_log_der_matrix (:,:), SF_log_der_matrix (:,:), & k_matrix (:,:), s_matrix_real (:,:), s_matrix_imag (:,:) !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! ! Initizalization: start the time count !---------------------------------------------------------------------------! call cpu_time ( time_total_start ) !---------------------------------------------------------------------------! ! Initialize fwigxjpf library !---------------------------------------------------------------------------! call fwig_table_init ( 2 * 100 , 9 ) call fwig_temp_init ( 2 * 100 ) !---------------------------------------------------------------------------! ! Print the header !---------------------------------------------------------------------------! call write_header ( \"main\" ) !---------------------------------------------------------------------------! ! Read the input file !---------------------------------------------------------------------------! call read_input_file !---------------------------------------------------------------------------! ! S-matrix file: write input parameters and basis levels !---------------------------------------------------------------------------! open ( 11 , file = trim ( smatrixfile ), form = 'unformatted' , iostat = io_status , & iomsg = err_message ) call file_io_status ( io_status , err_message , 11 , \"o\" ) !---------------------------------------------------------------------------! write ( 11 ) label , 2 , nlevel , reducedmass write ( 11 ) ( v1array ( ilevel ), j1array ( ilevel ), ilevel = 1 , nlevel ) write ( 11 ) ( elevel ( ilevel ), ilevel = 1 , nlevel ) write ( 11 ) initial , energy !---------------------------------------------------------------------------! ! Prepare the file with the partial XS !---------------------------------------------------------------------------! if ( parity_index == 1 ) then open ( 12 , file = trim ( partialfile ), form = 'formatted' , status = 'unknown' , & iostat = io_status , iomsg = err_message ) call file_io_status ( io_status , err_message , 12 , \"o\" ) !------------------------------------------------------------------------! call write_message ( \"  jtot  iblock  v1_f  j1_f  <-  v1_i  j1_i'\" // & repeat ( \" \" , 14 ) // \"K.E.\" // repeat ( \" \" , 16 ) // \"XS\" , unit_ = 12 ) !------------------------------------------------------------------------! endif !---------------------------------------------------------------------------! ! Convert units: starting now, everything is in atomic units !---------------------------------------------------------------------------! call units_conversion !---------------------------------------------------------------------------! ! Read the radial terms of the potential from external file !---------------------------------------------------------------------------! call potential_read !---------------------------------------------------------------------------! ! Reduce matrix elements that are not needed !---------------------------------------------------------------------------! call potential_reduction !---------------------------------------------------------------------------! ! Interpolate radial terms !---------------------------------------------------------------------------! call potential_interpolation !---------------------------------------------------------------------------! ! Search for energetically accessible levels and prepare the arrays that are ! needed in the calculations of the state-to-state XS !---------------------------------------------------------------------------! number_of_open_basis_levels = count_open_basis_levels () call allocate_1d ( open_basis_levels , number_of_open_basis_levels ) call allocate_1d ( open_basis_wavevectors , number_of_open_basis_levels ) call save_open_basis_levels ( number_of_open_basis_levels , open_basis_levels , & open_basis_wavevectors ) !---------------------------------------------------------------------------! ! xs array summed over all blocks !---------------------------------------------------------------------------! call allocate_1d ( xs_total , & number_of_open_basis_levels * number_of_open_basis_levels ) !---------------------------------------------------------------------------! ! xs array a single JTOT value !---------------------------------------------------------------------------! call allocate_1d ( xs_jtot , & number_of_open_basis_levels * number_of_open_basis_levels ) !---------------------------------------------------------------------------! ! xs array a single parity block !---------------------------------------------------------------------------! call allocate_1d ( xs_block , & number_of_open_basis_levels * number_of_open_basis_levels ) !---------------------------------------------------------------------------! ! Initialization is finished !---------------------------------------------------------------------------! call cpu_time ( time_init_stop ) if ( prntlvl . ge . 2 ) call time_count_summary ( time_total_start , time_init_stop , & time_init , \"Initialization completed in \" ) !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! ! Prepare J-blocks !---------------------------------------------------------------------------! ! If JTOTMAX=-1 is called, iterate until convergence is achieved: ! this is managed by ncacdiag and ncacoff !---------------------------------------------------------------------------! ncacdiag = 0 ncacoff = 0 iblock = 0 terminate = . false . !---------------------------------------------------------------------------! ! Loop over total angular momentum !---------------------------------------------------------------------------! call write_message ( repeat ( \"*\" , 90 )) call write_message ( repeat ( \" \" , 28 ) // \"*** Loop over JTOT: ***\" ) !---------------------------------------------------------------------------! do jtot_ = jtotmin , jtotmax , jtotstep !------------------------------------------------------------------------! call write_header ( \"block\" , opt_integer_ = jtot_ ) !------------------------------------------------------------------------! call cpu_time ( time_jtot_start ) !------------------------------------------------------------------------! xs_jtot = 0 call set_number_of_channels ( jtot_ , size_even , size_odd ) !------------------------------------------------------------------------! do parity_index = 0 , 1 !---------------------------------------------------------------------! call cpu_time ( time_parity_start ) !---------------------------------------------------------------------! select case ( parity_index ) case ( 0 ) number_of_channels = size_even case ( 1 ) number_of_channels = size_odd end select !---------------------------------------------------------------------! if ( number_of_channels == 0 ) cycle !---------------------------------------------------------------------! ! Summary of the current block !---------------------------------------------------------------------! iblock = iblock + 1 if ( prntlvl . ge . 1 ) then call write_message ( \"Block number: \" // integer_to_character ( iblock )) call write_message ( \"jtot: \" // & trim ( adjustl ( integer_to_character ( jtot_ ))) // \" parity: \" // & trim ( adjustl ( integer_to_character (( - 1 ) ** parity_index ) ))) call write_message ( \"Number of scattering channels: \" // & integer_to_character ( number_of_channels )) endif !---------------------------------------------------------------------! ! Prepare of the basis for each J/p block: ! channels_omega_values holds all values of omega (BF_) ! channels_l_values holds all values of l (SF_) ! channels_level_indices holds the indices which refer to the basis arrays: !   --   v1level/j1level/elevel !---------------------------------------------------------------------! call allocate_1d ( channels_omega_values , number_of_channels ) call allocate_1d ( channels_l_values , number_of_channels ) call allocate_1d ( channels_level_indices , number_of_channels ) !---------------------------------------------------------------------! ! Prepare channels_omega_values, channels_level_indices and channels_l_values !---------------------------------------------------------------------! call set_channels_level_indices_channels_omega_values ( & number_of_channels , jtot_ , parity_index , channels_level_indices , & channels_omega_values ) call set_channels_l_values ( number_of_channels , jtot_ , parity_index , & channels_l_values ) !---------------------------------------------------------------------! ! Print the BF quantum numbers on screen !---------------------------------------------------------------------! if ( prntlvl . ge . 1 ) call print_bf_channels ( number_of_channels , jtot_ , & parity_index , channels_level_indices , channels_omega_values ) !---------------------------------------------------------------------! ! Determine the number of open (energetically accessible) channels ! and the largest wavevector in the block !---------------------------------------------------------------------! call set_number_of_open_channels_wavmax ( number_of_channels , & channels_level_indices , channels_omega_values , & number_of_open_channels , wavmax ) !---------------------------------------------------------------------! ! If there are no open channels, skip this block !---------------------------------------------------------------------! if ( number_of_open_channels == 0 ) then call write_message ( repeat ( '-' , 90 )) call write_message ( \"No open channels for block no.\" // & integer_to_character ( iblock ) ) call write_message ( repeat ( '-' , 90 )) cycle endif !---------------------------------------------------------------------! ! Determine the number of steps on the intermolecular (R) grid ! This is done either directly (if dr > 0) ! or through the number of steps per half de Broglie wavelength !---------------------------------------------------------------------! wavvdepth = dsqrt ( 2 * reducedmass * vdepth ) if ( dr <= 0 ) then nsteps = nint (( Rmax - Rmin ) / PI * (( wavmax + wavvdepth ) * steps )) else nsteps = nint (( Rmax - Rmin ) / dr ) + 1 endif !---------------------------------------------------------------------! ! Prepare the coupling matrix !---------------------------------------------------------------------! call cpu_time ( time_coupling_start ) call check_nonzero_coupling_matrix_elements ( number_of_channels , & channels_level_indices , channels_omega_values , & number_of_nonzero_coupling_matrix_elements , & number_of_nonzero_coupling_coefficients ) call allocate_1d ( nonzero_terms_per_element , number_of_nonzero_coupling_matrix_elements ) call allocate_1d ( nonzero_coupling_coefficients , number_of_nonzero_coupling_coefficients ) call allocate_1d ( nonzero_legendre_indices , number_of_nonzero_coupling_coefficients ) call prepare_coupling_matrix_elements ( number_of_channels , & channels_level_indices , channels_omega_values , & number_of_nonzero_coupling_matrix_elements , & number_of_nonzero_coupling_coefficients , nonzero_terms_per_element ,& nonzero_legendre_indices , nonzero_coupling_coefficients ) if ( prntlvl . ge . 2 ) call print_coupling_matrix_elements_summary ( & number_of_channels , number_of_nonzero_coupling_matrix_elements , & number_of_nonzero_coupling_coefficients ) call cpu_time ( time_coupling_stop ) if ( prntlvl . ge . 2 ) call write_message ( \"Calculations of the coupling \" // & \"matrix took \" // trim ( adjustl ( float_to_character ( & time_coupling_stop - time_coupling_start , \"(E14.8)\" ))) // \" seconds\" ) !---------------------------------------------------------------------! ! Prepare the log-derivative matrix (Eqs. 6.29 and 6.43) ! and the K-matrix (Eq. 6.53) !---------------------------------------------------------------------! call allocate_2d ( BF_log_der_matrix , number_of_channels , number_of_channels ) call allocate_2d ( SF_log_der_matrix , number_of_channels , number_of_channels ) call allocate_2d ( k_matrix , number_of_open_channels , number_of_open_channels ) !---------------------------------------------------------------------! ! Call the propagator: !---------------------------------------------------------------------! call numerov ( channels_level_indices , channels_omega_values , & number_of_nonzero_coupling_matrix_elements , & number_of_nonzero_coupling_coefficients , nonzero_terms_per_element ,& nonzero_legendre_indices , nonzero_coupling_coefficients , nsteps , & number_of_channels , jtot_ , BF_log_der_matrix ) call write_message ( \"Coupled equations were solved from \" // & trim ( adjustl ( float_to_character ( Rmin , \"(F10.4)\" ))) // \" a.u. to \" // & trim ( adjustl ( float_to_character ( Rmax , \"(F10.4)\" ))) // \" a.u. in \" // & trim ( adjustl ( integer_to_character ( nsteps ))) // \" steps (dr = \" // & trim ( adjustl ( float_to_character (( rmax - rmin ) / dble ( nsteps - 1 ), & \"(E14.8)\" ))) // \" a.u.)\" ) !---------------------------------------------------------------------! ! Transform the log-derivative matrix to the SF frame !---------------------------------------------------------------------! call bf_to_sf_transformation ( number_of_channels , jtot_ , & channels_level_indices , channels_omega_values , channels_l_values , & BF_log_der_matrix , SF_log_der_matrix ) !---------------------------------------------------------------------! ! Get the K-matrix from log-derivative matrix (Eq. 6.53) !---------------------------------------------------------------------! call calculate_k_matrix ( number_of_channels , SF_log_der_matrix , & number_of_open_channels , channels_level_indices , channels_l_values ,& rmax , k_matrix ) !---------------------------------------------------------------------! ! Get the S-matrix from the K-matrix (Eq. 6.57) !---------------------------------------------------------------------! call allocate_2d ( s_matrix_real , number_of_open_channels , number_of_open_channels ) call allocate_2d ( s_matrix_imag , number_of_open_channels , number_of_open_channels ) call calculate_s_matrix ( number_of_open_channels , k_matrix , s_matrix_real , s_matrix_imag ) !---------------------------------------------------------------------! ! Array of wavevectors (necessary for the XS calculations) !---------------------------------------------------------------------! call allocate_1d ( wv , number_of_open_channels ) do iopen = 1 , number_of_open_channels wv ( iopen ) = dsqrt (( 2 * reducedmass * & ( ETOTAL () - elevel ( channels_level_indices ( iopen ))))) / bohrtoangstrom enddo !---------------------------------------------------------------------! ! S-matrix is written to the binary S-matrix file !---------------------------------------------------------------------! write ( 11 ) jtot_ , parity_index , number_of_open_channels write ( 11 ) ( channels_level_indices ( iopen ), channels_l_values ( iopen ),& wv ( iopen ), iopen = 1 , number_of_open_channels ) write ( 11 ) (( s_matrix_real ( iopen , iopen2 ), iopen2 = 1 , iopen ),& iopen = 1 , number_of_open_channels ) write ( 11 ) (( s_matrix_imag ( iopen , iopen2 ), iopen2 = 1 , iopen ),& iopen = 1 , number_of_open_channels ) !---------------------------------------------------------------------! ! Check if the S-matrices are unitary !---------------------------------------------------------------------! call unitarity_check ( number_of_open_channels , s_matrix_real , s_matrix_imag , unitarity_block_check ) !---------------------------------------------------------------------! ! If the unitary is not fulfilled, keep the information about this block !---------------------------------------------------------------------! if (. not .( unitarity_block_check )) then call append ( smatcheckarr , jtot_ ) endif !---------------------------------------------------------------------! ! Calculate all available cross-sections !---------------------------------------------------------------------! call CROSSSECTION ( jtot_ , number_of_open_channels , number_of_channels , & number_of_open_basis_levels , open_basis_levels , & open_basis_wavevectors , s_matrix_real , s_matrix_imag , channels_level_indices , & channels_l_values , xs_block ) !---------------------------------------------------------------------! ! Print the results from this parity block to the partial XS file ! and add the calculated partial XS to the xs_jtot array !---------------------------------------------------------------------! do icount = 1 , number_of_open_basis_levels do icount2 = 1 , number_of_open_basis_levels if ( parity_index == 1 ) then write ( partial_line , & \"(I6,2X,I6,2X,I4,2X,I4,6X,I4,2X,I4,2X,E16.8,2X,E16.8)\" ) & jtot_ , iblock , v1array ( open_basis_levels ( icount2 )), & j1array ( open_basis_levels ( icount2 )), & v1array ( open_basis_levels ( icount )), & j1array ( open_basis_levels ( icount )), & ( etotal () - elevel ( open_basis_levels ( icount ))) * hartreetocm , & xs_block (( icount - 1 ) * number_of_open_basis_levels + icount2 ) call write_message ( partial_line , unit_ = 12 ) endif xs_jtot (( icount - 1 ) * number_of_open_basis_levels + icount2 ) = & xs_jtot (( icount - 1 ) * number_of_open_basis_levels + icount2 ) & + xs_block (( icount - 1 ) * number_of_open_basis_levels + icount2 ) enddo enddo !---------------------------------------------------------------------! ! Check the time after each parity block: !---------------------------------------------------------------------! call cpu_time ( time_parity_stop ) if ( prntlvl . ge . 2 ) call time_count_summary ( time_parity_start , & time_parity_stop , time_parity , \"Parity block completed in \" ) !---------------------------------------------------------------------! ! ... end of the loop over parity !---------------------------------------------------------------------! call write_message ( repeat ( \" \" , 43 ) // \"***\" ) enddo !------------------------------------------------------------------------! ! Add the cross-sections from this Jtot block: !------------------------------------------------------------------------! do icount = 1 , number_of_open_basis_levels do icount2 = 1 , number_of_open_basis_levels xs_total (( icount - 1 ) * number_of_open_basis_levels + icount2 ) = & xs_total (( icount - 1 ) * number_of_open_basis_levels + icount2 ) & + xs_jtot (( icount - 1 ) * number_of_open_basis_levels + icount2 ) enddo enddo !------------------------------------------------------------------------! ! Determine the largest partial elastic/inelastic XS in this Jtot block: !------------------------------------------------------------------------! jinddiag = 0 jindoff1 = 0 jindoff2 = 0 maxXSdiag = 0.0_dp maxXSoff = 0.0_dp do icount = 1 , number_of_open_basis_levels do icount2 = 1 , number_of_open_basis_levels if ( open_basis_levels ( icount2 ) == open_basis_levels ( icount )) then if (( xs_jtot (( icount - 1 ) * number_of_open_basis_levels + icount2 )). gt . maxXSdiag ) then maxXSdiag = xs_jtot (( icount - 1 ) * number_of_open_basis_levels + icount2 ) jinddiag = icount endif else if (( xs_jtot (( icount - 1 ) * number_of_open_basis_levels + icount2 )). gt . maxXSoff ) then maxXSoff = xs_jtot (( icount - 1 ) * number_of_open_basis_levels + icount2 ) jindoff1 = icount jindoff2 = icount2 endif endif enddo enddo !-----------------------------------------------------------------------! call print_largest_partial_xs ( jtot_ , maxXSdiag , maxXSoff , jinddiag , & jindoff1 , jindoff2 , number_of_open_basis_levels , open_basis_levels ) !-----------------------------------------------------------------------! if ( jtotmax == 999999 ) then call check_dtol_otol ( maxXSdiag , maxXSoff , ncacdiag , ncacoff , terminate ) endif !------------------------------------------------------------------------! ! Check the time after each JTOT block: !------------------------------------------------------------------------! call cpu_time ( time_jtot_stop ) !------------------------------------------------------------------------! ! Print all the XS after current JTOT block !------------------------------------------------------------------------! if ( prntlvl . ge . 3 ) then call write_message ( \"Cross sections for J: \" // & trim ( adjustl ( integer_to_character ( jtot_ ))) // \" and energy: \" // & trim ( adjustl ( float_to_character ( ETOTAL () * hartreetocm , \"(F10.4)\" ))) & // \" cm-1\" ) call write_message ( \"  v1_f  j1_f  <-  v1_i  j1_i\" // repeat ( \" \" , 14 ) & // \"K.E.\" // repeat ( \" \" , 16 ) // \"XS\" ) do icount = 1 , number_of_open_basis_levels do icount2 = 1 , number_of_open_basis_levels write ( xs_line , \"(2X,I4,2X,I4,6X,I4,2X,I4,2X,E16.8,2X,E16.8)\" ) & v1array ( open_basis_levels ( icount2 )), & j1array ( open_basis_levels ( icount2 )), & v1array ( open_basis_levels ( icount )), & j1array ( open_basis_levels ( icount )), & ( etotal () - elevel ( open_basis_levels ( icount ))) * hartreetocm , & xs_total (( icount - 1 ) * number_of_open_basis_levels + icount2 ) call write_message ( xs_line ) enddo enddo endif !------------------------------------------------------------------------! if ( prntlvl . ge . 2 ) call time_count_summary ( time_jtot_start , & time_jtot_stop , time_jtot , \"JTOT block completed in \" ) !------------------------------------------------------------------------! ! terminate the loop if dtol/otol condition is satisfied !------------------------------------------------------------------------! if ( terminate ) exit enddo call write_message ( repeat ( '*' , 90 )) call write_message ( repeat ( \" \" , 31 ) // \"Loop over JTOT finished\" ) call write_message ( repeat ( '*' , 90 )) call write_message ( \"*\" // repeat ( \" \" , 40 ) // \"SUMMARY\" // repeat ( \" \" , 41 ) & // \"*\" ) call write_message ( repeat ( '*' , 90 )) !---------------------------------------------------------------------------! ! if for some JTOTs the S-matrix did not fulfill the unitary check, ! these are listed here !---------------------------------------------------------------------------! if ( allocated ( smatcheckarr )) then print * call write_message ( repeat ( \"-\" , 90 )) call write_message ( repeat ( \" \" , 37 ) // \"*** WARNING ***\" ) call write_message ( repeat ( \"-\" , 90 )) call write_message ( \"Check unitarity of the S-matrix in the following \" // & \"JTOT blocks:\" ) do icheck = 1 , size ( smatcheckarr ) call write_message ( \"JTOT:\" // repeat ( \" \" , 8 ) // integer_to_character ( & smatcheckarr ( icheck ))) enddo call write_message ( repeat ( \"-\" , 90 )) print * endif !---------------------------------------------------------------------------! ! Print all the calculated XS !---------------------------------------------------------------------------! call write_message ( \"Final state-to-state XS\" ) call write_message ( \"  v1_f  j1_f  <-  v1_i  j1_i\" // repeat ( \" \" , 14 ) // & \"K.E.\" // repeat ( \" \" , 16 ) // \"XS\" ) do icount = 1 , number_of_open_basis_levels do icount2 = 1 , number_of_open_basis_levels write ( xs_line , \"(2X,I4,2X,I4,6X,I4,2X,I4,2X,E16.8,2X,E16.8)\" ) & v1array ( open_basis_levels ( icount2 )), & j1array ( open_basis_levels ( icount2 )), & v1array ( open_basis_levels ( icount )), & j1array ( open_basis_levels ( icount )), & ( etotal () - elevel ( open_basis_levels ( icount ))) * hartreetocm , & xs_total (( icount - 1 ) * number_of_open_basis_levels + icount2 ) call write_message ( xs_line ) enddo enddo !---------------------------------------------------------------------------! call fwig_temp_free (); call fwig_table_free (); !---------------------------------------------------------------------------! ! Stop the time count !---------------------------------------------------------------------------! call cpu_time ( time_total_stop ) call time_count_summary ( time_total_start , time_total_stop , time_total , & \"Total CPU time: \" ) close ( 11 ) close ( 12 ) !---------------------------------------------------------------------------! end program SCATTERING !------------------------------------------------------------------------------! !------------------------------------------------------------------------------!","tags":"","loc":"sourcefile/scattering.f90.html"},{"title":"array_operations_fill_symmetric_matrix_submod.f90 – the SCATTERING code","text":"This file depends on sourcefile~~array_operations_fill_symmetric_matrix_submod.f90~~EfferentGraph sourcefile~array_operations_fill_symmetric_matrix_submod.f90 array_operations_fill_symmetric_matrix_submod.f90 sourcefile~array_operations_mod.f90 array_operations_mod.f90 sourcefile~array_operations_fill_symmetric_matrix_submod.f90->sourcefile~array_operations_mod.f90 sourcefile~utility_functions_mod.f90 utility_functions_mod.f90 sourcefile~array_operations_fill_symmetric_matrix_submod.f90->sourcefile~utility_functions_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules array_operations_fill_symmetric_matrix_submod Source Code array_operations_fill_symmetric_matrix_submod.f90 Source Code submodule ( array_operations_mod ) array_operations_fill_symmetric_matrix_submod !! a submodule for append subroutines use utility_functions_mod , only : to_lowercase implicit none contains module subroutine fill_symmetric_matrix_int32 ( matrix_ , upper_lower_ ) !! Fill the upper/lower triangle of a symmetric matrix (integer). integer , intent ( inout ) :: matrix_ (:,:) character ( len = 1 ), intent ( in ) :: upper_lower_ !---------------------------------------------------------------------! integer :: i_ , size_1_ , size_2_ , size_ !---------------------------------------------------------------------! size_1_ = size ( matrix_ , dim = 1 ) size_2_ = size ( matrix_ , dim = 2 ) if ( size_1_ . eq . size_2_ ) then size_ = size_1_ else print * , \"Error in fill_symmetric_matrix_int: size in dim = 1 (\" , size_1_ ,& \") is different than in dim = 2 (\" , size_2_ , \")\" print * , \"Adapt this subroutine to rectangle matrices\" stop endif !---------------------------------------------------------------------! select case ( to_lowercase ( upper_lower_ )) case ( 'l' ) do i_ = 1 , size_ - 1 matrix_ ( i_ + 1 : size_ , i_ ) = matrix_ ( i_ , i_ + 1 : size_ ) enddo case ( 'u' ) do i_ = 1 , size_ - 1 matrix_ ( i_ , i_ + 1 : size_ ) = matrix_ ( i_ + 1 : size_ , i_ ) enddo case default write ( * , * ) \"Invalid argument to fill_symmetric_matrix_int32 subroutine\" write ( * , * ) \"upper_lower_:\" , upper_lower_ write ( * , * ) \"'u' or 'l' expected\" stop end select !---------------------------------------------------------------------! end subroutine fill_symmetric_matrix_int32 module subroutine fill_symmetric_matrix_sp ( matrix_ , upper_lower_ ) !! Fill the upper/lower triangle of a symmetric matrix (single precision). real ( sp ), intent ( inout ) :: matrix_ (:,:) character ( len = 1 ), intent ( in ) :: upper_lower_ !---------------------------------------------------------------------! integer :: i_ , size_1_ , size_2_ , size_ !---------------------------------------------------------------------! size_1_ = size ( matrix_ , dim = 1 ) size_2_ = size ( matrix_ , dim = 2 ) if ( size_1_ . eq . size_2_ ) then size_ = size_1_ else print * , \"Error in fill_symmetric_matrix_sp: size in dim = 1 (\" , size_1_ ,& \") is different than in dim = 2 (\" , size_2_ , \")\" print * , \"Adapt this subroutine to rectangle matrices\" stop endif !---------------------------------------------------------------------! select case ( to_lowercase ( upper_lower_ )) case ( 'l' ) do i_ = 1 , size_ - 1 matrix_ ( i_ + 1 : size_ , i_ ) = matrix_ ( i_ , i_ + 1 : size_ ) enddo case ( 'u' ) do i_ = 1 , size_ - 1 matrix_ ( i_ , i_ + 1 : size_ ) = matrix_ ( i_ + 1 : size_ , i_ ) enddo case default write ( * , * ) \"Invalid argument to fill_symmetric_matrix_sp subroutine\" write ( * , * ) \"upper_lower_:\" , upper_lower_ write ( * , * ) \"'u' or 'l' expected\" stop end select !---------------------------------------------------------------------! end subroutine fill_symmetric_matrix_sp module subroutine fill_symmetric_matrix_dp ( matrix_ , upper_lower_ ) !! fill the upper/lower triangle of a symmetric matrix real ( dp ), intent ( inout ) :: matrix_ (:,:) character ( len = 1 ), intent ( in ) :: upper_lower_ !---------------------------------------------------------------------! integer :: i_ , size_1_ , size_2_ , size_ !---------------------------------------------------------------------! size_1_ = size ( matrix_ , dim = 1 ) size_2_ = size ( matrix_ , dim = 2 ) if ( size_1_ . eq . size_2_ ) then size_ = size_1_ else print * , \"Error in fill_symmetric_matrix_dp: size in dim = 1 (\" , size_1_ ,& \") is different than in dim = 2 (\" , size_2_ , \")\" print * , \"Adapt this subroutine to rectangle matrices\" stop endif !---------------------------------------------------------------------! select case ( to_lowercase ( upper_lower_ )) case ( 'l' ) do i_ = 1 , size_ - 1 matrix_ ( i_ + 1 : size_ , i_ ) = matrix_ ( i_ , i_ + 1 : size_ ) enddo case ( 'u' ) do i_ = 1 , size_ - 1 matrix_ ( i_ , i_ + 1 : size_ ) = matrix_ ( i_ + 1 : size_ , i_ ) enddo case default write ( * , * ) \"Invalid argument of the fill_symetric_matrix_dp subroutine\" write ( * , * ) \"upper_lower_\" , upper_lower_ write ( * , * ) \"'u' or 'l' expected\" stop end select !---------------------------------------------------------------------! end subroutine fill_symmetric_matrix_dp end submodule array_operations_fill_symmetric_matrix_submod","tags":"","loc":"sourcefile/array_operations_fill_symmetric_matrix_submod.f90.html"},{"title":"boundary_conditions_mod.f90 – the SCATTERING code","text":"This file depends on sourcefile~~boundary_conditions_mod.f90~~EfferentGraph sourcefile~boundary_conditions_mod.f90 boundary_conditions_mod.f90 sourcefile~input_reader_mod.f90 input_reader_mod.f90 sourcefile~boundary_conditions_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~utility_functions_mod.f90 utility_functions_mod.f90 sourcefile~boundary_conditions_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~math_functions_mod.f90 math_functions_mod.f90 sourcefile~boundary_conditions_mod.f90->sourcefile~math_functions_mod.f90 sourcefile~array_operations_mod.f90 array_operations_mod.f90 sourcefile~boundary_conditions_mod.f90->sourcefile~array_operations_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~array_operations_mod.f90 sourcefile~math_functions_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~special_functions_mod.f90 special_functions_mod.f90 sourcefile~math_functions_mod.f90->sourcefile~special_functions_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~boundary_conditions_mod.f90~~AfferentGraph sourcefile~boundary_conditions_mod.f90 boundary_conditions_mod.f90 sourcefile~scattering.f90 scattering.f90 sourcefile~scattering.f90->sourcefile~boundary_conditions_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules boundary_conditions_mod Source Code boundary_conditions_mod.f90 Source Code module boundary_conditions_mod !! This module contains subroutines that transform the asymptotic !! log-derivative matrix into the scattering S-matrix: !! 1. pfunc      - calculates the P coefficients from Eq. (6.19) !! 2. transsum   - calculates the sum over \\bar{\\Omega} in Eq. (6.17-6.18) !! 3. bftosfmat  - transforms a given BF-matrix to the SF frame of rerence !! 4. calculate_k_matrix - transforms log-derivative matrix into reactance matrix !     (Eq.6.42) !! 5. kmattosmat - transfroms reactance matrix into scattering S-matrix !     (Eq.6.44) !---------------------------------------------------------------------------! use , intrinsic :: iso_fortran_env , only : int32 , sp => real32 , dp => real64 use io_mod use fwigxjpf , only : fwig3jj use math_functions_mod , only : riccati_bessel_j , riccati_bessel_y , & modified_bessel_k_ratio use utility_functions_mod , only : write_warning use array_operations_mod , only : invert_symmetric_matrix , fill_symmetric_matrix !---------------------------------------------------------------------------! implicit none !---------------------------------------------------------------------------! contains !---------------------------------------------------------------------------! function p_coeff ( jtot_ , j_ , l_ , omega_ ) result ( p_coeff_ ) !! calculates the P coefficients from Eq. (6.19) !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: jtot_ !! total angular momentum integer ( int32 ), intent ( in ) :: j_ !! rotational quantum number integer ( int32 ), intent ( in ) :: l_ !! orbital angular momentum integer ( int32 ), intent ( in ) :: omega_ !! projection of j on the BF-Z axis real ( dp ) :: p_coeff_ !! result (...) !---------------------------------------------------------------------! real ( dp ) :: delta_ !---------------------------------------------------------------------! delta_ = 0.d0 if ( omega_ == 0 ) delta_ = 1.0_dp p_coeff_ = ( - 1.0_dp ) ** ( jtot_ + omega_ ) * dsqrt ( 2.0_dp ) & * dsqrt ( real ( 2 * l_ + 1 , dp )) * fwig3jj ( 2 * j_ , 2 * jtot_ , 2 * l_ , & 2 * omega_ , - 2 * omega_ , 0 ) / dsqrt ( 1.0_dp + delta_ ) !---------------------------------------------------------------------! end function p_coeff !---------------------------------------------------------------------------! subroutine transform_summation ( number_of_channels , jtot_ , v_ , j_ , vp_ , & jp_ , l_ , lp_ , channels_level_indices , channels_omega_values , & bf_matrix , sf_element ) !! performs the summation in Eqs. (6.17) and (6.18) !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: number_of_channels !! size of the basis integer ( int32 ), intent ( in ) :: jtot_ !! total angular momentum integer ( int32 ), intent ( in ) :: v_ , j_ , vp_ , jp_ !! vibrational and rotational quantum numbers integer ( int32 ), intent ( in ) :: l_ , lp_ !! orbital angular momenta integer ( int32 ), intent ( in ) :: channels_level_indices ( number_of_channels ) !! holds the indices pointing to the basis arrays integer ( int32 ), intent ( in ) :: channels_omega_values ( number_of_channels ) !! holds all values of \\bar{\\Omega} real ( dp ), intent ( in ) :: bf_matrix ( number_of_channels , number_of_channels ) !! matrix in the BF frame real ( dp ), intent ( out ) :: sf_element !! (output) matrix element in the SF frame !---------------------------------------------------------------------! integer ( int32 ) :: ii , ij , omtmp , omptmp , v1tmp , j1tmp , v1ptmp , j1ptmp real ( dp ) :: coeff_outer , coeff_inner , sum_outer , sum_inner !---------------------------------------------------------------------! sum_outer = 0.0_dp do ii = 1 , number_of_channels if ( v1array ( channels_level_indices ( ii )) /= v_ . or . & j1array ( channels_level_indices ( ii )) /= j_ ) cycle coeff_outer = p_coeff ( jtot_ , j_ , l_ , channels_omega_values ( ii )) sum_inner = 0.0_dp do ij = 1 , number_of_channels if ( v1array ( channels_level_indices ( ij )) /= vp_ . or . & j1array ( channels_level_indices ( ij )) /= jp_ ) cycle coeff_inner = p_coeff ( jtot_ , jp_ , lp_ , channels_omega_values ( ij )) sum_inner = sum_inner + coeff_inner * bf_matrix ( ii , ij ) end do sum_outer = sum_outer + coeff_outer * sum_inner end do sf_element = sum_outer !---------------------------------------------------------------------! end subroutine transform_summation !------------------------------------------------------------------------! subroutine bf_to_sf_transformation ( number_of_channels , jtot_ , & channels_level_indices , channels_omega_values , channels_l_values , & bf_matrix , sf_matrix ) !! takes an input matrix in the BF-frame and transforms it to !! the SF-frame; calls transsum and pfunc !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: number_of_channels !! size of the basis integer ( int32 ), intent ( in ) :: jtot_ !! total angular momentum integer ( int32 ), intent ( in ) :: channels_level_indices ( number_of_channels ) !! holds the indices pointing to the basis arrays integer ( int32 ), intent ( in ) :: channels_omega_values ( number_of_channels ) !! holds all values of \\bar{\\Omega} integer ( int32 ), intent ( in ) :: channels_l_values ( number_of_channels ) !! holds all values of l real ( dp ), intent ( in ) :: bf_matrix ( number_of_channels , number_of_channels ) !! matrix in the BF frame real ( dp ), intent ( inout ) :: sf_matrix ( number_of_channels , number_of_channels ) !! (output) matrix in the SF frame !---------------------------------------------------------------------! integer ( int32 ) :: l_ , lp_ , omega_ , omegap_ , v1_ , j1_ , v1p_ , j1p_ , ii , ij real ( dp ) :: coeff , sf_result !---------------------------------------------------------------------! do ii = 1 , number_of_channels v1_ = v1array ( channels_level_indices ( ii )) j1_ = j1array ( channels_level_indices ( ii )) l_ = channels_l_values ( ii ) do ij = 1 , number_of_channels v1p_ = v1array ( channels_level_indices ( ij )) j1p_ = j1array ( channels_level_indices ( ij )) lp_ = channels_l_values ( ij ) call transform_summation ( number_of_channels , jtot_ , v1_ , j1_ , v1p_ , j1p_ , & l_ , lp_ , channels_level_indices , channels_omega_values , & bf_matrix , sf_result ) sf_matrix ( ii , ij ) = sf_result enddo enddo !---------------------------------------------------------------------! end subroutine bf_to_sf_transformation !------------------------------------------------------------------------! subroutine calculate_k_matrix ( number_of_channels , log_der_matrix , & number_of_open_channels , channels_level_indices , channels_l_values , & r_ , k_matrix ) !! implementation of Eq. 6.53 !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: number_of_channels !! y-matrix is of number_of_channels x number_of_channels size real ( dp ), intent ( in ) :: log_der_matrix ( number_of_channels , number_of_channels ) !! asymptotic log-derivative matrix integer ( int32 ), intent ( in ) :: number_of_open_channels !! number of open channels integer ( int32 ), intent ( in ) :: channels_level_indices ( number_of_channels ) !! holds the indices pointing to the basis arrays integer ( int32 ), intent ( in ) :: channels_l_values ( number_of_channels ) !! holds all values of l real ( dp ), intent ( in ) :: r_ !! Rmax real ( dp ), intent ( inout ) :: k_matrix ( number_of_open_channels , number_of_open_channels ) !! K-matrix !---------------------------------------------------------------------! integer ( int32 ) :: index_open , index_closed , ii , iopen , iopen2 , & iclosed , status_ real ( dp ) :: wavenumber , x , j_element_ , jp_element_ , n_element_ , & np_element_ , ratio integer ( int32 ) :: open_channels_indices ( number_of_open_channels ) integer ( int32 ) :: closed_channels_indices ( number_of_channels - number_of_open_channels ) real ( dp ) :: diag_n_matrix ( number_of_channels , number_of_channels ), & diag_np_matrix ( number_of_channels , number_of_channels ), & diag_j_matrix ( number_of_channels , number_of_open_channels ), & diag_jp_matrix ( number_of_channels , number_of_open_channels ) !---------------------------------------------------------------------! ! diag_j_matrix   -  diagonal J matrix (Eqs. 6.37 & 6.39) ! diag_jp_matrix  -  diagonal J`matrix (derivative of J) ! diag_n_matrix   -  diagonal N matrix (Eqs. 6.30 & 6.40) ! diag_np_matrix  -  diagonal N`matrix (derivative of N) !---------------------------------------------------------------------! diag_j_matrix = 0 diag_jp_matrix = 0 diag_n_matrix = 0 diag_np_matrix = 0 !---------------------------------------------------------------------! index_open = 0 index_closed = 0 !---------------------------------------------------------------------! ! save indices to open and closed channels !---------------------------------------------------------------------! do ii = 1 , number_of_channels if ( elevel ( channels_level_indices ( ii )). le . ETOTAL ()) then index_open = index_open + 1 open_channels_indices ( index_open ) = ii else index_closed = index_closed + 1 closed_channels_indices ( index_closed ) = ii endif enddo !---------------------------------------------------------------------! ! Prepare J, J', N and N' matrices ! open channels: !---------------------------------------------------------------------! do iopen = 1 , number_of_open_channels wavenumber = dsqrt ( 2 * reducedmass * ( ETOTAL ()& - elevel ( channels_level_indices ( open_channels_indices ( iopen ))))) x = wavenumber * r_ call riccati_bessel_j ( channels_l_values ( open_channels_indices ( iopen )),& x , j_element_ , jp_element_ ) diag_j_matrix ( iopen , iopen ) = ( wavenumber ) ** ( - 0.5d0 ) * j_element_ diag_jp_matrix ( iopen , iopen ) = ( wavenumber ) ** ( 0.5d0 ) * jp_element_ call riccati_bessel_y ( channels_l_values ( open_channels_indices ( iopen )),& x , n_element_ , np_element_ ) diag_n_matrix ( iopen , iopen ) = ( wavenumber ) ** ( - 0.5d0 ) * n_element_ diag_np_matrix ( iopen , iopen ) = ( wavenumber ) ** ( 0.5d0 ) * np_element_ enddo !---------------------------------------------------------------------! ! Prepare J, J', N and N' matrices ! closed channels: !---------------------------------------------------------------------! do iclosed = 1 , number_of_channels - number_of_open_channels wavenumber = dsqrt ( dabs ( 2 * reducedmass * ( ETOTAL ()& - elevel ( channels_level_indices ( closed_channels_indices ( iclosed )))))) x = wavenumber * r_ call modified_bessel_k_ratio ( channels_l_values ( closed_channels_indices ( iclosed )), x , ratio ) !------------------------------------------------------------------! ! substitution for closed channels, (Eqs. 6.44 - 6.45) !------------------------------------------------------------------! diag_n_matrix ( number_of_open_channels + iclosed , number_of_open_channels + iclosed ) = 1.d0 diag_np_matrix ( number_of_open_channels + iclosed , number_of_open_channels + iclosed ) = ( wavenumber ) * ratio enddo !---------------------------------------------------------------------! call DGEMM ( 'N' , 'N' , number_of_channels , number_of_channels , & number_of_channels , 1.0d0 , log_der_matrix , number_of_channels , diag_n_matrix , & number_of_channels , - 1.d0 , diag_np_matrix , number_of_channels ) call DGEMM ( 'N' , 'N' , number_of_channels , number_of_open_channels , & number_of_channels , - 1.0d0 , log_der_matrix , number_of_channels , diag_j_matrix , & number_of_channels , 1.d0 , diag_jp_matrix , number_of_channels ) !---------------------------------------------------------------------! call DGESV ( number_of_channels , number_of_open_channels , diag_np_matrix , & number_of_channels , diag_j_matrix , diag_jp_matrix , number_of_channels , status_ ) !---------------------------------------------------------------------! do iopen = 1 , number_of_open_channels do iopen2 = 1 , number_of_open_channels k_matrix ( iopen , iopen2 ) = diag_jp_matrix ( iopen , iopen2 ) enddo enddo !---------------------------------------------------------------------! end subroutine calculate_k_matrix !------------------------------------------------------------------------! subroutine calculate_s_matrix ( number_of_open_channels , k_matrix , & s_matrix_real , s_matrix_imag ) !! implementation of Eq. 6.57 !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: number_of_open_channels !! number of open channels real ( dp ), intent ( in ) :: k_matrix ( number_of_open_channels , number_of_open_channels ) !! K-matrix real ( dp ), intent ( inout ) :: s_matrix_real ( number_of_open_channels , number_of_open_channels ) !! (output) real part of the S-matrix real ( dp ), intent ( inout ) :: s_matrix_imag ( number_of_open_channels , number_of_open_channels ) !! (output) imaginary part of the S-matrix !---------------------------------------------------------------------! integer ( int32 ) :: iopen , iopen2 real ( dp ) :: s_tmp_matrix ( number_of_open_channels , number_of_open_channels ) !---------------------------------------------------------------------! s_matrix_real = 0 s_matrix_imag = 0 !---------------------------------------------------------------------! call DGEMM ( 'N' , 'N' , number_of_open_channels , number_of_open_channels , & number_of_open_channels , 0.5d0 , k_matrix , number_of_open_channels , & k_matrix , number_of_open_channels , 0.d0 , s_tmp_matrix , number_of_open_channels ) do iopen = 1 , number_of_open_channels s_tmp_matrix ( iopen , iopen ) = s_tmp_matrix ( iopen , iopen ) + 0.5d0 enddo call invert_symmetric_matrix ( s_tmp_matrix ) call fill_symmetric_matrix ( s_tmp_matrix , 'u' ) call DGEMM ( 'N' , 'N' , number_of_open_channels , number_of_open_channels , & number_of_open_channels , - 1.0d0 , s_tmp_matrix , number_of_open_channels ,& k_matrix , number_of_open_channels , 0.d0 , s_matrix_imag , number_of_open_channels ) do iopen = 1 , number_of_open_channels do iopen2 = 1 , number_of_open_channels s_matrix_real ( iopen , iopen2 ) = s_tmp_matrix ( iopen , iopen2 ) enddo s_matrix_real ( iopen , iopen ) = s_matrix_real ( iopen , iopen ) - 1.d0 enddo !------------------------------------------------------------------------! end subroutine calculate_s_matrix !------------------------------------------------------------------------! subroutine unitarity_check ( number_of_open_channels , s_matrix_real , & s_matrix_imag , totalcheck ) !! checks the unitarity of the S-matrix (Eq. 6.15) !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: number_of_open_channels !! number of open channels real ( dp ), intent ( in ) :: s_matrix_real ( number_of_open_channels , number_of_open_channels ) !! real part of the S-matrix real ( dp ), intent ( in ) :: s_matrix_imag ( number_of_open_channels , number_of_open_channels ) !! imaginary part of the S-matrix logical , intent ( inout ) :: totalcheck !! (output) if .true. unitary is fulfilled, .false. otherwise !---------------------------------------------------------------------! character ( len = 200 ) :: line_ integer ( int32 ) :: iopen , iopen2 real ( dp ) :: unitarychecktmp , unitary_tol real ( dp ) :: unitarycheck ( number_of_open_channels ) !---------------------------------------------------------------------! totalcheck = . true . unitary_tol = 1e-6_dp !---------------------------------------------------------------------! if ( prntlvl . ge . 4 ) then call write_message ( \"Check of the unitarity of the S-matrix:\" ) call write_message ( repeat ( \" \" , 34 ) // \"*** S-matrix elements: ***\" ) call write_message ( \"   ROW   COL\" // repeat ( \" \" , 15 ) // \"S**2\" // & repeat ( \" \" , 17 ) // \"RE (S)\" // repeat ( \" \" , 17 ) // \"IM (S)\" ) endif !---------------------------------------------------------------------! do iopen = 1 , number_of_open_channels unitarychecktmp = 0.0_dp do iopen2 = 1 , number_of_open_channels unitarychecktmp = unitarychecktmp + & s_matrix_real ( iopen , iopen2 ) ** 2. + s_matrix_imag ( iopen , iopen2 ) ** 2. !---------------------------------------------------------------! if ( prntlvl . ge . 4 ) then write ( line_ , \"(1X,I5,1X,I5,8X,E15.8,8X,E15.8,8X,E15.8)\" ) & iopen , iopen2 , s_matrix_real ( iopen , iopen2 ) ** 2. + s_matrix_imag ( iopen , iopen2 ) ** 2. , & s_matrix_real ( iopen , iopen2 ), s_matrix_imag ( iopen , iopen2 ) call write_message ( line_ ) endif !---------------------------------------------------------------! enddo unitarycheck ( iopen ) = unitarychecktmp enddo !---------------------------------------------------------------------! do iopen = 1 , number_of_open_channels if ( dabs ( unitarycheck ( iopen ) - 1.d0 ). gt . unitary_tol ) then call write_warning ( \"Unitary condition is not fulfilled for channel no.\" ) write ( line_ , \"(1X,I5,8X,E15.8)\" ) iopen , unitarycheck ( iopen ) call write_message ( trim ( adjustl ( line_ ))) call write_message ( \"Consider increasing the STEPS parameter\" ) totalcheck = . false . endif enddo if ( prntlvl . ge . 4 ) then call write_message ( repeat ( \" \" , 43 ) // \"***\" ) call write_message ( \"Check of the unitarity of the S-matrix:\" ) call write_message ( \"   ROW\" // repeat ( \" \" , 12 ) // \"sum(S**2)\" ) do iopen = 1 , number_of_open_channels write ( line_ , \"(1X,I5,8X,E15.8)\" ) iopen , unitarycheck ( iopen ) call write_message ( trim ( adjustl ( line_ ))) enddo call write_message ( repeat ( \" \" , 43 ) // \"***\" ) endif !---------------------------------------------------------------------! end subroutine unitarity_check !------------------------------------------------------------------------! end module boundary_conditions_mod","tags":"","loc":"sourcefile/boundary_conditions_mod.f90.html"},{"title":"propagator_mod.f90 – the SCATTERING code","text":"This file depends on sourcefile~~propagator_mod.f90~~EfferentGraph sourcefile~propagator_mod.f90 propagator_mod.f90 sourcefile~input_reader_mod.f90 input_reader_mod.f90 sourcefile~propagator_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~pes_read_mod.f90 pes_read_mod.f90 sourcefile~propagator_mod.f90->sourcefile~pes_read_mod.f90 sourcefile~math_functions_mod.f90 math_functions_mod.f90 sourcefile~propagator_mod.f90->sourcefile~math_functions_mod.f90 sourcefile~array_operations_mod.f90 array_operations_mod.f90 sourcefile~propagator_mod.f90->sourcefile~array_operations_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~array_operations_mod.f90 sourcefile~utility_functions_mod.f90 utility_functions_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~pes_read_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~pes_read_mod.f90->sourcefile~math_functions_mod.f90 sourcefile~pes_read_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~math_functions_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~special_functions_mod.f90 special_functions_mod.f90 sourcefile~math_functions_mod.f90->sourcefile~special_functions_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~propagator_mod.f90~~AfferentGraph sourcefile~propagator_mod.f90 propagator_mod.f90 sourcefile~scattering.f90 scattering.f90 sourcefile~scattering.f90->sourcefile~propagator_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules PROPAGATORS Source Code propagator_mod.f90 Source Code module PROPAGATORS !! this modules contains the subroutines used by the propagator: !! 1. cenitrfugal_matrix - prepares the centrifugal term (Eq. (6.19)) !! 2. pes_contribution   - prepares the interaction energy term (Eq. (6.21)) !! 3. radtermvalue - returns the value of a radial coupling term at given R !! 4. calculate_log_der_matrix - calculates the log-derivative matrix (Eq. 6.29) !! 5. pes_diagonalization - diagonalizes the coupling matrix from rmin to rmax !! 6. numerov - renormalized Numerov's algorithm !----------------------------------------------------------------------------! use , intrinsic :: iso_fortran_env , only : int32 , sp => real32 , dp => real64 use io_mod use array_operations_mod , only : invert_symmetric_matrix , fill_symmetric_matrix use math_functions_mod , only : ispline use POTENTIAL implicit none contains !---------------------------------------------------------------------------! subroutine cenitrfugal_matrix ( number_of_channels , jj , & channels_level_indices , channels_omega_values , centmatrix ) !! calculates the (R**2)*centrifugal matrix from Eq. (6.19) !! only called once at the beginning of the calculations !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: number_of_channels !! size of the basis integer ( int32 ), intent ( in ) :: jj !! total angular momentum integer ( int32 ), intent ( in ) :: channels_level_indices ( number_of_channels ) !! holds the indices pointing to the basis arrays integer ( int32 ), intent ( in ) :: channels_omega_values ( number_of_channels ) !! holds all values of \\bar{\\Omega} real ( dp ), intent ( out ) :: centmatrix ( number_of_channels , number_of_channels ) !! (output) - (R**2)*centrifugal matrix !---------------------------------------------------------------------! integer ( int32 ) :: omegatmp , omegaptmp , v1tmp , j1tmp , v1ptmp , j1ptmp , & ii , ij real ( dp ) :: centtmp , delta1 , delta2 !---------------------------------------------------------------------! centmatrix = 0 do ii = 1 , number_of_channels v1tmp = v1array ( channels_level_indices ( ii )) j1tmp = j1array ( channels_level_indices ( ii )) omegatmp = channels_omega_values ( ii ) delta1 = 0.d0 if ( omegatmp . eq . 0 ) delta1 = 1.d0 do ij = 1 , ii v1ptmp = v1array ( channels_level_indices ( ij )) j1ptmp = j1array ( channels_level_indices ( ij )) omegaptmp = channels_omega_values ( ij ) delta2 = 0.d0 if ( omegaptmp . eq . 0 ) delta2 = 1.d0 if ( v1tmp . ne . v1ptmp ) cycle if ( j1tmp . ne . j1ptmp ) cycle if ( abs ( omegatmp - omegaptmp ). gt . 1 ) cycle if ( omegatmp . eq . omegaptmp ) then centmatrix ( ii , ij ) = jj * ( jj + 1 ) + j1tmp * ( j1tmp + 1 ) - 2 * omegatmp ** 2 else if ( omegatmp - omegaptmp . eq . 1 ) then centtmp = - dsqrt ( dfloat (( jj * ( jj + 1 ) - & omegatmp * ( omegatmp - 1 )) * ( j1tmp * ( j1tmp + 1 )& - omegatmp * ( omegatmp - 1 )))) centmatrix ( ii , ij ) = centtmp * dsqrt ( 1.d0 + delta1 ) * dsqrt ( 1.d0 + delta2 ) else if ( omegatmp - omegaptmp . eq . - 1 ) then centtmp = - dsqrt ( dfloat (( jj * ( jj + 1 ) - omegatmp * ( omegatmp + 1 )) & * ( j1tmp * ( j1tmp + 1 ) - omegatmp * ( omegatmp + 1 )))) centmatrix ( ii , ij ) = centtmp * dsqrt ( 1.d0 + delta1 ) * dsqrt ( 1.d0 + delta2 ) endif enddo enddo !---------------------------------------------------------------------! call fill_symmetric_matrix ( centmatrix , 'u' ) !---------------------------------------------------------------------! end subroutine !------------------------------------------------------------------------------! subroutine pes_contribution ( number_of_channels , jj , r , & channels_level_indices , channels_omega_values , & number_of_nonzero_coupling_matrix_elements , & number_of_nonzero_coupling_coefficients , & nonzero_terms_per_element , nonzero_legendre_indices , & nonzero_coupling_coefficients , vmatrix ) !! calculates the contribution from the PES in (X) at given R !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: number_of_channels !! size of the basis integer ( int32 ), intent ( in ) :: jj !! total angular momentum real ( dp ), intent ( in ) :: r !! intermolecular distance integer ( int32 ), intent ( in ) :: channels_level_indices ( number_of_channels ) !! holds the indices pointing to the basis arrays integer ( int32 ), intent ( in ) :: channels_omega_values ( number_of_channels ) !! holds all values of \\bar{\\Omega} integer ( int32 ), intent ( in ) :: number_of_nonzero_coupling_matrix_elements !! number of non-zero terms in the sum () for each non-zero element of the coupling matrix integer ( int32 ), intent ( in ) :: number_of_nonzero_coupling_coefficients !! number of all non-zero algberaix coefficients in the whole coupling matrix integer ( int32 ), intent ( in ) :: nonzero_terms_per_element ( number_of_nonzero_coupling_matrix_elements ) !! keeps the number of non-zero terms in the sum (Eq. (6.21)) for !! each non-zero element of W/V integer ( int32 ), intent ( in ) :: nonzero_legendre_indices ( number_of_nonzero_coupling_coefficients ) !! holds the proper indices pointing to l1/l2/lltabs, which !! correspond to the non-vanishing elements of the sum  (Eq. (6.21)) !! for each non-zero element of W/V real ( dp ), intent ( in ) :: nonzero_coupling_coefficients ( number_of_nonzero_coupling_coefficients ) !! holds the values of the non-zero algebraic coefficients real ( dp ), intent ( out ) :: vmatrix ( number_of_channels , number_of_channels ) !! (output) - the PES contribution to the coupling matrix !---------------------------------------------------------------------! integer ( int32 ) :: indvl , inonzero_coupling_matrix_elements , omegatmp , omegaptmp , l1 , & nonzerolam , v1tmp , j1tmp , v1ptmp , j1ptmp , ii , ij , il real ( dp ) :: erot , sumtemp , pscoeff , v !---------------------------------------------------------------------! vmatrix = 0 indvl = 0 inonzero_coupling_matrix_elements = 0 !---------------------------------------------------------------------! do ii = 1 , number_of_channels v1tmp = v1array ( channels_level_indices ( ii )) j1tmp = j1array ( channels_level_indices ( ii )) omegatmp = channels_omega_values ( ii ) erot = elevel ( channels_level_indices ( ii )) do ij = 1 , ii v1ptmp = v1array ( channels_level_indices ( ij )) j1ptmp = j1array ( channels_level_indices ( ij )) omegaptmp = channels_omega_values ( ij ) if ( omegatmp . ne . omegaptmp ) cycle inonzero_coupling_matrix_elements = inonzero_coupling_matrix_elements + 1 nonzerolam = nonzero_terms_per_element ( inonzero_coupling_matrix_elements ) sumtemp = 0.d0 do il = 1 , nonzerolam indvl = indvl + 1 l1 = l1tab ( nonzero_legendre_indices ( indvl )) pscoeff = nonzero_coupling_coefficients ( indvl ) call RADTERMVALUE ( r , l1 , v1tmp , j1tmp , v1ptmp , j1ptmp , v ) sumtemp = sumtemp + pscoeff * v enddo vmatrix ( ii , ij ) = - 2 * reducedmass * sumtemp enddo vmatrix ( ii , ii ) = vmatrix ( ii , ii ) - ( 2 * reducedmass * erot ) enddo !---------------------------------------------------------------------! call fill_symmetric_matrix ( vmatrix , 'u' ) !---------------------------------------------------------------------! end subroutine pes_contribution !------------------------------------------------------------------------------! subroutine RADTERMVALUE ( rr , l1 , v1 , j1 , v1p , j1p , v ) !! returns the value of a specific radial coupling term at rr !---------------------------------------------------------------------! real ( dp ), intent ( in ) :: rr !! intermolecular distance integer ( int32 ), intent ( in ) :: l1 !! Legendre expansion index integer ( int32 ), intent ( in ) :: v1 , j1 , v1p , j1p !! rovibrational quantum numbers real ( dp ), intent ( out ) :: v !! value of the radial coupling coefficient !---------------------------------------------------------------------! integer ( int32 ) :: il , icoupl , indl , indl2 real ( dp ) :: rrcurr !---------------------------------------------------------------------! ! If iunits=1, the r-values in the radialtermsfile are in angstrom !---------------------------------------------------------------------! if ( iunits . eq . 1 ) then rrcurr = rr * bohrtoangstrom else if ( iunits . eq . 0 ) then rrcurr = rr endif !---------------------------------------------------------------------! ! Locate the correct l1 index in l1tab !---------------------------------------------------------------------! do il = 1 , nterms if ( l1tab ( il ). eq . l1 ) then indl = il endif enddo !---------------------------------------------------------------------! ! Locate the correct quantum number that describes the v/j coupling !---------------------------------------------------------------------! indl2 = 0 do icoupl = 1 , ncoupl if ((( reduced_v1ppes ( icoupl ). eq . v1p ). and .& ( reduced_j1pes ( icoupl ). eq . j1 ). and .& ( reduced_v1pes ( icoupl ). eq . v1 ). and .& ( reduced_j1ppes ( icoupl ). eq . j1p )). or .& (( reduced_v1pes ( icoupl ). eq . v1p ). and .& ( reduced_j1pes ( icoupl ). eq . j1p ). and .& ( reduced_v1ppes ( icoupl ). eq . v1 ). and .& ( reduced_j1ppes ( icoupl ). eq . j1 ))) then indl2 = icoupl endif enddo !---------------------------------------------------------------------! if ( indl2 . eq . 0 ) then call write_error ( \"Column with v1 = \" // integer_to_character ( v1 ) & // \", j1 = \" // integer_to_character ( j1 ) // \", v1` = \" // & integer_to_character ( v1p ) // \", j1` = \" // & integer_to_character ( j1p ) // \"not found\" ) endif !---------------------------------------------------------------------! v = ISPLINE ( rrcurr , nr , rmat , vmat3D (:, indl , indl2 ), bmat3D (:, indl , indl2 ), & cmat3D (:, indl , indl2 ), dmat3D (:, indl , indl2 )) !---------------------------------------------------------------------! if (( iunits . eq . 0 ). or .( iunits . eq . 1 )) then v = v / hartreetocm endif !---------------------------------------------------------------------! end subroutine !------------------------------------------------------------------------------! subroutine calculate_log_der_matrix ( h , y_dim , tt_min , tt_n , tt_plus , r_n , r_plus , log_der_matrix ) !! calculates the log-derivative matrix from Eq. (6.29) !! called by numerov and log_derivative at the end of the propagation !---------------------------------------------------------------------! real ( dp ), intent ( in ) :: h !! step of the propagation integer ( int32 ), intent ( in ) :: y_dim !! dimension of the log-derivative matrix real ( dp ), intent ( in ) :: tt_min ( y_dim , y_dim ) !! T-matrix at R_{max - 1} real ( dp ), intent ( in ) :: tt_n ( y_dim , y_dim ) !! T-matrix at R_{max} real ( dp ), intent ( in ) :: tt_plus ( y_dim , y_dim ) !! T-matrix at R_{max + 1} real ( dp ), intent ( in ) :: r_n ( y_dim , y_dim ) !! R-matrix at R_{max} real ( dp ), intent ( in ) :: r_plus ( y_dim , y_dim ) !! R-matrix at R_{max + 1} real ( dp ), intent ( inout ) :: log_der_matrix ( y_dim , y_dim ) !! log-derivative matrix !---------------------------------------------------------------------! integer ( int32 ) :: i , j real ( dp ) :: a ( y_dim , y_dim ), b ( y_dim , y_dim ), c ( y_dim , y_dim ), & d ( y_dim , y_dim ), e ( y_dim , y_dim ), f ( y_dim , y_dim ), g ( y_dim , y_dim ), & ab ( y_dim , y_dim ), abc ( y_dim , y_dim ), de ( y_dim , y_dim ), & def ( y_dim , y_dim ), bra ( y_dim , y_dim ) !---------------------------------------------------------------------! log_der_matrix = 0 !---------------------------------------------------------------------! do i = 1 , y_dim do j = 1 , y_dim a ( i , j ) = - tt_plus ( i , j ) b ( i , j ) = - tt_plus ( i , j ) c ( i , j ) = r_plus ( i , j ) d ( i , j ) = - tt_min ( i , j ) e ( i , j ) = - tt_min ( i , j ) f ( i , j ) = r_n ( i , j ) g ( i , j ) = - tt_n ( i , j ) end do a ( i , i ) = 0.5 + a ( i , i ) b ( i , i ) = 1. + b ( i , i ) d ( i , i ) = 0.5 + d ( i , i ) e ( i , i ) = 1. + e ( i , i ) g ( i , i ) = 1. + g ( i , i ) end do !---------------------------------------------------------------------! call invert_symmetric_matrix ( b ) call fill_symmetric_matrix ( b , \"u\" ) call invert_symmetric_matrix ( e ) call fill_symmetric_matrix ( e , \"u\" ) call invert_symmetric_matrix ( f ) call fill_symmetric_matrix ( f , \"u\" ) !---------------------------------------------------------------------! CALL DGEMM ( 'N' , 'N' , y_dim , y_dim , y_dim , 1.0d0 ,& a , y_dim , b , y_dim , 0.d0 , ab , y_dim ) CALL DGEMM ( 'N' , 'N' , y_dim , y_dim , y_dim , 1.0d0 ,& ab , y_dim , c , y_dim , 0.d0 , abc , y_dim ) CALL DGEMM ( 'N' , 'N' , y_dim , y_dim , y_dim , 1.0d0 ,& d , y_dim , e , y_dim , 0.d0 , de , y_dim ) CALL DGEMM ( 'N' , 'N' , y_dim , y_dim , y_dim , 1.0d0 ,& de , y_dim , f , y_dim , 0.d0 , DEF , y_dim ) !----------------------------------------------------------------------! bra = abc - def !---------------------------------------------------------------------! CALL DGEMM ( 'N' , 'N' , y_dim , y_dim , y_dim , dble ( 1.d0 / h ), bra ,& y_dim , g , y_dim , 0.d0 , log_der_matrix , y_dim ) !---------------------------------------------------------------------! end subroutine calculate_log_der_matrix !------------------------------------------------------------------------! subroutine numerov ( channels_level_indices , channels_omega_values , & number_of_nonzero_coupling_matrix_elements , & number_of_nonzero_coupling_coefficients , nonzero_terms_per_element , & nonzero_legendre_indices , nonzero_coupling_coefficients , nsteps , & number_of_channels , jj , log_der_matrix ) !! renormalized Numerov propagator !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: number_of_channels !! size of the basis integer ( int32 ), intent ( in ) :: channels_level_indices ( number_of_channels ) !! holds the indices pointing to the basis arrays integer ( int32 ), intent ( in ) :: channels_omega_values ( number_of_channels ) !! holds all values of \\bar{\\Omega} integer ( int32 ), intent ( in ) :: number_of_nonzero_coupling_matrix_elements !! number of non-zero terms in the sum () for each non-zero element of the coupling matrix integer ( int32 ), intent ( in ) :: number_of_nonzero_coupling_coefficients !! number of all non-zero algberaix coefficients in the whole coupling matrix integer ( int32 ), intent ( in ) :: nonzero_terms_per_element ( number_of_nonzero_coupling_matrix_elements ) !! keeps the number of non-zero terms in the sum (Eq. (6.21)) for !! each non-zero element of W/V integer ( int32 ), intent ( in ) :: nonzero_legendre_indices ( number_of_nonzero_coupling_coefficients ) !! holds the proper indices pointing to l1/l2/lltabs, which !! correspond to the non-vanishing elements of the sum  (Eq. (6.21)) !! for each non-zero element of W/V real ( dp ), intent ( in ) :: nonzero_coupling_coefficients ( number_of_nonzero_coupling_coefficients ) !! holds the values of the non-zero algebraic coefficients integer ( int32 ), intent ( in ) :: nsteps !! number of steps from rmin to rmax integer ( int32 ), intent ( in ) :: jj !! total angular momentum real ( dp ), intent ( inout ) :: log_der_matrix (:,:) !! resulting log-derivative matrix at RMAX !---------------------------------------------------------------------! integer ( int32 ) :: i , ii , ij real ( dp ) :: start , finish , r , step_numerov real ( dp ), allocatable , dimension (:,:) :: umatrix , r_temp , rmatrix , & t_minus , t_center , t_plus , r_center , r_plus , w_tmp , v_tmp real ( dp ), dimension ( number_of_channels , number_of_channels ) :: & cent_mat , v_mat , w_mat , t_mat , u_left , u_right !---------------------------------------------------------------------! CALL CPU_TIME ( start ) !---------------------------------------------------------------------! ! Calculate the centrifugal term !---------------------------------------------------------------------! call cenitrfugal_matrix ( number_of_channels , jj , channels_level_indices , & channels_omega_values , cent_mat ) step_numerov = ( rmax - rmin ) / dble ( nsteps - 1 ) call allocate_2d ( R_temp , number_of_channels , number_of_channels ) !---------------------------------------------------------------------! ! Calculate the PES contribution at rmin !---------------------------------------------------------------------! call pes_contribution ( number_of_channels , jj , rmin , & channels_level_indices , channels_omega_values , & number_of_nonzero_coupling_matrix_elements , & number_of_nonzero_coupling_coefficients , & nonzero_terms_per_element , nonzero_legendre_indices , & nonzero_coupling_coefficients , v_mat ) !---------------------------------------------------------------------! ! Coupling matrix W at rmin !---------------------------------------------------------------------! w_mat = v_mat - ( 1. / rmin ** 2. ) * cent_mat !---------------------------------------------------------------------! ! T-matrix (Eq. 6.23) !---------------------------------------------------------------------! do ii = 1 , number_of_channels do ij = 1 , number_of_channels t_mat ( ii , ij ) = - (( step_numerov ** 2. ) / 1 2. ) * ( w_mat ( ii , ij )) enddo t_mat ( ii , ii ) = - (( step_numerov ** 2. ) / 1 2. ) * & ( 2 * reducedmass * ETOTAL ()) + t_mat ( ii , ii ) enddo !---------------------------------------------------------------------! ! U-matrix (Eq. 6.25) !---------------------------------------------------------------------! do ii = 1 , number_of_channels do ij = 1 , number_of_channels u_left ( ii , ij ) = - t_mat ( ii , ij ) end do u_left ( ii , ii ) = 1.d0 + u_left ( ii , ii ) end do call invert_symmetric_matrix ( u_left ) call fill_symmetric_matrix ( u_left , 'u' ) !---------------------------------------------------------------------! ! R-matrix at rmin + 1 = U-matrix at rmin !---------------------------------------------------------------------! do ii = 1 , number_of_channels do ij = 1 , number_of_channels r_temp ( ii , ij ) = 1 2.d0 * u_left ( ii , ij ) enddo r_temp ( ii , ii ) = r_temp ( ii , ii ) - 1 0.d0 enddo !---------------------------------------------------------------------! ! Continue the propagation to rmax !---------------------------------------------------------------------! do i = 2 , nsteps !------------------------------------------------------------------! ! Coupling matrix W at R !------------------------------------------------------------------! R = rmin + ( i - 1 ) * step_numerov call allocate_2d ( rmatrix , number_of_channels , number_of_channels ) call allocate_2d ( umatrix , number_of_channels , number_of_channels ) call pes_contribution ( number_of_channels , jj , R , & channels_level_indices , channels_omega_values , & number_of_nonzero_coupling_matrix_elements , & number_of_nonzero_coupling_coefficients , & nonzero_terms_per_element , nonzero_legendre_indices , & nonzero_coupling_coefficients , v_mat ) w_mat = v_mat - ( 1. / R ** 2. ) * cent_mat !------------------------------------------------------------------! ! T-matrix at R (6.18) !------------------------------------------------------------------! do ii = 1 , number_of_channels do ij = 1 , number_of_channels t_mat ( ii , ij ) = - (( step_numerov ** 2. ) / 1 2. ) * ( w_mat ( ii , ij )) enddo t_mat ( ii , ii ) = - (( step_numerov ** 2. ) / 1 2. ) * & ( 2 * reducedmass * ETOTAL ()) + t_mat ( ii , ii ) enddo !------------------------------------------------------------------! ! U-matrix at R (6.20) !------------------------------------------------------------------! do ii = 1 , number_of_channels do ij = 1 , number_of_channels u_left ( ii , ij ) = - t_mat ( ii , ij ) end do u_left ( ii , ii ) = 1.d0 + u_left ( ii , ii ) end do call invert_symmetric_matrix ( u_left ) call fill_symmetric_matrix ( u_left , 'u' ) do ii = 1 , number_of_channels do ij = 1 , number_of_channels umatrix ( ii , ij ) = 1 2.d0 * u_left ( ii , ij ) enddo umatrix ( ii , ii ) = umatrix ( ii , ii ) - 1 0.d0 enddo call invert_symmetric_matrix ( r_temp ) call fill_symmetric_matrix ( r_temp , 'u' ) !------------------------------------------------------------------! ! Prepare T at Rmax - 1 and R at Rmax !------------------------------------------------------------------! if ( i == nsteps - 1 ) then call allocate_2d ( v_tmp , number_of_channels , number_of_channels ) call allocate_2d ( w_tmp , number_of_channels , number_of_channels ) call allocate_2d ( t_minus , number_of_channels , number_of_channels ) call pes_contribution ( number_of_channels , jj , r , & channels_level_indices , channels_omega_values , & number_of_nonzero_coupling_matrix_elements , & number_of_nonzero_coupling_coefficients , & nonzero_terms_per_element , nonzero_legendre_indices , & nonzero_coupling_coefficients , v_tmp ) w_tmp = v_tmp - ( 1. / R ** 2. ) * cent_mat do ii = 1 , number_of_channels do ij = 1 , number_of_channels t_minus ( ii , ij ) = - (( step_numerov ** 2. ) / 1 2. ) * & ( w_tmp ( ii , ij )) enddo t_minus ( ii , ii ) = - (( step_numerov ** 2. ) / 1 2. ) * & ( 2 * reducedmass * ETOTAL ()) + t_minus ( ii , ii ) enddo call allocate_2d ( r_center , number_of_channels , number_of_channels ) r_center = umatrix - r_temp !---------------------------------------------------------------! ! Prepare T at Rmax and R max + 1, and R at Rmax + 1 !---------------------------------------------------------------! else if ( i == nsteps ) then call allocate_2d ( v_tmp , number_of_channels , number_of_channels ) call allocate_2d ( w_tmp , number_of_channels , number_of_channels ) call allocate_2d ( t_center , number_of_channels , number_of_channels ) call pes_contribution ( number_of_channels , jj , r , & channels_level_indices , channels_omega_values , & number_of_nonzero_coupling_matrix_elements , & number_of_nonzero_coupling_coefficients , & nonzero_terms_per_element , nonzero_legendre_indices , & nonzero_coupling_coefficients , v_tmp ) w_tmp = v_tmp - ( 1. / R ** 2. ) * cent_mat do ii = 1 , number_of_channels do ij = 1 , number_of_channels t_center ( ii , ij ) = - (( step_numerov ** 2. ) / 1 2. ) * & ( w_tmp ( ii , ij )) enddo t_center ( ii , ii ) = - (( step_numerov ** 2. ) / 1 2. ) * & ( 2 * reducedmass * ETOTAL ()) + t_center ( ii , ii ) enddo call allocate_2d ( r_plus , number_of_channels , number_of_channels ) r_plus = umatrix - r_temp r = rmax + step_numerov call allocate_2d ( v_tmp , number_of_channels , number_of_channels ) call allocate_2d ( t_plus , number_of_channels , number_of_channels ) call allocate_2d ( w_tmp , number_of_channels , number_of_channels ) call pes_contribution ( number_of_channels , jj , r , & channels_level_indices , channels_omega_values , & number_of_nonzero_coupling_matrix_elements , & number_of_nonzero_coupling_coefficients , & nonzero_terms_per_element , nonzero_legendre_indices , & nonzero_coupling_coefficients , v_tmp ) w_tmp = v_tmp - ( 1. / R ** 2. ) * cent_mat do ii = 1 , number_of_channels do ij = 1 , number_of_channels t_plus ( ii , ij ) = - (( step_numerov ** 2. ) / 1 2. ) * & ( w_tmp ( ii , ij )) enddo t_plus ( ii , ii ) = - (( step_numerov ** 2. ) / 1 2. ) * & ( 2 * reducedmass * ETOTAL ()) + t_plus ( ii , ii ) enddo end if !------------------------------------------------------------------! ! R-matrix at R_{n+1} (Eq. 6.28) !------------------------------------------------------------------! rmatrix = umatrix - r_temp call allocate_2d ( r_temp , number_of_channels , number_of_channels ) !------------------------------------------------------------------! ! Move R_{n+1} to R_{n} !------------------------------------------------------------------! r_temp = rmatrix end do CALL CPU_TIME ( finish ) !---------------------------------------------------------------------! ! Eq. (6.29) !---------------------------------------------------------------------! call calculate_log_der_matrix ( step_numerov , number_of_channels , & t_minus , t_center , t_plus , r_center , r_plus , log_der_matrix ) !---------------------------------------------------------------------! if ( prntlvl . ge . 2 ) then call write_message ( \"Numerov propagator took \" // & trim ( adjustl ( float_to_character ( finish - start , \"(E14.8)\" ))) // & \" seconds\" ) endif !---------------------------------------------------------------------! end subroutine numerov !------------------------------------------------------------------------------! end module PROPAGATORS","tags":"","loc":"sourcefile/propagator_mod.f90.html"},{"title":"utility_functions_mod.f90 – the SCATTERING code","text":"Files dependent on this one sourcefile~~utility_functions_mod.f90~~AfferentGraph sourcefile~utility_functions_mod.f90 utility_functions_mod.f90 sourcefile~input_reader_mod.f90 input_reader_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~coupling_matrix_mod.f90 coupling_matrix_mod.f90 sourcefile~coupling_matrix_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~coupling_matrix_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~math_functions_mod.f90 math_functions_mod.f90 sourcefile~coupling_matrix_mod.f90->sourcefile~math_functions_mod.f90 sourcefile~sts_xs_mod.f90 sts_xs_mod.f90 sourcefile~sts_xs_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~sts_xs_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~pes_read_mod.f90 pes_read_mod.f90 sourcefile~pes_read_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~pes_read_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~pes_read_mod.f90->sourcefile~math_functions_mod.f90 sourcefile~boundary_conditions_mod.f90 boundary_conditions_mod.f90 sourcefile~boundary_conditions_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~boundary_conditions_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~boundary_conditions_mod.f90->sourcefile~math_functions_mod.f90 sourcefile~scattering.f90 scattering.f90 sourcefile~scattering.f90->sourcefile~utility_functions_mod.f90 sourcefile~scattering.f90->sourcefile~input_reader_mod.f90 sourcefile~scattering.f90->sourcefile~coupling_matrix_mod.f90 sourcefile~scattering.f90->sourcefile~sts_xs_mod.f90 sourcefile~scattering.f90->sourcefile~pes_read_mod.f90 sourcefile~scattering.f90->sourcefile~boundary_conditions_mod.f90 sourcefile~channels_mod.f90 channels_mod.f90 sourcefile~scattering.f90->sourcefile~channels_mod.f90 sourcefile~propagator_mod.f90 propagator_mod.f90 sourcefile~scattering.f90->sourcefile~propagator_mod.f90 sourcefile~channels_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~channels_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~math_functions_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~array_operations_fill_symmetric_matrix_submod.f90 array_operations_fill_symmetric_matrix_submod.f90 sourcefile~array_operations_fill_symmetric_matrix_submod.f90->sourcefile~utility_functions_mod.f90 sourcefile~propagator_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~propagator_mod.f90->sourcefile~pes_read_mod.f90 sourcefile~propagator_mod.f90->sourcefile~math_functions_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules utility_functions_mod Source Code utility_functions_mod.f90 Source Code module utility_functions_mod !! utility_functions_mod contains functions which handle writing !! messages/errors/warnings on screen, formatting headers, summary of the !! calculations and a few other supporting functions. !---------------------------------------------------------------------------! use , intrinsic :: iso_fortran_env , only : int32 , sp => real32 , dp => real64 , & output_unit !---------------------------------------------------------------------------! implicit none private public :: write_header , write_message , write_warning , write_error , time_count_summary , & alloc_status , file_io_status , incorrect_value , to_lowercase , & integer_to_character , float_to_character !---------------------------------------------------------------------------! character ( len =* ), parameter :: letters = & \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\" character ( len =* ), parameter :: uppercase = letters ( 1 : 26 ) character ( len =* ), parameter :: lowercase = letters ( 27 :) !---------------------------------------------------------------------------! interface incorrect_value !! interface for the following message: !! ``incorrect value encountered: !!   variable_name = variable_value`` module procedure incorrect_value_ch !! for character variables module procedure incorrect_value_int32 !! for integer variables module procedure incorrect_value_sp !! for single precision variables module procedure incorrect_value_dp !! for double precision variables end interface !---------------------------------------------------------------------------! contains !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine write_message ( message_ , unit_ ) !! writes a message on a chosen unit !---------------------------------------------------------------------! character ( len = * ), intent ( in ) :: message_ !! a message to be written integer ( int32 ), optional , intent ( in ) :: unit_ !! optional, unit where the message will be written !---------------------------------------------------------------------! if ( present ( unit_ )) then write ( unit_ , '(a)' ) trim ( message_ ) else write ( output_unit , '(a)' ) trim ( message_ ) endif !---------------------------------------------------------------------! end subroutine write_message !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine write_warning ( message_ , unit_ ) !! writes a warning message on a chosen unit !---------------------------------------------------------------------! character ( len = * ), intent ( in ) :: message_ !! a message to be written integer ( int32 ), optional , intent ( in ) :: unit_ !! optional, unit where the message will be written !---------------------------------------------------------------------! call write_message ( 'Warning: ' // trim ( message_ ), unit_ ) !---------------------------------------------------------------------! end subroutine write_warning !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine write_error ( message_ , unit_ ) !! writes an error message on a chosen unit !---------------------------------------------------------------------! character ( len = * ), intent ( in ) :: message_ !! a message to be written integer ( int32 ), optional , intent ( in ) :: unit_ !! optional, unit where the message will be written !---------------------------------------------------------------------! call write_message ( 'Error: ' // trim ( message_ ), unit_ ) stop !---------------------------------------------------------------------! end subroutine write_error !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine write_header ( header_type , opt_integer_ ) !! writes headers on screen character ( len = * ), intent ( in ) :: header_type !! specifies the type of the header: 'main', 'input_read', !! 'input_check', 'input_summary', 'initialization', 'check_norm', !! 'save_basis', 'save_pes', 'radial_terms', 'save_radial_terms', !! 'reconstruction' integer ( int32 ), optional , intent ( in ) :: opt_integer_ !! optional integer used in case \"block\" to pass jtot value !---------------------------------------------------------------------! character ( len = 100 ) :: header_star , header_str character ( len = 10 ) :: tmp_str_ integer ( int32 ) :: len_str_ !---------------------------------------------------------------------! select case ( trim ( header_type )) case ( 'main' ) write ( header_star , fmt = \"(a90)\" ) repeat ( \"*\" , 90 ) call write_message ( header_star ) call write_message ( header_star ) write ( header_str , fmt = '(a,25x,a43,20x,a)' ) & '*' , 'BIGOS quantum scattering package, vs. 0.00.' , '*' call write_message ( header_str ) write ( header_str , fmt = '(a,36x,a19,33x,a)' ) & '*' , 'the SCATTERING code' , '*' call write_message ( header_str ) write ( header_str , fmt = '(a,29x,a31,28x,a)' ) & '*' , 'adjusted for H2-He calculations' , '*' call write_message ( header_str ) write ( header_str , fmt = '(a,37x,a17,34x,a)' ) & '*' , 'by Hubert Jozwiak' , '*' call write_message ( header_str ) write ( header_str , fmt = '(a,40x,a11,37x,a)' ) & '*' , '20/12/2023 ' , '*' call write_message ( header_str ) call write_message ( header_star ) case ( 'block' ) call write_message ( repeat ( '*' , 90 )) if ( present ( opt_integer_ )) then write ( tmp_str_ , \"(i10)\" ) opt_integer_ len_str_ = len_trim ( tmp_str_ ) write ( * , '(\"*\", A, \"JTOT = \", A, A, \"*\")' ) & repeat ( ' ' , 40 - len_str_ ), tmp_str_ , repeat ( ' ' , 41 ) call write_message ( repeat ( '*' , 90 )) else call write_error ( \"**** JTOT value not provided in \" // & \"write_header_block ****\" ) endif case default call incorrect_value ( 'header_type (write_header)' , header_type ) end select !---------------------------------------------------------------------! end subroutine write_header !   !---------------------------------------------------------------------------! !   !---------------------------------------------------------------------------! !      subroutine write_summary(total_, inp_read_, inp_check_, inp_summary_,    & !          units_, grids_, system_, normalization_, pes_save_, basis_save_,     & !          radterm_calcs_, radterm_save_, reconstruct_) !         !! writes the summary on screen !         !---------------------------------------------------------------------! !         real(dp), intent(in)           :: total_, inp_read_, inp_check_,      & !           inp_summary_, units_, grids_, system_, normalization_, pes_save_,   & !           basis_save_, radterm_calcs_, radterm_save_, reconstruct_ !            !! total time of the run & time intervals for smaller tasks !            !! completed by the code; if a task wasn't invoked, print '---' !            !! on screen !         !---------------------------------------------------------------------! !         real(dp), parameter  :: zero_tolerance = 1.0e-12_dp !         !---------------------------------------------------------------------! !         character(len = 100) :: header_star, header_str, line !         !---------------------------------------------------------------------! !         call write_message('') !         write(header_star, fmt = '(a72)') repeat('*', 72) !         call write_message(header_star) !         write(header_str, fmt = '(a,23x,a,x,es11.4,x,a,22x,a)')               & !                 '*','Finished in',total_,'s','*' !         call write_message(header_str) !         call write_message(header_star) !         if (inp_read_.gt.zero_tolerance) then !            write(line, fmt = '(a,24x,es11.4,x,a,22x,a)')                      & !                    '* Input read', inp_read_, 's', '*' !         else !            write(line, fmt = '(a,24x,6x,a,26x,a)')                            & !                    '* Input read', '---', '*' !         endif !         call write_message(line) !         if (inp_check_.gt.zero_tolerance) then !            write(line, fmt = '(a,23x,es11.4,x,a,22x,a)')                      & !                    '* Input check', inp_check_, 's', '*' !         else !            write(line, fmt = '(a,23x,6x,a,26x,a)')                            & !                    '* Input check', '---', '*' !         endif !         call write_message(line) !         if (inp_summary_.gt.zero_tolerance) then !            write(line, fmt = '(a,21x,es11.4,x,a,22x,a)')                      & !                    '* Input summary', inp_summary_, 's', '*' !         else !            write(line, fmt = '(a,21x,6x,a,26x,a)')                            & !                    '* Input summary', '---', '*' !         endif !         call write_message(line) !         if (units_.gt.zero_tolerance) then !            write(line, fmt = '(a,17x,es11.4,x,a,22x,a)')                      & !                    '* Units preparation', units_, 's', '*' !         else !            write(line, fmt = '(a,17x,6x,a,26x,a)')                            & !                    '* Units preparation', '---', '*' !         endif !         call write_message(line) !         if (grids_.gt.zero_tolerance) then !            write(line, fmt = '(a,17x,es11.4,x,a,22x,a)')                      & !                    '* Grids preparation', grids_, 's', '*' !         else !            write(line, fmt = '(a,17x,6x,a,26x,a)')                            & !                    '* Grids preparation', '---', '*' !         endif !         call write_message(line) !         if (system_.gt.zero_tolerance) then !            write(line, fmt = '(a,11x,es11.4,x,a,22x,a)')                      & !                    '* PES & basis preparation', system_, 's', '*' !         else !            write(line, fmt = '(a,11x,6x,a,26x,a)')                            & !                    '* PES & basis preparation', '---', '*' !         endif !         call write_message(line) !         if (normalization_.gt.zero_tolerance) then !            write(line, fmt = '(a,15x,es11.4,x,a,22x,a)')                      & !                    '* Normalization check', normalization_, 's', '*' !         else !            write(line, fmt = '(a,15x,6x,a,26x,a)')                            & !                    '* Normalization check', '---', '*' !         endif !         call write_message(line) !         if (pes_save_.gt.zero_tolerance) then !            write(line, fmt = '(a,24x,es11.4,x,a,22x,a)')                      & !                    '* Saving PES', pes_save_, 's', '*' !         else !            write(line, fmt = '(a,24x,6x,a,26x,a)')                            & !                    '* Saving PES', '---', '*' !         endif !         call write_message(line) !         if (basis_save_.gt.zero_tolerance) then !            write(line, fmt = '(a,22x,es11.4,x,a,22x,a)')                      & !                    '* Saving basis', basis_save_, 's', '*' !         else !            write(line, fmt = '(a,22x,6x,a,26x,a)')                            & !                    '* Saving basis', '---', '*' !         endif !         call write_message(line) !         if (radterm_calcs_.gt.zero_tolerance) then !            write(line, fmt = '(a,9x,es11.4,x,a,22x,a)')                       & !                    '* Radial terms calculations', radterm_calcs_, 's', '*' !         else !            write(line, fmt = '(a,9x,6x,a,26x,a)')                             & !                    '* Radial terms calculations', '---', '*' !         endif !         call write_message(line) !         if (radterm_save_.gt.zero_tolerance) then !            write(line, fmt = '(a,15x,es11.4,x,a,22x,a)')                      & !                    '* Saving radial terms', radterm_save_, 's', '*' !         else !            write(line, fmt = '(a,15x,6x,a,26x,a)')                            & !                    '* Saving radial terms', '---', '*' !         endif !         call write_message(line) !         if (reconstruct_.gt.zero_tolerance) then !            write(line, fmt = '(a,9x,es11.4,x,a,22x,a)')                       & !                    '* Reconstruction of the PES', reconstruct_, 's', '*' !         else !            write(line, fmt = '(a,9x,6x,a,26x,a)')                             & !                    '* Reconstruction of the PES', '---', '*' !         endif !         call write_message(line) !         write(line, fmt = '(a,24x,es11.4,x,a,22x,a)')                         & !                 '* Total time', total_, 's', '*' !         call write_message(line) !         call write_message(header_star) !         !---------------------------------------------------------------------! !      end subroutine write_summary !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine time_count_summary ( start_ , stop_ , time_ , message_ ) !! print the message about the time it took to complete a single task !---------------------------------------------------------------------! real ( dp ), intent ( in ) :: start_ !! initial time real ( dp ), intent ( in ) :: stop_ !! final time real ( dp ), intent ( out ) :: time_ !! stop_ - start_ character ( len = * ), optional , intent ( in ) :: message_ !! (optional) a message to print instead of a default !! \"Completed in ... s\" !---------------------------------------------------------------------! character ( len = 12 ) :: default_message = 'Completed in' character ( len = 100 ) :: time_msg !---------------------------------------------------------------------! time_ = stop_ - start_ if ( present ( message_ )) then write ( time_msg , fmt = '(a,x,a,es11.4,x,a)' ) & '--' , trim ( message_ ), time_ , 's' else write ( time_msg , fmt = '(a,x,a,es11.4,x,a)' ) & '--' , default_message , time_ , 's' endif call write_message ( time_msg ) !---------------------------------------------------------------------! end subroutine time_count_summary !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine alloc_status ( istat_ , message_ , op_ , unit_ ) !! check the status after allocation !---------------------------------------------------------------------! integer ( int32 ) :: istat_ !! result of stat=istat in (de)allocate character ( len = * ), intent ( in ) :: message_ !! a message to be written character ( len = 1 ), intent ( in ) :: op_ !! 'a' for allocation, 'd' for deallocation integer ( int32 ), optional , intent ( in ) :: unit_ !! optional, unit where the message will be written !---------------------------------------------------------------------! character ( len = :), allocatable :: add_prefix_ !---------------------------------------------------------------------! add_prefix_ = '' if ( istat_ /= 0 ) then select case ( op_ ) case ( 'a' ) add_prefix_ = 'memory allocation: ' // trim ( message_ ) case ( 'd' ) add_prefix_ = 'memory deallocation: ' // trim ( message_ ) case default call write_error & ( 'Incorrect op_ argument in alloc_status subroutine (' & // trim ( op_ ) // ')' ) end select call write_error ( add_prefix_ , unit_ ) endif !---------------------------------------------------------------------! end subroutine alloc_status !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine file_io_status ( istat_ , iomsg_ , channel_ , op_ , unit_ ) !! check the status during various io operations on files !---------------------------------------------------------------------! integer ( int32 ) :: istat_ !! result of iostat in open/read/write/close character ( len = * ), intent ( in ) :: iomsg_ !! result of iomsg in open/read/write/close integer ( int32 ), intent ( in ) :: channel_ !! name of the file character ( len = 1 ), intent ( in ) :: op_ !! 'o' for opening of the file, 'r' for reading, 'w' for writing, !! 'c' for closing integer ( int32 ), optional , intent ( in ) :: unit_ !! optional, unit where the message will be written !---------------------------------------------------------------------! character ( len = :), allocatable :: add_prefix_ !---------------------------------------------------------------------! add_prefix_ = '' if ( istat_ /= 0 ) then select case ( op_ ) case ( 'o' ) add_prefix_ = 'opening file on channel: ' // & integer_to_character ( channel_ ) case ( 'r' ) add_prefix_ = 'reading file on channel: ' // & integer_to_character ( channel_ ) case ( 'w' ) add_prefix_ = 'writing to file on channel: ' // & integer_to_character ( channel_ ) case ( 'c' ) add_prefix_ = 'closing file on channel: ' // & integer_to_character ( channel_ ) case default call write_error & ( 'Incorrect op_ argument in file_io_status subroutine (' & // trim ( op_ ) // ')' ) end select call write_error ( trim ( add_prefix_ ) // \" with message: \" // iomsg_ , unit_ ) endif !---------------------------------------------------------------------! end subroutine file_io_status !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine incorrect_value_ch ( name_ , value_ , unit_ ) !! ``incorrect value encountered: !!   variable_name = variable_value`` !---------------------------------------------------------------------! character ( len = * ), intent ( in ) :: name_ !! name of the variable character ( len = * ), intent ( in ) :: value_ !! value of the variable integer ( int32 ), optional , intent ( in ) :: unit_ !! optional, unit where the message will be written !---------------------------------------------------------------------! character ( len = :), allocatable :: add_prefix_ !---------------------------------------------------------------------! add_prefix_ = 'Incorrect value encountered:  ' // trim ( name_ ) // ' = ' // & trim ( value_ ) call write_error ( add_prefix_ , unit_ ) !---------------------------------------------------------------------! end subroutine incorrect_value_ch !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine incorrect_value_int32 ( name_ , value_ , unit_ ) !! ``incorrect value encountered: !!   variable_name = variable_value`` !---------------------------------------------------------------------! character ( len = * ), intent ( in ) :: name_ !! name of the variable integer ( int32 ), intent ( in ) :: value_ !! value of the variable integer ( int32 ), optional , intent ( in ) :: unit_ !! optional, unit where the message will be written !---------------------------------------------------------------------! character ( len = 20 ) :: tmp_ character ( len = :), allocatable :: add_prefix_ !---------------------------------------------------------------------! write ( tmp_ , '(i5)' ) value_ add_prefix_ = 'Incorrect value encountered:  ' // trim ( name_ ) // ' = ' // & trim ( tmp_ ) call write_error ( add_prefix_ , unit_ ) !---------------------------------------------------------------------! end subroutine incorrect_value_int32 !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine incorrect_value_sp ( name_ , value_ , unit_ ) !! ``incorrect value encountered: !!   variable_name = variable_value`` !---------------------------------------------------------------------! character ( len = * ), intent ( in ) :: name_ !! name of the variable real ( sp ), intent ( in ) :: value_ !! value of the variable integer ( int32 ), optional , intent ( in ) :: unit_ !! optional, unit where the message will be written !---------------------------------------------------------------------! character ( len = 16 ), allocatable :: tmp_ character ( len = :), allocatable :: add_prefix_ !---------------------------------------------------------------------! write ( tmp_ , '(e16.8)' ) value_ add_prefix_ = 'Incorrect value encountered:  ' // trim ( name_ ) // ' = ' // & trim ( tmp_ ) call write_error ( add_prefix_ , unit_ ) !---------------------------------------------------------------------! end subroutine incorrect_value_sp !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine incorrect_value_dp ( name_ , value_ , unit_ ) !! ``incorrect value encountered: !!   variable_name = variable_value`` !---------------------------------------------------------------------! character ( len = * ), intent ( in ) :: name_ !! name of the variable real ( dp ), intent ( in ) :: value_ !! value of the variable integer ( int32 ), optional , intent ( in ) :: unit_ !! optional, unit where the message will be written !---------------------------------------------------------------------! character ( len = 16 ), allocatable :: tmp_ character ( len = :), allocatable :: add_prefix_ !---------------------------------------------------------------------! write ( tmp_ , '(e16.8)' ) value_ add_prefix_ = 'Incorrect value encountered:  ' // trim ( name_ ) // ' = ' // & trim ( tmp_ ) call write_error ( add_prefix_ , unit_ ) !---------------------------------------------------------------------! end subroutine incorrect_value_dp !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! function to_lowercase ( str ) result ( low_str ) !! forces lowercase on given string !---------------------------------------------------------------------! character ( len =* ), intent ( in ) :: str !! input string character ( len = len ( str )) :: low_str !! output (lowercase) string !---------------------------------------------------------------------! integer ( int32 ) :: i !---------------------------------------------------------------------! do i = 1 , len ( str ) low_str ( i : i ) = char_to_lowercase ( str ( i : i )) enddo !---------------------------------------------------------------------! end function to_lowercase !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! function char_to_lowercase ( s ) result ( l_s ) !! forces lowercase on a single character !---------------------------------------------------------------------! character ( len = 1 ), intent ( in ) :: s !! input character character ( len = 1 ) :: l_s !! output (lowercase) character !---------------------------------------------------------------------! integer ( int32 ) :: indx !---------------------------------------------------------------------! indx = index ( uppercase , s ) if ( indx > 0 ) then l_s = lowercase ( indx : indx ) else l_s = s endif !---------------------------------------------------------------------! end function char_to_lowercase !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! function integer_to_character ( i ) result ( res ) !! transfers integer to a character !---------------------------------------------------------------------! integer , intent ( in ) :: i !! input integer character ( len = 32 ) :: res !! output character !---------------------------------------------------------------------! write ( res , '(i0)' ) i res = adjustl ( res ) !---------------------------------------------------------------------! end function integer_to_character !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! function float_to_character ( f , format_string ) result ( res ) !! Converts a floating-point number to a character string. !---------------------------------------------------------------------! real ( dp ), intent ( in ) :: f !! input floating-point number character ( len =* ), intent ( in ), optional :: format_string !! Optional format string. character ( len = 64 ) :: res !! Output character string. !---------------------------------------------------------------------! character ( len = 32 ) :: default_format , user_format !---------------------------------------------------------------------! ! Default format: 6 decimal places !---------------------------------------------------------------------! default_format = '(F0.6)' !---------------------------------------------------------------------! if ( present ( format_string )) then user_format = trim ( format_string ) else user_format = default_format endif !---------------------------------------------------------------------! write ( res , user_format ) f res = adjustl ( res ) !---------------------------------------------------------------------! end function float_to_character !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! end module utility_functions_mod","tags":"","loc":"sourcefile/utility_functions_mod.f90.html"},{"title":"channels_mod.f90 – the SCATTERING code","text":"This file depends on sourcefile~~channels_mod.f90~~EfferentGraph sourcefile~channels_mod.f90 channels_mod.f90 sourcefile~input_reader_mod.f90 input_reader_mod.f90 sourcefile~channels_mod.f90->sourcefile~input_reader_mod.f90 sourcefile~utility_functions_mod.f90 utility_functions_mod.f90 sourcefile~channels_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~utility_functions_mod.f90 sourcefile~array_operations_mod.f90 array_operations_mod.f90 sourcefile~input_reader_mod.f90->sourcefile~array_operations_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~channels_mod.f90~~AfferentGraph sourcefile~channels_mod.f90 channels_mod.f90 sourcefile~scattering.f90 scattering.f90 sourcefile~scattering.f90->sourcefile~channels_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules channels_mod Source Code channels_mod.f90 Source Code module channels_mod !---------------------------------------------------------------------------! use , intrinsic :: iso_fortran_env , only : int32 , sp => real32 , dp => real64 use io_mod use utility_functions_mod , only : write_error , write_message , write_warning , & integer_to_character , float_to_character !---------------------------------------------------------------------------! implicit none !---------------------------------------------------------------------------! contains !------------------------------------------------------------------------! subroutine set_number_of_channels ( jtot_ , size_BF_even , size_BF_odd ) !! determine the number of scattering channels in each parity block !! for given JTOT; check both BF and SF frames !---------------------------------------------------------------------! !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: jtot_ !! total angular momentum integer ( int32 ), intent ( inout ) :: size_BF_even !! number of channels in p = 1 block integer ( int32 ), intent ( inout ) :: size_BF_odd !! number of channels in p = -1 block !---------------------------------------------------------------------! integer ( int32 ) :: ii , j1tmp , omegamax , lmin , lmax , l_len , len_even , & len_odd , size_SF_even , size_SF_odd !---------------------------------------------------------------------! ! BF frame !---------------------------------------------------------------------! size_BF_even = 0 size_BF_odd = 0 do ii = 1 , nlevel j1tmp = j1array ( ii ) omegamax = min ( j1tmp , jtot_ ) size_BF_even = size_BF_even + omegamax + 1 size_BF_odd = size_BF_odd + omegamax enddo !---------------------------------------------------------------------! ! SF frame !---------------------------------------------------------------------! size_SF_even = 0 size_SF_odd = 0 do ii = 1 , nlevel j1tmp = j1array ( ii ) lmin = abs ( jtot_ - j1tmp ) lmax = jtot_ + j1tmp l_len = lmax - lmin + 1 len_even = int (( l_len + 1 ) / 2 ) len_odd = int (( l_len - 1 ) / 2 ) size_SF_even = size_SF_even + len_even size_SF_odd = size_SF_odd + len_odd enddo !---------------------------------------------------------------------! ! Check if the results are the same !---------------------------------------------------------------------! if ( size_BF_even . ne . size_SF_even ) then call write_error ( \"Different number of channels in even block \" // & \"(BF/SF); check set_number_of_channels\" ) endif !---------------------------------------------------------------------! if ( size_BF_odd . ne . size_SF_odd ) then call write_error ( \"Different number of channels in odd block \" // & \"(BF/SF); check set_number_of_channels\" ) endif !---------------------------------------------------------------------! end subroutine set_number_of_channels !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine set_channels_level_indices_channels_omega_values ( number_of_channels , jtot_ , nparity , channels_level_indices , & channels_omega_values ) !! Prepares the channels_level_indices array which holds indices that refer to the !! basis arrays: v1level/j1level/elevel, and channels_omega_values which holds values !! of \\bar{\\Omega} !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: number_of_channels !! number of channels in the block integer ( int32 ), intent ( in ) :: jtot_ !! total angular momentum integer ( int32 ), intent ( in ) :: nparity !! parity exponent of the block (0 if p = +1, 1 if p = -1) integer ( int32 ), intent ( inout ) :: channels_level_indices ( number_of_channels ) !! holds the indices pointing to the basis arrays integer ( int32 ), intent ( inout ) :: channels_omega_values ( number_of_channels ) !! holds all values of \\bar{\\Omega} !---------------------------------------------------------------------! integer ( int32 ) :: isize_ , omegatmp , omegamax , ij , iomega !---------------------------------------------------------------------! isize_ = 0 !---------------------------------------------------------------------! do ij = 1 , nlevel omegamax = min ( j1array ( ij ), jtot_ ) if ( nparity . eq . 0 ) then do iomega = 1 , omegamax + 1 if ( isize_ >= number_of_channels ) then call write_error ( \"Array index isize_ out of bounds of \" // & \"channels_l_values in set_channels_level_indices_channels_omega_values.\" ) end if omegatmp = iomega - 1 channels_omega_values ( isize_ + 1 ) = omegatmp channels_level_indices ( isize_ + 1 ) = ij isize_ = isize_ + 1 enddo else do iomega = 1 , omegamax if ( isize_ >= number_of_channels ) then call write_error ( \"Array index isize_ out of bounds of \" // & \"channels_l_values in set_channels_level_indices_channels_omega_values.\" ) end if omegatmp = iomega channels_omega_values ( isize_ + 1 ) = omegatmp channels_level_indices ( isize_ + 1 ) = ij isize_ = isize_ + 1 enddo endif enddo !---------------------------------------------------------------------! end subroutine set_channels_level_indices_channels_omega_values !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine set_channels_l_values ( number_of_channels , jtot_ , nparity , channels_l_values ) !! Prepares the channels_l_values array which holds values of orbital angular momentum !! (l), an SF-frame quantum number. !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: number_of_channels !! number of channels in the block integer ( int32 ), intent ( in ) :: jtot_ !! total angular momentum integer ( int32 ), intent ( in ) :: nparity !! parity exponent of the block (0 if p = +1, 1 if p = -1) integer ( int32 ), intent ( inout ) :: channels_l_values ( number_of_channels ) !! holds all values of l !---------------------------------------------------------------------! integer :: lmin , lmax , ltmp integer :: ij , il , isize_ !---------------------------------------------------------------------! isize_ = 0 do ij = 1 , nlevel lmin = abs ( jtot_ - j1array ( ij )) lmax = jtot_ + j1array ( ij ) do il = lmin , lmax ltmp = il if ( mod ( ltmp + j1array ( ij ) + jtot_ , 2 ) == nparity ) then if ( isize_ >= number_of_channels ) then call write_error ( \"Array index isize_ out of bounds of \" // & \"channels_l_values in set_channels_l_values.\" ) end if channels_l_values ( isize_ + 1 ) = ltmp isize_ = isize_ + 1 endif enddo enddo !---------------------------------------------------------------------! end subroutine set_channels_l_values !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine set_number_of_open_channels_wavmax ( number_of_channels , & channels_level_indices , channels_omega_values , & number_of_open_channels , wavmax ) !! Calculates the number of energetically open channels (number_of_open_channels) and !! the largest wave number (wavmax) in the block. !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: number_of_channels !! number of channels in the block integer ( int32 ), intent ( in ) :: channels_level_indices ( number_of_channels ) !! holds the indices pointing to the basis arrays integer ( int32 ), intent ( in ) :: channels_omega_values ( number_of_channels ) !! holds all values of \\bar{\\Omega} integer ( int32 ), intent ( inout ) :: number_of_open_channels !! number of open channels real ( dp ), intent ( inout ) :: wavmax !! the largest wave number (wavmax) in the block !---------------------------------------------------------------------! integer ( int32 ) :: isize_ real ( dp ) :: wavenumber !---------------------------------------------------------------------! number_of_open_channels = 0 wavmax = 0.0_dp !---------------------------------------------------------------------! do isize_ = 1 , number_of_channels if (( ETOTAL () - elevel ( channels_level_indices ( isize_ ))) > 0.0_dp ) then number_of_open_channels = number_of_open_channels + 1 wavenumber = dsqrt ( 2 * reducedmass * ( ETOTAL () - elevel ( channels_level_indices ( isize_ )))) wavmax = max ( wavmax , wavenumber ) endif enddo !---------------------------------------------------------------------! end subroutine set_number_of_open_channels_wavmax !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! subroutine print_bf_channels ( number_of_channels , jtot_ , nparity , channels_level_indices , channels_omega_values ) !! prints BF quantum numbers on screen !---------------------------------------------------------------------! integer ( int32 ), intent ( in ) :: number_of_channels !! number of channels in the block integer ( int32 ), intent ( in ) :: jtot_ !! total angular momentum integer ( int32 ), intent ( in ) :: nparity !! parity exponent of the block (0 if p = +1, 1 if p = -1) integer ( int32 ), intent ( inout ) :: channels_level_indices ( number_of_channels ) !! holds the indices pointing to the basis arrays integer ( int32 ), intent ( inout ) :: channels_omega_values ( number_of_channels ) !! holds all values of \\bar{\\Omega} !---------------------------------------------------------------------! character ( len = 200 ) :: line_ integer ( int32 ) :: isize_ , itmp , v1tmp , j1tmp , omegatmp real ( dp ) :: erot , wavenumber !---------------------------------------------------------------------! call write_message ( \"  v1      j1     omega      p\" // repeat ( \" \" , 11 ) // & \"E_j\" // repeat ( \" \" , 16 ) // \"wv\" ) !---------------------------------------------------------------------! do isize_ = 1 , number_of_channels v1tmp = v1array ( channels_level_indices ( isize_ )) j1tmp = j1array ( channels_level_indices ( isize_ )) omegatmp = channels_omega_values ( isize_ ) erot = elevel ( channels_level_indices ( isize_ )) itmp = ( - 1 ) ** nparity if (( ETOTAL () - erot ) <= 0.0_dp ) then write ( line_ , \"(I4,4X,I4,6X,I4,5X,I2,2X,F12.4,4X,'--------------')\" ) & v1tmp , j1tmp , omegatmp , itmp * ( - 1 ) ** jtot_ , erot * hartreetocm call write_message ( line_ ) else wavenumber = dsqrt ( 2 * reducedmass * ( ETOTAL () - erot )) write ( line_ , \"(I4,4X,I4,6X,I4,5X,I2,2X,F12.4,4X,F14.8)\" ) & v1tmp , j1tmp , omegatmp , itmp * ( - 1 ) ** jtot_ , erot * hartreetocm , & wavenumber / bohrtoangstrom call write_message ( line_ ) endif enddo !---------------------------------------------------------------------! end subroutine print_bf_channels !---------------------------------------------------------------------------! !---------------------------------------------------------------------------! end module channels_mod","tags":"","loc":"sourcefile/channels_mod.f90.html"},{"title":"array_operations_allocate_submod.f90 – the SCATTERING code","text":"This file depends on sourcefile~~array_operations_allocate_submod.f90~~EfferentGraph sourcefile~array_operations_allocate_submod.f90 array_operations_allocate_submod.f90 sourcefile~array_operations_mod.f90 array_operations_mod.f90 sourcefile~array_operations_allocate_submod.f90->sourcefile~array_operations_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules array_operations_allocate_submod Source Code array_operations_allocate_submod.f90 Source Code submodule ( array_operations_mod ) array_operations_allocate_submod !! a submodule for allocate subroutines implicit none contains !------------------------------------------------------------------------! pure module subroutine allocate_1d_int32 ( array_ , size_ ) !! allocate a 1d array and fill it with 0s (intger version) integer ( int32 ), allocatable , intent ( inout ) :: array_ (:) integer ( int32 ), intent ( in ) :: size_ !---------------------------------------------------------------------! if ( allocated ( array_ )) deallocate ( array_ ) allocate ( array_ ( size_ )) array_ = 0 !---------------------------------------------------------------------! end subroutine allocate_1d_int32 !------------------------------------------------------------------------! pure module subroutine allocate_1d_sp ( array_ , size_ ) !! allocate a 1d array and fill it with 0s (single precision version) real ( sp ), allocatable , intent ( inout ) :: array_ (:) integer ( int32 ), intent ( in ) :: size_ !---------------------------------------------------------------------! if ( allocated ( array_ )) deallocate ( array_ ) allocate ( array_ ( size_ )) array_ = 0 !---------------------------------------------------------------------! end subroutine allocate_1d_sp !------------------------------------------------------------------------! pure module subroutine allocate_1d_dp ( array_ , size_ ) !! allocate a 1d array and fill it with 0s (double precision version) real ( dp ), allocatable , intent ( inout ) :: array_ (:) integer ( int32 ), intent ( in ) :: size_ !---------------------------------------------------------------------! if ( allocated ( array_ )) deallocate ( array_ ) allocate ( array_ ( size_ )) array_ = 0 !---------------------------------------------------------------------! end subroutine allocate_1d_dp !------------------------------------------------------------------------! !------------------------------------------------------------------------! pure module subroutine allocate_2d_int32 ( array_ , size1_ , size2_ ) !! allocate a 2d array and fill it with 0s (intger version) integer ( int32 ), allocatable , intent ( inout ) :: array_ (:,:) integer ( int32 ), intent ( in ) :: size1_ , size2_ !---------------------------------------------------------------------! if ( allocated ( array_ )) deallocate ( array_ ) allocate ( array_ ( size1_ , size2_ )) array_ = 0 !---------------------------------------------------------------------! end subroutine allocate_2d_int32 !------------------------------------------------------------------------! pure module subroutine allocate_2d_sp ( array_ , size1_ , size2_ ) !! allocate a 2d array and fill it with 0s (single precision version) real ( sp ), allocatable , intent ( inout ) :: array_ (:,:) integer ( int32 ), intent ( in ) :: size1_ , size2_ !---------------------------------------------------------------------! if ( allocated ( array_ )) deallocate ( array_ ) allocate ( array_ ( size1_ , size2_ )) array_ = 0 !---------------------------------------------------------------------! end subroutine allocate_2d_sp !------------------------------------------------------------------------! pure module subroutine allocate_2d_dp ( array_ , size1_ , size2_ ) !! allocate a 2d array and fill it with 0s (double precision version) real ( dp ), allocatable , intent ( inout ) :: array_ (:,:) integer ( int32 ), intent ( in ) :: size1_ , size2_ !---------------------------------------------------------------------! if ( allocated ( array_ )) deallocate ( array_ ) allocate ( array_ ( size1_ , size2_ )) array_ = 0 !---------------------------------------------------------------------! end subroutine allocate_2d_dp !------------------------------------------------------------------------! !------------------------------------------------------------------------! pure module subroutine allocate_3d_int32 ( array_ , size1_ , size2_ , size3_ ) !! allocate a 3d array and fill it with 0s (intger version) integer ( int32 ), allocatable , intent ( inout ) :: array_ (:,:,:) integer ( int32 ), intent ( in ) :: size1_ , size2_ , size3_ !---------------------------------------------------------------------! if ( allocated ( array_ )) deallocate ( array_ ) allocate ( array_ ( size1_ , size2_ , size3_ )) array_ = 0 !---------------------------------------------------------------------! end subroutine allocate_3d_int32 !------------------------------------------------------------------------! pure module subroutine allocate_3d_sp ( array_ , size1_ , size2_ , size3_ ) !! allocate a 3d array and fill it with 0s (single precision version) real ( sp ), allocatable , intent ( inout ) :: array_ (:,:,:) integer ( int32 ), intent ( in ) :: size1_ , size2_ , size3_ !---------------------------------------------------------------------! if ( allocated ( array_ )) deallocate ( array_ ) allocate ( array_ ( size1_ , size2_ , size3_ )) array_ = 0 !---------------------------------------------------------------------! end subroutine allocate_3d_sp !------------------------------------------------------------------------! pure module subroutine allocate_3d_dp ( array_ , size1_ , size2_ , size3_ ) !! allocate a 3d array and fill it with 0s (double precision version) real ( dp ), allocatable , intent ( inout ) :: array_ (:,:,:) integer ( int32 ), intent ( in ) :: size1_ , size2_ , size3_ !---------------------------------------------------------------------! if ( allocated ( array_ )) deallocate ( array_ ) allocate ( array_ ( size1_ , size2_ , size3_ )) array_ = 0 !---------------------------------------------------------------------! end subroutine allocate_3d_dp !------------------------------------------------------------------------! !------------------------------------------------------------------------! end submodule array_operations_allocate_submod","tags":"","loc":"sourcefile/array_operations_allocate_submod.f90.html"},{"title":"Program Description – the SCATTERING code","text":"The purpose of the SCATTERING code is to solve the coupled equations for a given scattering system, provide the\nscattering S-matrix elements, and calculate the state-to-state cross-sections. Contrary to other publically available codes, such as MOLSCAT ,\nor Hibridon , the SCATTERING code solves coupled equations in the body-fixed (BF) frame,\nwhere the coupling matrix exhibits a predominantly block-diagonal structure with blocks interconnected by centrifugal terms.\nThis significantly reduces computational time and memory requirements. The theory of non-reactive scattering in systems with arbitrary angular momenta in the BF frame was developed Launay ,\nand was recently recalled in the context of scattering calculations for He-perturbed shape of HD\nrovibrational resonances (see Stankiewicz et al ) and O 2 -perturbed resonances of HCl \n(see Olejnik et al ). We briefly summarize it in the Theoretical Background section. Structure of the code The user controls the code through the input file and by supplying properly-formatted radial coupling terms. \nThe input file is interpreted by io_mod module and the radial coupling terms are \nread and interpolated by subroutines kept in potential module. scattering is the central program. After reading the input file and radial coupling terms, \nit performs a loop over the total angular momentum and parity. For each iteration, the main program determines all expansion coefficients\n g_{\\boldsymbol{\\lambda},\\gamma,\\gamma'}&#94;{Jp}  (see Eq. (3) in the Coupling Matrix section).\nIn the next step, the propagation of the log-derivative matrix takes place through numerov that are kept in propagator_mod.f90 .\nThe resulting BF-log-derivative matrix is transformed to the SF-system using subroutines from boundary_conditions_mod module\nwhich also involves procedures that determine the scattering S-matrix (see Solution of the coupled equations section).\nThe main part of the code calls for the partial state-to-state cross sections calculated \nby subroutines kept in statetostateXS . The results are written to the S-matrix file (see S-matrix file ). The output file contains the information about each  J - and  p -labeled block and, if needed, provides the accumulated state-to-state cross sections .","tags":"","loc":"page/index.html"},{"title":"Theoretical background – the SCATTERING code","text":"The theory of non-reactive scattering in systems with arbitrary angular momenta in the BF frame was developed Launay ,\nand was recently recalled in the context of scattering calculations for He-perturbed shape of HD\nrovibrational resonances (see Stankiewicz et al ) and O 2 -perturbed resonances of HCl \n(see Olejnik et al ). We briefly summarize it in this section: What are coupled equations? Coupling Matrix Solutions of the coupled equations State-to-state cross-sections","tags":"","loc":"page/background/index.html"},{"title":"What are coupled equations? – the SCATTERING code","text":"In quantum scattering, coupled equations are sets of differential equations that describe \ndynamics of colliding molecules and/or atoms under the influence of the interaction potential. \nThese equations are \"coupled\" because the solution for one equation depends on the solutions of the others. \nIn the context of diatom-atom collisions, these equations account for rotational and vibrational states of the diatom and the relative motion of the colliding partners. Coupled equations are derived from time-independent Schrodinger equation, by expanding the scattering wave function\nin the chosen basis,  |\\gamma \\rangle  which leads to a set of coupled differential equations on the\nexpansion coefficients,  f_{\\gamma} (R) . The basis states  |\\gamma \\rangle  define the collision channels.\nIn the total angular momentum ( J ) representation, the coupled equations are block-diagonal with respect\nto total angular momentum and parity: Here,  W  is the coupling matrix which involves the contribution from the atom - molecule interaction energy,  {V}&#94;{Jp}_{\\gamma, \\gamma'}(R) ,\nrelative motion of atom with respect to the molecule, quantified by the square relative angular momentum operator,  \\mathbf{L}&#94;{2\\,Jp}_{\\gamma, \\gamma'}  , \nand relatvie kinetic energy of the colliding pair, expressed using wavevector,  k_{\\gamma} = \\sqrt{2\\mu(E - E_{\\mathrm{mol}})} .\n \\mu   is the reduced mass of the atom - molecule system,  E  is the total energy and  E_{\\mathrm{mol}}  is the internal (rovibrational)\nenergy of the molecule. For diatom ( &#94;{1}\\Sigma ) - atom ( &#94;{1}S ) scattering in the BF frame, collision channels are defined through \nvibrational and rotational quantum numbers of the molecule,  v  and  j , \nand the absolute value of the projection of the rotational angular momentum of the molecule (and the total angular momentum)\non the intermolecular axis,  \\bar{\\Omega} . Note In this section,  \\gamma  is a shorthand notation for a set of quantum numbers, \n \\gamma = v, j, \\bar{\\Omega}, J .","tags":"","loc":"page/background/coupled_equations.html"},{"title":"Coupling Matrix – the SCATTERING code","text":"Coupling matrix In order to construct the coupling matrix, we need the explicit form of matrix elements of  {W}&#94;{Jp}_{\\gamma, \\gamma'}(R) . Matrix elements of the interaction potential are given as Here,  v_{\\boldsymbol{\\lambda},\\gamma,\\gamma'} (R)  denotes the radial coupling terms of the potential energy surface: i.e. the 3D molecule - atom PES,  V(R, r, \\theta) , averaged over Legendre polynomials,  P_{\\lambda} (\\cos\\theta), \nand rovibrational wave functions of the isolated molecule,   \\chi_{\\eta}(r) , where  \\eta = v, j.\nNote that they are independent of  J  and  p . Note Radial coupling terms are calculated separately and provided to the SCATTERING code in a tabulated form: they are read\nin by the potential_read procedure and interpolated (see also Supplying radial coupling terms )\nby potential_interpolation . These subroutines are placed in the potential_mod module. Interpolated radial coupling terms at aritrary  R  are provided by the radtermvalue procedure from the propagators module.  g_{{\\lambda},\\gamma,\\gamma'}&#94;{Jp}  are the algebraic coefficients of the expansion which stem from matrix elements of Legendre polynomials, \n P_{\\lambda} (\\cos\\theta)  in the  \\gamma  basis. They are given as where quantities in brackets are the 3-j symbols. Note The SCATTERING code uses 3-j symbols calculated by the wigxjpf library H. T. Johansson and C. Forssén, Fast and Accurate Evaluation of Wigner 3j, 6j, and 9j Symbols Using Prime Factorization and Multiword Integer Arithmetic, SIAM J. Sci. Comput., 38(1) (2016), A376-A384. See eprint or Pre-print (2015) Algebraic coefficients are R-independent and are calculated only once per each block. \nNote that they are block-diagonal with respect to \\bar{\\Omega}. Note Calculation of  g_{{\\lambda},\\gamma,\\gamma'}&#94;{Jp}  algebraic coefficients is handled \nby the check_nonzero_coupling_matrix_elements and prepare_coupling_matrix_elements procedures from the algebraic_coefficients module. Procedure check_nonzero_coupling_matrix_elements first checks how many\nmatrix elements fulfill the  \\delta_{\\bar{\\Omega},\\bar{\\Omega}'}  condition - this is saved in the number_of_nonzero_coupling_matrix_elements variable.\nOn top of that, for each non-zero matrix element, the number of non-zero terms in the sum over \\lambda\nis checked and saved in number_of_nonzero_coupling_coefficients variable.\nThe coefficients are calculated with prepare_coupling_matrix_elements procedure and saved\nin the nonzero_coupling_coefficients variable.\nThe corresponding  \\lambda  indices are written indirectly in nonzero_legendre_indices array\nwhich holds indices to l1tab . Note The total contribution from the interaction potential, Eq. \\eqref{eq:pes_contribution}, is determined by pes_contribution procedure from propagators module. The centrifugal term,  \\mathbf{L}&#94;{2\\,Jp}_{\\gamma, \\gamma'} , is block-diagonal with respect to the rotational quantum number  j .\nTerms diagonal with respect to  \\bar{\\Omega}  are given as The centrifugal term additionally introduces couplings with  \\bar{\\Omega}  and  \\bar{\\Omega}' = \\bar{\\Omega} \\pm 1  blocks Note Matrix elements,  \\mathbf{L}&#94;{2\\,Jp}_{\\gamma, \\gamma'} , are calculated by the centrifugal_matrix subroutine from the propagators module.\nThese are called only once per block, at the begining of the numerov procedure.","tags":"","loc":"page/background/coupling_matrix.html"},{"title":"Solution of the coupled equations – the SCATTERING code","text":"Solution of the coupled equations Coupled equations are solved numerically. The SCATTERING code uses renormalized Numerov's algorithm (see Johnson )\nto propagate the log-derivative of  {f}&#94;{Jp}_{\\gamma} (R): Note Renormalized Numerov's algorithm is implemented in numerov procedure in propagators module. At the last point of propagation,  R_{max} , the log-derivative matrix is transformed to the space-fixed (SF) frame using the following transformation where the coefficients of the transformation are given as Note The transformation between arbitrary BF and SF matrices is implemented in boundary_conditions_mod : Eq. \\eqref{eq:BF-SF-transform} is implemented in bf_to_sf_transformation and transform_summation subroutines, while Eq. \\eqref{eq:p-coeff} is handled by the p_coeff function. In the next step, the SF log-derivative matrix is then transformed to the reactance K-matrix through the following equation Here,   {J}  and  {N}  are diagonal matrices with elements depending on whether the corresponding \n \\gamma  level is energetically accessible ( E - E_{\\gamma} \\geq 0  ) or inaccessible (  E-E_{\\gamma} < 0 ).\nThese two cases are referred to as open and closed channels, respectively.\nFor the open channels, the  {J}  and  {N}  matrices take the following form: where  S_{l}(k_{\\gamma}R)  and  C_{l}(k_{\\gamma}R)  are Riccati-Bessel functions of the first and second kind, respectively. For the closed channels: with  I_{l+\\frac{1}{2}}(k_{\\gamma} R)  and  K_{l+\\frac{1}{2}}(k_{\\gamma} R)  being the modified Bessel functions of the first and second kind.\nPrimes in the formula for the reactance matrix denote derivatives of the Bessel functions. Note The SCATTERING code uses Riccati-Bessel and modified Bessel functions calculated by the special_functions library Shanjie Zhang, Jianming Jin, Computation of Special Functions, Wiley, 1996, ISBN: 0-471-11963-6, LC: QA351.C45. The  {K}&#94;{Jp}  matrix takes the block form: where  {K}_{oo} ,  {K}_{oc} ,  {K}_{co}  and  {K}_{cc}  are open-open, open-closed,\n closed-open and closed-closed submatrices of  {K}&#94;{Jp} . It can be shown (see Johnson ),\nthat the open-open part of the  reactance matrix is not changed upon the following replacement: This allows to avoid computational problems with modified Bessel functions. The same transformation is applied for the  {N}  and  {N}'  matrices. Note This part of calculations, starting from Eq. \\eqref{eq:log-der-to-K},\nis handled by the calculate_k_matrix subroutine in the boundary_conditions_mod module. Finally, the scattering S-matrix  {S}&#94;{Jp}  is obtained from the open-open portion of  {K}&#94;{Jp}  Note Eq. \\eqref{eq:K-to-S} is implemented in the calculate_s_matrix procedure in the boundary_conditions_mod module. The S-matrices are saved to external, binary file, in a manner similar to the one used by MOLSCAT (see S-matrix file ).","tags":"","loc":"page/background/solution.html"},{"title":"Cross-sections – the SCATTERING code","text":"Cross-sections Apart from S-matrices, the SCATTERING code calculates the state-to-state cross-sections: Note Cross-sections calculations take place within the statetostateXS module, in the calculate_sts_xs procedure.","tags":"","loc":"page/background/cross_sections.html"},{"title":"Input file – the SCATTERING code","text":"Input file Note The input file is read at the beginning of the calculations by subroutine read_input_file from the io_mod module. This subroutine uses namelist method of reading input files into the source code. Each input file should consist of three groups: INPUT, BASIS and POTENTIAL.\nNote that the names of the groups correspond to the ones used by MOLSCAT. The INPUT group defines the most important information about each run: label (character) - 80-character string describing the code run. reducedmass (double precision) - value of the reduced mass of the collisional system, in atomic mass units. ietoterel (integer) - can only take two values: ietoterel = 0 (default), energy is interpreted as the total energy of the colliding system; initial is ignored, ietoterel = 1, energy is interpreted as the relative kinetic energy, calculated with respect to the initial level in the basis. energy (double precision) - its interpretation depends on ietoterel . initial (integer) - see ietoterel . jtotmin , jtotmax , jtotstep (integers) - the calculations are performed from\n  J_{min} =  jtotmin to   J_{max} =  jtotmax with  \\Delta J =  jtotstep .\n  If jtotmax = -1, calculations are performed until ncac consecutive values of total angular momentum contribute less than dtol to the elastic state-to-state cross sections, and less than otol to the inelastic state-to-state cross sections. rmin , rmax (double precision) - the propagation is performed from  R_{min} =  rmin to\n R_{max} =  rmax . Note that there are no subroutines responsible for the extrapolation of the radial terms implemented in the code. dr (double precision) - if positive, it corresponds to the step of the propagator (in  a_{0}  ). steps (integer) - number of steps per half-wavelength of de Broglie's wavefunction of the system (see Sec.~\\ref{sec:Scattering-Details-Scattering}). vdepth (double precision, 0 by default) - the user is advised to specify the absolute value of the depth of the potential energy surface, \nwhich is included in the determination of the step size of the propagator (see Sec.~\\ref{sec:Scattering-Details-Scattering}). ncac (integer), dtol , otol (double precision), see ( jtotmin , jtotmax and jtotstep ). nlevel (integer) - number of levels in the basis set. nr (integer) - number of the grid points for the radial coupling terms in the potential expansion. nterms (integer) - number of  \\lambda  terms in the potential expansion, see Eq. (3) in Coupling Matrix section. totalcol (integer) - determines the total number of columns containing the radial coupling terms (see Supplying radial coupling terms ). n_skip_lines (integer) - number of lines at the beginning of the radial coupling terms file, which will be ignored while reading (see Supplying radial coupling terms ). iunits (integer) - if the  R  grid in the radial coupling terms file is given in atomic units (  a_{0}  ), choose iunits =0.\n If the radial distance is given in \\AA, put iunits = 1. potentialfile (character, RadialTerms.dat by default) - the name of the file with the radial coupling terms. smatrixfile (character, SmatrixFile.dat by default) - the name of the s-matrix file. ipart (integer) - if partial cross sections (for each parity block, within each $J$-block) are needed, put ipart = 1. Otherwise, put ipart = 0. partialfile (character, PartialFile.dat by default) - the name of the file with partial cross sections. prntlvl (integer, 2 by default): prntlvl = 0, basic information about a run, prntlvl = 1, information about each block is printed on screen, prntlvl = 2, information about the calculation time of some of the important parts of the code is printed, prntlvl = 3, accumulated state-to-state cross sections are printed on screen after each total angular momentum block, prntlvl  >  4, S-matrices are printed on screen. BASIS group specifies the vibrational and rotational quantum numbers of colliding molecules and the energy levels of rovibrational states v1array (integer array of nlevel size) - keeps values of the vibrational ( v ) quantum numbers that describe the levels of a diatomic molecule. j1array (integer array of nlevel size) - keeps values of the rotational ( j ) quantum numbers that describe the levels of a diatomic molecule. elevel (double precision array of nlevel size) - keeps energies of the rovibrational levels of a diatomic molecule, in cm &#94;{-1} . POTENTIAL group describes the quantum numbers of the radial coupling terms,  v_{\\boldsymbol{\\lambda},\\gamma,\\gamma'} (R) , see Eq. (3) in Coupling Matrix section.\nThis group of variables involves: l1tab (integer array of nterms size) - keeps values of  \\lambda  indices, describing the radial terms of the potential. v1pes , j1pes , v1ppes , j1ppes (integer arrays of totalcol size) keep values of  v, j, v', j'  indices of the radial coupling terms of the potential.","tags":"","loc":"page/inputfile.html"},{"title":"Installation – the SCATTERING code","text":"Prerequisites Make. A modern Fortran compiler, such as GNU Fortran Compiler (gfortran) or Intel Fortran Compiler (ifort) LAPACK and BLAS libraries Git (optional) wget the SCATTERING code uses the wigxjpf and special_functions libraries. These are downloaded and installed along with the rest of the code. Get the source code Using git git clone https://github.com/hjozwiak-umk/bigos_h2he.git ./bigos_dir This will create a directory ./bigos_dir on the local machine. Enter this directory. Without git Download the source code as a zip file: bigos.zip Extract the contents to ./bigos_dir and enter this directory. Build the code Ubuntu Windows 11","tags":"","loc":"page/installation/index.html"},{"title":"Building the code - Ubuntu – the SCATTERING code","text":"Before building the code, make sure that we have all the necessary compilers, librariries and apps installed : sudo apt install make gfortran liblapack-dev libblas-dev wget git Enter ./bigos_dir Run make all . Note The script will download and extract the wigxjpf library in ./libs directory, and then build and compile the contents of ./src directory. The executable, scattering.x , is located in the main directory. You can now run make test to make sure that you recover reference outputs in the ref/ directory.","tags":"","loc":"page/installation/ubuntu.html"},{"title":"Building the code - Windows 11 – the SCATTERING code","text":"Before building the code, make sure that we have all the necessary compilers, librariries and apps installed : Here, we provide a step-by-step instruction for installation of the necessary packages using Cygwin . Download the Cygwin installer from the official website Launch Cygwin setup. Choose \"Install from Internet\". Set up a Root directory. Set up a local package directory. Choose \"Use System Proxy Settings\". Choose A Download Site. After a while, a new \"Select Packages\" window appears. Navigate to \"Full\" list in the upper right corner: Locate necessery packages: make , gcc-fortran , liblapack-devel , libopenblas , git , wget and unzip . Choose the most recent version. Proceed with the installation and close the Setup window. Launch Cygwin Terminal Clone the repository from git git clone https://github.com/hjozwiak-umk/bigos_h2he.git ./bigos_dir Enter ./bigos_dir Run make all . Note The script will download and extract the wigxjpf library in ./libs directory, and then build and compile the contents of ./src directory. The executable, scattering.x , is located in the main directory. You can now run make test to make sure that you recover reference outputs in the ref/ directory.","tags":"","loc":"page/installation/windows11.html"},{"title":"Supplying radial terms – the SCATTERING code","text":"Supplying the radial coupling terms of the potential energy surface The code reads radial coupling terms from a separate file. The reading process is controlled by both the input file and pes_read_mod.f90 . The radial terms file starts with n_skip_lines lines which describe the file and are ignored by the code.\nThe reading procedure is continued using two loops: the first one over nterms (number of radial terms, which match the size of l1tab ),\n and the second one over nr (the number of points on the  R -grid).\nThe code assumes that each loop over nterms begins with a current value of}  \\lambda , and that the radial coupling terms are ordered in columns, where the first column corresponds to the  R -grid.\nAdditional loop over totalcol reads radial terms which couple different  v, j  and  v', j'  states.\nThe order of columns in the radial terms file must correspond to the values supplied in the v1pes , j1pes , v1ppes , j1ppes arrays in the input file. Modify the potential_read subroutine in pes_read_mod.f90 , if the radial terms file has a different format. The user can supply a larger set of terms that describe the coupling between different rovibrational states ( v, j  and   v', j'  ) than actually needed.\nThe POTENTIALREDUCTION subroutine from pes_read_mod.f90 will only pick and interpolate the necessary terms (see Sec.~\\ref{sec:Scattering-Examples-I2)).\nNote that the procedure will be skipped if totalcol  <=  nlevel  \\cdot  (nlevel+1)/2.","tags":"","loc":"page/radialterms.html"},{"title":"S-matrix file – the SCATTERING code","text":"S-matrix file The following information is saved to the S-matrix binary file: label , \"2\" (a code name for diatom - atom scattering in the BIGOS package), nlevel , reducedmass (in atomic mass untis), (v1array(ilevel), j1array(ilevel), ilevel = 1, nlevel) (elevel(ilevel), ilevel = 1, nlevel) (in cm -1 ) initial, energy (in cm -1 ) jtot_, parity_index, number_of_open_channels (current value of  J ,  p  (if  p=1 , parity_index = 0, if  p = -1 , parity_index = 1) and number of open channels within the block) (channels_level_indices(iopen), channels_l_values(iopen), wv(iopen), iopen = 1, number_of_open_channels) (channels_level_indices is an integer array which keeps the values of pointers to the v1array and j1array, channels_l_values is an array containing all  l  values\ncorresponding to open channels, wv keeps values of  k_{\\gamma}  for each open channel (in 1/\\AA)). (srmatrix(iopen,iopen2), iopen2 = 1, iopen), iopen = 1, nopen) (real part of the S-matrix; only the lower triangle of the matrix is saved) (simatrix(iopen,iopen2), iopen2 = 1, iopen), iopen = 1, nopen) (imaginary part of the S-matrix; only the lower triangle of the matrix is saved) The last four steps are repeated for each block, looping over parity and total angular momentum.","tags":"","loc":"page/smatrixfile.html"}]}